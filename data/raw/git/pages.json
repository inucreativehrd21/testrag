[
  {
    "title": "1.1 시작하기 - 버전 관리란?",
    "summary": "이 장에서 설명하는 것은 Git을 처음 접하는 사람에게 필요한 내용이다. 먼저 버전 관리 도구에 대한 이해와 Git을 설치하는 방법을 설명하고 마지막으로 Git 서버를 설정하고 사용하는 방법을 설명한다. 이 장을 다 읽고 나면 Git 탄생 배경, Git을 사용하는 이유, Git을 설정하고 사용하는 방법을 터득하게 될 것이다. 버전 관리란? “버전 관리” 는 무엇이고 우리는 왜 이것을 알아야 할까? 버전 관리 시스템은 파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템이다. 이 책에서는 버전 관리하는 예제로 소프트웨어 소스 코드만 보여주지만, 실제로 거의 모든 컴퓨터 파일의 버전을 관리할 수 있다. 그래픽 디자이너나 웹 디자이너도 버전 관리 시스템(VCS - Version Control System)을 사용할 수 있다. VCS로 이미지나 레이아웃의 버전(변경 이력 혹은 수정 내용)을 관리하는 것은 매우 현명하다. VCS를 사용하면 각 파일을 이전",
    "sections": [
      {
        "header": "",
        "content": "이 장에서 설명하는 것은 Git을 처음 접하는 사람에게 필요한 내용이다. 먼저 버전 관리 도구에 대한 이해와 Git을 설치하는 방법을 설명하고 마지막으로 Git 서버를 설정하고 사용하는 방법을 설명한다. 이 장을 다 읽고 나면 Git 탄생 배경, Git을 사용하는 이유, Git을 설정하고 사용하는 방법을 터득하게 될 것이다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 182
        }
      },
      {
        "header": "버전 관리란?",
        "content": "“버전 관리” 는 무엇이고 우리는 왜 이것을 알아야 할까? 버전 관리 시스템은 파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템이다. 이 책에서는 버전 관리하는 예제로 소프트웨어 소스 코드만 보여주지만, 실제로 거의 모든 컴퓨터 파일의 버전을 관리할 수 있다.\n\n그래픽 디자이너나 웹 디자이너도 버전 관리 시스템(VCS - Version Control System)을 사용할 수 있다. VCS로 이미지나 레이아웃의 버전(변경 이력 혹은 수정 내용)을 관리하는 것은 매우 현명하다. VCS를 사용하면 각 파일을 이전 상태로 되돌릴 수 있고, 프로젝트를 통째로 이전 상태로 되돌릴 수 있고, 시간에 따라 수정 내용을 비교해 볼 수 있고, 누가 문제를 일으켰는지도 추적할 수 있고, 누가 언제 만들어낸 이슈인지도 알 수 있다. VCS를 사용하면 파일을 잃어버리거나 잘못 고쳤을 때도 쉽게 복구할 수 있다. 이런 모든 장점을 큰 노력 없이 이용할 수 있다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 498
        }
      },
      {
        "header": "로컬 버전 관리",
        "content": "많은 사람은 버전을 관리하기 위해 디렉토리로 파일을 복사하는 방법을 쓴다(똑똑한 사람이라면 디렉토리 이름에 시간을 넣을 거다). 이 방법은 간단하므로 자주 사용한다. 그렇지만, 정말 뭔가 잘못되기 쉽다. 작업하던 디렉토리를 지워버리거나, 실수로 파일을 잘못 고칠 수도 있고, 잘못 복사할 수도 있다.\n\n이런 이유로 프로그래머들은 오래전에 로컬 VCS라는 걸 만들었다. 이 VCS는 아주 간단한 데이터베이스를 사용해서 파일의 변경 정보를 관리했다.\n\n많이 쓰는 VCS 도구 중에 RCS(Revision Control System)라고 부르는 것이 있는데 오늘날까지도 아직 많은 회사가 사용하고 있다. RCS는 기본적으로 Patch Set(파일에서 변경되는 부분)을 관리한다. 이 Patch Set은 특별한 형식의 파일로 저장한다. 그리고 일련의 Patch Set을 적용해서 모든 파일을 특정 시점으로 되돌릴 수 있다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 456
        }
      },
      {
        "header": "중앙집중식 버전 관리(CVCS)",
        "content": "프로젝트를 진행하다 보면 다른 개발자와 함께 작업해야 하는 경우가 많다. 이럴 때 생기는 문제를 해결하기 위해 CVCS(중앙집중식 VCS)가 개발됐다. CVS, Subversion, Perforce 같은 시스템은 파일을 관리하는 서버가 별도로 있고 클라이언트가 중앙 서버에서 파일을 받아서 사용(Checkout)한다. 수년 동안 이러한 시스템들이 많은 사랑을 받았다.\n\nCVCS 환경은 로컬 VCS에 비해 장점이 많다. 모두 누가 무엇을 하고 있는지 알 수 있다. 관리자는 누가 무엇을 할지 꼼꼼하게 관리할 수 있다. 모든 클라이언트의 로컬 데이터베이스를 관리하는 것보다 VCS 하나를 관리하기가 훨씬 쉽다.\n\n그러나 이 CVCS 환경은 몇 가지 치명적인 결점이 있다. 가장 대표적인 것이 중앙 서버에 발생한 문제다. 만약 서버가 한 시간 동안 다운되면 그동안 아무도 다른 사람과 협업할 수 없고 사람들이 하는 일을 백업할 방법도 없다. 그리고 중앙 데이터베이스가 있는 하드디스크에 문제가 생기면 프로젝트의 모든 히스토리를 잃는다. 물론 사람마다 하나씩 가진 스냅샷은 괜찮다. 로컬 VCS 시스템도 이와 비슷한 결점이 있고 이런 문제가 발생하면 모든 것을 잃는다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 595
        }
      },
      {
        "header": "분산 버전 관리 시스템",
        "content": "DVCS(분산 버전 관리 시스템)을 설명할 차례다. Git, Mecurial, Bazaar, Darcs 같은 DVCS에서의 클라이언트는 단순히 파일의 마지막 스냅샷을 Checkout 하지 않는다. 그냥 저장소를 히스토리와 더불어 전부 복제한다. 서버에 문제가 생기면 이 복제물로 다시 작업을 시작할 수 있다. 클라이언트 중에서 아무거나 골라도 서버를 복원할 수 있다. Clone은 모든 데이터를 가진 진정한 백업이다.\n\n게다가 대부분의 DVCS 환경에서는 리모트 저장소가 존재한다. 리모트 저장소가 많을 수도 있다. 그래서 사람들은 동시에 다양한 그룹과 다양한 방법으로 협업할 수 있다. 계층 모델 같은 중앙집중식 시스템으로는 할 수 없는 워크플로를 다양하게 사용할 수 있다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 378
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/시작하기-버전-관리란%3F",
    "doc_type": "git",
    "total_sections": 5
  },
  {
    "title": "1.3 시작하기 - Git 기초",
    "summary": "Git 기초 Git의 핵심은 뭘까? 이 질문은 Git을 이해하는데 굉장히 중요하다. Git이 무엇이고 어떻게 동작하는지 이해한다면 쉽게 Git을 효과적으로 사용할 수 있다. Git을 배우려면 Subversion이나 Perforce 같은 다른 VCS를 사용하던 경험을 버려야 한다. Git은 미묘하게 달라서 다른 VCS에서 쓰던 개념으로는 헷갈린다. 사용자 인터페이스는 매우 비슷하지만, 정보를 취급하는 방식이 다르다. 이런 차이점을 이해하면 Git을 사용하는 것이 어렵지 않다. 차이가 아니라 스냅샷 Subversion과 Subversion 비슷한 놈들과 Git의 가장 큰 차이점은 데이터를 다루는 방법에 있다. 큰 틀에서 봤을 때 VCS 시스템 대부분은 관리하는 정보가 파일들의 목록이다. CVS, Subversion, Perforce, Bazaar 등의 시스템은 각 파일의 변화를 시간순으로 관리하면서 파일들의 집합을 관리한다(보통 델타 기반 버전관리 시스템이라 함). 그림 4. 각 파일에",
    "sections": [
      {
        "header": "Git 기초",
        "content": "Git의 핵심은 뭘까? 이 질문은 Git을 이해하는데 굉장히 중요하다. Git이 무엇이고 어떻게 동작하는지 이해한다면 쉽게 Git을 효과적으로 사용할 수 있다. Git을 배우려면 Subversion이나 Perforce 같은 다른 VCS를 사용하던 경험을 버려야 한다. Git은 미묘하게 달라서 다른 VCS에서 쓰던 개념으로는 헷갈린다. 사용자 인터페이스는 매우 비슷하지만, 정보를 취급하는 방식이 다르다. 이런 차이점을 이해하면 Git을 사용하는 것이 어렵지 않다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 260
        }
      },
      {
        "header": "차이가 아니라 스냅샷",
        "content": "Subversion과 Subversion 비슷한 놈들과 Git의 가장 큰 차이점은 데이터를 다루는 방법에 있다. 큰 틀에서 봤을 때 VCS 시스템 대부분은 관리하는 정보가 파일들의 목록이다. CVS, Subversion, Perforce, Bazaar 등의 시스템은 각 파일의 변화를 시간순으로 관리하면서 파일들의 집합을 관리한다(보통 델타 기반 버전관리 시스템이라 함).\n\nGit은 이런 식으로 데이터를 저장하지도 취급하지도 않는다. 대신 Git은 데이터를 파일 시스템 스냅샷의 연속으로 취급하고 크기가 아주 작다. Git은 커밋하거나 프로젝트의 상태를 저장할 때마다 파일이 존재하는 그 순간을 중요하게 여긴다. 파일이 달라지지 않았으면 Git은 성능을 위해서 파일을 새로 저장하지 않는다. 단지 이전 상태의 파일에 대한 링크만 저장한다. Git은 데이터를 스냅샷의 스트림처럼 취급한다.\n\n이것이 Git이 다른 VCS와 구분되는 점이다. 이점 때문에 Git은 다른 시스템들이 과거로부터 답습해왔던 버전 컨트롤의 개념과 다르다는 것이고 많은 부분을 새로운 관점에서 바라본다. Git은 강력한 도구를 지원하는 작은 파일시스템이다. Git은 단순한 VCS가 아니다. Git 브랜치에서 설명할 Git 브랜치를 사용하면 얻게 되는 이득이 무엇인지 설명한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 643
        }
      },
      {
        "header": "거의 모든 명령을 로컬에서 실행",
        "content": "거의 모든 명령이 로컬 파일과 데이터만 사용하기 때문에 네트워크에 있는 다른 컴퓨터는 필요 없다. 대부분의 명령어가 네트워크의 속도에 영향을 받는 CVCS에 익숙하다면 Git이 매우 놀라울 것이다. Git의 이런 특징에서 나오는 미칠듯한 속도는 오직 Git느님만이 구사할 수 있는 전능이다. 프로젝트의 모든 히스토리가 로컬 디스크에 있기 때문에 모든 명령이 순식간에 실행된다.\n\n예를 들어 Git은 프로젝트의 히스토리를 조회할 때 서버 없이 조회한다. 그냥 로컬 데이터베이스에서 히스토리를 읽어서 보여 준다. 그래서 눈 깜짝할 사이에 히스토리를 조회할 수 있다. 어떤 파일의 현재 버전과 한 달 전의 상태를 비교해보고 싶을 때도 Git은 그냥 한 달 전의 파일과 지금의 파일을 로컬에서 찾는다. 파일을 비교하기 위해 리모트에 있는 서버에 접근하고 나서 예전 버전을 가져올 필요가 없다.\n\n즉 오프라인 상태이거나 VPN에 연결하지 못해도 막힘 없이 일 할 수 있다. 비행기나 기차 등에서 작업하고 네트워크에 접속하고 있지 않아도 커밋할 수 있다(로컬 저장소라는 점이 기억나는지). 다른 VCS 시스템에서는 불가능한 일이다. Perforce를 예로 들자면 서버에 연결할 수 없을 때 할 수 있는 일이 별로 없다. Subversion이나 CVS에서도 마찬가지다. 오프라인이기 때문에 데이터베이스에 접근할 수 없어서 파일을 편집할 수는 있지만, 커밋할 수 없다. 매우 사소해 보이지만 실제로 이 상황에 부닥쳐보면 느껴지는 차이가 매우 크다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 746
        }
      },
      {
        "header": "Git의 무결성",
        "content": "Git은 데이터를 저장하기 전에 항상 체크섬을 구하고 그 체크섬으로 데이터를 관리한다. 그래서 체크섬을 이해하는 Git 없이는 어떠한 파일이나 디렉토리도 변경할 수 없다. 체크섬은 Git에서 사용하는 가장 기본적인(Atomic) 데이터 단위이자 Git의 기본 철학이다. Git 없이는 체크섬을 다룰 수 없어서 파일의 상태도 알 수 없고 심지어 데이터를 잃어버릴 수도 없다.\n\nGit은 SHA-1 해시를 사용하여 체크섬을 만든다. 만든 체크섬은 40자 길이의 16진수 문자열이다. 파일의 내용이나 디렉토리 구조를 이용하여 체크섬을 구한다. SHA-1은 아래처럼 생겼다.\n\nGit은 모든 것을 해시로 식별하기 때문에 이런 값은 여기저기서 보인다. 실제로 Git은 파일을 이름으로 저장하지 않고 해당 파일의 해시로 저장한다.",
        "code_examples": [
          "```bash\n24b9da6552252987aa493b52f8696cd6d3b00373\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 402
        }
      },
      {
        "header": "Git은 데이터를 추가할 뿐",
        "content": "Git으로 무얼 하든 Git 데이터베이스에 데이터가 추가 된다. 되돌리거나 데이터를 삭제할 방법이 없다. 다른 VCS처럼 Git도 커밋하지 않으면 변경사항을 잃어버릴 수 있다. 하지만, 일단 스냅샷을 커밋하고 나면 데이터를 잃어버리기 어렵다.\n\nGit을 사용하면 프로젝트가 심각하게 망가질 걱정 없이 매우 즐겁게 여러 가지 실험을 해 볼 수 있다. 되돌리기을 보면 Git에서 데이터를 어떻게 저장하고 손실을 어떻게 복구하는지 알 수 있다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 245
        }
      },
      {
        "header": "세 가지 상태",
        "content": "이 부분은 중요하기에 집중해서 읽어야 한다. Git을 공부하기 위해 반드시 짚고 넘어가야 할 부분이다. Git은 파일을 Committed, Modified, Staged 이렇게 세 가지 상태로 관리한다.\n\nCommitted란 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 의미한다.\n\nModified는 수정한 파일을 아직 로컬 데이터베이스에 커밋하지 않은 것을 말한다.\n\nStaged란 현재 수정한 파일을 곧 커밋할 것이라고 표시한 상태를 의미한다.\n\n이 세 가지 상태는 Git 프로젝트의 세 가지 단계와 연결돼 있다. Git 디렉토리, 워킹 트리, Staging Area 이렇게 세 가지 단계를 이해하고 넘어가자.\n\nGit 디렉토리는 Git이 프로젝트의 메타데이터와 객체 데이터베이스를 저장하는 곳을 말한다. 이 Git 디렉토리가 Git의 핵심이다. 다른 컴퓨터에 있는 저장소를 Clone 할 때 Git 디렉토리가 만들어진다.\n\n워킹 트리는 프로젝트의 특정 버전을 Checkout 한 것이다. Git 디렉토리는 지금 작업하는 디스크에 있고 그 디렉토리 안에 압축된 데이터베이스에서 파일을 가져와서 워킹 트리를 만든다.\n\nStaging Area는 Git 디렉토리에 있다. 단순한 파일이고 곧 커밋할 파일에 대한 정보를 저장한다. Git에서는 기술용어로는 “Index” 라고 하지만, “Staging Area” 라는 용어를 써도 상관 없다.\n\nGit으로 하는 일은 기본적으로 아래와 같다.\n\nStaging Area에 파일을 Stage 해서 커밋할 스냅샷을 만든다. 모든 파일을 추가할 수도 있고 선택하여 추가할 수도 있다.\n\nStaging Area에 있는 파일들을 커밋해서 Git 디렉토리에 영구적인 스냅샷으로 저장한다.\n\nGit 디렉토리에 있는 파일들은 Committed 상태이다. 파일을 수정하고 Staging Area에 추가했다면 Staged이다. 그리고 Checkout 하고 나서 수정했지만, 아직 Staging Area에 추가하지 않았으면 Modified이다. Git의 기초에서 이 상태에 대해 좀 더 자세히 배운다. 특히 Staging Area를 이용하는 방법부터 아예 생략하는 방법까지도 설명한다.\n\n• Committed란 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 의미한다.\n• Modified는 수정한 파일을 아직 로컬 데이터베이스에 커밋하지 않은 것을 말한다.\n• Staged란 현재 수정한 파일을 곧 커밋할 것이라고 표시한 상태를 의미한다.\n\n• 워킹 트리에서 파일을 수정한다.\n• Staging Area에 파일을 Stage 해서 커밋할 스냅샷을 만든다. 모든 파일을 추가할 수도 있고 선택하여 추가할 수도 있다.\n• Staging Area에 있는 파일들을 커밋해서 Git 디렉토리에 영구적인 스냅샷으로 저장한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 12,
          "content_length": 1371
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/시작하기-Git-기초",
    "doc_type": "git",
    "total_sections": 6
  },
  {
    "title": "1.5 시작하기 - Git 설치",
    "summary": "Git 설치 Git을 사용하려면 우선 설치해야 한다. 이미 설치했으면 최신 버전으로 업데이트하는 게 좋다. 패키지를 설치하거나 별도의 인스톨러로 설치할 수 있다. 아니면 직접 소스코드를 내려받아서 컴파일할 수도 있다. 노트 이 책은 Git 2.0.0 버전을 기준으로 썼다. 대부분의 명령어는 그 이전 버전에서도 잘 동작하지만, 몇 가지 기능은 아예 없거나 미묘하게 다를 수 있다. Git의 하위 호환성은 정말 훌륭하기 때문에 2.0 이후 버전에서는 잘 동작한다. Linux에 설치 Linux에서 패키지로 Git을 설치할 때는 보통 각 배포판에서 사용하는 패키지 관리도구를 사용하여 설치한다. Fedora(또는 비슷하게 RPM 기반 패키지 시스템을 사용하는 RHEL, CentOS)에서는 아래와 같이 dnf 를 사용 한다. $ sudo dnf install git-all Ubuntu등의 데비안 계열 배포판에서는 apt 를 사용한다. $ sudo apt install git-all 다른 Unix",
    "sections": [
      {
        "header": "Git 설치",
        "content": "Git을 사용하려면 우선 설치해야 한다. 이미 설치했으면 최신 버전으로 업데이트하는 게 좋다. 패키지를 설치하거나 별도의 인스톨러로 설치할 수 있다. 아니면 직접 소스코드를 내려받아서 컴파일할 수도 있다.\n\n이 책은 Git 2.0.0 버전을 기준으로 썼다. 대부분의 명령어는 그 이전 버전에서도 잘 동작하지만, 몇 가지 기능은 아예 없거나 미묘하게 다를 수 있다. Git의 하위 호환성은 정말 훌륭하기 때문에 2.0 이후 버전에서는 잘 동작한다.\n\n노트 | 이 책은 Git 2.0.0 버전을 기준으로 썼다. 대부분의 명령어는 그 이전 버전에서도 잘 동작하지만, 몇 가지 기능은 아예 없거나 미묘하게 다를 수 있다. Git의 하위 호환성은 정말 훌륭하기 때문에 2.0 이후 버전에서는 잘 동작한다.\n\n[Note] 노트 이 책은 Git 2.0.0 버전을 기준으로 썼다. 대부분의 명령어는 그 이전 버전에서도 잘 동작하지만, 몇 가지 기능은 아예 없거나 미묘하게 다를 수 있다. Git의 하위 호환성은 정말 훌륭하기 때문에 2.0 이후 버전에서는 잘 동작한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 2,
          "content_length": 534
        }
      },
      {
        "header": "Linux에 설치",
        "content": "Linux에서 패키지로 Git을 설치할 때는 보통 각 배포판에서 사용하는 패키지 관리도구를 사용하여 설치한다. Fedora(또는 비슷하게 RPM 기반 패키지 시스템을 사용하는 RHEL, CentOS)에서는 아래와 같이 dnf 를 사용 한다.\n\nUbuntu등의 데비안 계열 배포판에서는 apt 를 사용한다.\n\n다른 Unix 배포판에 설치하려면 http://git-scm.com/download/linux 에서 확인하라.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ sudo dnf install git-all\n```",
          "```bash\n$ sudo apt install git-all\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 233
        }
      },
      {
        "header": "Mac에 설치",
        "content": "Mac에 Git을 설치하는 방법 중에는 Xcode Command Line Tools를 설치하는 방법이 가장 쉽다. Mavericks(10.9)부터는 Terminal에 단지 처음으로 'git’을 실행하는 것으로 설치가 시작된다. 'git’이 설치돼 있지 않으면 설치하라고 안내해준다.\n\n만약 Git이 시스템에 설치되어있지 않은 경우, 설치할 수 있도록 안내 메시지가 뜰 것이다.\n\n좀 더 최신 버전이 필요하면 바이너리 인스톨러로 설치할 수 있다. macOS용 Git 인스톨러는 Git 웹사이트에서 관리하고 있으며 http://git-scm.com/download/mac 에서 내려받는다.\n\n'GitHub for Mac’을 설치하는 방법도 있다. 이 도구에도 CLI 도구를 설치하는 옵션이 있다. 'GitHub for Mac’은 http://mac.github.com에서 내려받는다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git --version\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 436
        }
      },
      {
        "header": "Windows에 설치",
        "content": "Windows에 Git을 설치하는 방법은 여러 가지다. 공식 배포판은 Git 웹사이트에서 내려받을 수 있다. http://git-scm.com/download/win에 가면 자동으로 다운로드가 시작된다. 이 프로젝트가 'Git for Windows’인데, Git 자체와는 다른 별도의 프로젝트다. 자세한 정보는 https://git-for-windows.github.io/에서 확인한다.\n\n자동화된 설치 방식은 Git Chocolatey 패키지를 통해 이용해볼 수 있다. 패키지는 커뮤니티에 의해 운영되는 프로그램인 점을 알려드린다.\n\nWindows에서도 Git을 사용하는 또 다른 방법으로 'GitHub Desktop’을 설치하는 방법이 있다. 이 인스톨러는 CLI와 GUI를 모두 설치해준다. 설치하면 Git을 Powershell에서 사용할 수 있다. 인증정보(Credential) 캐싱과 CRLF 설정까지 잘 된다. 이런 것들은 차차 배우게 될 것인데, Git 사용자라면 쓰게 될 기능들이다. 'GitHub Desktop’은 GitHub Desktop 웹사이트에서 내려받는다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 549
        }
      },
      {
        "header": "소스코드로 설치하기",
        "content": "가장 최신 버전이 필요하면 소스코드로 설치하는 것이 좋다. 바이너리 인스톨러는 약간 늦는다. 최근 Git은 매우 성숙해서 변경이 크지 않지만, 그래도 약간 차이 난다.\n\nGit을 설치하려면 Git이 의존하고 있는 라이브러리인 autotools, curl, zlib, openssl, expat, libiconv등이 필요하다. 예를 들어 dnf 을 사용하는 Fedora등의 시스템이나 apt-get 이 있는 데비안 계열 시스템이면 아래 명령어 중 하나를 실행하여 필요한 패키지를 설치할 수 있다.\n\n문서를 다양한(doc, html, info) 형식으로 추가하려면 다음의 패키지들이 추가로 필요하다(주의: CentOS나 Scientific Linux 같은 RHEL 계열 사용자는 EPEL 저장소를 켜고 docbook2X 패키지를 다운로드해야 한다.)\n\n데비안 계열 시스템이면 install-info 패키지도 설치해야 한다.\n\nRPM을 사용하는 Fedora나 비슷한 시스템을 사용한다면 getopt 패키지도 설치해야 한다(이는 데비안 계열 시스템에는 이미 설치되어 있다).\n\nFedora/RHEL/RHEL 계열 사용자라면 아래 명령도 필요하다.\n\n모든 준비가 완료되면, 최신 배포 버전을 가져와야 한다. Kernel.org(https://www.kernel.org/pub/software/scm/git)에서 내려받을 수도 있고 GitHub에 있는 미러(https://github.com/git/git/releases)에서도 받을 수도 있다. 보통 GitHub 페이지에서 최신 버전을 내려받는 것이 더 간단하지만 kernel.org에는 배포 시그너처가 있어서 내려받은 것을 검증할 수 있다.\n\n설치하고 나면 Git을 사용하여 Git 소스코드를 받아서 수정할 수도 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ sudo dnf install dh-autoreconf curl-devel expat-devel gettext-devel \\\n  openssl-devel perl-devel zlib-devel\n$ sudo apt-get install dh-autoreconf libcurl4-gnutls-dev libexpat1-dev \\\n  gettext libz-dev libssl-dev\n```",
          "```bash\n$ sudo dnf install asciidoc xmlto docbook2X\n$ sudo apt-get install asciidoc xmlto docbook2x\n```",
          "```bash\n$ sudo apt-get install install-info\n```",
          "```bash\n$ sudo dnf install getopt\n$ sudo apt-get install getopt\n```",
          "```bash\n$ sudo ln -s /usr/bin/db2x_docbook2texi /usr/bin/docbook2x-texi\n```",
          "```bash\n$ tar -zxf git-2.0.0.tar.gz\n$ cd git-2.0.0\n$ make configure\n$ ./configure --prefix=/usr\n$ make all doc info\n$ sudo make install install-doc install-html install-info\n```",
          "```bash\n$ git clone git://git.kernel.org/pub/scm/git/git.git\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 874
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/시작하기-Git-설치",
    "doc_type": "git",
    "total_sections": 5
  },
  {
    "title": "1.6 시작하기 - Git 최초 설정",
    "summary": "Git 최초 설정 Git을 설치하고 나면 Git의 사용 환경을 적절하게 설정해 주어야 한다. 환경 설정은 한 컴퓨터에서 한 번만 하면 된다. 설정한 내용은 Git을 업그레이드해도 유지된다. 언제든지 다시 바꿀 수 있는 명령어도 있다. 'git config’라는 도구로 설정 내용을 확인하고 변경할 수 있다. Git은 이 설정에 따라 동작한다. 이때 사용하는 설정 파일은 세 가지나 된다. /etc/gitconfig 파일: 시스템의 모든 사용자와 모든 저장소에 적용되는 설정이다. git config --system 옵션으로 이 파일을 읽고 쓸 수 있다. (이 파일은 시스템 전체 설정파일이기 때문에 수정하려면 시스템의 관리자 권한이 필요하다.) ~/.gitconfig, ~/.config/git/config 파일: 특정 사용자(즉 현재 사용자)에게만 적용되는 설정이다. git config --global 옵션으로 이 파일을 읽고 쓸 수 있다. 특정 사용자의 모든 저장소 설정에 적용된다. .g",
    "sections": [
      {
        "header": "Git 최초 설정",
        "content": "Git을 설치하고 나면 Git의 사용 환경을 적절하게 설정해 주어야 한다. 환경 설정은 한 컴퓨터에서 한 번만 하면 된다. 설정한 내용은 Git을 업그레이드해도 유지된다. 언제든지 다시 바꿀 수 있는 명령어도 있다.\n\n'git config’라는 도구로 설정 내용을 확인하고 변경할 수 있다. Git은 이 설정에 따라 동작한다. 이때 사용하는 설정 파일은 세 가지나 된다.\n\n/etc/gitconfig 파일: 시스템의 모든 사용자와 모든 저장소에 적용되는 설정이다. git config --system 옵션으로 이 파일을 읽고 쓸 수 있다. (이 파일은 시스템 전체 설정파일이기 때문에 수정하려면 시스템의 관리자 권한이 필요하다.)\n\n~/.gitconfig, ~/.config/git/config 파일: 특정 사용자(즉 현재 사용자)에게만 적용되는 설정이다. git config --global 옵션으로 이 파일을 읽고 쓸 수 있다. 특정 사용자의 모든 저장소 설정에 적용된다.\n\n.git/config : 이 파일은 Git 디렉토리에 있고 특정 저장소(혹은 현재 작업 중인 프로젝트)에만 적용된다. --local 옵션을 사용하면 이 파일을 사용하도록 지정할 수 있다. 하지만 기본적으로 이 옵션이 적용되어 있다. (당연히, 이 옵션을 적용하려면 Git 저장소인 디렉토리로 이동 한 후 적용할 수 있다.)\n\n각 설정은 역순으로 우선시 된다. 그래서 .git/config 가 /etc/gitconfig 보다 우선한다.\n\nWindows에서는 $HOME 디렉토리에서 .gitconfig 파일을 찾는다(아마도 C:\\Users\\$USER 디렉토리). Windows에서도 /etc/gitconfig 파일은 그 경로에서 찾는다. 이 경로는 아마도 MSys 루트의 상대경로일 텐데, MSys 루트는 인스톨러로 Git을 Windows에 설치할 때 결정된다. 'Git for Windows' 2.x 버전에서는 조금 다르다. Windows XP 사용자는 C:\\Documents and Settings\\All Users\\Application Data\\Git\\config 디렉토리에서 찾을 수 있고 Windows Vista 이후 버전 사용자는 C:\\ProgramData\\Git\\config 에서 찾을 수 있다. 이 시스템 설정 파일의 경로는 git config -f <file> 명령으로 변경할 수 있다. 관리자 권한이 필요하다.\n\n• /etc/gitconfig 파일: 시스템의 모든 사용자와 모든 저장소에 적용되는 설정이다. git config --system 옵션으로 이 파일을 읽고 쓸 수 있다. (이 파일은 시스템 전체 설정파일이기 때문에 수정하려면 시스템의 관리자 권한이 필요하다.)\n• ~/.gitconfig, ~/.config/git/config 파일: 특정 사용자(즉 현재 사용자)에게만 적용되는 설정이다. git config --global 옵션으로 이 파일을 읽고 쓸 수 있다. 특정 사용자의 모든 저장소 설정에 적용된다.\n• .git/config : 이 파일은 Git 디렉토리에 있고 특정 저장소(혹은 현재 작업 중인 프로젝트)에만 적용된다. --local 옵션을 사용하면 이 파일을 사용하도록 지정할 수 있다. 하지만 기본적으로 이 옵션이 적용되어 있다. (당연히, 이 옵션을 적용하려면 Git 저장소인 디렉토리로 이동 한 후 적용할 수 있다.)",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1646
        }
      },
      {
        "header": "사용자 정보",
        "content": "Git을 설치하고 나서 가장 먼저 해야 하는 것은 사용자이름과 이메일 주소를 설정하는 것이다. Git은 커밋할 때마다 이 정보를 사용한다. 한 번 커밋한 후에는 정보를 변경할 수 없다.\n\n다시 말하자면 --global 옵션으로 설정하는 것은 딱 한 번만 하면 된다. 해당 시스템에서 해당 사용자가 사용할 때는 이 정보를 사용한다. 만약 프로젝트마다 다른 이름과 이메일 주소를 사용하고 싶으면 --global 옵션을 빼고 명령을 실행한다.\n\nGUI 도구들은 처음 실행할 때 이 설정을 묻는다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git config --global user.name \"John Doe\"\n$ git config --global user.email johndoe@example.com\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 274
        }
      },
      {
        "header": "편집기",
        "content": "사용자 정보를 설정하고 나면 Git에서 사용할 텍스트 편집기를 고른다. 기본적으로 Git은 시스템의 기본 편집기를 사용한다.\n\n하지만, Emacs 같은 다른 텍스트 편집기를 사용할 수 있고 아래와 같이 실행하면 된다.\n\nWindows 사용자라면 다른 텍스트 편집기를 사용할 수 있다. 실행파일의 전체 경로를 설정해주면 된다. 실행파일의 전체 경로는 사용하는 편집기에 따라 다르다.\n\nWindows 환경에서 많이 사용되는 Notepad 편집기의 경우 주로 32비트 버전을 사용하게 된다. 현재 기준으로 64비트 버전을 사용하면 동작하지 않는 플러그인이 많다. 32비트 Windows 시스템이거나, 64비트 Windows 시스템에서 64비트 Notepad을 설치했다면 다음과 같이 설정한다.\n\n64비트 Windows 시스템에서 32비트 Notepad++을 설치했다면 C:\\Program Files (x86) 에 설치된다.\n\nVim과 Emacs, Notepad++은 꽤 인기 있는 편집기로 개발자들이 즐겨 사용한다. Mac이나 Linux 같은 Unix 시스템, Windows 시스템에서 사용 가능하다. 여기서 소개하는 편집기들이 불편해서 다른 편집기를 사용하고자 한다면 해당 편집기를 Git 편집기로 설정하는 방법을 찾아봐야 한다.\n\n자신의 편집기를 설정하지 않으면 갑자기 실행된 편집기에 당황할 수 있다. 그땐 당황하지 말고 편집기를 그냥 종료하면 Git 명령을 취소할 수 있다.\n\n노트 | Vim과 Emacs, Notepad++은 꽤 인기 있는 편집기로 개발자들이 즐겨 사용한다. Mac이나 Linux 같은 Unix 시스템, Windows 시스템에서 사용 가능하다. 여기서 소개하는 편집기들이 불편해서 다른 편집기를 사용하고자 한다면 해당 편집기를 Git 편집기로 설정하는 방법을 찾아봐야 한다.\n\n경고 | 자신의 편집기를 설정하지 않으면 갑자기 실행된 편집기에 당황할 수 있다. 그땐 당황하지 말고 편집기를 그냥 종료하면 Git 명령을 취소할 수 있다.\n\n[Note] 노트 Vim과 Emacs, Notepad++은 꽤 인기 있는 편집기로 개발자들이 즐겨 사용한다. Mac이나 Linux 같은 Unix 시스템, Windows 시스템에서 사용 가능하다. 여기서 소개하는 편집기들이 불편해서 다른 편집기를 사용하고자 한다면 해당 편집기를 Git 편집기로 설정하는 방법을 찾아봐야 한다.\n\n[Warning] 경고 자신의 편집기를 설정하지 않으면 갑자기 실행된 편집기에 당황할 수 있다. 그땐 당황하지 말고 편집기를 그냥 종료하면 Git 명령을 취소할 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git config --global core.editor emacs\n```",
          "```bash\n$ git config --global core.editor \"'C:/Program Files/Notepad++/notepad++.exe' -multiInst -nosession\"\n```",
          "```bash\n$ git config --global core.editor \"'C:/Program Files (x86)/Notepad++/notepad++.exe' -multiInst -nosession\"\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 7,
          "content_length": 1261
        }
      },
      {
        "header": "설정 확인",
        "content": "git config --list 명령을 실행하면 설정한 모든 것을 보여주어 바로 확인할 수 있다.\n\nGit은 같은 키를 여러 파일(/etc/gitconfig 와 ~/.gitconfig 같은)에서 읽기 때문에 같은 키가 여러 개 있을 수도 있다. 그러면 Git은 나중 값을 사용한다.\n\ngit config <key> 명령으로 Git이 특정 Key에 대해 어떤 값을 사용하는지 확인할 수 있다.\n\nGit이 설정된 값을 읽을 때 여러 파일에서 동일한 키에 대해 다른 값을 설정하고 있을 수 있다. 값이 기대한 값과 다를 수 있는데 값만 보고 쉽게 그 원인을 찾을 수 없다. 이 때 키에 설정된 값이 어디에서 설정되었는지 확인할 수 있는데 다음과 같은 명령으로 어떤 파일로부터 설정된 값인지를 확인할 수 있다.\n\n노트 | Git이 설정된 값을 읽을 때 여러 파일에서 동일한 키에 대해 다른 값을 설정하고 있을 수 있다. 값이 기대한 값과 다를 수 있는데 값만 보고 쉽게 그 원인을 찾을 수 없다. 이 때 키에 설정된 값이 어디에서 설정되었는지 확인할 수 있는데 다음과 같은 명령으로 어떤 파일로부터 설정된 값인지를 확인할 수 있다. $ git config --show-origin rerere.autoUpdate file:/home/johndoe/.gitconfig false\n\n[Note] 노트 Git이 설정된 값을 읽을 때 여러 파일에서 동일한 키에 대해 다른 값을 설정하고 있을 수 있다. 값이 기대한 값과 다를 수 있는데 값만 보고 쉽게 그 원인을 찾을 수 없다. 이 때 키에 설정된 값이 어디에서 설정되었는지 확인할 수 있는데 다음과 같은 명령으로 어떤 파일로부터 설정된 값인지를 확인할 수 있다. $ git config --show-origin rerere.autoUpdate file:/home/johndoe/.gitconfig false",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git config --list\nuser.name=John Doe\nuser.email=johndoe@example.com\ncolor.status=auto\ncolor.branch=auto\ncolor.interactive=auto\ncolor.diff=auto\n...\n```",
          "```bash\n$ git config user.name\nJohn Doe\n```",
          "```bash\n$ git config --show-origin rerere.autoUpdate\nfile:/home/johndoe/.gitconfig\tfalse\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 4,
          "content_length": 920
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/시작하기-Git-최초-설정",
    "doc_type": "git",
    "total_sections": 4
  },
  {
    "title": "1.7 시작하기 - 도움말 보기",
    "summary": "도움말 보기 명령어에 대한 도움말이 필요할 때 도움말을 보는 방법은 두 가지로 동일한 결과를 볼 수 있다. $ git help <verb> $ man git-<verb> 예를 들어 아래와 같이 실행하면 git config 명령에 대한 도움말을 볼 수 있다. $ git help config 도움말은 언제 어디서나 볼 수 있다. 오프라인으로도 볼 수 있다. 도움말과 이 책으로 부족하면 다른 사람의 도움을 받는 것이 필요하다. Freenode IRC 서버(irc.freenode.net)에 있는 #git 이나 #github 채널로 찾아가라. 이 채널에는 보통 수백 명의 사람이 접속해 있다. 모두 Git에 대해 잘 알고 있다. 기꺼이 도와줄 것이다. Git 명령을 사용하기 위해 매우 자세한 도움말 전체를 볼 필요 없이 각 명령에서 사용할 수 있는 옵션들에 대해서 간략히 살펴볼수도 있다. -h, --help 옵션을 사용하면 다음과 같이 Git 명령에서 사용할 수 있는 옵션들에 대한 간단한 도움",
    "sections": [
      {
        "header": "도움말 보기",
        "content": "명령어에 대한 도움말이 필요할 때 도움말을 보는 방법은 두 가지로 동일한 결과를 볼 수 있다.\n\n예를 들어 아래와 같이 실행하면 git config 명령에 대한 도움말을 볼 수 있다.\n\n도움말은 언제 어디서나 볼 수 있다. 오프라인으로도 볼 수 있다. 도움말과 이 책으로 부족하면 다른 사람의 도움을 받는 것이 필요하다. Freenode IRC 서버(irc.freenode.net)에 있는 #git 이나 #github 채널로 찾아가라. 이 채널에는 보통 수백 명의 사람이 접속해 있다. 모두 Git에 대해 잘 알고 있다. 기꺼이 도와줄 것이다.\n\nGit 명령을 사용하기 위해 매우 자세한 도움말 전체를 볼 필요 없이 각 명령에서 사용할 수 있는 옵션들에 대해서 간략히 살펴볼수도 있다. -h, --help 옵션을 사용하면 다음과 같이 Git 명령에서 사용할 수 있는 옵션들에 대한 간단한 도움말을 출력한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git help <verb>\n$ man git-<verb>\n```",
          "```bash\n$ git help config\n```",
          "```bash\n$ git add -h\nusage: git add [<options>] [--] <pathspec>...\n\n    -n, --dry-run         dry run\n    -v, --verbose         be verbose\n\n    -i, --interactive     interactive picking\n    -p, --patch           select hunks interactively\n    -e, --edit            edit current diff and apply\n    -f, --force           allow adding otherwise ignored files\n    -u, --update          update tracked files\n    -N, --intent-to-add   record only the fact that the path will be added later\n    -A, --all             add changes from all tracked and untracked files\n    --ignore-removal      ignore paths removed in the working tree (same as --no-all)\n    --refresh             don't add, only refresh the index\n    --ignore-errors       just skip files which cannot be added because of errors\n    --ignore-missing      check if - even missing - files are ignored in dry run\n    --chmod <(+/-)x>      override the executable bit of the listed files\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 451
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/시작하기-도움말-보기",
    "doc_type": "git",
    "total_sections": 1
  },
  {
    "title": "2.1 Git의 기초 - Git 저장소 만들기",
    "summary": "Git을 사용하는 방법을 알고 싶은데 한 챕터밖에 읽을 시간이 없다면 이번 챕터를 읽어야 한다. Git에서 자주 사용하는 명령어는 모두 2장에 등장한다. 2장을 다 읽으면 저장소를 만들고 설정하는 방법, 파일을 추적하거나(Track) 추적을 그만두는 방법, 변경 내용을 Stage 하고 커밋하는 방법을 알게 된다. 파일이나 파일 패턴을 무시하도록 Git을 설정하는 방법, 실수를 쉽고 빠르게 만회하는 방법, 프로젝트 히스토리를 조회하고 커밋을 비교하는 방법, 리모트 저장소에 Push 하고 Pull 하는 방법을 살펴본다. Git 저장소 만들기 주로 다음 두 가지 중 한 가지 방법으로 Git 저장소를 쓰기 시작한다. 아직 버전관리를 하지 않는 로컬 디렉토리 하나를 선택해서 Git 저장소를 적용하는 방법 다른 어딘가에서 Git 저장소를 Clone 하는 방법 어떤 방법을 사용하든 로컬 디렉토리에 Git 저장소가 준비되면 이제 뭔가 해볼 수 있다. 기존 디렉토리를 Git 저장소로 만들기 버전관리",
    "sections": [
      {
        "header": "",
        "content": "Git을 사용하는 방법을 알고 싶은데 한 챕터밖에 읽을 시간이 없다면 이번 챕터를 읽어야 한다. Git에서 자주 사용하는 명령어는 모두 2장에 등장한다. 2장을 다 읽으면 저장소를 만들고 설정하는 방법, 파일을 추적하거나(Track) 추적을 그만두는 방법, 변경 내용을 Stage 하고 커밋하는 방법을 알게 된다. 파일이나 파일 패턴을 무시하도록 Git을 설정하는 방법, 실수를 쉽고 빠르게 만회하는 방법, 프로젝트 히스토리를 조회하고 커밋을 비교하는 방법, 리모트 저장소에 Push 하고 Pull 하는 방법을 살펴본다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 291
        }
      },
      {
        "header": "Git 저장소 만들기",
        "content": "주로 다음 두 가지 중 한 가지 방법으로 Git 저장소를 쓰기 시작한다.\n\n아직 버전관리를 하지 않는 로컬 디렉토리 하나를 선택해서 Git 저장소를 적용하는 방법\n\n다른 어딘가에서 Git 저장소를 Clone 하는 방법\n\n어떤 방법을 사용하든 로컬 디렉토리에 Git 저장소가 준비되면 이제 뭔가 해볼 수 있다.\n\n• 아직 버전관리를 하지 않는 로컬 디렉토리 하나를 선택해서 Git 저장소를 적용하는 방법\n• 다른 어딘가에서 Git 저장소를 Clone 하는 방법",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 256
        }
      },
      {
        "header": "기존 디렉토리를 Git 저장소로 만들기",
        "content": "버전관리를 하지 아니하는 기존 프로젝트를 Git으로 관리하고 싶은 경우 우선 프로젝트의 디렉토리로 이동한다. 이러한 과정을 처음 해보는 것이라면 시스템마다 조금 다른 점을 주의하자.\n\n그리고 아래와 같은 명령을 실행한다:\n\n이 명령은 .git 이라는 하위 디렉토리를 만든다. .git 디렉토리에는 저장소에 필요한 뼈대 파일(Skeleton)이 들어 있다. 이 명령만으로는 아직 프로젝트의 어떤 파일도 관리하지 않는다. (.git 디렉토리가 막 만들어진 직후에 정확히 어떤 파일이 있는지에 대한 내용은 Git의 내부에서 다룬다)\n\nGit이 파일을 관리하게 하려면 저장소에 파일을 추가하고 커밋해야 한다. git add 명령으로 파일을 추가하고 git commit 명령으로 커밋한다:\n\n명령어 몇 개로 순식간에 Git 저장소를 만들고 파일 버전 관리를 시작했다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ cd /home/user/my_project\n```",
          "```bash\n$ cd /Users/user/my_project\n```",
          "```bash\n$ cd /c/user/my_project\n```",
          "```bash\n$ git init\n```",
          "```bash\n$ git add *.c\n$ git add LICENSE\n$ git commit -m 'initial project version'\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 424
        }
      },
      {
        "header": "기존 저장소를 Clone 하기",
        "content": "다른 프로젝트에 참여하려거나(Contribute) Git 저장소를 복사하고 싶을 때 git clone 명령을 사용한다. 이미 Subversion 같은 VCS에 익숙한 사용자에게는 \"checkout\" 이 아니라 \"clone\" 이라는 점이 도드라져 보일 것이다. Git이 Subversion과 다른 가장 큰 차이점은 서버에 있는 거의 모든 데이터를 복사한다는 것이다. git clone 을 실행하면 프로젝트 히스토리를 전부 받아온다. 실제로 서버의 디스크가 망가져도 클라이언트 저장소 중에서 아무거나 하나 가져다가 복구하면 된다(서버에만 적용했던 설정은 복구하지 못하지만 모든 데이터는 복구된다 - 서버에 Git 설치하기에서 좀 더 자세히 다룬다).\n\ngit clone <url> 명령으로 저장소를 Clone 한다. libgit2 라이브러리 소스코드를 Clone 하려면 아래과 같이 실행한다.\n\n이 명령은 “libgit2” 라는 디렉토리를 만들고 그 안에 .git 디렉토리를 만든다. 그리고 저장소의 데이터를 모두 가져와서 자동으로 가장 최신 버전을 Checkout 해 놓는다. libgit2 디렉토리로 이동하면 Checkout으로 생성한 파일을 볼 수 있고 당장 하고자 하는 일을 시작할 수 있다.\n\n아래과 같은 명령을 사용하여 저장소를 Clone 하면 libgit2 이 아니라 다른 디렉토리 이름으로 Clone 할 수 있다.\n\n디렉토리 이름이 mylibgit 이라는 것만 빼면 이 명령의 결과와 앞선 명령의 결과는 같다.\n\nGit은 다양한 프로토콜을 지원한다. 이제까지는 https:// 프로토콜을 사용했지만 git:// 를 사용할 수도 있고 user@server:path/to/repo.git 처럼 SSH 프로토콜을 사용할 수도 있다. 자세한 내용은 서버에 Git 설치하기에서 다루며 각 프로토콜의 장단점과 Git 저장소에 접근하는 방법을 설명한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git clone https://github.com/libgit2/libgit2\n```",
          "```bash\n$ git clone https://github.com/libgit2/libgit2 mylibgit\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 924
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git의-기초-Git-저장소-만들기",
    "doc_type": "git",
    "total_sections": 4
  },
  {
    "title": "2.2 Git의 기초 - 수정하고 저장소에 저장하기",
    "summary": "수정하고 저장소에 저장하기 만질 수 있는 Git 저장소를 하나 만들었고 워킹 디렉토리에 Checkout도 했다. 이제는 파일을 수정하고 파일의 스냅샷을 커밋해 보자. 파일을 수정하다가 저장하고 싶으면 스냅샷을 커밋한다. 워킹 디렉토리의 모든 파일은 크게 Tracked(관리대상임)와 Untracked(관리대상이 아님)로 나눈다. Tracked 파일은 이미 스냅샷에 포함돼 있던 파일이다. Tracked 파일은 또 Unmodified(수정하지 않음)와 Modified(수정함) 그리고 Staged(커밋으로 저장소에 기록할) 상태 중 하나이다. 간단히 말하자면 Git이 알고 있는 파일이라는 것이다. 그리고 나머지 파일은 모두 Untracked 파일이다. Untracked 파일은 워킹 디렉토리에 있는 파일 중 스냅샷에도 Staging Area에도 포함되지 않은 파일이다. 처음 저장소를 Clone 하면 모든 파일은 Tracked이면서 Unmodified 상태이다. 파일을 Checkout 하고 나",
    "sections": [
      {
        "header": "수정하고 저장소에 저장하기",
        "content": "만질 수 있는 Git 저장소를 하나 만들었고 워킹 디렉토리에 Checkout도 했다. 이제는 파일을 수정하고 파일의 스냅샷을 커밋해 보자. 파일을 수정하다가 저장하고 싶으면 스냅샷을 커밋한다.\n\n워킹 디렉토리의 모든 파일은 크게 Tracked(관리대상임)와 Untracked(관리대상이 아님)로 나눈다. Tracked 파일은 이미 스냅샷에 포함돼 있던 파일이다. Tracked 파일은 또 Unmodified(수정하지 않음)와 Modified(수정함) 그리고 Staged(커밋으로 저장소에 기록할) 상태 중 하나이다. 간단히 말하자면 Git이 알고 있는 파일이라는 것이다.\n\n그리고 나머지 파일은 모두 Untracked 파일이다. Untracked 파일은 워킹 디렉토리에 있는 파일 중 스냅샷에도 Staging Area에도 포함되지 않은 파일이다. 처음 저장소를 Clone 하면 모든 파일은 Tracked이면서 Unmodified 상태이다. 파일을 Checkout 하고 나서 아무것도 수정하지 않았기 때문에 그렇다.\n\n마지막 커밋 이후 아직 아무것도 수정하지 않은 상태에서 어떤 파일을 수정하면 Git은 그 파일을 Modified 상태로 인식한다. 실제로 커밋을 하기 위해서는 이 수정한 파일을 Staged 상태로 만들고, Staged 상태의 파일을 커밋한다. 이런 라이프사이클을 계속 반복한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 668
        }
      },
      {
        "header": "파일의 상태 확인하기",
        "content": "파일의 상태를 확인하려면 보통 git status 명령을 사용한다. Clone 한 후에 바로 이 명령을 실행하면 아래과 같은 메시지를 볼 수 있다.\n\n위의 내용은 파일을 하나도 수정하지 않았다는 것을 말해준다. Tracked 파일은 하나도 수정되지 않았다는 의미다. Untracked 파일은 아직 없어서 목록에 나타나지 않는다. 그리고 현재 작업 중인 브랜치를 알려주며 서버의 같은 브랜치로부터 진행된 작업이 없는 것을 나타낸다. 기본 브랜치가 master이기 때문에 현재 브랜치 이름이 “master” 로 나온다. 브랜치 관련 내용은 차차 알아가자. Git 브랜치 에서 브랜치와 Refs에 대해 자세히 다룬다.\n\n프로젝트에 README 파일을 만들어보자. README 파일은 새로 만든 파일이기 때문에 git status 를 실행하면 'Untracked files’에 들어 있다:\n\nREADME 파일은 “Untracked files” 부분에 속해 있는데 이것은 README 파일이 Untracked 상태라는 것을 말한다. Git은 Untracked 파일을 아직 스냅샷(커밋)에 넣어지지 않은 파일이라고 본다. 파일이 Tracked 상태가 되기 전까지는 Git은 절대 그 파일을 커밋하지 않는다. 그래서 일하면서 생성하는 바이너리 파일 같은 것을 커밋하는 실수는 하지 않게 된다. README 파일을 추가해서 직접 Tracked 상태로 만들어 보자.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nnothing to commit, working directory clean\n```",
          "```bash\n$ echo 'My Project' > README\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n    README\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 699
        }
      },
      {
        "header": "파일을 새로 추적하기",
        "content": "git add 명령으로 파일을 새로 추적할 수 있다. 아래 명령을 실행하면 Git은 README 파일을 추적한다.\n\ngit status 명령을 다시 실행하면 README 파일이 Tracked 상태이면서 커밋에 추가될 Staged 상태라는 것을 확인할 수 있다.\n\n“Changes to be committed” 에 들어 있는 파일은 Staged 상태라는 것을 의미한다. 커밋하면 git add 를 실행한 시점의 파일이 커밋되어 저장소 히스토리에 남는다. 앞에서 git init 명령을 실행한 후, git add (files) 명령을 실행했던 걸 기억할 것이다. 이 명령을 통해 디렉토리에 있는 파일을 추적하고 관리하도록 한다. git add 명령은 파일 또는 디렉토리의 경로를 아규먼트로 받는다. 디렉토리면 아래에 있는 모든 파일들까지 재귀적으로 추가한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git add README\n```",
          "```bash\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   README\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 422
        }
      },
      {
        "header": "Modified 상태의 파일을 Stage 하기",
        "content": "이미 Tracked 상태인 파일을 수정하는 법을 알아보자. CONTRIBUTING.md 라는 파일을 수정하고 나서 git status 명령을 다시 실행하면 결과는 아래와 같다.\n\n이 CONTRIBUTING.md 파일은 “Changes not staged for commit” 에 있다. 이것은 수정한 파일이 Tracked 상태이지만 아직 Staged 상태는 아니라는 것이다. Staged 상태로 만들려면 git add 명령을 실행해야 한다. git add 명령은 파일을 새로 추적할 때도 사용하고 수정한 파일을 Staged 상태로 만들 때도 사용한다. Merge 할 때 충돌난 상태의 파일을 Resolve 상태로 만들때도 사용한다. add의 의미는 프로젝트에 파일을 추가한다기 보다는 다음 커밋에 추가한다고 받아들이는게 좋다. git add 명령을 실행하여 CONTRIBUTING.md 파일을 Staged 상태로 만들고 git status 명령으로 결과를 확인해보자.\n\n두 파일 모두 Staged 상태이므로 다음 커밋에 포함된다. 하지만 아직 더 수정해야 한다는 것을 알게 되어 바로 커밋하지 못하는 상황이 되었다고 생각해보자. 이 상황에서 CONTRIBUTING.md 파일을 열고 수정한다. 이제 커밋할 준비가 다 됐다고 생각할 테지만, Git은 그렇지 않다. git status 명령으로 파일의 상태를 다시 확인해보자.\n\n헉! CONTRIBUTING.md 가 Staged 상태이면서 동시에 Unstaged 상태로 나온다. 어떻게 이런 일이 가능할까? git add 명령을 실행하면 Git은 파일을 바로 Staged 상태로 만든다. 지금 이 시점에서 커밋을 하면 git commit 명령을 실행하는 시점의 버전이 커밋되는 것이 아니라 마지막으로 git add 명령을 실행했을 때의 버전이 커밋된다. 그러니까 git add 명령을 실행한 후에 또 파일을 수정하면 git add 명령을 다시 실행해서 최신 버전을 Staged 상태로 만들어야 한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   README\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n```",
          "```bash\n$ git add CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   README\n    modified:   CONTRIBUTING.md\n```",
          "```bash\n$ vim CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   README\n    modified:   CONTRIBUTING.md\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n```",
          "```bash\n$ git add CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   README\n    modified:   CONTRIBUTING.md\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 977
        }
      },
      {
        "header": "파일 상태를 짤막하게 확인하기",
        "content": "git status 명령으로 확인할 수 있는 내용이 좀 많아 보일 수 있다. 사실 그렇다. 좀 더 간단하게 변경 내용을 보여주는 옵션이 있다. git status -s 또는 git status --short 처럼 옵션을 주면 현재 변경한 상태를 짤막하게 보여준다.\n\n아직 추적하지 않는 새 파일 앞에는 ?? 표시가 붙는다. Staged 상태로 추가한 파일 중 새로 생성한 파일 앞에는 A 표시가, 수정한 파일 앞에는 M 표시가 붙는다. 위 명령의 결과에서 상태정보 컬럼에는 두 가지 정보를 보여준다. 왼쪽에는 Staging Area에서의 상태를, 오른쪽에는 Working Tree에서의 상태를 표시한다. README 파일 같은 경우 내용을 변경했지만 아직 Staged 상태로 추가하지는 않았다. lib/simplegit.rb 파일은 내용을 변경하고 Staged 상태로 추가까지 한 상태이다. 위 결과에서 차이점을 비교해보자. Rakefile 은 변경하고 Staged 상태로 추가한 후 또 내용을 변경해서 Staged 이면서 Unstaged 상태인 파일이다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git status -s\n M README\nMM Rakefile\nA  lib/git.rb\nM  lib/simplegit.rb\n?? LICENSE.txt\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 535
        }
      },
      {
        "header": "파일 무시하기",
        "content": "어떤 파일은 Git이 관리할 필요가 없다. 보통 로그 파일이나 빌드 시스템이 자동으로 생성한 파일이 그렇다. 그런 파일을 무시하려면 .gitignore 파일을 만들고 그 안에 무시할 파일 패턴을 적는다. 아래는 .gitignore 파일의 예이다.\n\n첫번째 라인은 확장자가 “.o” 나 “.a” 인 파일을 Git이 무시하라는 것이고 둘째 라인은 ~ 로 끝나는 모든 파일을 무시하라는 것이다. 보통 대부분의 텍스트 편집기에서 임시파일로 사용하는 파일 이름이기 때문이다. “.o” 와 “.a” 는 각각 빌드 시스템이 만들어내는 오브젝트와 아카이브 파일이고 ~ 로 끝나는 파일은 Emacs나 VI 같은 텍스트 편집기가 임시로 만들어내는 파일이다. 또 log, tmp, pid 같은 디렉토리나, 자동으로 생성하는 문서 같은 것들도 추가할 수 있다. .gitignore 파일은 보통 처음에 만들어 두는 것이 편리하다. 그래서 Git 저장소에 커밋하고 싶지 않은 파일을 실수로 커밋하는 일을 방지할 수 있다.\n\n.gitignore 파일에 입력하는 패턴은 아래 규칙을 따른다.\n\n아무것도 없는 라인이나, # 로 시작하는 라인은 무시한다.\n\n표준 Glob 패턴을 사용한다. 이는 프로젝트 전체에 적용된다.\n\n슬래시(/)로 시작하면 하위 디렉토리에 적용되지(Recursivity) 않는다.\n\n디렉토리는 슬래시(/)를 끝에 사용하는 것으로 표현한다.\n\n느낌표(!)로 시작하는 패턴의 파일은 무시하지 않는다.\n\nGlob 패턴은 정규표현식을 단순하게 만든 것으로 생각하면 되고 보통 쉘에서 많이 사용한다. 애스터리스크(*)는 문자가 하나도 없거나 하나 이상을 의미하고, [abc] 는 중괄호 안에 있는 문자 중 하나를 의미한다(그러니까 이 경우에는 a, b, c). 물음표(?)는 문자 하나를 말하고, [0-9] 처럼 중괄호 안의 캐릭터 사이에 하이픈(-)을 사용하면 그 캐릭터 사이에 있는 문자 하나를 말한다. 애스터리스크 2개를 사용하여 디렉토리 안의 디렉토리 까지 지정할 수 있다. a/**/z 패턴은 a/z, a/b/z, a/b/c/z 디렉토리에 사용할 수 있다.\n\n아래는 .gitignore 파일의 예이다.\n\nGitHub은 다양한 프로젝트에서 자주 사용하는 .gitignore 예제를 관리하고 있다. 어떤 내용을 넣을지 막막하다면 https://github.com/github/gitignore 사이트에서 적당한 예제를 찾을 수 있다.\n\n.gitignore 를 사용하는 간단한 방식은 하나의 .gitignore 파일을 최상위 디렉토리에 하나 두고 모든 하위 디렉토리에까지 적용시키는 방식이다. 물론 .gitignore 파일을 하나만 두는 것이 아니라 하위 디렉토리에도 추가로 둘 수도 있다. .gitignore 정책은 현재 .gitignore 파일이 위치한 디렉토리와 그 하위 디렉토리에 적용된다. (리눅스 커널 소스 저장소에는 .gitignore 파일이 206개나 있음)\n\n다수의 .gitignore 파일을 두고 정책을 적용하는 부분은 이 책에서 다루는 범위를 벗어난다. 자세한 내용은 man gitignore 에서 확인할 수 있다.\n\n• 아무것도 없는 라인이나, # 로 시작하는 라인은 무시한다.\n• 표준 Glob 패턴을 사용한다. 이는 프로젝트 전체에 적용된다.\n• 슬래시(/)로 시작하면 하위 디렉토리에 적용되지(Recursivity) 않는다.\n• 디렉토리는 슬래시(/)를 끝에 사용하는 것으로 표현한다.\n• 느낌표(!)로 시작하는 패턴의 파일은 무시하지 않는다.\n\n힌트 | GitHub은 다양한 프로젝트에서 자주 사용하는 .gitignore 예제를 관리하고 있다. 어떤 내용을 넣을지 막막하다면 https://github.com/github/gitignore 사이트에서 적당한 예제를 찾을 수 있다.\n\n노트 | .gitignore 를 사용하는 간단한 방식은 하나의 .gitignore 파일을 최상위 디렉토리에 하나 두고 모든 하위 디렉토리에까지 적용시키는 방식이다. 물론 .gitignore 파일을 하나만 두는 것이 아니라 하위 디렉토리에도 추가로 둘 수도 있다. .gitignore 정책은 현재 .gitignore 파일이 위치한 디렉토리와 그 하위 디렉토리에 적용된다. (리눅스 커널 소스 저장소에는 .gitignore 파일이 206개나 있음) 다수의 .gitignore 파일을 두고 정책을 적용하는 부분은 이 책에서 다루는 범위를 벗어난다. 자세한 내용은 man gitignore 에서 확인할 수 있다.\n\n[Tip] 힌트 GitHub은 다양한 프로젝트에서 자주 사용하는 .gitignore 예제를 관리하고 있다. 어떤 내용을 넣을지 막막하다면 https://github.com/github/gitignore 사이트에서 적당한 예제를 찾을 수 있다.\n\n[Note] 노트 .gitignore 를 사용하는 간단한 방식은 하나의 .gitignore 파일을 최상위 디렉토리에 하나 두고 모든 하위 디렉토리에까지 적용시키는 방식이다. 물론 .gitignore 파일을 하나만 두는 것이 아니라 하위 디렉토리에도 추가로 둘 수도 있다. .gitignore 정책은 현재 .gitignore 파일이 위치한 디렉토리와 그 하위 디렉토리에 적용된다. (리눅스 커널 소스 저장소에는 .gitignore 파일이 206개나 있음) 다수의 .gitignore 파일을 두고 정책을 적용하는 부분은 이 책에서 다루는 범위를 벗어난다. 자세한 내용은 man gitignore 에서 확인할 수 있다.",
        "code_examples": [
          "```bash\n# 확장자가 .a인 파일 무시\n*.a\n\n# 윗 라인에서 확장자가 .a인 파일은 무시하게 했지만 lib.a는 무시하지 않음\n!lib.a\n\n# 현재 디렉토리에 있는 TODO파일은 무시하고 subdir/TODO처럼 하위디렉토리에 있는 파일은 무시하지 않음\n/TODO\n\n# build/ 디렉토리에 있는 모든 파일은 무시\nbuild/\n\n# doc/notes.txt 파일은 무시하고 doc/server/arch.txt 파일은 무시하지 않음\ndoc/*.txt\n\n# doc 디렉토리 아래의 모든 .pdf 파일을 무시\ndoc/**/*.pdf\n```"
        ],
        "usage_examples": [
          "```bash\n$ cat .gitignore\n*.[oa]\n*~\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 13,
          "content_length": 2666
        }
      },
      {
        "header": "Staged와 Unstaged 상태의 변경 내용을 보기",
        "content": "단순히 파일이 변경됐다는 사실이 아니라 어떤 내용이 변경됐는지 살펴보려면 git status 명령이 아니라 git diff 명령을 사용해야 한다. 보통 우리는 '수정했지만, 아직 Staged 파일이 아닌 것?'과 '어떤 파일이 Staged 상태인지?'가 궁금하기 때문에 git status 명령으로도 충분하다. 더 자세하게 볼 때는 git diff 명령을 사용하는데 Patch처럼 어떤 라인을 추가했고 삭제했는지가 궁금할 때 사용한다. git diff 는 나중에 더 자세히 다룬다.\n\nREADME 파일을 수정해서 Staged 상태로 만들고 CONTRIBUTING.md 파일은 그냥 수정만 해둔다. 이 상태에서 git status 명령을 실행하면 아래와 같은 메시지를 볼 수 있다.\n\ngit diff 명령을 실행하면 수정했지만 아직 staged 상태가 아닌 파일을 비교해 볼 수 있다.\n\n이 명령은 워킹 디렉토리에 있는 것과 Staging Area에 있는 것을 비교한다. 그래서 수정하고 아직 Stage 하지 않은 것을 보여준다.\n\n만약 커밋하려고 Staging Area에 넣은 파일의 변경 부분을 보고 싶으면 git diff --staged 옵션을 사용한다. 이 명령은 저장소에 커밋한 것과 Staging Area에 있는 것을 비교한다.\n\n꼭 잊지 말아야 할 것이 있는데 git diff 명령은 마지막으로 커밋한 후에 수정한 것들 전부를 보여주지 않는다. git diff 는 Unstaged 상태인 것들만 보여준다. 수정한 파일을 모두 Staging Area에 넣었다면 git diff 명령은 아무것도 출력하지 않는다.\n\nCONTRIBUTING.md 파일을 Stage 한 후에 다시 수정해도 git diff 명령을 사용할 수 있다. 이때는 Staged 상태인 것과 Unstaged 상태인 것을 비교한다.\n\ngit diff 명령으로 Unstaged 상태인 변경 부분을 확인할 수 있다.\n\nStaged 상태인 파일은 git diff --cached 옵션으로 확인한다. --staged 와 --cached 는 같은 옵션이다.\n\n이 책에서는 계속 git diff 명령으로 여기저기서 써 먹는다. 즐겨 쓰거나 결과를 아름답게 보여주는 Diff 도구가 있으면 사용할 수 있다. git diff 대신 git difftool 명령을 사용해서 emerge, vimdiff 같은 도구로 비교할 수 있다. 상용 제품도 사용할 수 있다. git difftool --tool-help 라는 명령은 사용가능한 도구를 보여준다.\n\n노트 | 외부 도구로 비교하기 이 책에서는 계속 git diff 명령으로 여기저기서 써 먹는다. 즐겨 쓰거나 결과를 아름답게 보여주는 Diff 도구가 있으면 사용할 수 있다. git diff 대신 git difftool 명령을 사용해서 emerge, vimdiff 같은 도구로 비교할 수 있다. 상용 제품도 사용할 수 있다. git difftool --tool-help 라는 명령은 사용가능한 도구를 보여준다.\n\n[Note] 노트 외부 도구로 비교하기 이 책에서는 계속 git diff 명령으로 여기저기서 써 먹는다. 즐겨 쓰거나 결과를 아름답게 보여주는 Diff 도구가 있으면 사용할 수 있다. git diff 대신 git difftool 명령을 사용해서 emerge, vimdiff 같은 도구로 비교할 수 있다. 상용 제품도 사용할 수 있다. git difftool --tool-help 라는 명령은 사용가능한 도구를 보여준다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    modified:   README\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n```",
          "```bash\n$ git diff\ndiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\nindex 8ebb991..643e24f 100644\n--- a/CONTRIBUTING.md\n+++ b/CONTRIBUTING.md\n@@ -65,7 +65,8 @@ branch directly, things can get messy.\n Please include a nice description of your changes when you submit your PR;\n if we have to read the whole diff to figure out why you're contributing\n in the first place, you're less likely to get feedback and have your change\n-merged in.\n+merged in. Also, split your changes into comprehensive chunks if your patch is\n+longer than a dozen lines.\n\n If you are starting to work on a particular area, feel free to submit a PR\n that highlights your work in progress (and note in the PR title that it's\n```",
          "```bash\n$ git diff --staged\ndiff --git a/README b/README\nnew file mode 100644\nindex 0000000..03902a1\n--- /dev/null\n+++ b/README\n@@ -0,0 +1 @@\n+My Project\n```",
          "```bash\n$ git add CONTRIBUTING.md\n$ echo '# test line' >> CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    modified:   CONTRIBUTING.md\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n```",
          "```bash\n$ git diff\ndiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\nindex 643e24f..87f08c8 100644\n--- a/CONTRIBUTING.md\n+++ b/CONTRIBUTING.md\n@@ -119,3 +119,4 @@ at the\n ## Starter Projects\n\n See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).\n+# test line\n```",
          "```bash\n$ git diff --cached\ndiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\nindex 8ebb991..643e24f 100644\n--- a/CONTRIBUTING.md\n+++ b/CONTRIBUTING.md\n@@ -65,7 +65,8 @@ branch directly, things can get messy.\n Please include a nice description of your changes when you submit your PR;\n if we have to read the whole diff to figure out why you're contributing\n in the first place, you're less likely to get feedback and have your change\n-merged in.\n+merged in. Also, split your changes into comprehensive chunks if your patch is\n+longer than a dozen lines.\n\n If you are starting to work on a particular area, feel free to submit a PR\n that highlights your work in progress (and note in the PR title that it's\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 10,
          "content_length": 1699
        }
      },
      {
        "header": "변경사항 커밋하기",
        "content": "수정한 것을 커밋하기 위해 Staging Area에 파일을 정리했다. Unstaged 상태의 파일은 커밋되지 않는다는 것을 기억해야 한다. Git은 생성하거나 수정하고 나서 git add 명령으로 추가하지 않은 파일은 커밋하지 않는다. 그 파일은 여전히 Modified 상태로 남아 있다. 커밋하기 전에 git status 명령으로 모든 것이 Staged 상태인지 확인할 수 있다. 그 후에 git commit 을 실행하여 커밋한다.\n\nGit 설정에 지정된 편집기가 실행되고, 아래와 같은 텍스트가 자동으로 포함된다 (아래 예제는 Vim 편집기의 화면이다. 이 편집기는 쉘의 EDITOR 환경 변수에 등록된 편집기이고 보통은 Vim이나 Emacs을 사용한다. 또 시작하기 에서 설명했듯이 git config --global core.editor 명령으로 어떤 편집기를 사용할지 설정할 수 있다).\n\n편집기는 아래와 같은 내용을 표시한다(아래 예제는 Vim 편집기).\n\n자동으로 생성되는 커밋 메시지의 첫 라인은 비어 있고 둘째 라인부터 git status 명령의 결과가 채워진다. 커밋한 내용을 쉽게 기억할 수 있도록 이 메시지를 포함할 수도 있고 메시지를 전부 지우고 새로 작성할 수 있다 (정확히 뭘 수정했는지도 보여줄 수 있는데, git commit 에 -v 옵션을 추가하면 편집기에 diff 메시지도 추가된다). 내용을 저장하고 편집기를 종료하면 Git은 입력된 내용(#로 시작하는 내용을 제외한)으로 새 커밋을 하나 완성한다.\n\n메시지를 인라인으로 첨부할 수도 있다. commit 명령을 실행할 때 아래와 같이 -m 옵션을 사용한다.\n\n이렇게 첫번째 커밋을 작성해보았다. commit 명령은 몇 가지 정보를 출력하는데 위 예제는 (master) 브랜치에 커밋했고 체크섬은 (463dc4f)이라고 알려준다. 그리고 수정한 파일이 몇 개이고 삭제됐거나 추가된 라인이 몇 라인인지 알려준다.\n\nGit은 Staging Area에 속한 스냅샷을 커밋한다는 것을 기억해야 한다. 수정은 했지만, 아직 Staging Area에 넣지 않은 것은 다음에 커밋할 수 있다. 커밋할 때마다 프로젝트의 스냅샷을 기록하기 때문에 나중에 스냅샷끼리 비교하거나 예전 스냅샷으로 되돌릴 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git commit\n```",
          "```bash\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n# On branch master\n# Your branch is up-to-date with 'origin/master'.\n#\n# Changes to be committed:\n#\tnew file:   README\n#\tmodified:   CONTRIBUTING.md\n#\n~\n~\n~\n\".git/COMMIT_EDITMSG\" 9L, 283C\n```",
          "```bash\n$ git commit -m \"Story 182: Fix benchmarks for speed\"\n[master 463dc4f] Story 182: Fix benchmarks for speed\n 2 files changed, 2 insertions(+)\n create mode 100644 README\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1106
        }
      },
      {
        "header": "Staging Area 생략하기",
        "content": "Staging Area는 커밋할 파일을 정리한다는 점에서 매우 유용하지만 복잡하기만 하고 필요하지 않은 때도 있다. 아주 쉽게 Staging Area를 생략할 수 있다. git commit 명령을 실행할 때 -a 옵션을 추가하면 Git은 Tracked 상태의 파일을 자동으로 Staging Area에 넣는다. 그래서 git add 명령을 실행하는 수고를 덜 수 있다.\n\n이 예제에서는 커밋하기 전에 git add 명령으로 CONTRIBUTING.md 파일을 추가하지 않았다는 점을 눈여겨보자. -a 옵션을 사용하면 모든 파일이 자동으로 추가된다. 편리한 옵션이긴 하지만 주의 깊게 사용해야 한다. 생각 없이 이 옵션을 사용하다 보면 추가하지 말아야 할 변경사항도 추가될 수 있기 때문이다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n$ git commit -a -m 'added new benchmarks'\n[master 83e38c7] added new benchmarks\n 1 file changed, 5 insertions(+), 0 deletions(-)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 385
        }
      },
      {
        "header": "파일 삭제하기",
        "content": "Git에서 파일을 제거하려면 git rm 명령으로 Tracked 상태의 파일을 삭제한 후에(정확하게는 Staging Area에서 삭제하는 것) 커밋해야 한다. 이 명령은 워킹 디렉토리에 있는 파일도 삭제하기 때문에 실제로 파일도 지워진다.\n\nGit 명령을 사용하지 않고 단순히 워킹 디렉터리에서 파일을 삭제하고 git status 명령으로 상태를 확인하면 Git은 현재 “Changes not staged for commit” (즉, Unstaged 상태)라고 표시해준다.\n\n그리고 git rm 명령을 실행하면 삭제한 파일은 Staged 상태가 된다.\n\n커밋하면 파일은 삭제되고 Git은 이 파일을 더는 추적하지 않는다. 이미 파일을 수정했거나 Staging Area에(역주 - Git Index라고도 부른다) 추가했다면 -f 옵션을 주어 강제로 삭제해야 한다. 이 점은 실수로 데이터를 삭제하지 못하도록 하는 안전장치다. 커밋 하지 않고 수정한 데이터는 Git으로 복구할 수 없기 때문이다.\n\n또 Staging Area에서만 제거하고 워킹 디렉토리에 있는 파일은 지우지 않고 남겨둘 수 있다. 다시 말해서 하드디스크에 있는 파일은 그대로 두고 Git만 추적하지 않게 한다. 이것은 .gitignore 파일에 추가하는 것을 빼먹었거나 대용량 로그 파일이나 컴파일된 파일인 .a 파일 같은 것을 실수로 추가했을 때 쓴다. --cached 옵션을 사용하여 명령을 실행한다.\n\n여러 개의 파일이나 디렉토리를 한꺼번에 삭제할 수도 있다. 아래와 같이 git rm 명령에 file-glob 패턴을 사용한다.\n\n* 앞에 \\ 을 사용한 것을 기억하자. 파일명 확장 기능은 쉘에만 있는 것이 아니라 Git 자체에도 있기 때문에 필요하다. 이 명령은 log/ 디렉토리에 있는 .log 파일을 모두 삭제한다. 아래의 예제처럼 할 수도 있다.\n\n이 명령은 ~ 로 끝나는 파일을 모두 삭제한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ rm PROJECTS.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges not staged for commit:\n  (use \"git add/rm <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        deleted:    PROJECTS.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```",
          "```bash\n$ git rm PROJECTS.md\nrm 'PROJECTS.md'\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    deleted:    PROJECTS.md\n```",
          "```bash\n$ git rm --cached README\n```",
          "```bash\n$ git rm log/\\*.log\n```",
          "```bash\n$ git rm \\*~\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 936
        }
      },
      {
        "header": "파일 이름 변경하기",
        "content": "Git은 다른 VCS 시스템과는 달리 파일 이름의 변경이나 파일의 이동을 명시적으로 관리하지 않는다. 다시 말해서 파일 이름이 변경됐다는 별도의 정보를 저장하지 않는다. Git은 똑똑해서 굳이 파일 이름이 변경되었다는 것을 추적하지 않아도 아는 방법이 있다. 파일의 이름이 변경된 것을 Git이 어떻게 알아내는지 살펴보자.\n\n이렇게 말하고 Git에 mv 명령이 있는 게 좀 이상하겠지만, 아래와 같이 파일 이름을 변경할 수 있다.\n\n잘 동작한다. 이 명령을 실행하고 Git의 상태를 확인해보면 Git은 이름이 바뀐 사실을 알고 있다.\n\n사실 git mv 명령은 아래 명령어를 수행한 것과 완전 똑같다.\n\ngit mv 명령은 일종의 단축 명령어이다. 이 명령으로 파일 이름을 바꿔도 되고 mv 명령으로 파일 이름을 직접 바꿔도 된다. 단지 git mv 명령은 편리하게 명령을 세 번 실행해주는 것 뿐이다. 어떤 도구로 이름을 바꿔도 상관없다. 중요한 것은 이름을 변경하고 나서 꼭 rm/add 명령을 실행해야 한다는 것 뿐이다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git mv file_from file_to\n```",
          "```bash\n$ git mv README.md README\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    renamed:    README.md -> README\n```",
          "```bash\n$ mv README.md README\n$ git rm README.md\n$ git add README\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 518
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git의-기초-수정하고-저장소에-저장하기",
    "doc_type": "git",
    "total_sections": 11
  },
  {
    "title": "2.3 Git의 기초 - 커밋 히스토리 조회하기",
    "summary": "커밋 히스토리 조회하기 새로 저장소를 만들어서 몇 번 커밋을 했을 수도 있고, 커밋 히스토리가 있는 저장소를 Clone 했을 수도 있다. 어쨌든 가끔 저장소의 히스토리를 보고 싶을 때가 있다. Git에는 히스토리를 조회하는 명령어인 git log 가 있다. 이 예제에서는 “simplegit” 이라는 매우 단순한 프로젝트를 사용한다. 아래와 같이 이 프로젝트를 Clone 한다. $ git clone https://github.com/schacon/simplegit-progit 이 프로젝트 디렉토리에서 git log 명령을 실행하면 아래와 같이 출력된다. $ git log commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon <schacon@gee-mail.com> Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number commit 085bb3bcb608e1e",
    "sections": [
      {
        "header": "커밋 히스토리 조회하기",
        "content": "새로 저장소를 만들어서 몇 번 커밋을 했을 수도 있고, 커밋 히스토리가 있는 저장소를 Clone 했을 수도 있다. 어쨌든 가끔 저장소의 히스토리를 보고 싶을 때가 있다. Git에는 히스토리를 조회하는 명령어인 git log 가 있다.\n\n이 예제에서는 “simplegit” 이라는 매우 단순한 프로젝트를 사용한다. 아래와 같이 이 프로젝트를 Clone 한다.\n\n이 프로젝트 디렉토리에서 git log 명령을 실행하면 아래와 같이 출력된다.\n\n특별한 아규먼트 없이 git log 명령을 실행하면 저장소의 커밋 히스토리를 시간순으로 보여준다. 즉, 가장 최근의 커밋이 가장 먼저 나온다. 그리고 이어서 각 커밋의 SHA-1 체크섬, 저자 이름, 저자 이메일, 커밋한 날짜, 커밋 메시지를 보여준다.\n\n원하는 히스토리를 검색할 수 있도록 git log 명령은 매우 다양한 옵션을 지원한다. 여기에서는 자주 사용하는 옵션을 설명한다.\n\n여러 옵션 중 -p, --patch 는 굉장히 유용한 옵션이다. -p 는 각 커밋의 diff 결과를 보여준다. 다른 유용한 옵션으로 -2 가 있는데 최근 두 개의 결과만 보여주는 옵션이다:\n\n이 옵션은 직접 diff를 실행한 것과 같은 결과를 출력하기 때문에 동료가 무엇을 커밋했는지 리뷰하고 빨리 조회하는데 유용하다. 또 git log 명령에는 히스토리의 통계를 보여주는 옵션도 있다. --stat 옵션으로 각 커밋의 통계 정보를 조회할 수 있다.\n\n이 결과에서 --stat 옵션은 어떤 파일이 수정됐는지, 얼마나 많은 파일이 변경됐는지, 또 얼마나 많은 라인을 추가하거나 삭제했는지 보여준다. 요약정보는 가장 뒤쪽에 보여준다.\n\n다른 또 유용한 옵션은 --pretty 옵션이다. 이 옵션을 통해 히스토리 내용을 보여줄 때 기본 형식 이외에 여러 가지 중에 하나를 선택할 수 있다. 몇개 선택할 수 있는 옵션의 값이 있다. oneline 옵션은 각 커밋을 한 라인으로 보여준다. 이 옵션은 많은 커밋을 한 번에 조회할 때 유용하다. 추가로 short, full, fuller 옵션도 있는데 이것은 정보를 조금씩 가감해서 보여준다.\n\n가장 재밌는 옵션은 format 옵션이다. 나만의 포맷으로 결과를 출력하고 싶을 때 사용한다. 특히 결과를 다른 프로그램으로 파싱하고자 할 때 유용하다. 이 옵션을 사용하면 포맷을 정확하게 일치시킬 수 있기 때문에 Git을 새 버전으로 바꿔도 결과 포맷이 바뀌지 않는다.\n\ngit log --pretty=format 에 쓸 몇가지 유용한 옵션` 포맷에서 사용하는 유용한 옵션.\n\n저자 시각 (형식은 –-date=옵션 참고)\n\n저자(Author) 와 커미터(Committer) 를 구분하는 것이 조금 이상해 보일 수 있다. 저자는 원래 작업을 수행한 원작자이고 커밋터는 마지막으로 이 작업을 적용한(저장소에 포함시킨) 사람이다. 만약 당신이 어떤 프로젝트에 패치를 보냈고 그 프로젝트의 담당자가 패치를 적용했다면 두 명의 정보를 모두 알 필요가 있다. 그래서 이 경우 당신이 저자고 그 담당자가 커미터다. 분산 환경에서의 Git 에서 이 주제에 대해 자세히 다룰 것이다.\n\noneline 옵션과 format 옵션은 --graph 옵션과 함께 사용할 때 더 빛난다. 이 명령은 브랜치와 머지 히스토리를 보여주는 아스키 그래프를 출력한다.\n\n다음 장에서 살펴볼 브랜치나 Merge 결과의 히스토리를 이런 식으로 살펴보면 훨씬 흥미롭다.\n\ngit log 명령의 기본적인 옵션과 출력물의 형식에 관련된 옵션을 살펴보았다. git log 명령은 앞서 살펴본 것보다 더 많은 옵션을 지원한다. git log 주요 옵션 는 지금 설명한 것과 함께 유용하게 사용할 수 있는 옵션이다. 각 옵션으로 어떻게 log 명령을 제어할 수 있는지 보여준다.\n\n각 커밋에서 수정된 파일의 통계정보를 보여준다.\n\n--stat 명령의 결과 중에서 수정한 파일, 추가된 라인, 삭제된 라인만 보여준다.\n\n커밋 정보중에서 수정된 파일의 목록만 보여준다.\n\n수정된 파일의 목록을 보여줄 뿐만 아니라 파일을 추가한 것인지, 수정한 것인지, 삭제한 것인지도 보여준다.\n\n40자 짜리 SHA-1 체크섬을 전부 보여주는 것이 아니라 처음 몇 자만 보여준다.\n\n정확한 시간을 보여주는 것이 아니라 “2 weeks ago” 처럼 상대적인 형식으로 보여준다.\n\n브랜치와 머지 히스토리 정보까지 아스키 그래프로 보여준다.\n\n지정한 형식으로 보여준다. 이 옵션에는 oneline, short, full, fuller, format이 있다. format은 원하는 형식으로 출력하고자 할 때 사용한다.\n\n--pretty=oneline --abbrev-commit 두 옵션을 함께 사용한 것과 같다.\n\n옵션 | 설명\n--- | ---\n%H | 커밋 해시\n%h | 짧은 길이 커밋 해시\n%T | 트리 해시\n%t | 짧은 길이 트리 해시\n%P | 부모 해시\n%p | 짧은 길이 부모 해시\n%an | 저자 이름\n%ae | 저자 메일\n%ad | 저자 시각 (형식은 –-date=옵션 참고)\n%ar | 저자 상대적 시각\n%cn | 커미터 이름\n%ce | 커미터 메일\n%cd | 커미터 시각\n%cr | 커미터 상대적 시각\n%s | 요약\n\n옵션 | 설명\n--- | ---\n-p | 각 커밋에 적용된 패치를 보여준다.\n--stat | 각 커밋에서 수정된 파일의 통계정보를 보여준다.\n--shortstat | --stat 명령의 결과 중에서 수정한 파일, 추가된 라인, 삭제된 라인만 보여준다.\n--name-only | 커밋 정보중에서 수정된 파일의 목록만 보여준다.\n--name-status | 수정된 파일의 목록을 보여줄 뿐만 아니라 파일을 추가한 것인지, 수정한 것인지, 삭제한 것인지도 보여준다.\n--abbrev-commit | 40자 짜리 SHA-1 체크섬을 전부 보여주는 것이 아니라 처음 몇 자만 보여준다.\n--relative-date | 정확한 시간을 보여주는 것이 아니라 “2 weeks ago” 처럼 상대적인 형식으로 보여준다.\n--graph | 브랜치와 머지 히스토리 정보까지 아스키 그래프로 보여준다.\n--pretty | 지정한 형식으로 보여준다. 이 옵션에는 oneline, short, full, fuller, format이 있다. format은 원하는 형식으로 출력하고자 할 때 사용한다.\n--oneline | --pretty=oneline --abbrev-commit 두 옵션을 함께 사용한 것과 같다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git clone https://github.com/schacon/simplegit-progit\n```",
          "```bash\n$ git log\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number\n\ncommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Sat Mar 15 16:40:33 2008 -0700\n\n    removed unnecessary test\n\ncommit a11bef06a3f659402fe7563abf99ad00de2209e6\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Sat Mar 15 10:31:28 2008 -0700\n\n    first commit\n```",
          "```bash\n$ git log -p -2\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number\n\ndiff --git a/Rakefile b/Rakefile\nindex a874b73..8f94139 100644\n--- a/Rakefile\n+++ b/Rakefile\n@@ -5,7 +5,7 @@ require 'rake/gempackagetask'\n spec = Gem::Specification.new do |s|\n     s.platform  =   Gem::Platform::RUBY\n     s.name      =   \"simplegit\"\n-    s.version   =   \"0.1.0\"\n+    s.version   =   \"0.1.1\"\n     s.author    =   \"Scott Chacon\"\n     s.email     =   \"schacon@gee-mail.com\"\n     s.summary   =   \"A simple gem for using Git in Ruby code.\"\n\ncommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Sat Mar 15 16:40:33 2008 -0700\n\n    removed unnecessary test\n\ndiff --git a/lib/simplegit.rb b/lib/simplegit.rb\nindex a0a60ae..47c6340 100644\n--- a/lib/simplegit.rb\n+++ b/lib/simplegit.rb\n@@ -18,8 +18,3 @@ class SimpleGit\n     end\n\n end\n-\n-if $0 == __FILE__\n-  git = SimpleGit.new\n-  puts git.show\n-end\n```",
          "```bash\n$ git log --stat\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number\n\n Rakefile | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ncommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Sat Mar 15 16:40:33 2008 -0700\n\n    removed unnecessary test\n\n lib/simplegit.rb | 5 -----\n 1 file changed, 5 deletions(-)\n\ncommit a11bef06a3f659402fe7563abf99ad00de2209e6\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Sat Mar 15 10:31:28 2008 -0700\n\n    first commit\n\n README           |  6 ++++++\n Rakefile         | 23 +++++++++++++++++++++++\n lib/simplegit.rb | 25 +++++++++++++++++++++++++\n 3 files changed, 54 insertions(+)\n```",
          "```bash\n$ git log --pretty=oneline\nca82a6dff817ec66f44342007202690a93763949 changed the version number\n085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test\na11bef06a3f659402fe7563abf99ad00de2209e6 first commit\n```",
          "```bash\n$ git log --pretty=format:\"%h - %an, %ar : %s\"\nca82a6d - Scott Chacon, 6 years ago : changed the version number\n085bb3b - Scott Chacon, 6 years ago : removed unnecessary test\na11bef0 - Scott Chacon, 6 years ago : first commit\n```",
          "```bash\n$ git log --pretty=format:\"%h %s\" --graph\n* 2d3acf9 ignore errors from SIGCHLD on trap\n*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit\n|\\\n| * 420eac9 Added a method for getting the current branch.\n* | 30e367c timeout code and tests\n* | 5a09431 add timeout protection to grit\n* | e1193f8 support for heads with slashes in them\n|/\n* d6016bc require time for xmlschema\n*  11d191e Merge branch 'defunkt' into local\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 25,
          "content_length": 3145
        }
      },
      {
        "header": "조회 제한조건",
        "content": "출력 형식과 관련된 옵션을 살펴봤지만 git log 명령은 조회 범위를 제한하는 옵션들도 있다. 히스토리 전부가 아니라 부분만 조회한다. 이미 최근 두 개만 조회하는 -2 옵션은 살펴봤다. 실제 사용법은 -<n> 이고 n은 최근 n개의 커밋을 의미한다. 사실 이 옵션을 자주 쓰진 않는다. Git은 기본적으로 출력을 pager류의 프로그램을 거쳐서 내보내므로 한 번에 한 페이지씩 보여준다.\n\n반면 --since 나 --until 같은 시간을 기준으로 조회하는 옵션은 매우 유용하다. 지난 2주 동안 만들어진 커밋들만 조회하는 명령은 아래와 같다.\n\n이 옵션은 다양한 형식을 지원한다.\"2008-01-15\" 같이 정확한 날짜도 사용할 수 있고 \"2 years 1 day 3 minutes ago\" 같이 상대적인 기간을 사용할 수도 있다.\n\n또 다른 기준도 있다. --author 옵션으로 저자를 지정하여 검색할 수도 있고 --grep 옵션으로 커밋 메시지에서 키워드를 검색할 수도 있다\n\n--author 와 --grep 옵션을 함께 사용하여 모두 만족하는 커밋을 찾으려면 --all-match 옵션도 반드시 함께 사용해야 한다.\n\n진짜 유용한 옵션으로 -S 가 있는데 이 옵션은 코드에서 추가되거나 제거된 내용 중에 특정 텍스트가 포함되어 있는지를 검색한다. 예를 들어 어떤 함수가 추가되거나 제거된 커밋만을 찾아보려면 아래와 같은 명령을 사용한다.\n\n마지막으로 파일 경로로 검색하는 옵션이 있는데 이것도 정말 유용하다. 디렉토리나 파일 이름을 사용하여 그 파일이 변경된 log의 결과를 검색할 수 있다. 이 옵션은 -- 와 함께 경로 이름을 사용하는데 명령어 끝 부분에 쓴다(역주 - git log — path1 path2).\n\ngit log 조회 범위를 제한하는 옵션 은 조회 범위를 제한하는 옵션들이다.\n\n명시한 날짜 이후의 커밋만 검색한다.\n\n명시한 날짜 이전의 커밋만 조회한다.\n\n커밋 메시지 안의 텍스트를 검색한다.\n\n커밋 변경(추가/삭제) 내용 안의 텍스트를 검색한다.\n\n이제 살펴볼 예제는 Merge 커밋을 제외한 순수한 커밋을 확인해보는 명령이다. Junio Hamano가 2008년 10월에 Git 소스코드 저장소에서 테스트 파일을 수정한 커밋들이다.\n\n총 4만여 개의 커밋 히스토리에서 이 명령의 검색 조건에 만족하는 것은 단 6개였다.\n\n저장소를 사용하는 워크플로우에 따라 머지 커밋이 차지하는 비중이 클 수도 있다. --no-merges 옵션을 사용하면 검색 결과에서 머지 커밋을 표시하지 않도록 할 수 있다.\n\n노트 | --author 와 --grep 옵션을 함께 사용하여 모두 만족하는 커밋을 찾으려면 --all-match 옵션도 반드시 함께 사용해야 한다.\n\n옵션 | 설명\n--- | ---\n-(n) | 최근 n 개의 커밋만 조회한다.\n--since, --after | 명시한 날짜 이후의 커밋만 검색한다.\n--until, --before | 명시한 날짜 이전의 커밋만 조회한다.\n--author | 입력한 저자의 커밋만 보여준다.\n--committer | 입력한 커미터의 커밋만 보여준다.\n--grep | 커밋 메시지 안의 텍스트를 검색한다.\n-S | 커밋 변경(추가/삭제) 내용 안의 텍스트를 검색한다.\n\n힌트 | 머지 커밋 표시하지 않기 저장소를 사용하는 워크플로우에 따라 머지 커밋이 차지하는 비중이 클 수도 있다. --no-merges 옵션을 사용하면 검색 결과에서 머지 커밋을 표시하지 않도록 할 수 있다.\n\n[Note] 노트 --author 와 --grep 옵션을 함께 사용하여 모두 만족하는 커밋을 찾으려면 --all-match 옵션도 반드시 함께 사용해야 한다.\n\n[Tip] 힌트 머지 커밋 표시하지 않기 저장소를 사용하는 워크플로우에 따라 머지 커밋이 차지하는 비중이 클 수도 있다. --no-merges 옵션을 사용하면 검색 결과에서 머지 커밋을 표시하지 않도록 할 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git log --since=2.weeks\n```",
          "```bash\n$ git log -S function_name\n```",
          "```bash\n$ git log --pretty=\"%h - %s\" --author=gitster --since=\"2008-10-01\" \\\n   --before=\"2008-11-01\" --no-merges -- t/\n5610e3b - Fix testcase failure when extended attributes are in use\nacd3b9e - Enhance hold_lock_file_for_{update,append}() API\nf563754 - demonstrate breakage of detached checkout with symbolic link HEAD\nd1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths\n51a94af - Fix \"checkout --track -b newbranch\" on detached HEAD\nb0ad11e - pull: allow \"git pull origin $something:$current_branch\" into an unborn branch\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 15,
          "content_length": 1917
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git의-기초-커밋-히스토리-조회하기",
    "doc_type": "git",
    "total_sections": 2
  },
  {
    "title": "2.4 Git의 기초 - 되돌리기",
    "summary": "되돌리기 일을 하다보면 모든 단계에서 어떤 것은 되돌리고(Undo) 싶을 때가 있다. 이번에는 우리가 한 일을 되돌리는 방법을 살펴본다. 한 번 되돌리면 복구할 수 없기에 주의해야 한다. Git을 사용하면 우리가 저지른 실수는 대부분 복구할 수 있지만 되돌린 것은 복구할 수 없다. 종종 완료한 커밋을 수정해야 할 때가 있다. 너무 일찍 커밋했거나 어떤 파일을 빼먹었을 때 그리고 커밋 메시지를 잘못 적었을 때 한다. 다시 커밋하고 싶으면 파일 수정 작업을 하고 Staging Area에 추가한 다음 --amend 옵션을 사용하여 커밋을 재작성 할 수 있다. $ git commit --amend 이 명령은 Staging Area를 사용하여 커밋한다. 만약 마지막으로 커밋하고 나서 수정한 것이 없다면(커밋하자마자 바로 이 명령을 실행하는 경우) 조금 전에 한 커밋과 모든 것이 같다. 이때는 커밋 메시지만 수정한다. 편집기가 실행되면 이전 커밋 메시지가 자동으로 포함된다. 메시지를 수정하지 ",
    "sections": [
      {
        "header": "되돌리기",
        "content": "일을 하다보면 모든 단계에서 어떤 것은 되돌리고(Undo) 싶을 때가 있다. 이번에는 우리가 한 일을 되돌리는 방법을 살펴본다. 한 번 되돌리면 복구할 수 없기에 주의해야 한다. Git을 사용하면 우리가 저지른 실수는 대부분 복구할 수 있지만 되돌린 것은 복구할 수 없다.\n\n종종 완료한 커밋을 수정해야 할 때가 있다. 너무 일찍 커밋했거나 어떤 파일을 빼먹었을 때 그리고 커밋 메시지를 잘못 적었을 때 한다. 다시 커밋하고 싶으면 파일 수정 작업을 하고 Staging Area에 추가한 다음 --amend 옵션을 사용하여 커밋을 재작성 할 수 있다.\n\n이 명령은 Staging Area를 사용하여 커밋한다. 만약 마지막으로 커밋하고 나서 수정한 것이 없다면(커밋하자마자 바로 이 명령을 실행하는 경우) 조금 전에 한 커밋과 모든 것이 같다. 이때는 커밋 메시지만 수정한다.\n\n편집기가 실행되면 이전 커밋 메시지가 자동으로 포함된다. 메시지를 수정하지 않고 그대로 커밋해도 기존의 커밋을 덮어쓴다.\n\n커밋을 했는데 Stage 하는 것을 깜빡하고 빠트린 파일이 있으면 아래와 같이 고칠 수 있다.\n\n여기서 실행한 명령어 3개는 모두 커밋 한 개로 기록된다. 두 번째 커밋은 첫 번째 커밋을 덮어쓴다.\n\n이렇게 --amend 옵션으로 커밋을 고치는 작업은, 추가로 작업한 일이 작다고 하더라도 이전의 커밋을 완전히 새로 고쳐서 새 커밋으로 변경하는 것을 의미한다. 이전의 커밋은 일어나지 않은 일이 되는 것이고 당연히 히스토리에도 남지 않는다.\n\n--amend 옵션으로 커밋을 고치는 작업이 주는 장점은 마지막 커밋 작업에서 아주 살짝 뭔가 빠뜨린 것을 넣거나 변경하는 것을 새 커밋으로 분리하지 않고 하나의 커밋에서 처리하는 것이다. “앗차, 빠진 파일 넣었음”, “이전 커밋에서 오타 살짝 고침” 등의 커밋을 만들지 않겠다는 말이다.\n\n노트 | 이렇게 --amend 옵션으로 커밋을 고치는 작업은, 추가로 작업한 일이 작다고 하더라도 이전의 커밋을 완전히 새로 고쳐서 새 커밋으로 변경하는 것을 의미한다. 이전의 커밋은 일어나지 않은 일이 되는 것이고 당연히 히스토리에도 남지 않는다. --amend 옵션으로 커밋을 고치는 작업이 주는 장점은 마지막 커밋 작업에서 아주 살짝 뭔가 빠뜨린 것을 넣거나 변경하는 것을 새 커밋으로 분리하지 않고 하나의 커밋에서 처리하는 것이다. “앗차, 빠진 파일 넣었음”, “이전 커밋에서 오타 살짝 고침” 등의 커밋을 만들지 않겠다는 말이다.\n\n[Note] 노트 이렇게 --amend 옵션으로 커밋을 고치는 작업은, 추가로 작업한 일이 작다고 하더라도 이전의 커밋을 완전히 새로 고쳐서 새 커밋으로 변경하는 것을 의미한다. 이전의 커밋은 일어나지 않은 일이 되는 것이고 당연히 히스토리에도 남지 않는다. --amend 옵션으로 커밋을 고치는 작업이 주는 장점은 마지막 커밋 작업에서 아주 살짝 뭔가 빠뜨린 것을 넣거나 변경하는 것을 새 커밋으로 분리하지 않고 하나의 커밋에서 처리하는 것이다. “앗차, 빠진 파일 넣었음”, “이전 커밋에서 오타 살짝 고침” 등의 커밋을 만들지 않겠다는 말이다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git commit --amend\n```",
          "```bash\n$ git commit -m 'initial commit'\n$ git add forgotten_file\n$ git commit --amend\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 8,
          "content_length": 1527
        }
      },
      {
        "header": "파일 상태를 Unstage로 변경하기",
        "content": "다음은 Staging Area와 워킹 디렉토리 사이를 넘나드는 방법을 설명한다. 두 영역의 상태를 확인할 때마다 변경된 상태를 되돌리는 방법을 알려주기 때문에 매우 편리하다. 예를 들어 파일을 두 개 수정하고서 따로따로 커밋하려고 했지만, 실수로 git add * 라고 실행해 버렸다. 두 파일 모두 Staging Area에 들어 있다. 이제 둘 중 하나를 어떻게 꺼낼까? 우선 git status 명령으로 확인해보자.\n\nChanges to be commited 밑에 git reset HEAD <file>… 메시지가 보인다. 이 명령으로 Unstaged 상태로 변경할 수 있다. CONTRIBUTING.md 파일을 Unstaged 상태로 변경해보자.\n\n명령어가 낮설게 느껴질 수도 있지만 잘 동작한다. CONTRIBUTING.md 파일은 Unstaged 상태가 됐다.\n\ngit reset 명령은 매우 위험하다. --hard 옵션과 함께 사용하면 더욱 위험하다. 하지만 위에서 처럼 옵션 없이 사용하면 워킹 디렉토리의 파일은 건드리지 않는다.\n\n지금까지 살펴본 내용이 git reset 명령에 대해 알아야 할 대부분의 내용이다. reset 명령이 정확히는 어떻게 동작하는지, 어떻게 전문적으로 활용하는지는 Reset 명확히 알고 가기 부분에서 자세히 살펴보기로 한다.\n\n노트 | git reset 명령은 매우 위험하다. --hard 옵션과 함께 사용하면 더욱 위험하다. 하지만 위에서 처럼 옵션 없이 사용하면 워킹 디렉토리의 파일은 건드리지 않는다.\n\n[Note] 노트 git reset 명령은 매우 위험하다. --hard 옵션과 함께 사용하면 더욱 위험하다. 하지만 위에서 처럼 옵션 없이 사용하면 워킹 디렉토리의 파일은 건드리지 않는다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git add *\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    renamed:    README.md -> README\n    modified:   CONTRIBUTING.md\n```",
          "```bash\n$ git reset HEAD CONTRIBUTING.md\nUnstaged changes after reset:\nM\tCONTRIBUTING.md\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    renamed:    README.md -> README\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 5,
          "content_length": 862
        }
      },
      {
        "header": "Modified 파일 되돌리기",
        "content": "어떻게 해야 CONTRIBUTING.md 파일을 수정하고 나서 다시 되돌릴 수 있을까? 그러니까 최근 커밋된 버전으로(아니면 처음 Clone 했을 때처럼 워킹 디렉토리에 처음 Checkout 한 그 내용으로) 되돌리는 방법이 무얼까? git status 명령이 친절하게 알려준다. 바로 위에 있는 예제에서 Unstaged 부분을 보자.\n\n위의 메시지는 수정한 파일을 되돌리는 방법을 꽤 정확하게 알려준다. 알려주는 대로 한 번 해보자.\n\n정상적으로 복원된 것을 알 수 있다.\n\ngit checkout — [file] 명령은 꽤 위험한 명령이라는 것을 알아야 한다. 원래 파일로 덮어썼기 때문에 수정한 내용은 전부 사라진다. 수정한 내용이 진짜 마음에 들지 않을 때만 사용하자.\n\n변경한 내용을 쉽게 버릴수는 없고 하지만 당장은 되돌려야만 하는 상황이라면 Stash와 Branch를 사용하자. Git 브랜치 에서 다루는 이 방법들이 훨씬 낫다.\n\nGit으로 커밋 한 모든 것은 언제나 복구할 수 있다. 삭제한 브랜치에 있었던 것도, --amend 옵션으로 다시 커밋한 것도 복구할 수 있다(자세한 것은 데이터 복구 에서 다룬다). 하지만 커밋하지 않고 잃어버린 것은 절대로 되돌릴 수 없다.\n\n중요 | git checkout — [file] 명령은 꽤 위험한 명령이라는 것을 알아야 한다. 원래 파일로 덮어썼기 때문에 수정한 내용은 전부 사라진다. 수정한 내용이 진짜 마음에 들지 않을 때만 사용하자.\n\n[Admonition] 중요 git checkout — [file] 명령은 꽤 위험한 명령이라는 것을 알아야 한다. 원래 파일로 덮어썼기 때문에 수정한 내용은 전부 사라진다. 수정한 내용이 진짜 마음에 들지 않을 때만 사용하자.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n```",
          "```bash\n$ git checkout -- CONTRIBUTING.md\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    renamed:    README.md -> README\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 6,
          "content_length": 856
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git의-기초-되돌리기",
    "doc_type": "git",
    "total_sections": 3
  },
  {
    "title": "2.5 Git의 기초 - 리모트 저장소",
    "summary": "리모트 저장소 리모트 저장소를 관리할 줄 알아야 다른 사람과 함께 일할 수 있다. 리모트 저장소는 인터넷이나 네트워크 어딘가에 있는 저장소를 말한다. 저장소는 여러 개가 있을 수 있는데 어떤 저장소는 읽고 쓰기 모두 할 수 있고 어떤 저장소는 읽기만 가능할 수 있다. 간단히 말해서 다른 사람들과 함께 일한다는 것은 리모트 저장소를 관리하면서 데이터를 거기에 Push 하고 Pull 하는 것이다. 리모트 저장소를 관리한다는 것은 저장소를 추가, 삭제하는 것뿐만 아니라 브랜치를 관리하고 추적할지 말지 등을 관리하는 것을 말한다. 이번에는 리모트 저장소를 관리하는 방법에 대해 설명한다. 노트 원격 저장소라 하더라도 로컬 시스템에 위치할 수도 있다. “remote” 저장소라고 이름이 붙어있어도 이 원격 저장소가 사실 같은 로컬 시스템에 존재할 수도 있다. 여기서 “remote” 라는 이름은 반드시 저장소가 네트워크나 인터넷을 통해 어딘가 멀리 떨어져 있어야만 한다는 것을 의미하지 않는다. 물",
    "sections": [
      {
        "header": "리모트 저장소",
        "content": "리모트 저장소를 관리할 줄 알아야 다른 사람과 함께 일할 수 있다. 리모트 저장소는 인터넷이나 네트워크 어딘가에 있는 저장소를 말한다. 저장소는 여러 개가 있을 수 있는데 어떤 저장소는 읽고 쓰기 모두 할 수 있고 어떤 저장소는 읽기만 가능할 수 있다. 간단히 말해서 다른 사람들과 함께 일한다는 것은 리모트 저장소를 관리하면서 데이터를 거기에 Push 하고 Pull 하는 것이다. 리모트 저장소를 관리한다는 것은 저장소를 추가, 삭제하는 것뿐만 아니라 브랜치를 관리하고 추적할지 말지 등을 관리하는 것을 말한다. 이번에는 리모트 저장소를 관리하는 방법에 대해 설명한다.\n\n“remote” 저장소라고 이름이 붙어있어도 이 원격 저장소가 사실 같은 로컬 시스템에 존재할 수도 있다. 여기서 “remote” 라는 이름은 반드시 저장소가 네트워크나 인터넷을 통해 어딘가 멀리 떨어져 있어야만 한다는 것을 의미하지 않는다. 물론 일반적인 원격 저장소와 마찬가지로 Push, Pull 등의 기능은 동일하게 사용한다.\n\n노트 | 원격 저장소라 하더라도 로컬 시스템에 위치할 수도 있다. “remote” 저장소라고 이름이 붙어있어도 이 원격 저장소가 사실 같은 로컬 시스템에 존재할 수도 있다. 여기서 “remote” 라는 이름은 반드시 저장소가 네트워크나 인터넷을 통해 어딘가 멀리 떨어져 있어야만 한다는 것을 의미하지 않는다. 물론 일반적인 원격 저장소와 마찬가지로 Push, Pull 등의 기능은 동일하게 사용한다.\n\n[Note] 노트 원격 저장소라 하더라도 로컬 시스템에 위치할 수도 있다. “remote” 저장소라고 이름이 붙어있어도 이 원격 저장소가 사실 같은 로컬 시스템에 존재할 수도 있다. 여기서 “remote” 라는 이름은 반드시 저장소가 네트워크나 인터넷을 통해 어딘가 멀리 떨어져 있어야만 한다는 것을 의미하지 않는다. 물론 일반적인 원격 저장소와 마찬가지로 Push, Pull 등의 기능은 동일하게 사용한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 2,
          "content_length": 962
        }
      },
      {
        "header": "리모트 저장소 확인하기",
        "content": "git remote 명령으로 현재 프로젝트에 등록된 리모트 저장소를 확인할 수 있다. 이 명령은 리모트 저장소의 단축 이름을 보여준다. 저장소를 Clone 하면 origin 이라는 리모트 저장소가 자동으로 등록되기 때문에 origin 이라는 이름을 볼 수 있다.\n\n-v 옵션을 주어 단축이름과 URL을 함께 볼 수 있다.\n\n리모트 저장소가 여러 개 있다면 이 명령은 등록된 전부를 보여준다. 여러 사람과 함께 작업하는 리모트 저장소가 여러개라면 아래와 같은 결과를 얻을 수도 있다.\n\n이렇게 리모트 저장소가 여러 개 등록되어 있으면 다른 사람이 기여한 내용(Contributions)을 쉽게 가져올 수 있다. 어떤 저장소에는 Push 권한까지 제공하기도 하지만 일단 이 화면에서 Push 가능 권한까지는 확인할 수 없다.\n\n리모트 저장소와 데이터를 주고받는데 사용하는 다양한 프로토콜에 대해서는 서버에 Git 설치하기 에서 자세히 살펴보기로 한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git clone https://github.com/schacon/ticgit\nCloning into 'ticgit'...\nremote: Reusing existing pack: 1857, done.\nremote: Total 1857 (delta 0), reused 0 (delta 0)\nReceiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.\nResolving deltas: 100% (772/772), done.\nChecking connectivity... done.\n$ cd ticgit\n$ git remote\norigin\n```",
          "```bash\n$ git remote -v\norigin\thttps://github.com/schacon/ticgit (fetch)\norigin\thttps://github.com/schacon/ticgit (push)\n```",
          "```bash\n$ cd grit\n$ git remote -v\nbakkdoor  https://github.com/bakkdoor/grit (fetch)\nbakkdoor  https://github.com/bakkdoor/grit (push)\ncho45     https://github.com/cho45/grit (fetch)\ncho45     https://github.com/cho45/grit (push)\ndefunkt   https://github.com/defunkt/grit (fetch)\ndefunkt   https://github.com/defunkt/grit (push)\nkoke      git://github.com/koke/grit.git (fetch)\nkoke      git://github.com/koke/grit.git (push)\norigin    git@github.com:mojombo/grit.git (fetch)\norigin    git@github.com:mojombo/grit.git (push)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 474
        }
      },
      {
        "header": "리모트 저장소 추가하기",
        "content": "이전 절에서도 git clone 명령이 묵시적으로 origin 리모트 저장소를 어떻게 추가되는지 설명했었지만 수박 겉핥기식으로 살펴봤을 뿐이었다. 여기에서는 리모트 저장소를 추가하는 방법을 자세하게 설명한다. 기존 워킹 디렉토리에 새 리모트 저장소를 쉽게 추가할 수 있는데 git remote add <단축이름> <url> 명령을 사용한다.\n\n이제 URL 대신에 pb 라는 이름을 사용할 수 있다. 예를 들어 로컬 저장소에는 없지만 Paul의 저장소에 있는 것을 가져오려면 아래과 같이 실행한다.\n\n로컬에서 pb/master 가 Paul의 master 브랜치이다. 이 브랜치를 로컬 브랜치중 하나에 Merge 하거나 Checkout 해서 브랜치 내용을 자세히 확인할 수 있다. (브랜치를 어떻게 사용하는지는 Git 브랜치 에서 자세히 살펴본다)",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git remote\norigin\n$ git remote add pb https://github.com/paulboone/ticgit\n$ git remote -v\norigin\thttps://github.com/schacon/ticgit (fetch)\norigin\thttps://github.com/schacon/ticgit (push)\npb\thttps://github.com/paulboone/ticgit (fetch)\npb\thttps://github.com/paulboone/ticgit (push)\n```",
          "```bash\n$ git fetch pb\nremote: Counting objects: 43, done.\nremote: Compressing objects: 100% (36/36), done.\nremote: Total 43 (delta 10), reused 31 (delta 5)\nUnpacking objects: 100% (43/43), done.\nFrom https://github.com/paulboone/ticgit\n * [new branch]      master     -> pb/master\n * [new branch]      ticgit     -> pb/ticgit\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 416
        }
      },
      {
        "header": "리모트 저장소를 Pull 하거나 Fetch 하기",
        "content": "앞서 설명했듯이 리모트 저장소에서 데이터를 가져오려면 간단히 아래와 같이 실행한다.\n\n이 명령은 로컬에는 없지만, 리모트 저장소에는 있는 데이터를 모두 가져온다. 그러면 리모트 저장소의 모든 브랜치를 로컬에서 접근할 수 있어서 언제든지 Merge를 하거나 내용을 살펴볼 수 있다.\n\n저장소를 Clone 하면 명령은 자동으로 리모트 저장소를 “origin” 이라는 이름으로 추가한다. 그래서 나중에 git fetch origin 명령을 실행하면 Clone 한 이후에(혹은 마지막으로 가져온 이후에) 수정된 것을 모두 가져온다. git fetch 명령은 리모트 저장소의 데이터를 모두 로컬로 가져오지만, 자동으로 Merge 하지 않는다. 그래서 당신이 로컬에서 하던 작업을 정리하고 나서 수동으로 Merge 해야 한다.\n\n그냥 쉽게 git pull 명령으로 리모트 저장소 브랜치에서 데이터를 가져올 뿐만 아니라 자동으로 로컬 브랜치와 Merge 시킬 수 있다(다음 섹션과 Git 브랜치 에서 좀더 자세히 살펴본다). 먼저 git clone 명령은 자동으로 로컬의 master 브랜치가 리모트 저장소의 master 브랜치를 추적하도록 한다(물론 리모트 저장소에 master 브랜치가 있다는 가정에서). 그리고 git pull 명령은 Clone 한 서버에서 데이터를 가져오고 그 데이터를 자동으로 현재 작업하는 코드와 Merge 시킨다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git fetch <remote>\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 688
        }
      },
      {
        "header": "리모트 저장소에 Push 하기",
        "content": "프로젝트를 공유하고 싶을 때 Upstream 저장소에 Push 할 수 있다. 이 명령은 git push <리모트 저장소 이름> <브랜치 이름> 으로 단순하다. master 브랜치를 origin 서버에 Push 하려면(다시 말하지만 Clone 하면 보통 자동으로 origin 이름이 생성된다) 아래와 같이 서버에 Push 한다.\n\n이 명령은 Clone 한 리모트 저장소에 쓰기 권한이 있고, Clone 하고 난 이후 아무도 Upstream 저장소에 Push 하지 않았을 때만 사용할 수 있다. 다시 말해서 Clone 한 사람이 여러 명 있을 때, 다른 사람이 Push 한 후에 Push 하려고 하면 Push 할 수 없다. 먼저 다른 사람이 작업한 것을 가져와서 Merge 한 후에 Push 할 수 있다. Git 브랜치 에서 서버에 Push 하는 방법에 대해 자세히 설명할 것이다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git push origin master\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 435
        }
      },
      {
        "header": "리모트 저장소 살펴보기",
        "content": "git remote show <리모트 저장소 이름> 명령으로 리모트 저장소의 구체적인 정보를 확인할 수 있다. origin 같은 단축이름으로 이 명령을 실행하면 아래와 같은 정보를 볼 수 있다.\n\n리모트 저장소의 URL과 추적하는 브랜치를 출력한다. 이 명령은 git pull 명령을 실행할 때 master 브랜치와 Merge 할 브랜치가 무엇인지 보여 준다. git pull 명령은 리모트 저장소 브랜치의 데이터를 모두 가져오고 나서 자동으로 Merge 할 것이다. 그리고 가져온 모든 리모트 저장소 정보도 출력한다.\n\n좀 더 Git을 열심히 사용하다 보면 git remote show 명령으로 더 많은 정보를 보는 날이 온다. 여러분도 언젠가는 아래와 같은 메시지(역주 - 다수의 브랜치를 사용하는 메시지)를 볼 날이 올 것이다.\n\n브랜치명을 생략하고 git push 명령을 실행할 때 어떤 브랜치가 어떤 브랜치로 Push 되는지 보여준다. 또 아직 로컬로 가져오지 않은 리모트 저장소의 브랜치는 어떤 것들이 있는지, 서버에서는 삭제됐지만 아직 가지고 있는 브랜치는 어떤 것인지, git pull 명령을 실행했을 때 자동으로 Merge 할 브랜치는 어떤 것이 있는지 보여준다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git remote show origin\n* remote origin\n  Fetch URL: https://github.com/schacon/ticgit\n  Push  URL: https://github.com/schacon/ticgit\n  HEAD branch: master\n  Remote branches:\n    master                               tracked\n    dev-branch                           tracked\n  Local branch configured for 'git pull':\n    master merges with remote master\n  Local ref configured for 'git push':\n    master pushes to master (up to date)\n```",
          "```bash\n$ git remote show origin\n* remote origin\n  URL: https://github.com/my-org/complex-project\n  Fetch URL: https://github.com/my-org/complex-project\n  Push  URL: https://github.com/my-org/complex-project\n  HEAD branch: master\n  Remote branches:\n    master                           tracked\n    dev-branch                       tracked\n    markdown-strip                   tracked\n    issue-43                         new (next fetch will store in remotes/origin)\n    issue-45                         new (next fetch will store in remotes/origin)\n    refs/remotes/origin/issue-11     stale (use 'git remote prune' to remove)\n  Local branches configured for 'git pull':\n    dev-branch merges with remote dev-branch\n    master     merges with remote master\n  Local refs configured for 'git push':\n    dev-branch                     pushes to dev-branch                     (up to date)\n    markdown-strip                 pushes to markdown-strip                 (up to date)\n    master                         pushes to master                         (up to date)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 604
        }
      },
      {
        "header": "리모트 저장소 이름을 바꾸거나 리모트 저장소를 삭제하기",
        "content": "git remote rename 명령으로 리모트 저장소의 이름을 변경할 수 있다. 예를 들어 pb 를 paul 로 변경하려면 git remote rename 명령을 사용한다.\n\n로컬에서 관리하던 리모트 저장소의 브랜치 이름도 바뀐다는 점을 생각해두자. 여태까지 pb/master 로 리모트 저장소 브랜치를 사용했으면 이제는 paul/master 라고 사용해야 한다.\n\n리모트 저장소를 삭제해야 한다면 git remote remove 나 git remote rm 명령을 사용한다. 서버 정보가 바뀌었을 때, 더는 별도의 미러가 필요하지 않을 때, 더는 기여자가 활동하지 않을 때 필요하다.\n\n위와 같은 방법으로 리모트 저장소를 삭제하면 해당 리모트 저장소에 관련된 추적 브랜치 정보나 모든 설정 내용도 함께 삭제된다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git remote rename pb paul\n$ git remote\norigin\npaul\n```",
          "```bash\n$ git remote remove paul\n$ git remote\norigin\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 400
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git의-기초-리모트-저장소",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "2.6 Git의 기초 - 태그",
    "summary": "태그 다른 VCS처럼 Git도 태그를 지원한다. 사람들은 보통 릴리즈할 때 사용한다(v1.0, 등등). 이번에는 태그를 조회하고 생성하는 법과 태그의 종류를 설명한다. 태그 조회하기 우선 git tag 명령으로 (-l, --list 는 옵션) 이미 만들어진 태그가 있는지 확인할 수 있다. $ git tag v0.1 v1.3 이 명령은 알파벳 순서로 태그를 보여준다. 사실 순서는 별로 중요한 게 아니다. 검색 패턴을 사용하여 태그를 검색할 수 있다. Git 소스 저장소는 500여 개의 태그가 있다. 만약 1.8.5 버전의 태그들만 검색하고 싶으면 아래와 같이 실행한다. $ git tag -l \"v1.8.5*\" v1.8.5 v1.8.5-rc0 v1.8.5-rc1 v1.8.5-rc2 v1.8.5-rc3 v1.8.5.1 v1.8.5.2 v1.8.5.3 v1.8.5.4 v1.8.5.5 노트 와일드카드를 사용하여 Tag 리스트를 확인하려면 -l, --list 옵션을 지정 단순히 모든 Tag 목",
    "sections": [
      {
        "header": "태그",
        "content": "다른 VCS처럼 Git도 태그를 지원한다. 사람들은 보통 릴리즈할 때 사용한다(v1.0, 등등). 이번에는 태그를 조회하고 생성하는 법과 태그의 종류를 설명한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 90
        }
      },
      {
        "header": "태그 조회하기",
        "content": "우선 git tag 명령으로 (-l, --list 는 옵션) 이미 만들어진 태그가 있는지 확인할 수 있다.\n\n이 명령은 알파벳 순서로 태그를 보여준다. 사실 순서는 별로 중요한 게 아니다.\n\n검색 패턴을 사용하여 태그를 검색할 수 있다. Git 소스 저장소는 500여 개의 태그가 있다. 만약 1.8.5 버전의 태그들만 검색하고 싶으면 아래와 같이 실행한다.\n\n단순히 모든 Tag 목록을 확인하기 위해 git tag 명령을 실행했을 때 -l 또는 --list 옵션이 적용된 것과 동일한 결과가 출력된다.\n\n하지만 와일드카드를 사용하여 태그 목록을 검색하는 경우에는 반드시 -l 또는 --list 옵션을 같이 써 줘야 원하는 결과를 얻을 수 있다.\n\n노트 | 와일드카드를 사용하여 Tag 리스트를 확인하려면 -l, --list 옵션을 지정 단순히 모든 Tag 목록을 확인하기 위해 git tag 명령을 실행했을 때 -l 또는 --list 옵션이 적용된 것과 동일한 결과가 출력된다. 하지만 와일드카드를 사용하여 태그 목록을 검색하는 경우에는 반드시 -l 또는 --list 옵션을 같이 써 줘야 원하는 결과를 얻을 수 있다.\n\n[Note] 노트 와일드카드를 사용하여 Tag 리스트를 확인하려면 -l, --list 옵션을 지정 단순히 모든 Tag 목록을 확인하기 위해 git tag 명령을 실행했을 때 -l 또는 --list 옵션이 적용된 것과 동일한 결과가 출력된다. 하지만 와일드카드를 사용하여 태그 목록을 검색하는 경우에는 반드시 -l 또는 --list 옵션을 같이 써 줘야 원하는 결과를 얻을 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git tag\nv0.1\nv1.3\n```",
          "```bash\n$ git tag -l \"v1.8.5*\"\nv1.8.5\nv1.8.5-rc0\nv1.8.5-rc1\nv1.8.5-rc2\nv1.8.5-rc3\nv1.8.5.1\nv1.8.5.2\nv1.8.5.3\nv1.8.5.4\nv1.8.5.5\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 5,
          "content_length": 786
        }
      },
      {
        "header": "태그 붙이기",
        "content": "Git의 태그는 Lightweight 태그와 Annotated 태그로 두 종류가 있다.\n\nLightweight 태그는 브랜치와 비슷한데 브랜치처럼 가리키는 지점을 최신 커밋으로 이동시키지 않는다. 단순히 특정 커밋에 대한 포인터일 뿐이다.\n\n한편 Annotated 태그는 Git 데이터베이스에 태그를 만든 사람의 이름, 이메일과 태그를 만든 날짜, 그리고 태그 메시지도 저장한다. GPG(GNU Privacy Guard)로 서명할 수도 있다. 일반적으로 Annotated 태그를 만들어 이 모든 정보를 사용할 수 있도록 하는 것이 좋다. 하지만 임시로 생성하는 태그거나 이러한 정보를 유지할 필요가 없는 경우에는 Lightweight 태그를 사용할 수도 있다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 369
        }
      },
      {
        "header": "Annotated 태그",
        "content": "Annotated 태그를 만드는 방법은 간단하다. tag 명령을 실행할 때 -a 옵션을 추가한다.\n\n-m 옵션으로 태그를 저장할 때 메시지를 함께 저장할 수 있다. 명령을 실행할 때 메시지를 입력하지 않으면 Git은 편집기를 실행시킨다.\n\ngit show 명령으로 태그 정보와 커밋 정보를 모두 확인할 수 있다.\n\n커밋 정보를 보여주기 전에 먼저 태그를 만든 사람이 누구인지, 언제 태그를 만들었는지, 그리고 태그 메시지가 무엇인지 보여준다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git tag -a v1.4 -m \"my version 1.4\"\n$ git tag\nv0.1\nv1.3\nv1.4\n```",
          "```bash\n$ git show v1.4\ntag v1.4\nTagger: Ben Straub <ben@straub.cc>\nDate:   Sat May 3 20:19:12 2014 -0700\n\nmy version 1.4\n\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 247
        }
      },
      {
        "header": "Lightweight 태그",
        "content": "Lightweight 태그는 기본적으로 파일에 커밋 체크섬을 저장하는 것뿐이다. 다른 정보는 저장하지 않는다. Lightweight 태그를 만들 때는 -a, -s, -m 옵션을 사용하지 않는다. 이름만 달아줄 뿐이다.\n\n이 태그에 git show 를 실행하면 별도의 태그 정보를 확인할 수 없다. 이 명령은 단순히 커밋 정보만을 보여준다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git tag v1.4-lw\n$ git tag\nv0.1\nv1.3\nv1.4\nv1.4-lw\nv1.5\n```",
          "```bash\n$ git show v1.4-lw\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 189
        }
      },
      {
        "header": "나중에 태그하기",
        "content": "예전 커밋에 대해서도 태그할 수 있다. 커밋 히스토리는 아래와 같다고 가정한다.\n\n“updated rakefile” 커밋을 v1.2로 태그하지 못했다고 해도 나중에 태그를 붙일 수 있다. 특정 커밋에 태그하기 위해서 명령의 끝에 커밋 체크섬을 명시한다(긴 체크섬을 전부 사용할 필요는 없다).\n\n이제 아래와 같이 만든 태그를 확인한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git log --pretty=oneline\n15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'\na6b4c97498bd301d84096da251c98a07c7723e65 beginning write support\n0d52aaab4479697da7686c15f77a3d64d9165190 one more thing\n6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'\n0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function\n4682c3261057305bdd616e23b64b0857d832627b added a todo file\n166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\n9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\n964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo\n8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme\n```",
          "```bash\n$ git tag -a v1.2 9fceb02\n```",
          "```bash\n$ git tag\nv0.1\nv1.2\nv1.3\nv1.4\nv1.4-lw\nv1.5\n\n$ git show v1.2\ntag v1.2\nTagger: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Feb 9 15:32:16 2009 -0800\n\nversion 1.2\ncommit 9fceb02d0ae598e95dc970b74767f19372d61af8\nAuthor: Magnus Chacon <mchacon@gee-mail.com>\nDate:   Sun Apr 27 20:43:35 2008 -0700\n\n    updated rakefile\n...\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 187
        }
      },
      {
        "header": "태그 공유하기",
        "content": "git push 명령은 자동으로 리모트 서버에 태그를 전송하지 않는다. 태그를 만들었으면 서버에 별도로 Push 해야 한다. 브랜치를 공유하는 것과 같은 방법으로 할 수 있다. git push origin <태그 이름> 을 실행한다.\n\n만약 한 번에 태그를 여러 개 Push 하고 싶으면 --tags 옵션을 추가하여 git push 명령을 실행한다. 이 명령으로 리모트 서버에 없는 태그를 모두 전송할 수 있다.\n\n이제 누군가 저장소에서 Clone 하거나 Pull을 하면 모든 태그 정보도 함께 전송된다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git push origin v1.5\nCounting objects: 14, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (12/12), done.\nWriting objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.\nTotal 14 (delta 3), reused 0 (delta 0)\nTo git@github.com:schacon/simplegit.git\n * [new tag]         v1.5 -> v1.5\n```",
          "```bash\n$ git push origin --tags\nCounting objects: 1, done.\nWriting objects: 100% (1/1), 160 bytes | 0 bytes/s, done.\nTotal 1 (delta 0), reused 0 (delta 0)\nTo git@github.com:schacon/simplegit.git\n * [new tag]         v1.4 -> v1.4\n * [new tag]         v1.4-lw -> v1.4-lw\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 282
        }
      },
      {
        "header": "태그를 Checkout 하기",
        "content": "예를 들어 태그가 특정 버전을 가리키고 있고, 특정 버전의 파일을 체크아웃 해서 확인하고 싶다면 다음과 같이 실행한다. 단 태그를 체크아웃하면(브랜치를 체크아웃 하는 것이 아니라면) “detached HEAD”(떨어져나온 HEAD) 상태가 되며 일부 Git 관련 작업이 브랜치에서 작업하는 것과 다르게 동작할 수 있다.\n\n“detached HEAD”(떨어져나온 HEAD) 상태에서는 작업을 하고 커밋을 만들면, 태그는 그대로 있으나 새로운 커밋이 하나 쌓인 상태가 되고 새 커밋에 도달할 수 있는 방법이 따로 없게 된다. 물론 커밋의 해시 값을 정확히 기억하고 있으면 가능하긴 하다. 특정 태그의 상태에서 새로 작성한 커밋이 버그 픽스와 같이 의미있도록 하려면 반드시 브랜치를 만들어서 작업하는 것이 좋다.\n\n물론 이렇게 브랜치를 만든 후에 version2 브랜치에 커밋하면 브랜치는 업데이트된다. 하지만, v2.0.0 태그는 가리키는 커밋이 변하지 않았으므로 두 내용이 가리키는 커밋이 다르다는 것을 알 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git checkout 2.0.0\nNote: checking out '2.0.0'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n\n  git checkout -b <new-branch>\n\nHEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final\n\n$ git checkout 2.0-beta-0.1\nPrevious HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final\nHEAD is now at df3f601... add atlas.json and cover image\n```",
          "```bash\n$ git checkout -b version2 v2.0.0\nSwitched to a new branch 'version2'\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 512
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git의-기초-태그",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "2.7 Git의 기초 - Git Alias",
    "summary": "Git Alias Git의 기초를 마치기 전에 Git을 좀 더 쉽고 편안하게 쓸 수 있게 만들어 줄 Alias 라는 팁 알려주려 한다. 우리는 이 책에서 이 팁을 다시 거론하지 않고 이런 팁을 알고 있다고 가정한다. 그래서 알고 있는 것이 좋다. 명령을 완벽하게 입력하지 않으면 Git은 알아듣지 못한다. Git의 명령을 전부 입력하는 것이 귀찮다면 git config 를 사용하여 각 명령의 Alias을 쉽게 만들 수 있다. 아래는 Alias을 만드는 예이다. $ git config --global alias.co checkout $ git config --global alias.br branch $ git config --global alias.ci commit $ git config --global alias.st status 이제 git commit 대신 git ci 만으로도 커밋할 수 있다. Git을 계속 사용한다면 다른 명령어도 자주 사용하게 될 것이다. 주저말고 자주 사용하",
    "sections": [
      {
        "header": "Git Alias",
        "content": "Git의 기초를 마치기 전에 Git을 좀 더 쉽고 편안하게 쓸 수 있게 만들어 줄 Alias 라는 팁 알려주려 한다. 우리는 이 책에서 이 팁을 다시 거론하지 않고 이런 팁을 알고 있다고 가정한다. 그래서 알고 있는 것이 좋다.\n\n명령을 완벽하게 입력하지 않으면 Git은 알아듣지 못한다. Git의 명령을 전부 입력하는 것이 귀찮다면 git config 를 사용하여 각 명령의 Alias을 쉽게 만들 수 있다. 아래는 Alias을 만드는 예이다.\n\n이제 git commit 대신 git ci 만으로도 커밋할 수 있다. Git을 계속 사용한다면 다른 명령어도 자주 사용하게 될 것이다. 주저말고 자주 사용하는 명령은 Alias을 만들어 편하게 사용하시길 바란다.\n\n이미 있는 명령을 편리하고 새로운 명령으로 만들어 사용할 수 있다. 예를 들어 파일을 Unstaged 상태로 변경하는 명령을 만들어서 불편함을 덜 수 있다. 아래와 같이 unstage 라는 Alias을 만든다.\n\n한결 간결해졌다. 추가로 last 명령을 만들어 보자:\n\n이제 최근 커밋을 좀 더 쉽게 확인할 수 있다.\n\n이것으로 쉽게 새로운 명령을 만들 수 있다. 그리고 Git의 명령어뿐만 아니라 외부 명령어도 실행할 수 있다. ! 를 제일 앞에 추가하면 외부 명령을 실행한다. 커스텀 스크립트를 만들어서 사용할 때 매우 유용하다. 아래 명령은 git visual 이라고 입력하면 gitk 가 실행된다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git config --global alias.co checkout\n$ git config --global alias.br branch\n$ git config --global alias.ci commit\n$ git config --global alias.st status\n```",
          "```bash\n$ git config --global alias.unstage 'reset HEAD --'\n```",
          "```bash\n$ git unstage fileA\n$ git reset HEAD -- fileA\n```",
          "```bash\n$ git config --global alias.last 'log -1 HEAD'\n```",
          "```bash\n$ git last\ncommit 66938dae3329c7aebe598c2246a8e6af90d04646\nAuthor: Josh Goebel <dreamer3@example.com>\nDate:   Tue Aug 26 19:48:51 2008 +0800\n\n    test for current head\n\n    Signed-off-by: Scott Chacon <schacon@example.com>\n```",
          "```bash\n$ git config --global alias.visual '!gitk'\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 709
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git의-기초-Git-Alias",
    "doc_type": "git",
    "total_sections": 1
  },
  {
    "title": "3.1 Git 브랜치 - 브랜치란 무엇인가",
    "summary": "모든 버전 관리 시스템은 브랜치를 지원한다. 개발을 하다 보면 코드를 여러 개로 복사해야 하는 일이 자주 생긴다. 코드를 통째로 복사하고 나서 원래 코드와는 상관없이 독립적으로 개발을 진행할 수 있는데, 이렇게 독립적으로 개발하는 것이 브랜치다.사람들은 브랜치 모델이 Git의 최고의 장점이라고, Git이 다른 것들과 구분되는 특징이라고 말한다. 당최 어떤 점이 그렇게 특별한 것일까. Git의 브랜치는 매우 가볍다. 순식간에 브랜치를 새로 만들고 브랜치 사이를 이동할 수 있다. 다른 버전 관리 시스템과는 달리 Git은 브랜치를 만들어 작업하고 나중에 Merge 하는 방법을 권장한다. 심지어 하루에 수십 번씩해도 괜찮다. Git 브랜치에 능숙해지면 개발 방식이 완전히 바뀌고 다른 도구를 사용할 수 없게 된다. 브랜치란 무엇인가 Git이 브랜치를 다루는 과정을 이해하려면 우선 Git이 데이터를 어떻게 저장하는지 알아야 한다. Git은 데이터를 Change Set이나 변경사항(Diff)으로",
    "sections": [
      {
        "header": "",
        "content": "모든 버전 관리 시스템은 브랜치를 지원한다. 개발을 하다 보면 코드를 여러 개로 복사해야 하는 일이 자주 생긴다. 코드를 통째로 복사하고 나서 원래 코드와는 상관없이 독립적으로 개발을 진행할 수 있는데, 이렇게 독립적으로 개발하는 것이 브랜치다.\n\n사람들은 브랜치 모델이 Git의 최고의 장점이라고, Git이 다른 것들과 구분되는 특징이라고 말한다. 당최 어떤 점이 그렇게 특별한 것일까. Git의 브랜치는 매우 가볍다. 순식간에 브랜치를 새로 만들고 브랜치 사이를 이동할 수 있다. 다른 버전 관리 시스템과는 달리 Git은 브랜치를 만들어 작업하고 나중에 Merge 하는 방법을 권장한다. 심지어 하루에 수십 번씩해도 괜찮다. Git 브랜치에 능숙해지면 개발 방식이 완전히 바뀌고 다른 도구를 사용할 수 없게 된다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 401
        }
      },
      {
        "header": "브랜치란 무엇인가",
        "content": "Git이 브랜치를 다루는 과정을 이해하려면 우선 Git이 데이터를 어떻게 저장하는지 알아야 한다.\n\nGit은 데이터를 Change Set이나 변경사항(Diff)으로 기록하지 않고 일련의 스냅샷으로 기록한다는 것을 시작하기 에서 보여줬다.\n\n커밋하면 Git은 현 Staging Area에 있는 데이터의 스냅샷에 대한 포인터, 저자나 커밋 메시지 같은 메타데이터, 이전 커밋에 대한 포인터 등을 포함하는 커밋 개체(커밋 Object)를 저장한다. 이전 커밋 포인터가 있어서 현재 커밋이 무엇을 기준으로 바뀌었는지를 알 수 있다. 최초 커밋을 제외한 나머지 커밋은 이전 커밋 포인터가 적어도 하나씩 있고 브랜치를 합친 Merge 커밋 같은 경우에는 이전 커밋 포인터가 여러 개 있다.\n\n파일이 3개 있는 디렉토리가 하나 있고 이 파일을 Staging Area에 저장하고 커밋하는 예제를 살펴 보자. 파일을 Stage 하면 Git 저장소에 파일을 저장하고(Git은 이것을 Blob이라고 부른다) Staging Area에 해당 파일의 체크섬을 저장한다(시작하기 에서 살펴본 SHA-1을 사용한다).\n\ngit commit 으로 커밋하면 먼저 루트 디렉토리와 각 하위 디렉토리의 트리 개체를 체크섬과 함께 저장소에 저장한다. 그다음에 커밋 개체를 만들고 메타데이터와 루트 디렉토리 트리 개체를 가리키는 포인터 정보를 커밋 개체에 넣어 저장한다. 그래서 필요하면 언제든지 스냅샷을 다시 만들 수 있다.\n\n이 작업을 마치고 나면 Git 저장소에는 다섯 개의 데이터 개체가 생긴다. 각 파일에 대한 Blob 세 개, 파일과 디렉토리 구조가 들어 있는 트리 개체 하나, 메타데이터와 루트 트리를 가리키는 포인터가 담긴 커밋 개체 하나이다.\n\n다시 파일을 수정하고 커밋하면 이전 커밋이 무엇인지도 저장한다.\n\nGit의 브랜치는 커밋 사이를 가볍게 이동할 수 있는 어떤 포인터 같은 것이다. 기본적으로 Git은 master 브랜치를 만든다. 처음 커밋하면 이 master 브랜치가 생성된 커밋을 가리킨다. 이후 커밋을 만들면 master 브랜치는 자동으로 가장 마지막 커밋을 가리킨다.\n\nGit 버전 관리 시스템에서 “master” 브랜치는 특별하지 않다. 다른 브랜치와 다른 것이 없다. 다만 모든 저장소에서 “master” 브랜치가 존재하는 이유는 git init 명령으로 초기화할 때 자동으로 만들어진 이 브랜치를 애써 다른 이름으로 변경하지 않기 때문이다.\n\n노트 | Git 버전 관리 시스템에서 “master” 브랜치는 특별하지 않다. 다른 브랜치와 다른 것이 없다. 다만 모든 저장소에서 “master” 브랜치가 존재하는 이유는 git init 명령으로 초기화할 때 자동으로 만들어진 이 브랜치를 애써 다른 이름으로 변경하지 않기 때문이다.\n\n[Note] 노트 Git 버전 관리 시스템에서 “master” 브랜치는 특별하지 않다. 다른 브랜치와 다른 것이 없다. 다만 모든 저장소에서 “master” 브랜치가 존재하는 이유는 git init 명령으로 초기화할 때 자동으로 만들어진 이 브랜치를 애써 다른 이름으로 변경하지 않기 때문이다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git add README test.rb LICENSE\n$ git commit -m 'The initial commit of my project'\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 9,
          "content_length": 1525
        }
      },
      {
        "header": "새 브랜치 생성하기",
        "content": "브랜치를 하나 새로 만들면 어떨까. 브랜치를 하나 만들어서 놀자. 아래와 같이 git branch 명령으로 testing 브랜치를 만든다.\n\n새로 만든 브랜치도 지금 작업하고 있던 마지막 커밋을 가리킨다.\n\n지금 작업 중인 브랜치가 무엇인지 Git은 어떻게 파악할까. 다른 버전 관리 시스템과는 달리 Git은 'HEAD’라는 특수한 포인터가 있다. 이 포인터는 지금 작업하는 로컬 브랜치를 가리킨다. 브랜치를 새로 만들었지만, Git은 아직 master 브랜치를 가리키고 있다. git branch 명령은 브랜치를 만들기만 하고 브랜치를 옮기지 않는다.\n\ngit log 명령에 --decorate 옵션을 사용하면 쉽게 브랜치가 어떤 커밋을 가리키는지도 확인할 수 있다.\n\n“master” 와 “testing” 이라는 브랜치가 f30ab 커밋 옆에 위치하여 이런식으로 브랜치가 가리키는 커밋을 확인할 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git branch testing\n```",
          "```bash\n$ git log --oneline --decorate\nf30ab (HEAD -> master, testing) add feature #32 - ability to add new formats to the central interface\n34ac2 Fixed bug #1328 - stack overflow under certain conditions\n98ca9 The initial commit of my project\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 452
        }
      },
      {
        "header": "브랜치 이동하기",
        "content": "git checkout 명령으로 다른 브랜치로 이동할 수 있다. 한번 testing 브랜치로 바꿔보자.\n\n이렇게 하면 HEAD는 testing 브랜치를 가리킨다.\n\n자, 이제 핵심이 보일 거다! 커밋을 새로 한 번 해보자.\n\n이 부분이 흥미롭다. 새로 커밋해서 testing 브랜치는 앞으로 이동했다. 하지만, master 브랜치는 여전히 이전 커밋을 가리킨다. master 브랜치로 되돌아가보자.\n\n방금 실행한 명령이 한 일은 두 가지다. master 브랜치가 가리키는 커밋을 HEAD가 가리키게 하고 워킹 디렉토리의 파일도 그 시점으로 되돌려 놓았다. 앞으로 커밋을 하면 다른 브랜치의 작업들과 별개로 진행되기 때문에 testing 브랜치에서 임시로 작업하고 원래 master 브랜치로 돌아와서 하던 일을 계속할 수 있다.\n\n브랜치를 이동하면 워킹 디렉토리의 파일이 변경된다는 점을 기억해두어야 한다. 이전에 작업했던 브랜치로 이동하면 워킹 디렉토리의 파일은 그 브랜치에서 가장 마지막으로 했던 작업 내용으로 변경된다. 파일 변경시 문제가 있어 브랜치를 이동시키는게 불가능한 경우 Git은 브랜치 이동 명령을 수행하지 않는다.\n\n파일을 수정하고 다시 커밋을 해보자.\n\n프로젝트 히스토리는 분리돼 진행한다(갈라지는 브랜치). 우리는 브랜치를 하나 만들어 그 브랜치에서 일을 좀 하고, 다시 원래 브랜치로 되돌아와서 다른 일을 했다. 두 작업 내용은 서로 독립적으로 각 브랜치에 존재한다. 커밋 사이를 자유롭게 이동하다가 때가 되면 두 브랜치를 Merge 한다. 간단히 branch, checkout, commit 명령을 써서 말이다.\n\ngit log 명령으로 쉽게 확인할 수 있다. 현재 브랜치가 가리키고 있는 히스토리가 무엇이고 어떻게 갈라져 나왔는지 보여준다. git log --oneline --decorate --graph --all 이라고 실행하면 히스토리를 출력한다.\n\n실제로 Git의 브랜치는 어떤 한 커밋을 가리키는 40글자의 SHA-1 체크섬 파일에 불과하기 때문에 만들기도 쉽고 지우기도 쉽다. 새로 브랜치를 하나 만드는 것은 41바이트 크기의 파일을(40자와 줄 바꿈 문자) 하나 만드는 것에 불과하다.\n\n브랜치가 필요할 때 프로젝트를 통째로 복사해야 하는 다른 버전 관리 도구와 Git의 차이는 극명하다. 통째로 복사하는 작업은 프로젝트 크기에 따라 다르겠지만 수십 초에서 수십 분까지 걸린다. 그에 비해 Git은 순식간이다. 게다가 커밋을 할 때마다 이전 커밋의 정보를 저장하기 때문에 Merge 할 때 어디서부터(Merge Base) 합쳐야 하는지 안다. 이런 특징은 개발자들이 수시로 브랜치를 만들어 사용하게 한다.\n\n이제 왜 그렇게 브랜치를 수시로 만들고 사용해야 하는지 알아보자.\n\n노트 | 브랜치를 이동하면 워킹 디렉토리의 파일이 변경된다 브랜치를 이동하면 워킹 디렉토리의 파일이 변경된다는 점을 기억해두어야 한다. 이전에 작업했던 브랜치로 이동하면 워킹 디렉토리의 파일은 그 브랜치에서 가장 마지막으로 했던 작업 내용으로 변경된다. 파일 변경시 문제가 있어 브랜치를 이동시키는게 불가능한 경우 Git은 브랜치 이동 명령을 수행하지 않는다.\n\n[Note] 노트 브랜치를 이동하면 워킹 디렉토리의 파일이 변경된다 브랜치를 이동하면 워킹 디렉토리의 파일이 변경된다는 점을 기억해두어야 한다. 이전에 작업했던 브랜치로 이동하면 워킹 디렉토리의 파일은 그 브랜치에서 가장 마지막으로 했던 작업 내용으로 변경된다. 파일 변경시 문제가 있어 브랜치를 이동시키는게 불가능한 경우 Git은 브랜치 이동 명령을 수행하지 않는다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git checkout testing\n```",
          "```bash\n$ vim test.rb\n$ git commit -a -m 'made a change'\n```",
          "```bash\n$ git checkout master\n```",
          "```bash\n$ vim test.rb\n$ git commit -a -m 'made other changes'\n```",
          "```bash\n$ git log --oneline --decorate --graph --all\n* c2b9e (HEAD, master) made other changes\n| * 87ab2 (testing) made a change\n|/\n* f30ab add feature #32 - ability to add new formats to the\n* 34ac2 fixed bug #1328 - stack overflow under certain conditions\n* 98ca9 initial commit of my project\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 12,
          "content_length": 1761
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git-브랜치-브랜치란-무엇인가",
    "doc_type": "git",
    "total_sections": 4
  },
  {
    "title": "3.2 Git 브랜치 - 브랜치와 Merge 의 기초",
    "summary": "브랜치와 Merge 의 기초 실제 개발과정에서 겪을 만한 예제를 하나 살펴보자. 브랜치와 Merge는 보통 이런 식으로 진행한다. 웹사이트가 있고 뭔가 작업을 진행하고 있다. 새로운 이슈를 처리할 새 Branch를 하나 생성한다. 새로 만든 Branch에서 작업을 진행한다. 이때 중요한 문제가 생겨서 그것을 해결하는 Hotfix를 먼저 만들어야 한다. 그러면 아래와 같이 할 수 있다. 새로운 이슈를 처리하기 이전의 운영(Production) 브랜치로 이동한다. Hotfix 브랜치를 새로 하나 생성한다. 수정한 Hotfix 테스트를 마치고 운영 브랜치로 Merge 한다. 다시 작업하던 브랜치로 옮겨가서 하던 일 진행한다. 브랜치의 기초 먼저 지금 작업하는 프로젝트에서 이전에 master 브랜치에 커밋을 몇 번 했다고 가정한다. 그림 18. 현재 커밋 히스토리 이슈 관리 시스템에 등록된 53번 이슈를 처리한다고 하면 이 이슈에 집중할 수 있는 브랜치를 새로 하나 만든다. 브랜치를 만들면",
    "sections": [
      {
        "header": "브랜치와 Merge 의 기초",
        "content": "실제 개발과정에서 겪을 만한 예제를 하나 살펴보자. 브랜치와 Merge는 보통 이런 식으로 진행한다.\n\n웹사이트가 있고 뭔가 작업을 진행하고 있다.\n\n새로운 이슈를 처리할 새 Branch를 하나 생성한다.\n\n새로 만든 Branch에서 작업을 진행한다.\n\n이때 중요한 문제가 생겨서 그것을 해결하는 Hotfix를 먼저 만들어야 한다. 그러면 아래와 같이 할 수 있다.\n\n새로운 이슈를 처리하기 이전의 운영(Production) 브랜치로 이동한다.\n\nHotfix 브랜치를 새로 하나 생성한다.\n\n수정한 Hotfix 테스트를 마치고 운영 브랜치로 Merge 한다.\n\n다시 작업하던 브랜치로 옮겨가서 하던 일 진행한다.\n\n• 웹사이트가 있고 뭔가 작업을 진행하고 있다.\n• 새로운 이슈를 처리할 새 Branch를 하나 생성한다.\n• 새로 만든 Branch에서 작업을 진행한다.\n\n• 새로운 이슈를 처리하기 이전의 운영(Production) 브랜치로 이동한다.\n• Hotfix 브랜치를 새로 하나 생성한다.\n• 수정한 Hotfix 테스트를 마치고 운영 브랜치로 Merge 한다.\n• 다시 작업하던 브랜치로 옮겨가서 하던 일 진행한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 573
        }
      },
      {
        "header": "브랜치의 기초",
        "content": "먼저 지금 작업하는 프로젝트에서 이전에 master 브랜치에 커밋을 몇 번 했다고 가정한다.\n\n이슈 관리 시스템에 등록된 53번 이슈를 처리한다고 하면 이 이슈에 집중할 수 있는 브랜치를 새로 하나 만든다. 브랜치를 만들면서 Checkout까지 한 번에 하려면 git checkout 명령에 -b 라는 옵션을 추가한다.\n\n위 명령은 아래 명령을 줄여놓은 것이다.\n\niss53 브랜치를 Checkout 했기 때문에(즉, HEAD 는 iss53 브랜치를 가리킨다) 뭔가 일을 하고 커밋하면 iss53 브랜치가 앞으로 나아간다.\n\n다른 상황을 가정해보자. 만드는 사이트에 문제가 생겨서 즉시 고쳐야 한다. 버그를 해결한 Hotfix에 iss53 이 섞이는 것을 방지하기 위해 iss53 과 관련된 코드를 어딘가에 저장해두고 원래 운영 환경의 소스로 복구해야 한다. Git을 사용하면 이런 노력을 들일 필요 없이 그냥 master 브랜치로 돌아가면 된다.\n\n그렇지만, 브랜치를 이동하려면 해야 할 일이 있다. 아직 커밋하지 않은 파일이 Checkout 할 브랜치와 충돌 나면 브랜치를 변경할 수 없다. 브랜치를 변경할 때는 워킹 디렉토리를 정리하는 것이 좋다. 이런 문제를 다루는 방법은(주로, Stash이나 커밋 Amend에 대해) 나중에 Stashing과 Cleaning 에서 다룰 것이다. 지금은 작업하던 것을 모두 커밋하고 master 브랜치로 옮긴다:\n\n이때 워킹 디렉토리는 53번 이슈를 시작하기 이전 모습으로 되돌려지기 때문에 새로운 문제에 집중할 수 있는 환경이 만들어진다. Git은 자동으로 워킹 디렉토리에 파일들을 추가하고, 지우고, 수정해서 Checkout 한 브랜치의 마지막 스냅샷으로 되돌려 놓는다는 것을 기억해야 한다.\n\n이젠 해결해야 할 핫픽스가 생겼을 때를 살펴보자. hotfix 라는 브랜치를 만들고 새로운 이슈를 해결할 때까지 사용한다.\n\n운영 환경에 적용하려면 문제를 제대로 고쳤는지 테스트하고 최종적으로 운영환경에 배포하기 위해 hotfix 브랜치를 master 브랜치에 합쳐야 한다. git merge 명령으로 아래와 같이 한다.\n\nMerge 메시지에서 “fast-forward” 가 보이는가. hotfix 브랜치가 가리키는 C4 커밋이 C2 커밋에 기반한 브랜치이기 때문에 브랜치 포인터는 Merge 과정 없이 그저 최신 커밋으로 이동한다. 이런 Merge 방식을 “Fast forward” 라고 부른다. 다시 말해 A 브랜치에서 다른 B 브랜치를 Merge 할 때 B 브랜치가 A 브랜치 이후의 커밋을 가리키고 있으면 그저 A 브랜치가 B 브랜치와 동일한 커밋을 가리키도록 이동시킬 뿐이다.\n\n이제 hotfix 는 master 브랜치에 포함됐고 운영환경에 적용할 수 있는 상태가 되었다고 가정해보자.\n\n급한 문제를 해결하고 master 브랜치에 적용하고 나면 다시 일하던 브랜치로 돌아가야 한다. 이제 더 이상 필요없는 hotfix 브랜치는 삭제한다. git branch 명령에 -d 옵션을 주고 브랜치를 삭제한다.\n\n자 이제 이슈 53번을 처리하던 환경으로 되돌아가서 하던 일을 계속 하자.\n\n위에서 작업한 hotfix 가 iss53 브랜치에 영향을 끼치지 않는다는 점을 이해하는 것이 중요하다. git merge master 명령으로 master 브랜치를 iss53 브랜치에 Merge 하면 iss53 브랜치에 hotfix 가 적용된다. 아니면 iss53 브랜치가 master 에 Merge 할 수 있는 수준이 될 때까지 기다렸다가 Merge 하면 hotfix 와 iss53 브랜치가 합쳐진다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git checkout -b iss53\nSwitched to a new branch \"iss53\"\n```",
          "```bash\n$ git branch iss53\n$ git checkout iss53\n```",
          "```bash\n$ vim index.html\n$ git commit -a -m 'added a new footer [issue 53]'\n```",
          "```bash\n$ git checkout master\nSwitched to branch 'master'\n```",
          "```bash\n$ git checkout -b hotfix\nSwitched to a new branch 'hotfix'\n$ vim index.html\n$ git commit -a -m 'fixed the broken email address'\n[hotfix 1fb7853] fixed the broken email address\n 1 file changed, 2 insertions(+)\n```",
          "```bash\n$ git checkout master\n$ git merge hotfix\nUpdating f42c576..3a0874c\nFast-forward\n index.html | 2 ++\n 1 file changed, 2 insertions(+)\n```",
          "```bash\n$ git branch -d hotfix\nDeleted branch hotfix (3a0874c).\n```",
          "```bash\n$ git checkout iss53\nSwitched to branch \"iss53\"\n$ vim index.html\n$ git commit -a -m 'finished the new footer [issue 53]'\n[iss53 ad82d7a] finished the new footer [issue 53]\n1 file changed, 1 insertion(+)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 14,
          "content_length": 1753
        }
      },
      {
        "header": "Merge 의 기초",
        "content": "53번 이슈를 다 구현하고 master 브랜치에 Merge 하는 과정을 살펴보자. iss53 브랜치를 master 브랜치에 Merge 하는 것은 앞서 살펴본 hotfix 브랜치를 Merge 하는 것과 비슷하다. git merge 명령으로 합칠 브랜치에서 합쳐질 브랜치를 Merge 하면 된다.\n\nhotfix 를 Merge 했을 때와 메시지가 다르다. 현재 브랜치가 가리키는 커밋이 Merge 할 브랜치의 조상이 아니므로 Git은 'Fast-forward’로 Merge 하지 않는다. 이 경우에는 Git은 각 브랜치가 가리키는 커밋 두 개와 공통 조상 하나를 사용하여 3-way Merge를 한다.\n\n단순히 브랜치 포인터를 최신 커밋으로 옮기는 게 아니라 3-way Merge 의 결과를 별도의 커밋으로 만들고 나서 해당 브랜치가 그 커밋을 가리키도록 이동시킨다. 그래서 이런 커밋은 부모가 여러 개고 Merge 커밋이라고 부른다.\n\niss53 브랜치를 master에 Merge 하고 나면 더는 iss53 브랜치가 필요 없다. 다음 명령으로 브랜치를 삭제하고 이슈의 상태를 처리 완료로 표시한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git checkout master\nSwitched to branch 'master'\n$ git merge iss53\nMerge made by the 'recursive' strategy.\nindex.html |    1 +\n1 file changed, 1 insertion(+)\n```",
          "```bash\n$ git branch -d iss53\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 556
        }
      },
      {
        "header": "충돌의 기초",
        "content": "가끔씩 3-way Merge가 실패할 때도 있다. Merge 하는 두 브랜치에서 같은 파일의 한 부분을 동시에 수정하고 Merge 하면 Git은 해당 부분을 Merge 하지 못한다. 예를 들어, 53번 이슈와 hotfix 가 같은 부분을 수정했다면 Git은 Merge 하지 못하고 아래와 같은 충돌(Conflict) 메시지를 출력한다.\n\nGit은 자동으로 Merge 하지 못해서 새 커밋이 생기지 않는다. 변경사항의 충돌을 개발자가 해결하지 않는 한 Merge 과정을 진행할 수 없다. Merge 충돌이 일어났을 때 Git이 어떤 파일을 Merge 할 수 없었는지 살펴보려면 git status 명령을 이용한다.\n\n충돌이 일어난 파일은 unmerged 상태로 표시된다. Git은 충돌이 난 부분을 표준 형식에 따라 표시해준다. 그러면 개발자는 해당 부분을 수동으로 해결한다. 충돌 난 부분은 아래와 같이 표시된다.\n\n======= 위쪽의 내용은 HEAD 버전(merge 명령을 실행할 때 작업하던 master 브랜치)의 내용이고 아래쪽은 iss53 브랜치의 내용이다. 충돌을 해결하려면 위쪽이나 아래쪽 내용 중에서 고르거나 새로 작성하여 Merge 한다. 아래는 아예 새로 작성하여 충돌을 해결하는 예제다.\n\n충돌한 양쪽에서 조금씩 가져와서 새로 수정했다. 그리고 <<<<<<<, =======, >>>>>>> 가 포함된 행을 삭제했다. 이렇게 충돌한 부분을 해결하고 git add 명령으로 다시 Git에 저장한다.\n\n다른 Merge 도구도 충돌을 해결할 수 있다. git mergetool 명령으로 실행한다.\n\n기본 도구 말고 사용할 수 있는 다른 Merge 도구도 있는데(Mac에서는 opendiff 가 실행된다), “one of the following tools.” 부분에 보여준다. 여기에 표시된 도구 중 하나를 고를 수 있다.\n\nMerge 시에 발생한 충돌을 다루는 더 어렵고 요상한 내용은 뒤에 고급 Merge 에서 다루기로 한다.\n\nMerge 도구를 종료하면 Git은 잘 Merge 했는지 물어본다. 잘 마쳤다고 입력하면 자동으로 git add 가 수행되고 해당 파일이 Staging Area에 저장된다. git status 명령으로 충돌이 해결된 상태인지 다시 한번 확인해볼 수 있다.\n\n충돌을 해결하고 나서 해당 파일이 Staging Area에 저장됐는지 확인했으면 git commit 명령으로 Merge 한 것을 커밋한다. 충돌을 해결하고 Merge 할 때는 커밋 메시지가 아래와 같다.\n\n어떻게 충돌을 해결했고 좀 더 확인해야 하는 부분은 무엇이고 왜 그렇게 해결했는지에 대해서 자세하게 기록한다. 자세한 기록은 나중에 이 Merge 커밋을 이해하는데 도움을 준다.\n\n노트 | Merge 시에 발생한 충돌을 다루는 더 어렵고 요상한 내용은 뒤에 고급 Merge 에서 다루기로 한다.\n\n[Note] 노트 Merge 시에 발생한 충돌을 다루는 더 어렵고 요상한 내용은 뒤에 고급 Merge 에서 다루기로 한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git merge iss53\nAuto-merging index.html\nCONFLICT (content): Merge conflict in index.html\nAutomatic merge failed; fix conflicts and then commit the result.\n```",
          "```bash\n$ git status\nOn branch master\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n\nUnmerged paths:\n  (use \"git add <file>...\" to mark resolution)\n\n    both modified:      index.html\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```",
          "```bash\n<<<<<<< HEAD:index.html\n<div id=\"footer\">contact : email.support@github.com</div>\n=======\n<div id=\"footer\">\n please contact us at support@github.com\n</div>\n>>>>>>> iss53:index.html\n```",
          "```bash\n<div id=\"footer\">\nplease contact us at email.support@github.com\n</div>\n```",
          "```bash\n$ git mergetool\n\nThis message is displayed because 'merge.tool' is not configured.\nSee 'git mergetool --tool-help' or 'git help config' for more details.\n'git mergetool' will now attempt to use one of the following tools:\nopendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge\nMerging:\nindex.html\n\nNormal merge conflict for 'index.html':\n  {local}: modified file\n  {remote}: modified file\nHit return to start merge resolution tool (opendiff):\n```",
          "```bash\n$ git status\nOn branch master\nAll conflicts fixed but you are still merging.\n  (use \"git commit\" to conclude merge)\n\nChanges to be committed:\n\n    modified:   index.html\n```",
          "```bash\nMerge branch 'iss53'\n\nConflicts:\n    index.html\n#\n# It looks like you may be committing a merge.\n# If this is not correct, please remove the file\n#\t.git/MERGE_HEAD\n# and try again.\n\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n# On branch master\n# All conflicts fixed but you are still merging.\n#\n# Changes to be committed:\n#\tmodified:   index.html\n#\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 11,
          "content_length": 1471
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git-브랜치-브랜치와-Merge-의-기초",
    "doc_type": "git",
    "total_sections": 4
  },
  {
    "title": "3.3 Git 브랜치 - 브랜치 관리",
    "summary": "브랜치 관리 지금까지 브랜치를 만들고, Merge 하고, 삭제하는 방법에 대해서 살펴봤다. 브랜치를 관리하는 데 필요한 다른 명령도 살펴보자. git branch 명령은 단순히 브랜치를 만들고 삭제하는 것이 아니다. 아무런 옵션 없이 실행하면 브랜치의 목록을 보여준다. $ git branch iss53 * master testing * 기호가 붙어 있는 master 브랜치는 현재 Checkout 해서 작업하는 브랜치를 나타낸다. 즉, 지금 수정한 내용을 커밋하면 master 브랜치에 커밋되고 포인터가 앞으로 한 단계 나아간다. git branch -v 명령을 실행하면 브랜치마다 마지막 커밋 메시지도 함께 보여준다. $ git branch -v iss53 93b412c fix javascript issue * master 7a98805 Merge branch 'iss53' testing 782fd34 add scott to the author list in the readmes 각 브",
    "sections": [
      {
        "header": "브랜치 관리",
        "content": "지금까지 브랜치를 만들고, Merge 하고, 삭제하는 방법에 대해서 살펴봤다. 브랜치를 관리하는 데 필요한 다른 명령도 살펴보자.\n\ngit branch 명령은 단순히 브랜치를 만들고 삭제하는 것이 아니다. 아무런 옵션 없이 실행하면 브랜치의 목록을 보여준다.\n\n* 기호가 붙어 있는 master 브랜치는 현재 Checkout 해서 작업하는 브랜치를 나타낸다. 즉, 지금 수정한 내용을 커밋하면 master 브랜치에 커밋되고 포인터가 앞으로 한 단계 나아간다. git branch -v 명령을 실행하면 브랜치마다 마지막 커밋 메시지도 함께 보여준다.\n\n각 브랜치가 지금 어떤 상태인지 확인하기에 좋은 옵션도 있다. 현재 Checkout 한 브랜치를 기준으로 --merged 와 --no-merged 옵션을 사용하여 Merge 된 브랜치인지 그렇지 않은지 필터링해 볼 수 있다. git branch --merged 명령으로 이미 Merge 한 브랜치 목록을 확인한다.\n\niss53 브랜치는 앞에서 이미 Merge 했기 때문에 목록에 나타난다. * 기호가 붙어 있지 않은 브랜치는 git branch -d 명령으로 삭제해도 되는 브랜치다. 이미 다른 브랜치와 Merge 했기 때문에 삭제해도 정보를 잃지 않는다.\n\n반대로 현재 Checkout 한 브랜치에 Merge 하지 않은 브랜치를 살펴보려면 git branch --no-merged 명령을 사용한다.\n\n위에는 없었던 다른 브랜치가 보인다. 아직 Merge 하지 않은 커밋을 담고 있기 때문에 git branch -d 명령으로 삭제되지 않는다.\n\nMerge 하지 않은 브랜치를 강제로 삭제하려면 -D 옵션으로 삭제한다.\n\n위에서 설명한 --merged, --no-merged 옵션을 사용할 때 커밋이나 브랜치 이름을 지정해주지 않으면 현재 브랜치를 기준으로 Merge 되거나 Merge 되지 않은 내용을 출력한다.\n\n위 명령을 사용할 때 특정 브랜치를 기준으로 Merge 되거나 혹은 Merge 되지 않은 브랜치 정보를 살펴보려면 명령에 브랜치 이름을 지정해주면 된다. 예를 들어 master 브랜치에 아직 Merge되지 않은 브랜치를 살펴보려면 다음과 같은 명령을 실행한다.\n\n힌트 | 위에서 설명한 --merged, --no-merged 옵션을 사용할 때 커밋이나 브랜치 이름을 지정해주지 않으면 현재 브랜치를 기준으로 Merge 되거나 Merge 되지 않은 내용을 출력한다. 위 명령을 사용할 때 특정 브랜치를 기준으로 Merge 되거나 혹은 Merge 되지 않은 브랜치 정보를 살펴보려면 명령에 브랜치 이름을 지정해주면 된다. 예를 들어 master 브랜치에 아직 Merge되지 않은 브랜치를 살펴보려면 다음과 같은 명령을 실행한다. $ git checkout testing $ git branch --no-merged master topicA featureB\n\n[Tip] 힌트 위에서 설명한 --merged, --no-merged 옵션을 사용할 때 커밋이나 브랜치 이름을 지정해주지 않으면 현재 브랜치를 기준으로 Merge 되거나 Merge 되지 않은 내용을 출력한다. 위 명령을 사용할 때 특정 브랜치를 기준으로 Merge 되거나 혹은 Merge 되지 않은 브랜치 정보를 살펴보려면 명령에 브랜치 이름을 지정해주면 된다. 예를 들어 master 브랜치에 아직 Merge되지 않은 브랜치를 살펴보려면 다음과 같은 명령을 실행한다. $ git checkout testing $ git branch --no-merged master topicA featureB",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git branch\n  iss53\n* master\n  testing\n```",
          "```bash\n$ git branch -v\n  iss53   93b412c fix javascript issue\n* master  7a98805 Merge branch 'iss53'\n  testing 782fd34 add scott to the author list in the readmes\n```",
          "```bash\n$ git branch --merged\n  iss53\n* master\n```",
          "```bash\n$ git branch --no-merged\n  testing\n```",
          "```bash\n$ git branch -d testing\nerror: The branch 'testing' is not fully merged.\nIf you are sure you want to delete it, run 'git branch -D testing'.\n```",
          "```bash\n$ git checkout testing\n$ git branch --no-merged master\n  topicA\n  featureB\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 10,
          "content_length": 1743
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git-브랜치-브랜치-관리",
    "doc_type": "git",
    "total_sections": 1
  },
  {
    "title": "3.4 Git 브랜치 - 브랜치 워크플로",
    "summary": "브랜치 워크플로 브랜치를 만들고 Merge 하는 것을 어디에 써먹어야 할까. 이 절에서는 Git 브랜치가 유용한 몇 가지 워크플로를 살펴본다. 여기서 설명하는 워크플로를 개발에 적용하면 도움이 될 것이다. Long-Running 브랜치 Git은 꼼꼼하게 3-way Merge를 사용하기 때문에 장기간에 걸쳐서 한 브랜치를 다른 브랜치와 여러 번 Merge 하는 것이 쉬운 편이다. 그래서 개발 과정에서 필요한 용도에 따라 브랜치를 만들어 두고 계속 사용할 수 있다. 그리고 정기적으로 브랜치를 다른 브랜치로 Merge 한다. 이런 접근법에 따라서 Git 개발자가 많이 선호하는 워크플로가 하나 있다. 배포했거나 배포할 코드만 master 브랜치에 Merge 해서 안정 버전의 코드만 master 브랜치에 둔다. 개발을 진행하고 안정화하는 브랜치는 develop 이나 next 라는 이름으로 추가로 만들어 사용한다. 이 브랜치는 언젠가 안정 상태가 되겠지만, 항상 안정 상태를 유지해야 하는 것이",
    "sections": [
      {
        "header": "브랜치 워크플로",
        "content": "브랜치를 만들고 Merge 하는 것을 어디에 써먹어야 할까. 이 절에서는 Git 브랜치가 유용한 몇 가지 워크플로를 살펴본다. 여기서 설명하는 워크플로를 개발에 적용하면 도움이 될 것이다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 105
        }
      },
      {
        "header": "Long-Running 브랜치",
        "content": "Git은 꼼꼼하게 3-way Merge를 사용하기 때문에 장기간에 걸쳐서 한 브랜치를 다른 브랜치와 여러 번 Merge 하는 것이 쉬운 편이다. 그래서 개발 과정에서 필요한 용도에 따라 브랜치를 만들어 두고 계속 사용할 수 있다. 그리고 정기적으로 브랜치를 다른 브랜치로 Merge 한다.\n\n이런 접근법에 따라서 Git 개발자가 많이 선호하는 워크플로가 하나 있다. 배포했거나 배포할 코드만 master 브랜치에 Merge 해서 안정 버전의 코드만 master 브랜치에 둔다. 개발을 진행하고 안정화하는 브랜치는 develop 이나 next 라는 이름으로 추가로 만들어 사용한다. 이 브랜치는 언젠가 안정 상태가 되겠지만, 항상 안정 상태를 유지해야 하는 것이 아니다. 테스트를 거쳐서 안정적이라고 판단되면 master 브랜치에 Merge 한다. 토픽 브랜치(앞서 살펴본 iss53 브랜치 같은 짧은 호흡 브랜치)에도 적용할 수 있는데, 해당 토픽을 처리하고 테스트해서 버그도 없고 안정적이면 그때 Merge 한다.\n\n사실 우리가 얘기하는 것은 커밋을 가리키는 포인터에 대한 얘기다. 커밋 포인터를 만들고 수정하고 분리하고 합치는지에 대한 것이다. 개발 브랜치는 공격적으로 히스토리를 만들어 나아가고 안정 브랜치는 이미 만든 히스토리를 뒤따르며 나아간다.\n\n실험실에서 충분히 테스트하고 실전에 배치하는 과정으로 보면 이해하기 쉽다\n\n코드를 여러 단계로 나누어 안정성을 높여가며 운영할 수 있다. 프로젝트 규모가 크면 proposed 혹은 pu (proposed updates)라는 이름의 브랜치를 만들고 next 나 master 브랜치에 아직 Merge 할 준비가 되지 않은 것을 일단 Merge 시킨다. 중요한 개념은 브랜치를 이용해 여러 단계에 걸쳐서 안정화해 나아가면서 충분히 안정화가 됐을 때 안정 브랜치로 Merge 한다는 점이다. 다시 말해서 Long-Running의 브랜치가 여러 개일 필요는 없지만 정말 유용하다는 점이다. 특히 규모가 크고 복잡한 프로젝트일수록 그 유용성이 반짝반짝 빛난다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1011
        }
      },
      {
        "header": "토픽 브랜치",
        "content": "토픽 브랜치는 프로젝트 크기에 상관없이 유용하다. 토픽 브랜치는 어떤 한 가지 주제나 작업을 위해 만든 짧은 호흡의 브랜치다. 다른 버전 관리 시스템에서는 이런 브랜치를 본 적이 없을 것이다. Git이 아닌 다른 버전 관리 도구에서는 브랜치를 하나 만드는 데 큰 비용이 든다. Git에서는 매우 일상적으로 브랜치를 만들고 Merge 하고 삭제한다.\n\n앞서 사용한 iss53 이나 hotfix 브랜치가 토픽 브랜치다. 우리는 브랜치를 새로 만들고 어느 정도 커밋하고 나서 다시 master 브랜치에 Merge 하고 브랜치 삭제도 해 보았다. 보통 주제별로 브랜치를 만들고 각각은 독립돼 있기 때문에 매우 쉽게 컨텍스트 사이를 옮겨 다닐 수 있다. 묶음별로 나눠서 일하면 내용별로 검토하기에도, 테스트하기에도 더 편하다. 각 작업을 하루든 한 달이든 유지하다가 master 브랜치에 Merge 할 시점이 되면 순서에 관계없이 그때 Merge 하면 된다.\n\nmaster 브랜치를 checkout 한 상태에서 어떤 작업을 한다고 해보자. 한 이슈를 처리하기 위해서 iss91 브랜치를 만들고 해당 작업을 한다. 같은 이슈를 다른 방법으로 해결해보고 싶을 때도 있다. iss91v2 브랜치를 만들고 다른 방법을 시도해 본다. 확신할 수 없는 아이디어를 적용해보기 위해 다시 master 브랜치로 되돌아가서 dumbidea 브랜치를 하나 더 만든다. 지금까지 말했던 커밋 히스토리는 아래 그림 같다.\n\n이슈를 처리했던 방법 중 두 번째 방법인 iss91v2 브랜치가 괜찮아서 적용하기로 결정했다. 그리고 아이디어를 확신할 수 없었던 dumbidea 브랜치를 같이 일하는 다른 개발자에게 보여줬더니 썩 괜찮다는 반응을 얻었다. iss91 브랜치는 (C5, C6 커밋도 함께) 버리고 다른 두 브랜치를 Merge 하면 아래 그림과 같이 된다.\n\n분산 환경에서의 Git에서 프로젝트를 Git으로 관리할 때 브랜치를 이용하여 만들 수 있는 여러 워크플로에 대해 살펴본다. 관련 부분을 살펴보면 프로젝트에 어떤 형태로 응용할수 있을 지 감이 올 것이다.\n\n지금까지 한 작업은 전부 로컬에서만 처리한다는 것을 꼭 기억하자. 로컬 저장소에서만 브랜치를 만들고 Merge 했으며 서버와 통신을 주고받는 일은 없었다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1114
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git-브랜치-브랜치-워크플로",
    "doc_type": "git",
    "total_sections": 3
  },
  {
    "title": "3.5 Git 브랜치 - 리모트 브랜치",
    "summary": "리모트 브랜치 리모트 Refs는 리모트 저장소에 있는 포인터인 레퍼런스다. 리모트 저장소에 있는 브랜치, 태그, 등등을 의미한다. git ls-remote [remote] 명령으로 모든 리모트 Refs를 조회할 수 있다. git remote show [remote] 명령은 모든 리모트 브랜치와 그 정보를 보여준다. 리모트 Refs가 있지만 보통은 리모트 트래킹 브랜치를 사용한다. 리모트 트래킹 브랜치는 리모트 브랜치를 추적하는 레퍼런스이며 브랜치다. 리모트 트래킹 브랜치는 로컬에 있지만 임의로 움직일 수 없다. 리모트 서버에 연결할 때마다 리모트의 브랜치 업데이트 내용에 따라서 자동으로 갱신될 뿐이다. 리모트 트래킹 브랜치는 일종의 북마크라고 할 수 있다. 리모트 저장소에 마지막으로 연결했던 순간에 브랜치가 무슨 커밋을 가리키고 있었는지를 나타낸다. 리모트 트래킹 브랜치의 이름은 <remote>/<branch> 형식으로 되어 있다. 예를 들어 리모트 저장소 origin 의 maste",
    "sections": [
      {
        "header": "리모트 브랜치",
        "content": "리모트 Refs는 리모트 저장소에 있는 포인터인 레퍼런스다. 리모트 저장소에 있는 브랜치, 태그, 등등을 의미한다. git ls-remote [remote] 명령으로 모든 리모트 Refs를 조회할 수 있다. git remote show [remote] 명령은 모든 리모트 브랜치와 그 정보를 보여준다. 리모트 Refs가 있지만 보통은 리모트 트래킹 브랜치를 사용한다.\n\n리모트 트래킹 브랜치는 리모트 브랜치를 추적하는 레퍼런스이며 브랜치다. 리모트 트래킹 브랜치는 로컬에 있지만 임의로 움직일 수 없다. 리모트 서버에 연결할 때마다 리모트의 브랜치 업데이트 내용에 따라서 자동으로 갱신될 뿐이다. 리모트 트래킹 브랜치는 일종의 북마크라고 할 수 있다. 리모트 저장소에 마지막으로 연결했던 순간에 브랜치가 무슨 커밋을 가리키고 있었는지를 나타낸다.\n\n리모트 트래킹 브랜치의 이름은 <remote>/<branch> 형식으로 되어 있다. 예를 들어 리모트 저장소 origin 의 master 브랜치를 보고 싶다면 origin/master 라는 이름으로 브랜치를 확인하면 된다. 다른 팀원과 함께 어떤 이슈를 구현할 때 그 팀원이 iss53 브랜치를 서버로 Push 했고 당신도 로컬에 iss53 브랜치가 있다고 가정하자. 이때 서버의 iss53 브랜치가 가리키는 커밋은 로컬에서 origin/iss53 이 가리키는 커밋이다.\n\n다소 헷갈릴 수 있으니 예제를 좀 더 살펴보자. git.ourcompany.com 이라는 Git 서버가 있고 이 서버의 저장소를 하나 Clone 하면 Git은 자동으로 origin 이라는 이름을 붙인다. origin 으로부터 저장소 데이터를 모두 내려받고 master 브랜치를 가리키는 포인터를 만든다. 이 포인터는 origin/master 라고 부르고 멋대로 조종할 수 없다. 그리고 Git은 로컬의 master 브랜치가 origin/master 를 가리키게 한다. 이제 이 master 브랜치에서 작업을 시작할 수 있다.\n\n브랜치 이름으로 많이 사용하는 “master” 라는 이름이 괜히 특별한 의미를 가지는 게 아닌 것처럼 “origin” 도 특별한 의미가 있는 것은 아니다. git init 명령이 자동으로 만들기 때문에 사용하는 이름인 “master” 와 마찬가지로 “origin” 도 git clone 명령이 자동으로 만들어주는 리모트 이름이다. git clone -o booyah 라고 옵션을 주고 명령을 실행하면 booyah/master 라고 사용자가 정한 대로 리모트 이름을 생성해준다.\n\n로컬 저장소에서 어떤 작업을 하고 있는데 동시에 다른 팀원이 git.ourcompany.com 서버에 Push 하고 master 브랜치를 업데이트한다. 그러면 이제 팀원 간의 히스토리는 서로 달라진다. 서버 저장소로부터 어떤 데이터도 주고받지 않아서 origin/master 포인터는 그대로다.\n\n리모트 서버로부터 저장소 정보를 동기화하려면 git fetch origin 명령을 사용한다. 명령을 실행하면 우선 “origin” 서버의 주소 정보(이 예에서는 git.ourcompany.com)를 찾아서, 현재 로컬의 저장소가 갖고 있지 않은 새로운 정보가 있으면 모두 내려받고, 받은 데이터를 로컬 저장소에 업데이트하고 나서, origin/master 포인터의 위치를 최신 커밋으로 이동시킨다.\n\n리모트 저장소를 여러 개 운영하는 상황을 이해할 수 있도록 개발용으로 사용할 Git 저장소를 팀 내부에 하나 추가해 보자. 이 저장소의 주소가 git.team1.ourcompany.com 이며 Git의 기초에서 살펴본 git remote add 명령으로 현재 작업 중인 프로젝트에 팀의 저장소를 추가한다. 이름을 teamone 으로 짓고 긴 서버 주소 대신 사용한다.\n\n서버를 추가하고 나면 git fetch teamone 명령으로 teamone 서버의 데이터를 내려받는다. 명령을 실행해도 teamone 서버의 데이터는 모두 origin 서버에도 있는 것들이라서 아무것도 내려받지 않는다. 하지만, 이 명령은 리모트 트래킹 브랜치 teamone/master 가 teamone 서버의 master 브랜치가 가리키는 커밋을 가리키게 한다.\n\n노트 | “origin” 의 의미 브랜치 이름으로 많이 사용하는 “master” 라는 이름이 괜히 특별한 의미를 가지는 게 아닌 것처럼 “origin” 도 특별한 의미가 있는 것은 아니다. git init 명령이 자동으로 만들기 때문에 사용하는 이름인 “master” 와 마찬가지로 “origin” 도 git clone 명령이 자동으로 만들어주는 리모트 이름이다. git clone -o booyah 라고 옵션을 주고 명령을 실행하면 booyah/master 라고 사용자가 정한 대로 리모트 이름을 생성해준다.\n\n[Note] 노트 “origin” 의 의미 브랜치 이름으로 많이 사용하는 “master” 라는 이름이 괜히 특별한 의미를 가지는 게 아닌 것처럼 “origin” 도 특별한 의미가 있는 것은 아니다. git init 명령이 자동으로 만들기 때문에 사용하는 이름인 “master” 와 마찬가지로 “origin” 도 git clone 명령이 자동으로 만들어주는 리모트 이름이다. git clone -o booyah 라고 옵션을 주고 명령을 실행하면 booyah/master 라고 사용자가 정한 대로 리모트 이름을 생성해준다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 9,
          "content_length": 2628
        }
      },
      {
        "header": "Push 하기",
        "content": "로컬의 브랜치를 서버로 전송하려면 쓰기 권한이 있는 리모트 저장소에 Push 해야 한다. 로컬 저장소의 브랜치는 자동으로 리모트 저장소로 전송되지 않는다. 명시적으로 브랜치를 Push 해야 정보가 전송된다. 따라서 리모트 저장소에 전송하지 않고 로컬 브랜치에만 두는 비공개 브랜치를 만들 수 있다. 또 다른 사람과 협업하기 위해 토픽 브랜치만 전송할 수도 있다.\n\nserverfix 라는 브랜치를 다른 사람과 공유할 때도 브랜치를 처음 Push 하는 것과 같은 방법으로 Push 한다. 아래와 같이 git push <remote> <branch> 명령을 사용한다.\n\nGit은 serverfix라는 브랜치 이름을 refs/heads/serverfix:refs/heads/serverfix 로 확장한다. 이것은 serverfix 라는 로컬 브랜치를 서버로 Push 하는데 리모트의 serverfix 브랜치로 업데이트한다는 것을 의미한다. 나중에 Git의 내부에서 refs/heads/ 의 뜻을 자세히 알아볼 것이기 때문에 일단 넘어가도록 한다. git push origin serverfix:serverfix 라고 Push 하는 것도 같은 의미인데 이것은 “로컬의 serverfix 브랜치를 리모트 저장소의 serverfix 브랜치로 Push 하라” 라는 뜻이다. 로컬 브랜치의 이름과 리모트 서버의 브랜치 이름이 다를 때 필요하다. 리모트 저장소에 serverfix 라는 이름 대신 다른 이름을 사용하려면 git push origin serverfix:awesomebranch 처럼 사용한다.\n\nHTTPS URL로 시작하는 리모트 저장소를 사용한다면 아마도 Push 나 Pull을 할 때 인증을 위한 사용자이름이나 암호를 묻는 것을 볼 수 있다. 보통 터미널에서 작업하는 경우 Git이 이 정보를 사용자로부터 받기 위해 사용자이름이나 암호를 입력받아 서버로 전달해서 권한을 확인한다.\n\n이 리모트에 접근할 때마다 매번 사용자이름나 암호를 입력하지 않도록 “credential cache” 기능을 이용할 수 있다. 이 기능을 활성화하면 Git은 몇 분 동안 입력한 사용자이름이나 암호를 저장해둔다. 이 기능을 활성화하려면 git config --global credential.helper cache 명령을 실행하여 환경설정을 추가한다.\n\n이 기능이 제공하는 다른 옵션에 대한 자세한 설명은 Credential 저장소를 참고한다.\n\n나중에 누군가 저장소를 Fetch 하고 나서 서버에 있는 serverfix 브랜치에 접근할 때 origin/serverfix 라는 이름으로 접근할 수 있다.\n\n여기서 짚고 넘어가야 할 게 있다. Fetch 명령으로 리모트 트래킹 브랜치를 내려받는다고 해서 로컬 저장소에 수정할 수 있는 브랜치가 새로 생기는 것이 아니다. 다시 말해서 serverfix 라는 브랜치가 생기는 것이 아니라 그저 수정 못 하는 origin/serverfix 브랜치 포인터가 생기는 것이다.\n\n새로 받은 브랜치의 내용을 Merge 하려면 git merge origin/serverfix 명령을 사용한다. Merge 하지 않고 리모트 트래킹 브랜치에서 시작하는 새 브랜치를 만들려면 아래와 같은 명령을 사용한다.\n\n그러면 origin/serverfix 에서 시작하고 수정할 수 있는 serverfix 라는 로컬 브랜치가 만들어진다.\n\n노트 | 암호를 매번 입력하지 않아도 된다 HTTPS URL로 시작하는 리모트 저장소를 사용한다면 아마도 Push 나 Pull을 할 때 인증을 위한 사용자이름이나 암호를 묻는 것을 볼 수 있다. 보통 터미널에서 작업하는 경우 Git이 이 정보를 사용자로부터 받기 위해 사용자이름이나 암호를 입력받아 서버로 전달해서 권한을 확인한다. 이 리모트에 접근할 때마다 매번 사용자이름나 암호를 입력하지 않도록 “credential cache” 기능을 이용할 수 있다. 이 기능을 활성화하면 Git은 몇 분 동안 입력한 사용자이름이나 암호를 저장해둔다. 이 기능을 활성화하려면 git config --global credential.helper cache 명령을 실행하여 환경설정을 추가한다. 이 기능이 제공하는 다른 옵션에 대한 자세한 설명은 Credential 저장소를 참고한다.\n\n[Note] 노트 암호를 매번 입력하지 않아도 된다 HTTPS URL로 시작하는 리모트 저장소를 사용한다면 아마도 Push 나 Pull을 할 때 인증을 위한 사용자이름이나 암호를 묻는 것을 볼 수 있다. 보통 터미널에서 작업하는 경우 Git이 이 정보를 사용자로부터 받기 위해 사용자이름이나 암호를 입력받아 서버로 전달해서 권한을 확인한다. 이 리모트에 접근할 때마다 매번 사용자이름나 암호를 입력하지 않도록 “credential cache” 기능을 이용할 수 있다. 이 기능을 활성화하면 Git은 몇 분 동안 입력한 사용자이름이나 암호를 저장해둔다. 이 기능을 활성화하려면 git config --global credential.helper cache 명령을 실행하여 환경설정을 추가한다. 이 기능이 제공하는 다른 옵션에 대한 자세한 설명은 Credential 저장소를 참고한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git push origin serverfix\nCounting objects: 24, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (15/15), done.\nWriting objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.\nTotal 24 (delta 2), reused 0 (delta 0)\nTo https://github.com/schacon/simplegit\n * [new branch]      serverfix -> serverfix\n```",
          "```bash\n$ git fetch origin\nremote: Counting objects: 7, done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 0), reused 3 (delta 0)\nUnpacking objects: 100% (3/3), done.\nFrom https://github.com/schacon/simplegit\n * [new branch]      serverfix    -> origin/serverfix\n```",
          "```bash\n$ git checkout -b serverfix origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 10,
          "content_length": 2516
        }
      },
      {
        "header": "브랜치 추적",
        "content": "리모트 트래킹 브랜치를 로컬 브랜치로 Checkout 하면 자동으로 “트래킹(Tracking) 브랜치” 가 만들어진다 (트래킹 하는 대상 브랜치를 “Upstream 브랜치” 라고 부른다). 트래킹 브랜치는 리모트 브랜치와 직접적인 연결고리가 있는 로컬 브랜치이다. 트래킹 브랜치에서 git pull 명령을 내리면 리모트 저장소로부터 데이터를 내려받아 연결된 리모트 브랜치와 자동으로 Merge 한다.\n\n서버로부터 저장소를 Clone을 하면 Git은 자동으로 master 브랜치를 origin/master 브랜치의 트래킹 브랜치로 만든다. 트래킹 브랜치를 직접 만들 수 있는데 리모트를 origin 이 아닌 다른 리모트로 할 수도 있고, 브랜치도 master 가 아닌 다른 브랜치로 추적하게 할 수 있다. git checkout -b <branch> <remote>/<branch> 명령으로 간단히 트래킹 브랜치를 만들 수 있다. --track 옵션을 사용하여 로컬 브랜치 이름을 자동으로 생성할 수 있다.\n\n이 명령은 매우 자주 쓰여서 더 생략할 수 있다. 입력한 브랜치가 있는 (a) 리모트가 딱 하나 있고 (b) 로컬에는 없으면 Git은 트래킹 브랜치를 만들어 준다.\n\n리모트 브랜치와 다른 이름으로 브랜치를 만들려면 로컬 브랜치의 이름을 아래와 같이 다르게 지정한다.\n\n이제 sf 브랜치에서 Push 나 Pull 하면 자동으로 origin/serverfix 로 데이터를 보내거나 가져온다.\n\n이미 로컬에 존재하는 브랜치가 리모트의 특정 브랜치를 추적하게 하려면 git branch 명령에 -u 나 --set-upstream-to 옵션을 붙여서 아래와 같이 설정한다.\n\n추적 브랜치를 설정했다면 추적 브랜치 이름을 @{upstream} 이나 @{u} 로 짧게 대체하여 사용할 수 있다. master 브랜치가 origin/master 브랜치를 추적하는 경우라면 git merge origin/master 명령과 git merge @{u} 명령을 똑같이 사용할 수 있다.\n\n추적 브랜치가 현재 어떻게 설정되어 있는지 확인하려면 git branch 명령에 -vv 옵션을 더한다. 이 명령을 실행하면 로컬 브랜치 목록과 로컬 브랜치가 추적하고 있는 리모트 브랜치도 함께 보여준다. 게다가, 로컬 브랜치가 앞서가는지 뒤쳐지는지에 대한 내용도 보여준다.\n\n위의 결과를 보면 iss53 브랜치는 origin/iss53 리모트 브랜치를 추적하고 있다는 것을 알 수 있고 “ahead” 표시를 통해 로컬 브랜치가 커밋 2개 앞서 있다(리모트 브랜치에는 없는 커밋이 로컬에는 존재)는 것을 알 수 있다. master 브랜치는 origin/master 브랜치를 추적하고 있으며 두 브랜치가 가리키는 커밋 내용이 같은 상태이다. 로컬 브랜치 중 serverfix 브랜치는 server-fix-good 이라는 teamone 리모트 서버의 브랜치를 추적하고 있으며 커밋 3개 앞서 있으며 동시에 커밋 1개로 뒤쳐져 있다. 이 말은 serverfix 브랜치에 서버로 보내지 않은 커밋이 3개, 서버의 브랜치에서 아직 로컬 브랜치로 머지하지 않은 커밋이 1개 있다는 말이다. 마지막 testing 브랜치는 추적하는 브랜치가 없는 상태이다.\n\n여기서 중요한 점은 명령을 실행했을 때 나타나는 결과는 모두 마지막으로 서버에서 데이터를 가져온(fetch) 시점을 바탕으로 계산한다는 점이다. 단순히 이 명령만으로는 서버의 최신 데이터를 반영하지는 않으며 로컬에 저장된 서버의 캐시 데이터를 사용한다. 현재 시점에서 진짜 최신 데이터로 추적 상황을 알아보려면 먼저 서버로부터 최신 데이터를 받아온 후에 추적 상황을 확인해야 한다. 아래처럼 두 명령을 이어서 사용하는 것이 적당하다 하겠다.\n\n노트 | Upstream 별명 추적 브랜치를 설정했다면 추적 브랜치 이름을 @{upstream} 이나 @{u} 로 짧게 대체하여 사용할 수 있다. master 브랜치가 origin/master 브랜치를 추적하는 경우라면 git merge origin/master 명령과 git merge @{u} 명령을 똑같이 사용할 수 있다.\n\n[Note] 노트 Upstream 별명 추적 브랜치를 설정했다면 추적 브랜치 이름을 @{upstream} 이나 @{u} 로 짧게 대체하여 사용할 수 있다. master 브랜치가 origin/master 브랜치를 추적하는 경우라면 git merge origin/master 명령과 git merge @{u} 명령을 똑같이 사용할 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git checkout --track origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n```",
          "```bash\n$ git checkout serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n```",
          "```bash\n$ git checkout -b sf origin/serverfix\nBranch sf set up to track remote branch serverfix from origin.\nSwitched to a new branch 'sf'\n```",
          "```bash\n$ git branch -u origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\n```",
          "```bash\n$ git branch -vv\n  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets\n  master    1ae2a45 [origin/master] deploying index fix\n* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it\n  testing   5ea463a trying something new\n```",
          "```bash\n$ git fetch --all; git branch -vv\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 10,
          "content_length": 2198
        }
      },
      {
        "header": "Pull 하기",
        "content": "git fetch 명령을 실행하면 서버에는 존재하지만, 로컬에는 아직 없는 데이터를 받아와서 저장한다. 이 때 워킹 디렉토리의 파일 내용은 변경되지 않고 그대로 남는다. 서버로부터 데이터를 가져와서 저장해두고 사용자가 Merge 하도록 준비만 해둔다. 간단히 말하면 git pull 명령은 대부분 git fetch 명령을 실행하고 나서 자동으로 git merge 명령을 수행하는 것 뿐이다. 바로 앞 절에서 살펴본 대로 clone 이나 checkout 명령을 실행하여 추적 브랜치가 설정되면 git pull 명령은 서버로부터 데이터를 가져와서 현재 로컬 브랜치와 서버의 추적 브랜치를 Merge 한다.\n\n일반적으로 fetch 와 merge 명령을 명시적으로 사용하는 것이 pull 명령으로 한번에 두 작업을 하는 것보다 낫다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 406
        }
      },
      {
        "header": "리모트 브랜치 삭제",
        "content": "동료와 협업하기 위해 리모트 브랜치를 만들었다가 작업을 마치고 master 브랜치로 Merge 했다. 협업하는 데 사용했던 그 리모트 브랜치는 이제 더 이상 필요하지 않기에 삭제할 수 있다. git push 명령에 --delete 옵션을 사용하여 리모트 브랜치를 삭제할 수 있다. serverfix 라는 리모트 브랜치를 삭제하려면 아래와 같이 실행한다.\n\n위 명령을 실행하면 서버에서 브랜치(즉 커밋을 가리키는 포인터) 하나가 사라진다. 서버에서 가비지 컬렉터가 동작하지 않는 한 데이터는 사라지지 않기 때문에 종종 의도치 않게 삭제한 경우에도 커밋한 데이터를 살릴 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git push origin --delete serverfix\nTo https://github.com/schacon/simplegit\n - [deleted]         serverfix\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 322
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git-브랜치-리모트-브랜치",
    "doc_type": "git",
    "total_sections": 5
  },
  {
    "title": "3.6 Git 브랜치 - Rebase 하기",
    "summary": "Rebase 하기 Git에서 한 브랜치에서 다른 브랜치로 합치는 방법으로는 두 가지가 있다. 하나는 Merge 이고 다른 하나는 Rebase 다. 이 절에서는 Rebase가 무엇인지, 어떻게 사용하는지, 좋은 점은 뭐고, 어떤 상황에서 사용하고 어떤 상황에서 사용하지 말아야 하는지 알아 본다. Rebase 의 기초 앞의 Merge 의 기초 절에서 살펴본 예제로 다시 돌아가 보자. 두 개의 나누어진 브랜치의 모습을 볼 수 있다. 그림 35. 두 개의 브랜치로 나누어진 커밋 히스토리 이 두 브랜치를 합치는 가장 쉬운 방법은 앞에서 살펴본 대로 merge 명령을 사용하는 것이다. 두 브랜치의 마지막 커밋 두 개(C3, C4)와 공통 조상(C2)을 사용하는 3-way Merge로 새로운 커밋을 만들어 낸다. 그림 36. 나뉜 브랜치를 Merge 하기 비슷한 결과를 만드는 다른 방식으로, C4 에서 변경된 사항을 Patch로 만들고 이를 다시 C3 에 적용시키는 방법이 있다. Git에서는 이",
    "sections": [
      {
        "header": "Rebase 하기",
        "content": "Git에서 한 브랜치에서 다른 브랜치로 합치는 방법으로는 두 가지가 있다. 하나는 Merge 이고 다른 하나는 Rebase 다. 이 절에서는 Rebase가 무엇인지, 어떻게 사용하는지, 좋은 점은 뭐고, 어떤 상황에서 사용하고 어떤 상황에서 사용하지 말아야 하는지 알아 본다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 154
        }
      },
      {
        "header": "Rebase 의 기초",
        "content": "앞의 Merge 의 기초 절에서 살펴본 예제로 다시 돌아가 보자. 두 개의 나누어진 브랜치의 모습을 볼 수 있다.\n\n이 두 브랜치를 합치는 가장 쉬운 방법은 앞에서 살펴본 대로 merge 명령을 사용하는 것이다. 두 브랜치의 마지막 커밋 두 개(C3, C4)와 공통 조상(C2)을 사용하는 3-way Merge로 새로운 커밋을 만들어 낸다.\n\n비슷한 결과를 만드는 다른 방식으로, C4 에서 변경된 사항을 Patch로 만들고 이를 다시 C3 에 적용시키는 방법이 있다. Git에서는 이런 방식을 Rebase 라고 한다. rebase 명령으로 한 브랜치에서 변경된 사항을 다른 브랜치에 적용할 수 있다.\n\n위의 예제는 아래와 같은 명령으로 Rebase 한다.\n\n실제로 일어나는 일을 설명하자면 일단 두 브랜치가 나뉘기 전인 공통 커밋으로 이동하고 나서 그 커밋부터 지금 Checkout 한 브랜치가 가리키는 커밋까지 diff를 차례로 만들어 어딘가에 임시로 저장해 놓는다. Rebase 할 브랜치(역주 - experiment)가 합칠 브랜치(역주 - master)가 가리키는 커밋을 가리키게 하고 아까 저장해 놓았던 변경사항을 차례대로 적용한다.\n\n그리고 나서 master 브랜치를 Fast-forward 시킨다.\n\nC4' 로 표시된 커밋에서의 내용은 Merge 예제에서 살펴본 C5 커밋에서의 내용과 같을 것이다. Merge 이든 Rebase 든 둘 다 합치는 관점에서는 서로 다를 게 없다. 하지만, Rebase가 좀 더 깨끗한 히스토리를 만든다. Rebase 한 브랜치의 Log를 살펴보면 히스토리가 선형이다. 일을 병렬로 동시에 진행해도 Rebase 하고 나면 모든 작업이 차례대로 수행된 것처럼 보인다.\n\nRebase는 보통 리모트 브랜치에 커밋을 깔끔하게 적용하고 싶을 때 사용한다. 아마 이렇게 Rebase 하는 리모트 브랜치는 직접 관리하는 것이 아니라 그냥 참여하는 브랜치일 것이다. 메인 프로젝트에 Patch를 보낼 준비가 되면 하는 것이 Rebase 니까 브랜치에서 하던 일을 완전히 마치고 origin/master 로 Rebase 한다. 이렇게 Rebase 하고 나면 프로젝트 관리자는 어떠한 통합작업도 필요 없다. 그냥 master 브랜치를 Fast-forward 시키면 된다.\n\nRebase를 하든지, Merge를 하든지 최종 결과물은 같고 커밋 히스토리만 다르다는 것이 중요하다. Rebase 의 경우는 브랜치의 변경사항을 순서대로 다른 브랜치에 적용하면서 합치고 Merge 의 경우는 두 브랜치의 최종결과만을 가지고 합친다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git checkout experiment\n$ git rebase master\nFirst, rewinding head to replay your work on top of it...\nApplying: added staged command\n```",
          "```bash\n$ git checkout master\n$ git merge experiment\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 1260
        }
      },
      {
        "header": "Rebase 활용",
        "content": "Rebase는 단순히 브랜치를 합치는 것만 아니라 다른 용도로도 사용할 수 있다. 다른 토픽 브랜치에서 갈라져 나온 토픽 브랜치 같은 히스토리가 있다고 하자. server 브랜치를 만들어서 서버 기능을 추가하고 그 브랜치에서 다시 client 브랜치를 만들어 클라이언트 기능을 추가한다. 마지막으로 server 브랜치로 돌아가서 몇 가지 기능을 더 추가한다.\n\n이때 테스트가 덜 된 server 브랜치는 그대로 두고 client 브랜치만 master 로 합치려는 상황을 생각해보자. server 와는 아무 관련이 없는 client 커밋은 C8, C9 이다. 이 두 커밋을 master 브랜치에 적용하기 위해서 --onto 옵션을 사용하여 아래와 같은 명령을 실행한다:\n\n이 명령은 master 브랜치부터 server 브랜치와 client 브랜치의 공통 조상까지의 커밋을 client 브랜치에서 없애고 싶을 때 사용한다. client 브랜치에서만 변경된 패치를 만들어 master 브랜치에서 client 브랜치를 기반으로 새로 만들어 적용한다. 조금 복잡하긴 해도 꽤 쓸모 있다.\n\n이제 master 브랜치로 돌아가서 Fast-forward 시킬 수 있다(master 브랜치를 client 브랜치 위치로 진행 시키기 참고).\n\nserver 브랜치의 일이 다 끝나면 git rebase <basebranch> <topicbranch> 라는 명령으로 Checkout 하지 않고 바로 server 브랜치를 master 브랜치로 Rebase 할 수 있다. 이 명령은 토픽(server) 브랜치를 Checkout 하고 베이스(master) 브랜치에 Rebase 한다.\n\nserver 브랜치의 수정사항을 master 브랜치에 적용했다. 그 결과는 master 브랜치에 server 브랜치의 수정 사항을 적용 같다.\n\n그리고 나서 master 브랜치를 Fast-forward 시킨다.\n\n모든 것이 master 브랜치에 통합됐기 때문에 더 필요하지 않다면 client 나 server 브랜치는 삭제해도 된다. 브랜치를 삭제해도 커밋 히스토리는 최종 커밋 히스토리 같이 여전히 남아 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git rebase --onto master server client\n```",
          "```bash\n$ git checkout master\n$ git merge client\n```",
          "```bash\n$ git rebase master server\n```",
          "```bash\n$ git checkout master\n$ git merge server\n```",
          "```bash\n$ git branch -d client\n$ git branch -d server\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1047
        }
      },
      {
        "header": "Rebase 의 위험성",
        "content": "Rebase가 장점이 많은 기능이지만 단점이 없는 것은 아니니 조심해야 한다. 그 주의사항은 아래 한 문장으로 표현할 수 있다.\n\n이미 공개 저장소에 Push 한 커밋을 Rebase 하지 마라\n\n이 지침만 지키면 Rebase를 하는 데 문제 될 게 없다. 하지만, 이 주의사항을 지키지 않으면 사람들에게 욕을 먹을 것이다.\n\nRebase는 기존의 커밋을 그대로 사용하는 것이 아니라 내용은 같지만 다른 커밋을 새로 만든다. 새 커밋을 서버에 Push 하고 동료 중 누군가가 그 커밋을 Pull 해서 작업을 한다고 하자. 그런데 그 커밋을 git rebase 로 바꿔서 Push 해버리면 동료가 다시 Push 했을 때 동료는 다시 Merge 해야 한다. 그리고 동료가 다시 Merge 한 내용을 Pull 하면 내 코드는 정말 엉망이 된다.\n\n이미 공개 저장소에 Push 한 커밋을 Rebase 하면 어떤 결과가 초래되는지 예제를 통해 알아보자. 중앙 저장소에서 Clone 하고 일부 수정을 하면 커밋 히스토리는 아래와 같아 진다.\n\n이제 팀원 중 누군가 커밋, Merge 하고 나서 서버에 Push 한다. 이 리모트 브랜치를 Fetch, Merge 하면 히스토리는 아래와 같이 된다.\n\n그런데 Push 했던 팀원은 Merge 한 일을 되돌리고 다시 Rebase 한다. 서버의 히스토리를 새로 덮어씌우려면 git push --force 명령을 사용해야 한다. 이후에 저장소에서 Fetch 하고 나면 아래 그림과 같은 상태가 된다.\n\n자 이렇게 되면 짬뽕이 된다. git pull 로 서버의 내용을 가져와서 Merge 하면 같은 내용의 수정사항을 포함한 Merge 커밋이 아래와 같이 만들어진다.\n\ngit log 로 히스토리를 확인해보면 저자, 커밋 날짜, 메시지가 같은 커밋이 두 개 있다(C4, C4'). 이렇게 되면 혼란스럽다. 게다가 이 히스토리를 서버에 Push 하면 같은 커밋이 두 개 있기 때문에 다른 사람들도 혼란스러워한다. C4 와 C6 는 포함되지 말았어야 할 커밋이다. 애초에 서버로 데이터를 보내기 전에 Rebase로 커밋을 정리했어야 했다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 1040
        }
      },
      {
        "header": "Rebase 한 것을 다시 Rebase 하기",
        "content": "만약 이런 상황에 빠질 때 유용한 Git 기능이 하나 있다. 어떤 팀원이 강제로 내가 한일을 덮어썼다고 하자. 그러면 내가 했던 일이 무엇이고 덮어쓴 내용이 무엇인지 알아내야 한다.\n\n커밋 SHA 체크섬 외에도 Git은 커밋에 Patch 할 내용으로 SHA-1 체크섬을 한번 더 구한다. 이 값은 “patch-id” 라고 한다.\n\n덮어쓴 커밋을 받아서 그 커밋을 기준으로 Rebase 할 때 Git은 원래 누가 작성한 코드인지 잘 찾아 낸다. 그래서 Patch가 원래대로 잘 적용된다.\n\n예를 들어 앞서 살펴본 예제를 보면 한 팀원이 다른 팀원이 의존하는 커밋을 없애고 Rebase 한 커밋을 다시 Push 함 상황에서 Merge 하는 대신 git rebase teamone/master 명령을 실행하면 Git은 아래와 같은 작업을 한다.\n\n현재 브랜치에만 포함된 커밋을 결정한다. (C2, C3, C4, C6, C7)\n\nMerge 커밋이 아닌 것을 결정한다. (C2, C3, C4)\n\n이 중 merge할 브랜치에 덮어쓰이지 않은 커밋을 결정한다. (C2, C3. C4는 C4’와 동일한 Patch다)\n\n결정한 커밋을 teamone/master 브랜치에 적용한다.\n\n결과를 확인해보면 같은 Merge를 다시 한다 같은 결과 대신 제대로 정리된 강제로 덮어쓴 브랜치에 Rebase 하기 같은 결과를 얻을 수 있다.\n\n동료가 생성했던 C4와 C4' 커밋 내용이 완전히 같을 때만 이렇게 동작된다. 커밋 내용이 아예 다르거나 비슷하다면 커밋이 두 개 생긴다(같은 내용이 두 번 커밋될 수 있기 때문에 깔끔하지 않다).\n\ngit pull 명령을 실행할 때 옵션을 붙여서 git pull --rebase 로 Rebase 할 수도 있다. 물론 git fetch 와 git rebase teamone/master 이 두 명령을 직접 순서대로 실행해도 된다.\n\ngit pull 명령을 실행할 때 기본적으로 --rebase 옵션이 적용되도록 pull.rebase 설정을 추가할 수 있다. git config --global pull.rebase true 명령으로 추가한다.\n\nPush 하기 전에 정리하려고 Rebase 하는 것은 괜찮다. 또 절대 공개하지 않고 혼자 Rebase 하는 경우도 괜찮다. 하지만, 이미 공개하여 사람들이 사용하는 커밋을 Rebase 하면 틀림없이 문제가 생긴다.\n\n나중에 후회하지 말고 git pull --rebase 로 문제를 미리 방지할 수 있다는 것을 같이 작업하는 동료와 모두 함께 공유하기 바란다.\n\n• 현재 브랜치에만 포함된 커밋을 결정한다. (C2, C3, C4, C6, C7)\n• Merge 커밋이 아닌 것을 결정한다. (C2, C3, C4)\n• 이 중 merge할 브랜치에 덮어쓰이지 않은 커밋을 결정한다. (C2, C3. C4는 C4’와 동일한 Patch다)\n• 결정한 커밋을 teamone/master 브랜치에 적용한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 14,
          "content_length": 1429
        }
      },
      {
        "header": "Rebase vs. Merge",
        "content": "Merge가 뭔지, Rebase가 뭔지 여러 예제를 통해 간단히 살펴보았다. 지금쯤 이런 의문이 들 거로 생각한다. 둘 중 무엇을 쓰는 게 좋지? 이 질문에 대한 답을 찾기 전에 히스토리의 의미에 대해서 잠깐 다시 생각해보자.\n\n히스토리를 보는 관점 중에 하나는 작업한 내용의 기록으로 보는 것이 있다. 작업 내용을 기록한 문서이고, 각 기록은 각각 의미를 가지며, 변경할 수 없다. 이런 관점에서 커밋 히스토리를 변경한다는 것은 역사를 부정하는 꼴이 된다. 언제 무슨 일이 있었는지 기록에 대해 거짓말 을 하게 되는 것이다. 이렇게 했을 때 지저분하게 수많은 Merge 커밋이 히스토리에 남게 되면 문제가 없을까? 역사는 후세를 위해 기록하고 보존해야 한다.\n\n히스토리를 프로젝트가 어떻게 진행되었나에 대한 이야기로도 볼 수 있다. 소프트웨어를 주의 깊게 편집하는 방법에 메뉴얼이나 세세한 작업내용을 초벌부터 공개하고 싶지 않을 수 있다. 나중에 다른 사람에게 들려주기 좋도록 Rebase 나 filter-branch 같은 도구로 프로젝트의 진행 이야기를 다듬으면 좋다.\n\nMerge 나 Rebase 중 무엇이 나으냐는 질문은 다시 생각해봐도 답이 그리 간단치 않다. Git은 매우 강력한 도구고 기능이 많아서 히스토리를 잘 쌓을 수 있지만, 모든 팀과 모든 이가 처한 상황은 모두 다르다. 예제를 통해 Merge 나 Rebase가 무엇이고 어떤 의미인지 배웠다. 이 둘을 어떻게 쓸지는 각자의 상황과 각자의 판단에 달렸다.\n\n일반적인 해답을 굳이 드리자면 로컬 브랜치에서 작업할 때는 히스토리를 정리하기 위해서 Rebase 할 수도 있지만, 리모트 등 어딘가에 Push로 내보낸 커밋에 대해서는 절대 Rebase 하지 말아야 한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 859
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git-브랜치-Rebase-하기",
    "doc_type": "git",
    "total_sections": 6
  },
  {
    "title": "5.2 분산 환경에서의 Git - 프로젝트에 기여하기",
    "summary": "프로젝트에 기여하기 프로젝트에 기여하는 방식을 설명하는데 가장 어려운 점은 그 방식이 매우 다양하다는 점이다. Git이 워낙 유연하게 설계됐기 때문에 사람들은 여러 가지 방식으로 사용할 수 있다. 게다가 프로젝트마다 환경이 달라서 프로젝트에 기여하는 방식을 쉽게 설명하기란 정말 어렵다. 기여하는 방식에 영향을 끼치는 몇 가지 변수가 있다. 활발히 기여하는 개발자의 수가 얼마인지, 선택한 워크플로가 무엇인지, 각 개발자에게 접근 권한을 어떻게 부여했는지, 외부에서도 기여할 수 있는지 등이 변수다. 첫 번째로 살펴볼 변수는 활발히 활동하는 개발자의 수이다. 얼마나 많은 개발자가 얼마나 자주 코드를 쏟아 내는가 하는 점이 활발한 개발자의 기준이다. 대부분 둘, 셋 정도의 개발자가 하루에 몇 번 커밋을 하고 활발하지 않은 프로젝트는 더 띄엄띄엄할 것이다. 하지만, 아주 큰 프로젝트는 수백, 수천 명의 개발자가 하루에도 수십, 수백 개의 커밋을 만들어 낸다. 개발자가 많으면 많을수록 코드를 ",
    "sections": [
      {
        "header": "프로젝트에 기여하기",
        "content": "프로젝트에 기여하는 방식을 설명하는데 가장 어려운 점은 그 방식이 매우 다양하다는 점이다. Git이 워낙 유연하게 설계됐기 때문에 사람들은 여러 가지 방식으로 사용할 수 있다. 게다가 프로젝트마다 환경이 달라서 프로젝트에 기여하는 방식을 쉽게 설명하기란 정말 어렵다. 기여하는 방식에 영향을 끼치는 몇 가지 변수가 있다. 활발히 기여하는 개발자의 수가 얼마인지, 선택한 워크플로가 무엇인지, 각 개발자에게 접근 권한을 어떻게 부여했는지, 외부에서도 기여할 수 있는지 등이 변수다.\n\n첫 번째로 살펴볼 변수는 활발히 활동하는 개발자의 수이다. 얼마나 많은 개발자가 얼마나 자주 코드를 쏟아 내는가 하는 점이 활발한 개발자의 기준이다. 대부분 둘, 셋 정도의 개발자가 하루에 몇 번 커밋을 하고 활발하지 않은 프로젝트는 더 띄엄띄엄할 것이다. 하지만, 아주 큰 프로젝트는 수백, 수천 명의 개발자가 하루에도 수십, 수백 개의 커밋을 만들어 낸다. 개발자가 많으면 많을수록 코드를 깔끔하게 적용하거나 Merge 하기 어려워진다. 어떤 커밋은 다른 개발자가 이미 기여한 것으로 불필요해지기도 하고 때론 서로 충돌이 일어난다. 어떻게 해야 코드를 최신으로 유지하면서 원하는 대로 수정할 수 있을까?\n\n두 번째 변수는 프로젝트에서 선택한 워크플로다. 개발자 모두가 메인 저장소에 쓰기 권한을 갖는 중앙집중형 방식인가? 프로젝트에 모든 Patch를 검사하고 통합하는 관리자가 따로 있는가? 모든 수정사항을 개발자끼리 검토하고 승인하는가? 자신이 그저 돕는게 아니라 어떤 책임을 맡고 있는지? 중간 관리자가 있어서 그들에게 먼저 알려야 하는가?\n\n세 번째 변수는 접근 권한이다. '프로젝트에 쓰기 권한이 있어서 직접 쓸 수 있는가? 아니면 읽기만 가능한가?'에 따라서 프로젝트에 기여하는 방식이 매우 달라진다. 쓰기 권한이 없다면 어떻게 수정 사항을 프로젝트에 반영할 수 있을까? 수정사항을 적용하는 정책이 프로젝트에 있는가? 얼마나 많은 시간을 프로젝트에 할애하는가? 얼마나 자주 기여하는가?\n\n이런 질문에 따라 프로젝트에 기여하는 방법과 워크플로가 달라진다. 간단한 것부터 복잡한 것까지 예제를 통해 각 상황을 살펴보면 실제 프로젝트에 필요한 워크플로를 선택하는 데 도움이 될 것이다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1105
        }
      },
      {
        "header": "커밋 가이드라인",
        "content": "다른 것보다 먼저 커밋 메시지에 대한 주의사항을 알아보자. 커밋 메시지를 잘 작성하는 가이드라인을 알아두면 다른 개발자와 함께 일하는 데 도움이 많이 된다. Git 프로젝트에 보면 커밋 메시지를 작성하는데 참고할 만한 좋은 팁이 많다. Git 프로젝트의 Documentation/SubmittingPatches 문서를 참고하자.\n\n무엇보다도 먼저 공백문자를 깨끗하게 정리하고 커밋해야 한다. Git은 공백문자를 검사해볼 수 있는 간단한 명령을 제공한다. 커밋을 하기 전에 git diff --check 명령으로 공백문자에 대한 오류를 확인할 수 있다.\n\n커밋을 하기 전에 공백문자에 대해 검사를 하면 공백으로 불필요하게 커밋되는 것을 막고 이런 커밋으로 인해 불필요하게 다른 개발자들이 신경 쓰는 일을 방지할 수 있다.\n\n그리고 각 커밋은 논리적으로 구분되는 Changeset이다. 최대한 수정사항을 한 주제로 요약할 수 있어야 하고 여러 가지 이슈에 대한 수정사항을 하나의 커밋에 담지 않아야 한다. 여러 가지 이슈를 한꺼번에 수정했다고 하더라도 Staging Area를 이용하여 한 커밋에 이슈 하나만 담기도록 한다. 작업 내용을 분할하고, 각 커밋마다 적절한 메시지를 작성한다. 같은 파일의 다른 부분을 수정하는 경우에는 git add -patch 명령을 써서 한 부분씩 나누어 Staging Area에 저장해야 한다(관련 내용은 대화형 명령 에서 다룬다). 결과적으로 최종 프로젝트의 모습은 한 번에 커밋을 하든 다섯 번에 나누어 커밋을 하든 똑같다.\n\n하지만, 여러 번 나누어 커밋하는 것이 다른 동료가 수정한 부분을 확인할 때나 각 커밋의 시점으로 복원해서 검토할 때 이해하기 훨씬 쉽다. 히스토리 단장하기 에서 이미 저장된 커밋을 다시 수정하거나 파일을 단계적으로 Staging Area에 저장하는 방법을 살펴본다. 다양한 도구를 이용해서 간단하고 이해하기 쉬운 커밋을 쌓아가야 한다.\n\n마지막으로 명심해야 할 점은 커밋 메시지 자체다. 좋은 커밋 메시지를 작성하는 습관은 Git을 사용하는 데 도움이 많이 된다. 일반적으로 커밋 메시지를 작성할 때 사용하는 규칙이 있다. 메시지의 첫 라인에 50자가 넘지 않는 아주 간략한 메시지를 적어 해당 커밋을 요약한다. 다음 한 라인은 비우고 그다음 라인부터 커밋을 자세히 설명한다. 예를 들어 Git 개발 프로젝트에서는 개발 동기와 구현 상황의 제약 조건이나 상황 등을 자세하게 요구한다. 이런 점은 따를 만한 좋은 가이드라인이다. 그리고 현재형 표현을 사용하는 것이 좋다. 명령문으로 시작하는 것도 좋은 방법이다. 예를 들어 “I added tests for (테스트를 추가함)” 보다는 “Add tests for (테스트 추가)” 와 같은 메시지를 작성한다. 아래 내용은 Tim Pope가 작성한 커밋 메시지의 템플릿이다.\n\n메시지를 이렇게 작성하면 함께 일하는 사람은 물론이고 자신에게도 매우 유용하다. Git 개발 프로젝트에는 잘 쓰인 커밋 메시지가 많으므로 프로젝트를 내려받아서 git log --no-merges 명령으로 꼭 살펴보기를 권한다.\n\n시간 관계상, 이 책에서 설명하는 예제의 커밋 메시지는 위와 같이 아주 멋지게 쓰지 않았다. git commit 명령에서 -m 옵션을 사용하여 간단하게 적는다.\n\n하지만! 저자처럼 하지 말고 시키는 대로 하는 것이 좋다.\n\n노트 | 책 처럼 하지말고, 시키는 대로 하기. 시간 관계상, 이 책에서 설명하는 예제의 커밋 메시지는 위와 같이 아주 멋지게 쓰지 않았다. git commit 명령에서 -m 옵션을 사용하여 간단하게 적는다. 하지만! 저자처럼 하지 말고 시키는 대로 하는 것이 좋다.\n\n[Note] 노트 책 처럼 하지말고, 시키는 대로 하기. 시간 관계상, 이 책에서 설명하는 예제의 커밋 메시지는 위와 같이 아주 멋지게 쓰지 않았다. git commit 명령에서 -m 옵션을 사용하여 간단하게 적는다. 하지만! 저자처럼 하지 말고 시키는 대로 하는 것이 좋다.",
        "code_examples": [
          "```bash\n영문 50글자 이하의 간략한 수정 요약\n\n자세한 설명. 영문 72글자 이상이 되면\n라인 바꿈을 하고 이어지는 내용을 작성한다.\n특정 상황에서는 첫 번째 라인이 이메일\n메시지의 제목이 되고 나머지는 메일\n내용이 된다. 빈 라인은 본문과 요약을\n구별해주기에 중요하다(본문 전체를 생략하지 않는 한).\n\n이어지는 내용도 한 라인 띄우고 쓴다.\n\n  - 목록 표시도 사용할 수 있다.\n\n  - 보통 '-' 나 '*' 표시를 사용해서 목록을 표현하고\n    표시 앞에 공백 하나, 각 목록 사이에는 빈 라인\n    하나를 넣는데, 이건 상황에 따라 다르다.\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 9,
          "content_length": 1950
        }
      },
      {
        "header": "비공개 소규모 팀",
        "content": "두세 명으로 이루어진 비공개 프로젝트가 가장 간단한 프로젝트일 것이다. “비공개” 라고 함은 소스코드가 공개되지 않은 것을 말하는 것이지 외부에서 접근할 수 없는 것을 말하지 않는다. 모든 개발자는 공유하는 저장소에 쓰기 권한이 있어야 한다.\n\n이런 환경에서는 보통 Subversion 같은 중앙집중형 버전 관리 시스템에서 사용하던 방식을 사용한다. 물론 Git이 가진 오프라인 커밋 기능이나 브랜치 Merge 기능을 이용하긴 하지만 크게 다르지 않다. 가장 큰 차이점은 서버가 아닌 클라이언트 쪽에서 Merge 한다는 점이다. 두 개발자가 저장소를 공유하는 시나리오를 살펴보자. 개발자인 John은 저장소를 Clone 하고 파일을 수정하고 나서 로컬에 커밋한다 (예제에서 Git이 출력하는 메시지 중 일부는 … 으로 줄이고 생략했다).\n\n개발자인 Jessica도 저장소를 Clone 하고 나서 파일을 하나 새로 추가하고 커밋한다.\n\nJessica는 서버에 커밋을 Push 한다.\n\nPush 명령을 실행하고 난 결과 중 가장 마지막 줄은 유용한 정보를 보여주고 있다. 마지막 줄의 기본적인 형태는 <oldref>..<newref> fromref → toref 이다. oldref 는 이전 레퍼런스를, newref 는 새 레퍼런스를, fromref 는 Push 명령에서 사용한 로컬 레퍼런스의 이름을, toref 는 Push로 업데이트한 리모트 레퍼런스를 나타낸다. 이어지는 내용에서 지금과 비슷한 Push 명령 출력 결과는 여러번 등장한다. 이 출력 메시지의 내용을 이해하고 있으면 다양한 상태에서 정확하게 어떤일이 벌어지는가를 좀 더 쉽게 이해할 수 있다. 자세한 내용을 좀 더 살펴보려면 Git 문서 git-push를 참고한다.\n\n다시 예제 내용으로 돌아오면, John도 내용을 변경하고 커밋을 만든 후 서버로 커밋을 Push 하려고 한다.\n\nJessica의 Push한 내용으로 인해, John의 커밋은 서버에서 거절된다. Subversion을 사용했던 사람은 이 부분을 이해하는 것이 중요하다. 같은 파일을 수정한 것도 아닌데 왜 Push가 거절되는 걸까? Subversion에서는 서로 다른 파일을 수정하는 이런 Merge 작업은 자동으로 서버가 처리한다. 하지만 Git은 로컬에서 먼저 Merge 해야 한다. 다시 말해 John은 Push 하기 전에 Jessica가 수정한 커밋을 Fetch 하고 Merge 해야 한다는 말이다.\n\n이를 위해 우선 John은 Jessica의 작업 내용을 아래와 같이 Fetch 한다(아래 명령은 Jessica의 작업 내용을 내려받긴 하지만 Merge 까지 하지는 않는 작업이다).\n\nFetch 하고 나면 John의 로컬 저장소는 아래와 같이 된다.\n\n이제 John은 Fetch하여 가져 온 Jessica의 작업 내용을 Merge 할 수 있다.\n\nMerge가 잘 이루어지면 John의 브랜치는 아래와 같은 상태가 된다.\n\nJohn은 Merge 하고 나서 자신이 작업한 코드가 제대로 동작하는지 확인한다. 그 후에 공유하는 저장소에 Push 한다.\n\n이제 John의 저장소는 아래와 같이 되었다.\n\n동시에 Jessica는 토픽 브랜치를 하나 만든다. issue54 브랜치를 만들고 세 번에 걸쳐서 커밋한다. 아직 John의 커밋을 Fetch 하지 않은 상황이기 때문에 아래와 같은 상황이 된다.\n\nJessica는 John이 새로 Push했다는 것을 알게 되어 하던 작업을 멈추고 John의 작업 내용을 살펴보려고 한다. 하지만 아직 Jessica는 John의 변경사항을 가지고 있지 않은 상태이다.\n\n위 명령으로 John이 Push 한 커밋을 모두 내려받는다. 그러면 Jessica의 저장소는 아래와 같은 상태가 된다.\n\n이제 orgin/master 와 Merge 할 차례다. Jessica는 토픽 브랜치에서의 작업을 마치고 어떤 내용이 Merge 되는지 git log 명령으로 확인한다.\n\nissue54..origin/master 문법은 히스토리를 검색할 때 뒤의 브랜치(origin/master)에 속한 커밋 중 앞의 브랜치(issue54)에 속하지 않은 커밋을 검색하는 문법이다. 자세한 내용은 범위로 커밋 가리키기에서 다룬다.\n\n앞의 명령에 따라 히스토리를 검색한 결과 John이 생성하고 Jessica가 Merge 하지 않은 커밋을 하나 찾았다. origin/master 브랜치를 Merge 하게 되면 검색된 커밋 하나가 로컬 작업에 Merge 될 것이다.\n\nMerge 할 내용을 확인한 Jessica는 자신이 작업한 내용과 John이 Push 한 작업(origin/master)을 master 브랜치에 Merge 하고 Push 한다.\n\nissue54 토픽 브랜치에 쌓은 모든 내용을 합치려면, 우선 master 브랜치를 Checkout 해야 한다.\n\norigin/master, issue54 모두 Upstream 브랜치이기 때문에 둘 중에 무엇을 먼저 Merge 하든 상관이 없다. 물론 어떤 것을 먼저 Merge 하느냐에 따라 히스토리 순서는 달라지지만, 최종 결과는 똑같다. Jessica는 먼저 issue54 브랜치를 Merge 한다.\n\n보다시피 Fast-forward Merge 이기 때문에 명령 실행 결과는 별 문제가 없다. origin/master 에 쌓여있던 John의 작업 내용을 다음과 같이 실행하여 Jessica는 Merge 작업을 완료할 수 있다.\n\n위와 같이 Merge가 잘 되면 그림 아래와 같은 상태가 된다.\n\norigin/master 브랜치가 Jessica의 master 브랜치로 나아갈(reachable) 수 있기 때문에 Push는 성공한다(물론 John이 그 사이에 Push 하지 않았다면).\n\n두 개발자의 커밋을 성공적으로 Merge 하고 나면 결과는 아래와 같다.\n\n매우 간단한 상황의 예제를 살펴보았다. 토픽 브랜치에서 수정하고 로컬의 master 브랜치에 Merge 한다. 작업한 내용을 프로젝트의 공유 저장소에 Push 하고자 할 때는 우선 origin/master 브랜치를 Fetch 하고 Merge 한다. 그리고 나서 Merge 한 결과를 다시 서버로 Push 한다. 이런 워크플로가 일반적이며 아래와 같이 나타낼 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# John's Machine\n$ git clone john@githost:simplegit.git\nCloning into 'simplegit'...\n...\n$ cd simplegit/\n$ vim lib/simplegit.rb\n$ git commit -am 'remove invalid default value'\n[master 738ee87] remove invalid default value\n 1 files changed, 1 insertions(+), 1 deletions(-)\n```",
          "```bash\n# Jessica's Machine\n$ git clone jessica@githost:simplegit.git\nCloning into 'simplegit'...\n...\n$ cd simplegit/\n$ vim TODO\n$ git commit -am 'add reset task'\n[master fbff5bc] add reset task\n 1 files changed, 1 insertions(+), 0 deletions(-)\n```",
          "```bash\n# Jessica's Machine\n$ git push origin master\n...\nTo jessica@githost:simplegit.git\n   1edee6b..fbff5bc  master -> master\n```",
          "```bash\n# John's Machine\n$ git push origin master\nTo john@githost:simplegit.git\n ! [rejected]        master -> master (non-fast forward)\nerror: failed to push some refs to 'john@githost:simplegit.git'\n```",
          "```bash\n$ git fetch origin\n...\nFrom john@githost:simplegit\n + 049d078...fbff5bc master     -> origin/master\n```",
          "```bash\n$ git merge origin/master\nMerge made by the 'recursive' strategy.\n TODO |    1 +\n 1 files changed, 1 insertions(+), 0 deletions(-)\n```",
          "```bash\n$ git push origin master\n...\nTo john@githost:simplegit.git\n   fbff5bc..72bbc59  master -> master\n```",
          "```bash\n# Jessica's Machine\n$ git fetch origin\n...\nFrom jessica@githost:simplegit\n   fbff5bc..72bbc59  master     -> origin/master\n```",
          "```bash\n$ git log --no-merges issue54..origin/master\ncommit 738ee872852dfaa9d6634e0dea7a324040193016\nAuthor: John Smith <jsmith@example.com>\nDate:   Fri May 29 16:01:27 2009 -0700\n\n   remove invalid default value\n```",
          "```bash\n$ git checkout master\nSwitched to branch 'master'\nYour branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.\n```",
          "```bash\n$ git merge issue54\nUpdating fbff5bc..4af4298\nFast forward\n README           |    1 +\n lib/simplegit.rb |    6 +++++-\n 2 files changed, 6 insertions(+), 1 deletions(-)\n```",
          "```bash\n$ git merge origin/master\nAuto-merging lib/simplegit.rb\nMerge made by the 'recursive' strategy.\n lib/simplegit.rb |    2 +-\n 1 files changed, 1 insertions(+), 1 deletions(-)\n```",
          "```bash\n$ git push origin master\n...\nTo jessica@githost:simplegit.git\n   72bbc59..8059c15  master -> master\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 27,
          "content_length": 3032
        }
      },
      {
        "header": "비공개 대규모 팀",
        "content": "이제 비공개 대규모 팀에서의 역할을 살펴보자. 이런 상황에는 보통 팀을 여러 개로 나눈다. 그래서 각각의 작은 팀이 서로 어떻게 하나로 Merge 하는지를 살펴본다.\n\nJohn과 Jessica는 “featureA” 기능을 함께 작업하게 됐다. Jessica는 Josie와 함께 “featureB” 기능도 작업하고 있다. 이런 상황이라면 회사는 Integration-manager 워크플로를 선택하는 게 좋다. 작은 팀이 수행한 결과물은 Integration-Manager가 Merge 하고 공유 저장소의 master 브랜치를 업데이트한다. 팀마다 브랜치를 하나씩 만들고 Integration-Manager는 그 브랜치를 Pull 해서 Merge 한다.\n\n두 팀에 모두 속한 Jessica의 작업 순서를 살펴보자. 우선 Jessica는 저장소를 Clone 하고 featureA 작업을 먼저 한다. featureA 브랜치를 만들고 수정하고 커밋한다.\n\n이 수정한 부분을 John과 공유해야 한다. 공유하려면 우선 featureA 브랜치를 서버로 Push 한다. Integration-Manager만 master 브랜치를 업데이트할 수 있기 때문에 master 브랜치로 Push를 할 수 없고 다른 브랜치로 John과 공유한다.\n\nJessica는 자신이 한 일을 featureA 라는 브랜치로 Push 했다는 이메일을 John에게 보낸다. John의 피드백을 기다리는 동안 Jessica는 Josie와 함께 하는 featureB 작업을 하기로 한다. 서버의 master 브랜치를 기반으로 새로운 브랜치를 하나 만든다.\n\n몇 가지 작업을 하고 featureB 브랜치에 커밋한다.\n\n그럼 Jessica의 저장소는 그림 아래와 같다.\n\n작업을 마치고 Push 하려고 하는데 Jesie가 이미 “featureB” 작업을 하고 서버에 featureBee 브랜치로 Push 했다는 이메일을 보내왔다. Jessica는 Jesie의 작업을 먼저 Merge 해야만 Push 할 수 있다. Merge 하기 위해서 우선 git fetch 로 Fetch 한다.\n\nJessica가 앞서 Checkout 한 featureB 브랜치에서 작업중일 때, Fetch 해 온 브랜치를 git merge 명령으로 Merge 한다.\n\n이 시점에서 Jissica는 Merge 한 “featureB” 작업을 서버로 Push 할 때 서버의 featureB 브랜치로 Push하지 않고자 한다. 이미 Josie가 생성한 featureBee 로 작업 내용을 Push 하러면 아래와 같이 실행한다.\n\n이것은 refspec 이란 것을 사용하는 것인데 Refspec 에서 자세하게 설명한다. 명령에서 사용한 -u 옵션은 --set-upstream 옵션의 짧은 표현인데 브랜치를 추적하도록 설정해서 이후 Push 나 Pull 할 때 좀 더 편하게 사용할 수 있다.\n\nJohn이 몇 가지 작업을 하고 나서 featureA 에 Push 했고 확인해 달라는 내용의 이메일을 보내왔다. Jessica는 John의 작업 내용을 확인하기 위해 다시 한 번 git fetch 로 Push된 작업을 Fetch 한다.\n\nJessica의 로컬 featureA 브랜치와 Fetch 해 온 John의 작업내용이 같은 featureA 브랜치 상에서 어떤 것이 업데이트됐는지 git log 명령으로 확인한다.\n\n확인을 마치면 로컬의 featureA 브랜치로 John의 작업 내용을 다음과 같이 Merge 한다.\n\nJessica는 일부 수정하고, featureA 브랜치에 커밋하고, 수정한 내용을 다시 서버로 Push 한다.\n\n위와 같은 작업을 마치고 나면 Jessica의 저장소는 아래와 같은 모습이 된다.\n\n그럼 featureA 와 featureBee 브랜치가 프로젝트의 메인 브랜치로 Merge 할 준비가 되었다고 Integration-Manager에게 알려준다. Integration-Manager가 두 브랜치를 모두 Merge 하고 난 후에 메인 브랜치를 Fetch 하면 아래와 같은 모양이 된다.\n\n수많은 팀의 작업을 동시에 진행하고 나중에 Merge 하는 기능을 사용하려고 다른 버전 관리 시스템에서 Git으로 바꾸는 조직들이 많아지고 있다. 팀은 자신의 브랜치로 작업하지만, 메인 브랜치에 영향을 끼치지 않는다는 점이 Git의 장점이다. 아래는 이런 워크플로를 나타내고 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# Jessica's Machine\n$ git checkout -b featureA\nSwitched to a new branch 'featureA'\n$ vim lib/simplegit.rb\n$ git commit -am 'add limit to log function'\n[featureA 3300904] add limit to log function\n 1 files changed, 1 insertions(+), 1 deletions(-)\n```",
          "```bash\n$ git push -u origin featureA\n...\nTo jessica@githost:simplegit.git\n * [new branch]      featureA -> featureA\n```",
          "```bash\n# Jessica's Machine\n$ git fetch origin\n$ git checkout -b featureB origin/master\nSwitched to a new branch 'featureB'\n```",
          "```bash\n$ vim lib/simplegit.rb\n$ git commit -am 'made the ls-tree function recursive'\n[featureB e5b0fdc] made the ls-tree function recursive\n 1 files changed, 1 insertions(+), 1 deletions(-)\n$ vim lib/simplegit.rb\n$ git commit -am 'add ls-files'\n[featureB 8512791] add ls-files\n 1 files changed, 5 insertions(+), 0 deletions(-)\n```",
          "```bash\n$ git fetch origin\n...\nFrom jessica@githost:simplegit\n * [new branch]      featureBee -> origin/featureBee\n```",
          "```bash\n$ git merge origin/featureBee\nAuto-merging lib/simplegit.rb\nMerge made by the 'recursive' strategy.\n lib/simplegit.rb |    4 ++++\n 1 files changed, 4 insertions(+), 0 deletions(-)\n```",
          "```bash\n$ git push -u origin featureB:featureBee\n...\nTo jessica@githost:simplegit.git\n   fba9af8..cd685d1  featureB -> featureBee\n```",
          "```bash\n$ git fetch origin\n...\nFrom jessica@githost:simplegit\n   3300904..aad881d  featureA   -> origin/featureA\n```",
          "```bash\n$ git log featureA..origin/featureA\ncommit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6\nAuthor: John Smith <jsmith@example.com>\nDate:   Fri May 29 19:57:33 2009 -0700\n\n    changed log output to 30 from 25\n```",
          "```bash\n$ git checkout featureA\nSwitched to branch 'featureA'\n$ git merge origin/featureA\nUpdating 3300904..aad881d\nFast forward\n lib/simplegit.rb |   10 +++++++++-\n1 files changed, 9 insertions(+), 1 deletions(-)\n```",
          "```bash\n$ git commit -am 'small tweak'\n[featureA 774b3ed] small tweak\n 1 files changed, 1 insertions(+), 1 deletions(-)\n$ git push\n...\nTo jessica@githost:simplegit.git\n   3300904..774b3ed  featureA -> featureA\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 18,
          "content_length": 2129
        }
      },
      {
        "header": "공개 프로젝트 Fork",
        "content": "비공개 팀을 운영하는 것과 공개 팀을 운영하는 것은 약간 다르다. 공개 팀을 운영할 때는 모든 개발자가 프로젝트의 공유 저장소에 직접적으로 쓰기 권한을 가지지는 않는다. 그래서 프로젝트의 관리자는 몇 가지 일을 더 해줘야 한다. Fork를 지원하는 Git 호스팅에서 Fork를 통해 프로젝트에 기여하는 법을 예제를 통해 살펴본다. Git 호스팅 사이트(GitHub, BitBucket, repo.or.cz 등) 대부분은 Fork 기능을 지원하며 프로젝트 관리자는 보통 Fork 하는 것으로 프로젝트를 운영한다. 다른 방식으로 이메일과 Patch를 사용하는 방식도 있는데 뒤이어 살펴본다.\n\n우선 처음 할 일은 메인 저장소를 Clone 하는 것이다. 그리고 나서 토픽 브랜치를 만들고 일정 부분 기여한다. 그 순서는 아래와 같다.\n\nrebase -i 명령을 사용하면 여러 커밋을 하나의 커밋으로 합치거나 프로젝트의 관리자가 수정사항을 쉽게 이해하도록 커밋을 정리할 수 있다. 히스토리 단장하기 에서 대화식으로 Rebase 하는 방법을 살펴본다.\n\n일단 프로젝트의 웹사이트로 가서 “Fork” 버튼을 누르면 원래 프로젝트 저장소에서 갈라져 나온, 쓰기 권한이 있는 저장소가 하나 만들어진다. 그러면 로컬에서 수정한 커밋을 원래 저장소에 Push 할 수 있다. 그 저장소를 로컬 저장소의 리모트 저장소로 등록한다. 예를 들어 myfork 로 등록한다.\n\n자 이제 등록한 리모트 저장소에 Push 한다. 작업하던 것을 로컬 저장소의 master 브랜치에 Merge 한 후 Push 하는 것보다 리모트 브랜치에 바로 Push를 하는 방식이 훨씬 간단하다. 이렇게 하는 이유는 관리자가 토픽 브랜치를 프로젝트에 포함시키고 싶지 않을 때 토픽 브랜치를 Merge 하기 이전 상태로 master 브랜치를 되돌릴 필요가 없기 때문이다. (cherry-pick 명령은 Rebase와 Cherry-Pick 워크플로 에서 자세히 다룬다). 관리자가 토픽 브랜치를 Merge 하든 Rebase 하든 Cherry-Pick 하든지 간에 결국 다시 관리자의 저장소를 Pull 할 때는 토픽 브랜치의 내용이 들어 있을 것이다.\n\n어떤 경우라도 다음과 같이 작업 내용을 Push 할 수 있다.\n\nFork 한 저장소에 Push 하고 나면 프로젝트 관리자에게 이 내용을 알려야 한다. 이것을 Pull Request 라고 한다. Git 호스팅 사이트에서 관리자에게 보낼 메시지를 생성하거나 git request-pull 명령으로 이메일을 수동으로 만들 수 있다. GitHub의 “Pull Request” 버튼은 자동으로 메시지를 만들어 주는데 관련 내용은 GitHub 에서 살펴볼 수 있다.\n\ngit request-pull 명령은 아규먼트를 두 개 입력받는다. 첫 번째 아규먼트는 작업한 토픽 브랜치의 Base 브랜치이다. 두 번째는 토픽 브랜치가 위치한 저장소 URL인데 위에서 등록한 리모트 저장소 이름을 적을 수 있다. 이 명령은 토픽 브랜치 수정사항을 요약한 내용을 결과로 보여준다. 예를 들어 Jessica가 John에게 Pull 요청을 보내는 상황을 살펴보자. Jessica는 토픽 브랜치에 두 번 커밋을 하고 Fork 한 저장소에 Push 했다. 그리고 아래와 같이 실행한다.\n\n관리자에게 이 내용을 보낸다. 이 내용에는 토픽 브랜치가 어느 시점에 갈라져 나온 것인지, 어떤 커밋이 있는지, Pull 하려면 어떤 저장소에 접근해야 하는지에 대한 내용이 들어 있다.\n\n프로젝트 관리자가 아니라고 해도 보통 origin/master 를 추적하는 master 브랜치는 가지고 있다. 그래도 토픽 브랜치를 만들고 일을 하면 관리자가 수정 내용을 거부할 때 쉽게 버릴 수 있다. 토픽 브랜치를 만들어서 주제별로 독립적으로 일을 하는 동안에도 주 저장소의 master 브랜치는 계속 수정된다. 하지만 주 저장소의 브랜치의 최근 커밋 이후로 Rebase 하면 깨끗하게 Merge 할 수 있다. 그리고 다른 주제의 일을 하려고 할 때는 앞서 Push 한 토픽 브랜치에서 시작하지 말고 주 저장소의 master 브랜치로부터 만들어야 한다.\n\n각 토픽은 일종의 실험실이라고 할 수 있다. 각 토픽은 서로 방해하지 않고 독립적으로 수정하고 Rebase 할 수 있다.\n\n프로젝트 관리자가 사람들의 수정 사항을 Merge 하고 나서 Jessica의 브랜치를 Merge 하려고 할 때 충돌이 날 수도 있다. 그러면 Jessica가 자신의 브랜치를 origin/master 에 Rebase 해서 충돌을 해결하고 다시 Pull Request을 보낸다.\n\n위 명령들을 실행하고 나면 히스토리는 아래와 같아진다.\n\n브랜치를 Rebase 해 버렸기 때문에 Push 할 때 -f 옵션을 주고 강제로 기존 서버에 있던 featureA 브랜치의 내용을 덮어 써야 한다. 아니면 새로운 브랜치를(예를 들어 featureAv2) 서버에 Push 해도 된다.\n\n또 다른 시나리오를 하나 더 살펴보자. 프로젝트 관리자는 featureB 브랜치의 내용은 좋지만, 상세 구현은 다르게 하고 싶다. 관리자는 featureB 담당자에게 상세 구현을 다르게 해달라고 요청한다. featureB 담당자는 하는 김에 featureB 브랜치를 프로젝트의 최신 master 브랜치 기반으로 옮긴다. 먼저 origin/master 브랜치에서 featureBv2 브랜치를 새로 하나 만들고, featureB 의 커밋들을 모두 Squash 해서 Merge 하고, 만약 충돌이 나면 해결하고, 상세 구현을 수정하고, 새 브랜치를 Push 한다.\n\n--squash 옵션은 현재 브랜치에 Merge 할 때 해당 브랜치의 커밋을 모두 커밋 하나로 합쳐서 Merge 한다. 이 때 Merge 커밋은 만들지 않는다. 다른 브랜치에서 수정한 사항을 전부 가져오는 것은 똑같다. 하지만 새로 만들어지는 커밋은 부모가 하나이고 커밋을 기록하기 전에 좀 더 수정할 기회도 있다. 다른 브랜치에서 수정한 사항을 전부 가져오면서 그전에 추가적으로 수정할 게 있으면 수정하고 Merge 할 수 있다. 게다가 새로 만들어지는 커밋은 부모가 하나다. --no-commit 옵션을 추가하면 커밋을 합쳐 놓고 자동으로 커밋하지 않는다.\n\n수정을 마치면 관리자에게 featureBv2 브랜치를 확인해 보라고 메시지를 보낸다.\n\n노트 | rebase -i 명령을 사용하면 여러 커밋을 하나의 커밋으로 합치거나 프로젝트의 관리자가 수정사항을 쉽게 이해하도록 커밋을 정리할 수 있다. 히스토리 단장하기 에서 대화식으로 Rebase 하는 방법을 살펴본다.\n\n[Note] 노트 rebase -i 명령을 사용하면 여러 커밋을 하나의 커밋으로 합치거나 프로젝트의 관리자가 수정사항을 쉽게 이해하도록 커밋을 정리할 수 있다. 히스토리 단장하기 에서 대화식으로 Rebase 하는 방법을 살펴본다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git clone <url>\n$ cd project\n$ git checkout -b featureA\n  ... work ...\n$ git commit\n  ... work ...\n$ git commit\n```",
          "```bash\n$ git remote add myfork <url>\n```",
          "```bash\n$ git push -u myfork featureA\n```",
          "```bash\n$ git request-pull origin/master myfork\nThe following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:\nJessica Smith (1):\n        added a new function\n\nare available in the git repository at:\n\n  git://githost/simplegit.git featureA\n\nJessica Smith (2):\n      add limit to log function\n      change log output to 30 from 25\n\n lib/simplegit.rb |   10 +++++++++-\n 1 files changed, 9 insertions(+), 1 deletions(-)\n```",
          "```bash\n$ git checkout -b featureB origin/master\n  ... work ...\n$ git commit\n$ git push myfork featureB\n$ git request-pull origin/master myfork\n  ... email generated request pull to maintainer ...\n$ git fetch origin\n```",
          "```bash\n$ git checkout featureA\n$ git rebase origin/master\n$ git push -f myfork featureA\n```",
          "```bash\n$ git checkout -b featureBv2 origin/master\n$ git merge --squash featureB\n  ... change implementation ...\n$ git commit\n$ git push myfork featureBv2\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 17,
          "content_length": 3334
        }
      },
      {
        "header": "대규모 공개 프로젝트와 이메일을 통한 관리",
        "content": "대규모 프로젝트는 보통 수정사항이나 Patch를 수용하는 자신만의 규칙을 마련해놓고 있다. 프로젝트마다 규칙은 서로 다를 수 있으므로 각 프로젝트의 규칙을 미리 알아둘 필요가 있다. 오래된 대규모 프로젝트는 대부분 메일링리스트를 통해서 Patch를 받아들이는데 예제를 통해 살펴본다.\n\n토픽 브랜치를 만들어 수정하는 작업은 앞서 살펴본 바와 거의 비슷하지만, Patch를 제출하는 방식이 다르다. 프로젝트를 Fork 하여 Push 하는 것이 아니라 커밋 내용을 메일로 만들어 개발자 메일링리스트에 제출한다.\n\n커밋을 두 번 하고 메일링리스트에 보내 보자. git format-patch 명령으로 메일링리스트에 보낼 mbox 형식의 파일을 생성한다. 각 커밋은 하나씩 이메일 메시지로 생성되는데 커밋 메시지의 첫 번째 라인이 제목이 되고 Merge 메시지 내용과 Patch 자체가 메일 메시지의 본문이 된다. 이 방식은 수신한 이메일에 들어 있는 Patch를 바로 적용할 수 있어서 좋다. 메일 속에는 커밋의 모든 내용이 포함된다. 메일에 포함된 Patch를 적용하는 것은 다음 절에서 살펴본다.\n\nformat-patch 명령을 실행하면 생성한 파일 이름을 보여준다. -M 옵션은 이름이 변경된 파일이 있는지 살펴보라는 옵션이다. 각 파일의 내용은 아래와 같다.\n\n메일링리스트에 이메일을 보내기 전에 각 Patch 파일을 손으로 고칠 수 있다. --- 라인과 Patch가 시작되는 라인(diff --git 로 시작하는 라인) 사이에 내용을 추가하면 다른 개발자는 읽을 수 있지만, 나중에 Patch에 적용되지는 않는다.\n\n특정 메일 프로그램을 사용하거나 이메일을 보내는 명령어로 메일링리스트에 보낼 수 있다. 붙여 넣기로 위의 내용이 그대로 들어가지 않는 메일 프로그램도 있다. 사용자 편의를 위해 공백이나 라인 바꿈 문자 등을 넣어 주는 메일 프로그램은 원본 그대로 들어가지 않는다. 다행히 Git에는 Patch 메일을 그대로 보낼 수 있는 도구가 있다. IMAP 프로토콜로 보낸다. 저자가 사용하는 방법으로 Gmail을 사용하여 Patch 메일을 전송하는 방법을 살펴보자. 추가로 Git 프로젝트의 Documentation/SubmittingPatches 문서의 마지막 부분을 살펴보면 다양한 메일 프로그램으로 메일을 보내는 방법을 설명한다.\n\n메일을 보내려면 먼저 ~/.gitconfig 파일에서 이메일 부분 설정한다. git config 명령으로 추가할 수도 있고 직접 파일을 열어서 추가할 수도 있다. 아무튼, 아래와 같이 설정을 한다.\n\nIMAP 서버가 SSL을 사용하지 않으면 마지막 두 라인은 필요 없고 host에서 imaps:// 대신 imap:// 로 한다. 이렇게 설정하면 git imap-send 명령으로 Patch 파일을 IMAP 서버의 Draft 폴더에 이메일로 보낼 수 있다.\n\n이후 Gmail의 Draft 폴더로 가서 To 부분을 메일링리스트의 주소로 변경하고 CC 부분에 해당 메일을 참고해야 하는 관리자나 개발자의 메일 주소를 적고 실제로 전송한다.\n\nSMTP 서버를 이용해서 Patch를 보낼 수도 있다. 먼저 SMTP 서버를 설정해야 한다. git config 명령으로 하나씩 설정할 수도 있지만 아래와 같이 ~/.gitconfig 파일의 sendemail 섹션을 손으로 직접 고쳐도 된다.\n\n이렇게 설정하면 git send-email 명령으로 패치를 보낼 수 있다.\n\n명령을 실행하면 아래와 같이 서버로 Patch를 보내는 내용이 화면에 나타난다.",
        "code_examples": [
          "```bash\n[imap]\n  folder = \"[Gmail]/Drafts\"\n  host = imaps://imap.gmail.com\n  user = user@gmail.com\n  pass = YX]8g76G_2^sFbd\n  port = 993\n  sslverify = false\n```",
          "```bash\n[sendemail]\n  smtpencryption = tls\n  smtpserver = smtp.gmail.com\n  smtpuser = user@gmail.com\n  smtpserverport = 587\n```"
        ],
        "usage_examples": [
          "```bash\n$ git checkout -b topicA\n  ... work ...\n$ git commit\n  ... work ...\n$ git commit\n```",
          "```bash\n$ git format-patch -M origin/master\n0001-add-limit-to-log-function.patch\n0002-changed-log-output-to-30-from-25.patch\n```",
          "```bash\n$ cat 0001-add-limit-to-log-function.patch\nFrom 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001\nFrom: Jessica Smith <jessica@example.com>\nDate: Sun, 6 Apr 2008 10:17:23 -0700\nSubject: [PATCH 1/2] add limit to log function\n\nLimit log functionality to the first 20\n\n---\n lib/simplegit.rb |    2 +-\n 1 files changed, 1 insertions(+), 1 deletions(-)\n\ndiff --git a/lib/simplegit.rb b/lib/simplegit.rb\nindex 76f47bc..f9815f1 100644\n--- a/lib/simplegit.rb\n+++ b/lib/simplegit.rb\n@@ -14,7 +14,7 @@ class SimpleGit\n   end\n\n   def log(treeish = 'master')\n-    command(\"git log #{treeish}\")\n+    command(\"git log -n 20 #{treeish}\")\n   end\n\n   def ls_tree(treeish = 'master')\n--\n2.1.0\n```",
          "```bash\n$ cat *.patch |git imap-send\nResolving imap.gmail.com... ok\nConnecting to [74.125.142.109]:993... ok\nLogging in...\nsending 2 messages\n100% (2/2) done\n```",
          "```bash\n$ git send-email *.patch\n0001-added-limit-to-log-function.patch\n0002-changed-log-output-to-30-from-25.patch\nWho should the emails appear to be from? [Jessica Smith <jessica@example.com>]\nEmails will be sent from: Jessica Smith <jessica@example.com>\nWho should the emails be sent to? jessica@example.com\nMessage-ID to be used as In-Reply-To for the first email? y\n```",
          "```bash\n(mbox) Adding cc: Jessica Smith <jessica@example.com> from\n  \\line 'From: Jessica Smith <jessica@example.com>'\nOK. Log says:\nSendmail: /usr/sbin/sendmail -i jessica@example.com\nFrom: Jessica Smith <jessica@example.com>\nTo: jessica@example.com\nSubject: [PATCH 1/2] added limit to log function\nDate: Sat, 30 May 2009 13:29:15 -0700\nMessage-Id: <1243715356-61726-1-git-send-email-jessica@example.com>\nX-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty\nIn-Reply-To: <y>\nReferences: <y>\n\nResult: OK\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 12,
          "content_length": 1726
        }
      },
      {
        "header": "요약",
        "content": "이번 절에서는 다양한 워크플로에 따라 Git을 어떻게 사용하는지 살펴보고 그에 필요한 도구들을 설명했다. 다음 절에서는 동전의 뒷면인 프로젝트를 운영하는 방법에 대하여 살펴본다. 즉 친절한 Dictator나 Integration-Manager가 되어 보는 것이다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 147
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/분산-환경에서의-Git-프로젝트에-기여하기",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "5.3 분산 환경에서의 Git - 프로젝트 관리하기",
    "summary": "프로젝트 관리하기 효율적으로 기여하는 방법뿐만 아니라 효율적으로 운영하는 방법도 알아야 한다. 언젠가는 단순히 프로젝트에 기여하는 것이 아니라 프로젝트를 직접 운영해야 할 수도 있다. 프로젝트를 운영하는 것은 크게 두 가지로 이루어진다. 하나는 format-patch 명령으로 생성한 Patch를 이메일로 받아서 프로젝트에 Patch를 적용하는 것이다. 다른 하나는 프로젝트의 다른 리모트 저장소로부터 변경 내용을 Merge 하는 것이다. 저장소를 아주 깔끔하고 정돈된 상태로 운영하고 Patch를 적용하거나 수정사항을 확인하기 쉬운 상태로 유지하려면 좋은 운영 방식을 터득해야 한다. 좋은 운영 방식은 다른 사람들이 이해하기 쉽고 프로젝트가 오랫동안 운영돼도 흐트러짐이 없어야 한다. 토픽 브랜치에서 일하기 메인 브랜치에 통합하기 전에 임시로 토픽 브랜치를 하나 만들고 거기에 통합해 보고 나서 다시 메인 브랜치에 통합하는 것이 좋다. 이렇게 하면 Patch를 적용할 때 이리저리 수정해 보기",
    "sections": [
      {
        "header": "프로젝트 관리하기",
        "content": "효율적으로 기여하는 방법뿐만 아니라 효율적으로 운영하는 방법도 알아야 한다. 언젠가는 단순히 프로젝트에 기여하는 것이 아니라 프로젝트를 직접 운영해야 할 수도 있다. 프로젝트를 운영하는 것은 크게 두 가지로 이루어진다. 하나는 format-patch 명령으로 생성한 Patch를 이메일로 받아서 프로젝트에 Patch를 적용하는 것이다. 다른 하나는 프로젝트의 다른 리모트 저장소로부터 변경 내용을 Merge 하는 것이다. 저장소를 아주 깔끔하고 정돈된 상태로 운영하고 Patch를 적용하거나 수정사항을 확인하기 쉬운 상태로 유지하려면 좋은 운영 방식을 터득해야 한다. 좋은 운영 방식은 다른 사람들이 이해하기 쉽고 프로젝트가 오랫동안 운영돼도 흐트러짐이 없어야 한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 373
        }
      },
      {
        "header": "토픽 브랜치에서 일하기",
        "content": "메인 브랜치에 통합하기 전에 임시로 토픽 브랜치를 하나 만들고 거기에 통합해 보고 나서 다시 메인 브랜치에 통합하는 것이 좋다. 이렇게 하면 Patch를 적용할 때 이리저리 수정해 보기도 하고 좀 더 고민해 봐야 하면 Patch를 적용해둔 채로 나중으로 미룰 수도 있다. 무슨 Patch인지 브랜치 이름에 간단히 적어주면 다른 작업을 하다가 나중에 이 브랜치로 돌아왔을 때 기억해내기 훨씬 수월하다. 프로젝트 관리자라면 이런 토픽 브랜치의 이름을 잘 지어야 한다. 예를 들어 sc 라는 사람이 작업한 Patch라면 sc/ruby_client 처럼 앞에 닉네임을 붙여서 브랜치를 만들 수 있다. master 브랜치에서 새 토픽 브랜치를 아래와 같이 만든다.\n\ncheckout -b 명령으로 브랜치를 만들고 Checkout까지 한 번에 할 수 있다.\n\n이렇게 토픽 브랜치를 만들고 받은 Patch를 적용해보고 적용한 내용을 다시 Long-Running 브랜치로 Merge 한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git branch sc/ruby_client master\n```",
          "```bash\n$ git checkout -b sc/ruby_client master\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 489
        }
      },
      {
        "header": "이메일로 받은 Patch를 적용하기",
        "content": "이메일로 받은 Patch를 프로젝트에 적용하기 전에 우선 토픽 브랜치에 Patch를 적용한다. Patch를 적용하는 방법은 git apply 명령을 사용하는 것과 git am 명령을 사용하는 것 두 가지가 있다.\n\ngit diff 나 Unix의 diff 명령(다음 절에서 다루겠지만 추천하지 않는 방법)으로 만든 Patch 파일을 적용할 때는 git apply 명령을 사용한다. Patch 파일이 /tmp/patch-ruby-client.patch 라고 하면 아래와 같은 명령으로 Patch를 적용할 수 있다.\n\n위 명령을 실행하면 Patch 파일 내용에 따라 현재 디렉토리의 파일들을 변경한다. 위 명령은 patch -p1 명령과 거의 같다. 하지만, 이 명령이 patch 명령보다 훨씬 더 꼼꼼하게 비교한다. git diff 로 생성한 Patch 파일에 파일을 추가하거나, 파일을 삭제하고, 파일의 이름을 변경하는 내용이 들어 있으면 그대로 적용된다. 이런 것은 patch 명령으로 할 수 없다. 그리고 git apply 는 “모두 적용, 아니면 모두 취소” 모델을 사용하기 때문에 Patch를 적용하는 데 실패하면 Patch를 적용하기 이전 상태로 전부 되돌려 놓는다. patch 명령은 여러 파일에 적용하다가 중간에 실패하면 거기서 그대로 중단하기 때문에 깔끔하지 못하다. git apply 는 patch 명령보다 훨씬 보수적이다. 이 명령은 자동으로 커밋해 주지 않기 때문에 변경된 파일을 직접 Staging Area에 추가하고 커밋해야 한다.\n\n실제로 Patch를 적용하기 전에 Patch가 잘 적용되는지 한 번 시험해보려면 git apply --check 명령을 사용한다.\n\n화면에 아무 내용도 뜨지 않으면 Patch가 깔끔하게 적용됐다는 것이다. 이 명령은 Patch를 적용해 보고 에러가 발생하면 0이 아닌 값을 반환하기 때문에 쉘 스크립트에서도 사용할 수 있다.\n\n프로젝트 기여자가 Git의 format-patch 명령을 잘 사용하면 관리자의 작업은 훨씬 쉬워진다. format-patch 명령으로 만든 Patch 파일은 기여자의 정보와 커밋 정보가 포함되어 있기 때문이다. 그래서 기여자가 diff보다 format-patch를 사용하도록 권해야 한다. git apply 는 기존 Patch 파일에만 사용한다.\n\nformat-patch 명령으로 생성한 Patch 파일은 git am 명령으로 적용한다(am 은 \"apply a series of patches from a mailbox\"의 약자다). git am 은 mbox 파일을 읽어 그 안에 이메일 메시지가 한 개가 있든 여러 개가 있든 처리할 수 있다. mbox 파일은 간단한 텍스트 파일이고 그 내용은 아래와 같다.\n\n이 내용은 format-patch 명령으로 생성한 파일의 앞부분이다. 이 파일은 mbox 이메일 형식이다. 받은 메일이 git send-email 로 만든 메일이라면 mbox 형식으로 저장하고 이 mbox 파일을 git am 명령으로 적용한다. 사용하는 메일 클라이언트가 여러 이메일을 mbox 파일 하나로 저장할 수 있다면 메일 여러 개를 한 번에 Patch 할 수 있다.\n\n이메일로 받은 것이 아니라 git format-patch 명령으로 만든 이슈 트래킹 시스템 같은데 올라온 파일이라면 먼저 내려받고서 git am 명령으로 Patch 한다.\n\nPatch가 성공하면 자동으로 새로운 커밋이 하나 만들어진다. 이메일의 From 과 Date 에서 저자 정보가, 이메일의 제목과 메시지에서 커밋 메시지가 추출돼 사용된다. 예를 들어 위의 mbox 예제 파일을 적용해서 생성되는 커밋은 아래와 같다.\n\nCommit 부분의 커밋 정보는 누가 언제 Patch 했는지 알려 준다. Author 정보는 실제로 누가 언제 Patch 파일을 만들었는지 알려 준다.\n\nPatch에 실패할 수도 있다. 보통 Patch가 생성된 시점보다 해당 브랜치가 너무 업데이트 됐을 때나 아직 적용되지 않은 다른 Patch가 필요한 경우에 일어난다. 이러면 git am 명령은 Patch를 중단하고 사용자에게 어떻게 처리할지 물어온다.\n\n성공적으로 Patch 하지 못하면 git은 Merge 나 Rebase 의 경우처럼 문제를 일으킨 파일에 충돌 표시를 해 놓는다. Merge 나 Rebase 할 때 충돌을 해결하는 것처럼 Patch의 충돌도 해결할 수 있다. 충돌한 파일을 열어서 충돌 부분을 수정하고 나서 Staging Area에 추가하고 git am --resolved 명령을 입력한다.\n\n충돌이 났을 때 Git에게 좀 더 머리를 써서 Patch를 적용하도록 하려면 -3 옵션을 사용한다. 이 옵션은 Git에게 3-way Patch를 적용해 보라고 하는 것이다. Patch가 어느 시점에서 갈라져 나온 것인지 알 수 없기 때문에 이 옵션은 기본적으로 비활성화돼 있다. 하지만 같은 프로젝트의 커밋이라면 기본 옵션보다 훨씬 똑똑하게 충돌 상황을 해결한다.\n\n위의 경우에서 -3 옵션이 없었으면 충돌이 났을 것이다. -3 옵션이 있어서 충돌 없이 깨끗하게 Patch가 적용됐다.\n\n하나의 mbox 파일에 들어 있는 여러 Patch를 적용할 때 am 명령의 대화형 방식을 사용할 수 있다. 이 방식을 사용하면 Patch를 적용할 때마다 묻는다.\n\n이 옵션은 Patch를 여러 개 적용할 때 유용하다. 적용하려는 Patch의 내용을 미리 꼭 기억해두지 않아도 되고 적용하기 전에 이미 적용된 Patch인지 알 수 있다.\n\n모든 Patch를 토픽 브랜치에 적용하고 커밋까지 마치면 Long-Running 브랜치에 어떻게 통합할지를 결정해야 한다.",
        "code_examples": [
          "```bash\nFrom 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001\nFrom: Jessica Smith <jessica@example.com>\nDate: Sun, 6 Apr 2008 10:17:23 -0700\nSubject: [PATCH 1/2] add limit to log function\n\nLimit log functionality to the first 20\n```"
        ],
        "usage_examples": [
          "```bash\n$ git apply /tmp/patch-ruby-client.patch\n```",
          "```bash\n$ git apply --check 0001-seeing-if-this-helps-the-gem.patch\nerror: patch failed: ticgit.gemspec:1\nerror: ticgit.gemspec: patch does not apply\n```",
          "```bash\n$ git am 0001-limit-log-function.patch\nApplying: add limit to log function\n```",
          "```bash\n$ git log --pretty=fuller -1\ncommit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0\nAuthor:     Jessica Smith <jessica@example.com>\nAuthorDate: Sun Apr 6 10:17:23 2008 -0700\nCommit:     Scott Chacon <schacon@gmail.com>\nCommitDate: Thu Apr 9 09:19:06 2009 -0700\n\n   add limit to log function\n\n   Limit log functionality to the first 20\n```",
          "```bash\n$ git am 0001-seeing-if-this-helps-the-gem.patch\nApplying: seeing if this helps the gem\nerror: patch failed: ticgit.gemspec:1\nerror: ticgit.gemspec: patch does not apply\nPatch failed at 0001.\nWhen you have resolved this problem run \"git am --resolved\".\nIf you would prefer to skip this patch, instead run \"git am --skip\".\nTo restore the original branch and stop patching run \"git am --abort\".\n```",
          "```bash\n$ (fix the file)\n$ git add ticgit.gemspec\n$ git am --resolved\nApplying: seeing if this helps the gem\n```",
          "```bash\n$ git am -3 0001-seeing-if-this-helps-the-gem.patch\nApplying: seeing if this helps the gem\nerror: patch failed: ticgit.gemspec:1\nerror: ticgit.gemspec: patch does not apply\nUsing index info to reconstruct a base tree...\nFalling back to patching base and 3-way merge...\nNo changes -- Patch already applied.\n```",
          "```bash\n$ git am -3 -i mbox\nCommit Body is:\n--------------------------\nseeing if this helps the gem\n--------------------------\nApply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 18,
          "content_length": 2747
        }
      },
      {
        "header": "리모트 브랜치로부터 통합하기",
        "content": "프로젝트 기여자가 자신의 저장소를 만들고 커밋을 몇 번 하고 저장소의 URL과 변경 내용을 메일로 보내왔다면 URL을 리모트 저장소로 등록하고 Merge 할 수 있다.\n\n예를 들어 Jessica가 ruby-client 브랜치에 엄청난 기능을 만들어 놨다고 이메일을 보내왔다. 이 리모트 브랜치를 등록하고 Checkout 해서 테스트한다.\n\n나중에 Jessiaca가 이메일로 또 다른 엄청난 기능을 개발한 브랜치를 보내오면 이미 저장소를 등록했기 때문에 바로 Fetch 하고 Checkout 할 수 있다.\n\n다른 개발자들과 함께 지속적으로 개발할 때는 이 방식이 가장 사용하기 좋다. 물론 기여하는 사람이 간단한 Patch를 이따금씩만 만들어 내면 이메일로 Patch 파일을 받는 것이 낫다. 기여자가 저장소 서버를 만들어 커밋하고 관리자가 리모트 저장소로 등록해서 Patch를 합치는 작업보다 시간과 노력이 덜 든다. 물론 Patch 한 두 개를 보내는 사람들까지도 모두 리모트 저장소로 등록해서 사용해도 된다. 스크립트나 호스팅 서비스를 사용하면 좀 더 쉽게 관리할 수 있다. 어쨌든 어떤 방식이 좋을지는 우리가 어떻게 개발하고 어떻게 기여할지에 달렸다.\n\n리모트 저장소로 등록하면 커밋의 히스토리도 알 수 있다. Merge 할 때 어디서부터 커밋이 갈라졌는지 알 수 있기 때문에 -3 옵션을 주지 않아도 자동으로 3-way Merge가 적용된다.\n\n리모트 저장소로 등록하지 않고도 Merge 할 수 있다. 계속 함께 일할 개발자가 아닐 때 사용하면 좋다. 아래는 리모트 저장소로 등록하지 않고 URL을 직접 사용하여 Merge를 하는 예이다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git remote add jessica git://github.com/jessica/myproject.git\n$ git fetch jessica\n$ git checkout -b rubyclient jessica/ruby-client\n```",
          "```bash\n$ git pull https://github.com/onetimeguy/project\nFrom https://github.com/onetimeguy/project\n * branch            HEAD       -> FETCH_HEAD\nMerge made by the 'recursive' strategy.\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 809
        }
      },
      {
        "header": "무슨 내용인지 확인하기",
        "content": "기여물이 포함된 토픽 브랜치가 있으니 이제 그 기여물을 Merge 할지 말지 결정해야 한다. 이번 절에서는 메인 브랜치에 Merge 할 때 필요한 명령어를 살펴본다. 주로 토픽 브랜치를 검토하는데 필요한 명령이다.\n\n먼저 지금 작업하는 브랜치에서 master 브랜치에 속하지 않는 커밋만 살펴보는 것이 좋다. --not 옵션으로 히스토리에서 master 브랜치에 속한 커밋은 제외하고 살펴본다. 앞서 살펴본 master..contrib 형식을 사용하여 확인할 수도 있다. contrib 브랜치에 Patch를 두 개 Merge 했으면 아래와 같은 명령어로 그 결과를 살펴볼 수 있다.\n\ngit log 명령에 -p 옵션을 주면 각 커밋에서 실제로 무슨 내용이 변경됐는지 살펴볼 수 있다. 이 옵션은 각 commit의 뒤에 diff의 내용을 출력해 준다.\n\n토픽 브랜치를 다른 브랜치에 Merge 하기 전에 어떤 부분이 변경될지 미리 살펴볼 수 있다. 이때는 색다른 명령을 사용해야 한다. 물론 아래와 같은 명령을 사용할 수도 있다.\n\n이 명령은 diff 내용을 보여주긴 하지만 잘못된 것을 보여줄 수도 있다. 토픽 브랜치에서 작업하는 동안 master 브랜치에 새로운 커밋이 추가될 수도 있다. 그렇기 때문에 기대하는 diff 결과가 아닐 수 있다. 위 명령은 토픽 브랜치의 마지막 커밋과 master 브랜치의 마지막 커밋을 비교한다. master 브랜치에 한 줄을 추가되면 토픽 브랜치에서 한 줄 삭제한 것으로 보여 준다.\n\nmaster 브랜치가 가리키는 커밋이 토픽 브랜치의 조상이라면 아무 문제 없다. 하지만, 그렇지 않은 경우라면 이 diff 도구는 토픽 브랜치에만 있는 내용은 추가하는 것이고 master 브랜치에만 있는 내용은 삭제하는 것으로 간주한다.\n\n정말 보고 싶은 것은 토픽 브랜치에 추가한 것이고 결국에는 이것을 master 브랜치에 추가하려는 것이다. 그러니까 master 브랜치와 토픽 브랜치의 공통 조상인 커밋을 찾아서 토픽 브랜치가 현재 가리키는 커밋과 비교해야 한다.\n\n아래와 같은 명령으로 공통 조상인 커밋을 찾고 이 조상 커밋에서 변경된 내용을 살펴본다.\n\n같은 내용을 명령 한 줄로 실행하면 다음과 같다.\n\n이 방법으로 원하는 결과를 얻을 수 있지만, 사용법이 불편하다. Git은 Triple-Dot 구문으로 간단하게 위와 같이 비교하는 방법을 지원한다. diff 명령을 사용할 때 두 브랜치 사이에 … 를 쓰면, 두 브랜치의 공통 조상과 브랜치의 마지막 커밋을 비교한다.\n\n이 명령은 master 브랜치와 현재 토픽 브랜치에서 달라진 것들만 보여주기 때문에 기억해두면 매우 유용하게 사용할 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git log contrib --not master\ncommit 5b6235bd297351589efc4d73316f0a68d484f118\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri Oct 24 09:53:59 2008 -0700\n\n    seeing if this helps the gem\n\ncommit 7482e0d16d04bea79d0dba8988cc78df655f16a0\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Mon Oct 22 19:38:36 2008 -0700\n\n    updated the gemspec to hopefully work better\n```",
          "```bash\n$ git diff master\n```",
          "```bash\n$ git merge-base contrib master\n36c7dba2c95e6bbb78dfa822519ecfec6e1ca649\n$ git diff 36c7db\n```",
          "```bash\n$ git diff $(git merge-base contrib master)\n```",
          "```bash\n$ git diff master...contrib\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 11,
          "content_length": 1305
        }
      },
      {
        "header": "기여물 통합하기",
        "content": "기여물을 토픽 브랜치에 다 적용하고 Long-Running 브랜치나 master 브랜치로 통합할 준비가 되었다면 이제 어떻게 해야 할까. 프로젝트를 운영하는 데 쓰는 작업 방식은 어떤 것이 있을까. 앞으로 그 예제 몇 가지를 살펴본다.\n\n바로 master 브랜치에 Merge 하는 것이 가장 간단하다. 이 워크플로에서는 master 브랜치가 안전한 코드라고 가정한다. 토픽 브랜치에서 작업을 하고 작업이 끝나면 토픽 브랜치를 검증하고 master 브랜치로 Merge 한 후 토픽 브랜치를 삭제하는 과정을 반복한다.\n\n여러 토픽 브랜치 히스토리. 처럼 ruby_client 브랜치와 php_client 브랜치가 있을 때 ,ruby_client 브랜치를 master 브랜치로 Merge 한 후 php_client 브랜치를 Merge 하면 Merge 한 후의 저장소. 같아진다.\n\n이 워크플로에서 가장 간단한 시나리오다. 프로젝트의 규모가 커지거나 코드를 더 안정적으로 관리할 때는 이렇게 쉽게 Merge 되지 않을 것이다.\n\n개발자가 많고 규모가 큰 프로젝트에서는 최소한 두 단계로 Merge 하는 것이 좋다. 살펴볼 예에서는 Long-Running 브랜치를 두 개를 유지한다. master 브랜치는 아주 안정적인 버전을 릴리즈하기 위해서 사용한다. develop 브랜치는 새로 수정된 코드를 통합할 때 사용한다. 그리고 두 브랜치를 모두 공개 저장소에 Push 한다. 우선 develop 브랜치에 토픽 브랜치(토픽 브랜치를 Merge 하기 전.)를 토픽 브랜치를 Merge 한 후. 같이 Merge 한다. 그 후에 릴리즈해도 될만한 수준이 되면 master 브랜치를 develop 브랜치까지 Fast-forward시킨다(토픽 브랜치를 릴리즈한 후.).\n\n이 워크플로를 사용하면 프로젝트 저장소를 Clone 하고 나서 개발자가 안정 버전이 필요하면 master 브랜치를 빌드하고 안정적이지 않더라도 좀 더 최신 버전이 필요하면 develop 브랜치를 Checkout 하여 빌드한다. 이 개념을 좀 더 확장해서 사용할 수 있다. 토픽 브랜치를 검증하기 위한 integrate 브랜치를 만들어 Merge 하고 토픽 브랜치가 검증되면 develop 브랜치에 Merge 한다. 그리고 develop 브랜치에서 충분히 안정하다는 것이 증명되면 그때 master 브랜치에 Fast-forward Merge 한다.\n\nGit을 개발하는 프로젝트는 Long-Running의 브랜치를 4개 운영한다. 각 브랜치 이름은 master, next, pu (Proposed Updates), maint 이다. maint 는 마지막으로 릴리즈한 버전을 지원하는 브랜치다. 기여자가 새로운 기능을 제안하면 관리자는 토픽 브랜치를 동시에 여러 개 관리하는 것은 복잡하다. 처럼 자신의 저장소에 토픽 브랜치를 만들어 관리한다. 그리고 토픽에 부족한 점은 없는지, 안정적인지 계속 테스트한다. 안정화되면 next 로 Merge 하고 저장소에 Push 한다. 그러면 모두가 잘 통합됐는지 확인할 수 있다.\n\n토픽 브랜치가 좀 더 개선돼야 하면 next 가 아니라 pu 에 Merge 한다. 충분히 검증을 했을 때에만 master 브랜치로 Merge 한다. master 브랜치에 Merge하고 나면 next 브랜치와 pu 브랜치는 master 브랜치를 기반으로 다시 만든다. 즉 next 브랜치는 정말 가끔 Rebase 하고 pu 는 자주 Rebase 하지만 master 는 항상 Fast-forward 한다.\n\n토픽 브랜치가 결국 master 브랜치로 Merge 되면 저장소에서 삭제한다. 그리고 이전 릴리즈 버전에 Patch가 필요하면 maint 브랜치를 이용해 대응한다. Git을 개발하는 프로젝트를 Clone 하면 브랜치가 4개 있고 각 브랜치를 이용하여 진행사항을 확인해볼 수 있다. 그래서 새로운 기능을 추가하려면 적당한 브랜치를 보고 고른다. 이 워크플로는 잘 구조화돼 있어서 코드가 새로 추가돼도 테스트하기 쉽다. 이 Git 프로젝트의 워크플로는 끝판왕이다. 완벽하게 이해하려면 Git 관리자 가이드를 봐야 한다.\n\n히스토리를 한 줄로 관리하려고 Merge 보다 Rebase 나 Cherry-Pick을 더 선호하는 관리자들도 있다. 토픽 브랜치에서 작업을 마친 후 master 브랜치에 Merge 할 때 master 브랜치를 기반으로 Rebase 한다. 그러면 커밋이 다시 만들어 진다. master 대신 develop 등의 브랜치에도 가능하다. 문제가 없으면 master 브랜치를 Fast-forward시킨다. 이렇게 히스토리를 한 줄로 유지할 수 있다.\n\n한 브랜치에서 다른 브랜치로 작업한 내용을 옮기는 또 다른 방식으로 Cherry-pick이란 것도 있다. Git의 Cherry-pick은 커밋 하나만 Rebase 하는 것이다. 커밋 하나로 Patch 내용을 만들어 현재 브랜치에 적용을 하는 것이다. 토픽 브랜치에 있는 커밋 중에서 하나만 고르거나 토픽 브랜치에 커밋이 하나밖에 없을 때 Rebase 보다 유용하다. 아래와 같은 예를 들어보자.\n\ne43a6 커밋 하나만 master 브랜치에 적용하려면 아래와 같은 명령을 실행한다.\n\n위 명령을 실행하면 e43a6 커밋에서 변경된 내용을 현재 브랜치에 똑같이 적용을 한다. 하지만, 변경을 적용한 시점이 다르므로 새 커밋의 SHA-1 해시값은 달라진다. 명령을 실행하고 나면 아래와 같이 된다.\n\nRebase 나 Cherry-pick 방식으로 토픽 브랜치를 합치고 나면 필요없는 토픽 브랜치나 커밋은 삭제한다.\n\n수시로 Merge 나 Rebase를 한다거나 오랫동안 유지되는 토픽브랜치를 쓰는 사람에게 유용한 “rerere” 기능이 있다.\n\nRerere의 뜻은 “reuse recorded resolution”(충돌 해결방법 재사용)으로 수작업으로 충돌 해결하던 것을 쉽게 해준다. rerere 기능이 활성화 돼 있으면 Merge가 성공할 때 마다 그 이전과 이후 상태를 저장해둔다. 나중에 충돌이 발생하면 비슷한 상황에서 Merge가 성공한 적이 있었는지 찾아보고 해결이 가능하다면 자동으로 해결한다.\n\nRerere 기능의 동작은 두 부분으로 나누어 볼 수 있다. Rerere 기능을 설정하는 부분과 Rerere 기능을 명령으로 사용하는 부분이다. 설정은 rerere.enabled 값을 설정하면 되는데 글로벌 설정에 저장해 두고 사용하면 편하다.\n\n이제부터 Merge가 성공할 때 마다 전후 상황을 기록해두고 나중에 충돌이 나면 사용할 수 있게 됐다.\n\n필요하다면 git rerere 명령을 사용하여 저장된 캐시를 바탕으로 대화형 인터페이스를 통해 충돌을 다룰 수도 있다. git rerere 명령을 직접 실행하면 현재 Merge 과정에서 발생한 충돌을 해결하는데 참고할 만한 이전 Merge 기록을 찾아준다(rerere.enabled 옵션이 켜져 있다면 자동). Rerere 기능을 사용할 때 기록할 내용을 세세하게 설정하거나, 기록된 내용 중에 특정 기록을 지운다거나 하는 보조 명령도 제공한다. 자세한 내용은 Rerere 에서 다루기로 한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git cherry-pick e43a6\nFinished one cherry-pick.\n[master]: created a0a41a9: \"More friendly message when locking the index fails.\"\n 3 files changed, 17 insertions(+), 3 deletions(-)\n```",
          "```bash\n$ git config --global rerere.enabled true\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 19,
          "content_length": 3462
        }
      },
      {
        "header": "릴리즈 버전에 태그 달기",
        "content": "적당한 때가 되면 릴리즈해야 한다. 그리고 언제든지 그 시점으로 되돌릴 수 있게 태그를 다는 것이 좋다. Git의 기초에서 살펴본 대로 태그를 달면 된다. 서명된 태그를 달면 아래와 같이 출력된다.\n\n태그에 서명하면 서명에 사용한 PGP 공개키도 배포해야 한다. Git 개발 프로젝트는 관리자의 PGP 공개키를 Blob 형식으로 Git 저장소에 함께 배포한다. 이 Blob 파일을 사용하여 태그에 서명했다. gpg --list-keys 명령으로 어떤 PGP 공개키를 포함할지 확인한다.\n\ngit hash-object 라는 명령으로 공개키를 바로 Git 저장소에 넣을 수 있다. 이 명령은 Git 저장소 안에 Blob 형식으로 공개키를 저장해주고 그 Blob의 SHA-1 값을 알려준다.\n\nhash-object 명령으로 구한 SHA-1 해시값으로 PGP 공개키를 가리키는 태그를 만든다.\n\ngit push --tags 명령으로 앞서 만든 maintainer-pgp-pub 태그를 공유한다. 다른 사람이 태그의 서명을 확인하려면 우선 Git 저장소에 저장된 PGP 공개키를 꺼내서 GPG키 데이터베이스에 저장해야 한다.\n\n사람들은 이렇게 공개키를 얻어서 서명된 태그를 확인한다. 또한, 관리자가 태그 메시지에 서명을 확인하는 방법을 적어 놓으면 좋다. git show <tag> 으로 어떻게 서명된 태그를 확인하는지 설명한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git tag -s v1.5 -m 'my signed 1.5 tag'\nYou need a passphrase to unlock the secret key for\nuser: \"Scott Chacon <schacon@gmail.com>\"\n1024-bit DSA key, ID F721C45A, created 2009-02-09\n```",
          "```bash\n$ gpg --list-keys\n/Users/schacon/.gnupg/pubring.gpg\n---------------------------------\npub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]\nuid                  Scott Chacon <schacon@gmail.com>\nsub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]\n```",
          "```bash\n$ gpg -a --export F721C45A | git hash-object -w --stdin\n659ef797d181633c87ec71ac3f9ba29fe5775b92\n```",
          "```bash\n$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92\n```",
          "```bash\n$ git show maintainer-pgp-pub | gpg --import\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 684
        }
      },
      {
        "header": "빌드넘버 만들기",
        "content": "Git은 'v123' 처럼 숫자 형태로 커밋 이름을 만들지 않기 때문에 사람이 기억하기 어렵다. 하지만 git describe 명령으로 좀 더 사람이 기억하기 쉬운 이름을 얻을 수 있다. Git은 가장 가까운 태그의 이름과, 태그에서 얼마나 더 커밋이 쌓였는지, 그리고 해당 커밋의 SHA-1 값을 조금 가져다가 이름을 만든다.\n\n이렇게 사람이 읽을 수 있는 이름으로 스냅샷이나 빌드를 만든다. 만약 저장소에서 Clone 한 후 소스코드로 Git을 설치하면 git --version 명령은 이렇게 생긴 빌드넘버를 보여준다. 태그가 달린 커밋에 git describe 명령을 사용하면 다른 정보 없이 태그 이름만 사용한다.\n\ngit describe 명령은 -a 나 -s 옵션을 주고 만든 Annotated 태그가 필요하다. 릴리즈 태그는 git describe 명령으로 만드니까 꼭 이름이 적당한지 사전에 확인해야 한다. 그리고 이 값은 checkout이나 show 명령에도 사용할 수 있지만, 전적으로 이름 뒤에 붙은 SHA-1 값을 사용한다. 그래서 이 값으로는 해당 커밋을 못 찾을 수도 있다. 최근 Linux 커널은 충돌 때문에 축약된 SHA-1가 8자에서 10자로 늘어났다. 이제는 8자일 때 생성한 값은 사용할 수 없다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git describe master\nv1.6.2-rc1-20-g8c5b85c\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 632
        }
      },
      {
        "header": "릴리즈 준비하기",
        "content": "배포할 릴리즈 버전이 준비되었다. 먼저 Git을 사용하지 않는 사람을 위해 소스코드 스냅샷을 압축한다. 쉽게 압축할 수 있도록 Git은 git archive 명령을 지원한다.\n\n이 압축 파일을 풀면 프로젝트의 가장 마지막 스냅샷이 나온다. ZIP 형식으로 압축 파일을 만들려면 --format=zip 옵션을 사용한다.\n\n이렇게 압축한 스냅샷 파일은 웹사이트나 이메일로 사람들에게 배포할 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz\n$ ls *.tar.gz\nv1.6.2-rc1-20-g8c5b85c.tar.gz\n```",
          "```bash\n$ git archive master --prefix='project/' --format=zip > `git describe master`.zip\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 221
        }
      },
      {
        "header": "Shortlog 보기",
        "content": "이메일로 프로젝트의 변경 사항을 사람들에게 알려야 할 때, git shortlog 명령을 사용하면 지난 릴리즈 이후의 변경 사항 목록을 쉽게 얻어올 수 있다. git shortlog 명령은 주어진 범위에 있는 커밋을 요약해준다. 아래는 최근 릴리즈 버전인 v1.0.1 이후의 커밋을 요약해 주는 예제이다.\n\n이렇게 v1.0.1 이후 변경 내용을 Author를 기준으로 정리한 커밋을 이메일로 전송한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git shortlog --no-merges master --not v1.0.1\nChris Wanstrath (8):\n      Add support for annotated tags to Grit::Tag\n      Add packed-refs annotated tag support.\n      Add Grit::Commit#to_patch\n      Update version and History.txt\n      Remove stray `puts`\n      Make ls_tree ignore nils\n\nTom Preston-Werner (4):\n      fix dates in history\n      dynamic version method\n      Version bump to 1.0.2\n      Regenerated gemspec for version 1.0.2\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 224
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/분산-환경에서의-Git-프로젝트-관리하기",
    "doc_type": "git",
    "total_sections": 10
  },
  {
    "title": "6.1 GitHub - 계정 만들고 설정하기",
    "summary": "GitHub은 가장 큰 Git 저장소 호스트이다. 수백만 개발자가 모여서 수백만 프로젝트를 수행하는 중추다. Git 저장소를 GitHub에 만들어 운영하는 비율이 높다. 많은 오픈 소스 프로젝트는 GitHub을 이용해서 Git 호스팅, 이슈 트래킹, 코드 리뷰, 등등의 일을 한다. Git을 많이 사용하다 보면 Git 프로젝트 자체에는 참여하지 않더라도 GitHub을 꼭 써야 하는 상황이 오거나 스스로 쓰고 싶어질 것이다.이 장은 GitHub을 잘 쓰는 방법을 설명한다. 계정을 생성해서 관리하는 방법, Git 저장소를 만들고 사용하는 방법, 프로젝트에 기여하거나 다른 사람의 기여를 받아들이는 방법, 프로그래밍 가능한 GitHub 인터페이스, 각종 팁으로 삶을 편하게 만드는 방법을 살펴본다.프로젝트를 GitHub에 만들 생각이 없거나 GitHub에 있는 프로젝트에 참여할 생각이 없으면 그냥 Git 도구로 넘어가도 된다. 계정 만들고 설정하기 가장 먼저 할 일은 무료 사용자 계정을 만드는",
    "sections": [
      {
        "header": "",
        "content": "GitHub은 가장 큰 Git 저장소 호스트이다. 수백만 개발자가 모여서 수백만 프로젝트를 수행하는 중추다. Git 저장소를 GitHub에 만들어 운영하는 비율이 높다. 많은 오픈 소스 프로젝트는 GitHub을 이용해서 Git 호스팅, 이슈 트래킹, 코드 리뷰, 등등의 일을 한다. Git을 많이 사용하다 보면 Git 프로젝트 자체에는 참여하지 않더라도 GitHub을 꼭 써야 하는 상황이 오거나 스스로 쓰고 싶어질 것이다.\n\n이 장은 GitHub을 잘 쓰는 방법을 설명한다. 계정을 생성해서 관리하는 방법, Git 저장소를 만들고 사용하는 방법, 프로젝트에 기여하거나 다른 사람의 기여를 받아들이는 방법, 프로그래밍 가능한 GitHub 인터페이스, 각종 팁으로 삶을 편하게 만드는 방법을 살펴본다.\n\n프로젝트를 GitHub에 만들 생각이 없거나 GitHub에 있는 프로젝트에 참여할 생각이 없으면 그냥 Git 도구로 넘어가도 된다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 466
        }
      },
      {
        "header": "계정 만들고 설정하기",
        "content": "가장 먼저 할 일은 무료 사용자 계정을 만드는 일이다. https://github.com에 방문해서 사용자이름과 이메일 주소, 암호를 입력하고 “Sign up for GitHub” 이라는 큰 녹색 버튼을 누른다.\n\n다음 보이는 화면은 유료 옵션에 대한 안내 페이지인데, 지금은 무시한다. GitHub는 입력한 이메일 주소로 확인 메일을 보냈을 것이다. 메일의 지시를 따르자. 나중에 살펴볼 테지만 이 과정은 매우 중요하다.\n\n무료 계정도 GitHub 기능을 전부 사용할 수 있다. 딱 한 가지 제약이 있는데 모든 사람이 읽을 수 있는 공개 프로젝트만 만들 수 있다. GitHub에 돈을 내면 비공개 프로젝트도 만들 수 있지만, 이 책에서 설명하지 않는다.\n\n화면 왼쪽 꼭대기에 있는 Octocat 로고를 클릭하면 대시보드 페이지로 이동한다. 이제 GitHub을 사용할 준비가 된 것이다.\n\n노트 | 무료 계정도 GitHub 기능을 전부 사용할 수 있다. 딱 한 가지 제약이 있는데 모든 사람이 읽을 수 있는 공개 프로젝트만 만들 수 있다. GitHub에 돈을 내면 비공개 프로젝트도 만들 수 있지만, 이 책에서 설명하지 않는다.\n\n[Note] 노트 무료 계정도 GitHub 기능을 전부 사용할 수 있다. 딱 한 가지 제약이 있는데 모든 사람이 읽을 수 있는 공개 프로젝트만 만들 수 있다. GitHub에 돈을 내면 비공개 프로젝트도 만들 수 있지만, 이 책에서 설명하지 않는다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 4,
          "content_length": 715
        }
      },
      {
        "header": "SSH 사용하기",
        "content": "이제는 https:// 프로토콜로도 Git 저장소를 사용하는 데 부족함이 없다. 간단히 사용자이름과 암호로 인증만 하면 된다. 공개 프로젝트를 Clone 하는 데는 인증도 필요 없다. 우리가 만든 계정은 프로젝트를 Fork 하고 그 프로젝트에 Push 할 때가 돼야 비로소 필요하다.\n\nSSH 리모트를 쓰려면 공개키를 설정해야 한다. (아직 공개키가 없으면 SSH 공개키 만들기를 참고) 아래 Windows의 오른쪽 꼭대기에 있는 계정 설정 링크를 클릭하자.\n\n그 왼쪽 메뉴에서 “SSH keys” 를 선택한다.\n\n여기서 “Add an SSH key” 버튼을 클릭한다. 키 이름을 적당히 입력하고 ~/.ssh/id_rsa.pub 파일의 내용을 입력 칸에 복사해 넣는다. 그리고 “Add key” 버튼을 클릭한다.\n\nSSH key 이름은 기억하기 쉬운 걸로 짓는다. \"내 노트북\"이나 \"회사 계정\"같이 구분하기 쉬운 이름으로 짓는다. 나중에 키를 삭제할 때 헷갈리지 않고 바로 알 수 있도록 짓는 것이 중요하다.\n\n노트 | SSH key 이름은 기억하기 쉬운 걸로 짓는다. \"내 노트북\"이나 \"회사 계정\"같이 구분하기 쉬운 이름으로 짓는다. 나중에 키를 삭제할 때 헷갈리지 않고 바로 알 수 있도록 짓는 것이 중요하다.\n\n[Note] 노트 SSH key 이름은 기억하기 쉬운 걸로 짓는다. \"내 노트북\"이나 \"회사 계정\"같이 구분하기 쉬운 이름으로 짓는다. 나중에 키를 삭제할 때 헷갈리지 않고 바로 알 수 있도록 짓는 것이 중요하다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 5,
          "content_length": 746
        }
      },
      {
        "header": "아바타",
        "content": "자동으로 생성해준 아바타를 다른 아바타로 바꿀 수도 있다. “SSh Keys” 탭 위에 있는 “Profile” 탭으로 가서 “Upload new picture” 를 클릭한다.\n\n여기서는 여러분의 하드디스크에 있을 Git 로고를 선택하고 필요한 만큼 자른다.\n\n이제부터 GitHub 사이트에서 어디에서든 사용자이름 옆에 아바타가 보인다.\n\nGravatar 서비스에 아바타를 업로드 한 적이 있으면 자동으로 그 아바타가 사용되고 지금 이 단계를 밟을 필요가 없다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 257
        }
      },
      {
        "header": "사용자 이메일 주소",
        "content": "GitHub는 Git 커밋에 있는 이메일 주소를 보고 어떤 사용자인지 식별한다. 사용자가 이메일 주소를 여러 개 사용해서 커밋했어도 GitHub에 그 이메일을 모두 등록하기만 했으면 GitHub는 잘 처리한다. “Emails” 화면에서 모두 등록한다.\n\n이메일 주소 추가하기.의 이메일 주소는 각각 다른 상태다. 첫 번째 주소는 이미 확인을 한 주(Primary) 주소이다. 알림이나 영수증 메일은 주 주소로 간다. 두 번째 주소도 확인한 주소로 주 주소로 변경 할 수 있는 상태다. 마지막 주소는 아직 확인이 안되어 주 주소로 변경할 수 없다. 저장소의 커밋 메시지에 이 주소 세 개 중 하나라도 있으면 GitHub가 해당 사용자 계정 페이지로 링크를 걸어준다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 371
        }
      },
      {
        "header": "투팩터 인증",
        "content": "더 안전한 보안을 위해서 “2FA”(투팩터 인증)을 설정한다. 2FA는 최근 들어 인기가 높아지는 인증 메커니즘이다. 암호를 도둑맞았을 때 위험을 완화하기 위해 사용한다. 2FA를 활성화 시키면 GitHub에 로그인 할 때 인증수단이 두 가지 필요하다(역주 - 기존 로그인 방식에 OTP나 SMS를 추가). 둘 중 한 가지 방법만 뚫려서는 공격자가 계정에 접근할 수 없다.\n\n2FA 설정 화면은 계정 설정 페이지의 Security 탭에 있다.\n\n“Set up two-factor authentication” 버튼을 클릭하면 2FA 설정 페이지로 이동한다. “TOTP(Time based One-Time 암호” 를 생성하는 스마트폰 앱을 사용하는 방식을 고르거나 GitHub가 인증 코드를 SMS로 전송해주는 방식을 고를 수 있다. 설정하면 로그인할 때 TOTP나 인증코드가 필요하다.\n\n마음에 드는 인증 방법을 고르고 지시에 따라 2FA를 설정한다. GitHub에 로그인할 때마다 한 가지 코드를 더 입력해야 한다. 이제 계정은 좀 더 안전해졌다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 530
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/GitHub-계정-만들고-설정하기",
    "doc_type": "git",
    "total_sections": 6
  },
  {
    "title": "6.2 GitHub - GitHub 프로젝트에 기여하기",
    "summary": "GitHub 프로젝트에 기여하기 계정은 이제 만들었으니 프로젝트에 참여하는 방법을 살펴볼 차례가 됐다. 프로젝트 Fork 하기 참여하고 싶은 프로젝트가 생기면 아마 그 프로젝트에 Push 할 권한은 없을 테니까 “Fork” 해야 한다. “Fork” 하면 GitHub이 프로젝트를 통째로 복사해준다. 그 복사본은 사용자 네임스페이스에 있고 Push 할 수도 있다. 노트 과거에는 “Fork” 가 좋은 의미로 쓰이지 않았다. 오픈 소스 프로젝트를 “Fork” 한다는 것은 복사해서 조금은 다른 프로젝트를 만드는 것을 의미했고 때때로 원래 프로젝트와 경쟁하거나 기여자를 나누는 결과를 가져오기도 했다. GitHub에서 “Fork” 는 단순히 자신의 네임스페이스로 복사하는 것을 뜻한다. 그래서 공개한 상태로 수정하고 좀 더 열린 방식으로 참여할 수 있다. 이 방식에서는 사람들을 프로젝트에 추가하고 Push 권한을 줘야 할 필요가 없다. 사람들은 프로젝트를 “Fork” 해서 Push 한다. 그리고 ",
    "sections": [
      {
        "header": "GitHub 프로젝트에 기여하기",
        "content": "계정은 이제 만들었으니 프로젝트에 참여하는 방법을 살펴볼 차례가 됐다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 39
        }
      },
      {
        "header": "프로젝트 Fork 하기",
        "content": "참여하고 싶은 프로젝트가 생기면 아마 그 프로젝트에 Push 할 권한은 없을 테니까 “Fork” 해야 한다. “Fork” 하면 GitHub이 프로젝트를 통째로 복사해준다. 그 복사본은 사용자 네임스페이스에 있고 Push 할 수도 있다.\n\n과거에는 “Fork” 가 좋은 의미로 쓰이지 않았다. 오픈 소스 프로젝트를 “Fork” 한다는 것은 복사해서 조금은 다른 프로젝트를 만드는 것을 의미했고 때때로 원래 프로젝트와 경쟁하거나 기여자를 나누는 결과를 가져오기도 했다. GitHub에서 “Fork” 는 단순히 자신의 네임스페이스로 복사하는 것을 뜻한다. 그래서 공개한 상태로 수정하고 좀 더 열린 방식으로 참여할 수 있다.\n\n이 방식에서는 사람들을 프로젝트에 추가하고 Push 권한을 줘야 할 필요가 없다. 사람들은 프로젝트를 “Fork” 해서 Push 한다. 그리고 Push 한 변경 내용을 원래 저장소로 보내 기여한다. 이것을 Pull Request라고 부르는데 나중에 다시 설명한다. 토론 스레드를 만들고 거기서 코드 리뷰를 하면서 토론하는 스레드를 만들어 토론을 시작한다. 프로젝트 소유자 마음에 들 때까지 소유자와 기여자는 함께 토론한다. 마음에 들게 되면 Merge 한다.\n\n프로젝트는 쉽게 Fork 할 수 있다. 프로젝트 페이지를 방문해서 오른쪽 꼭대기에 있는 “Fork” 버튼을 클릭한다.\n\n몇 초안에 복사된 프로젝트 페이지로 이동한다. 이 새 프로젝트의 소유자는 Fork 한 사람 자신이기 때문에 쓰기 권한이 있다.\n\n노트 | 과거에는 “Fork” 가 좋은 의미로 쓰이지 않았다. 오픈 소스 프로젝트를 “Fork” 한다는 것은 복사해서 조금은 다른 프로젝트를 만드는 것을 의미했고 때때로 원래 프로젝트와 경쟁하거나 기여자를 나누는 결과를 가져오기도 했다. GitHub에서 “Fork” 는 단순히 자신의 네임스페이스로 복사하는 것을 뜻한다. 그래서 공개한 상태로 수정하고 좀 더 열린 방식으로 참여할 수 있다.\n\n[Note] 노트 과거에는 “Fork” 가 좋은 의미로 쓰이지 않았다. 오픈 소스 프로젝트를 “Fork” 한다는 것은 복사해서 조금은 다른 프로젝트를 만드는 것을 의미했고 때때로 원래 프로젝트와 경쟁하거나 기여자를 나누는 결과를 가져오기도 했다. GitHub에서 “Fork” 는 단순히 자신의 네임스페이스로 복사하는 것을 뜻한다. 그래서 공개한 상태로 수정하고 좀 더 열린 방식으로 참여할 수 있다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 5,
          "content_length": 1188
        }
      },
      {
        "header": "GitHub 플로우",
        "content": "GitHub은 Pull Request가 중심인 협업 워크플로를 위주로 설계됐다. 이 워크플로는 Fork 해서 프로젝트에 기여하는 것인데 단일 저장소만 사용하는 작은 팀이나 전 세계에서 흩어져서 일하는 회사, 혹은 한 번도 본 적 없는 사람들 사이에서도 유용하다. Git 브랜치 에서 설명했던 토픽 브랜치 중심으로 일하는 방식이다.\n\nmaster 기반으로 토픽 브랜치를 만든다.\n\n자신의 GitHub 프로젝트에 브랜치를 Push 한다.\n\nGitHub에 Pull Request를 생성한다.\n\n토론하면서 그에 따라 계속 커밋한다.\n\n프로젝트 소유자는 Pull Request를 Merge 하고 닫는다.\n\n이 방식은 기본적으로 Integration-Manager 워크플로에서 설명하는 Integration-Manager 워크플로와 같다. 토론이나 리뷰를 이메일이 아니라 GitHub에서 제공하는 웹 기반 도구를 사용하는 것뿐이다.\n\nGitHub에 있는 오픈소스 프로젝트에 이 워크플로를 이용해서 뭔가 기여하는 예제를 살펴보자.\n\nTony는 자신의 Arduino 장치에서 실행해볼 만한 코드를 찾고 있었고 GitHub에 있는 https://github.com/schacon/blink에서 매우 흡족한 프로그램을 찾았다.\n\n다 좋은데 너무 빠르게 깜빡이는 게 마음에 안 들었다. 매초 깜빡이는 것보다 3초에 한 번 깜빡이는 게 더 좋을 것 같았다. 그래서 프로그램을 수정하고 원 프로젝트에 다시 보내기로 했다.\n\n앞서 설명했던 것처럼 'Fork' 버튼을 클릭해서 프로젝트를 복사한다. 사용자 이름이 “tonychacon” 이라면 https://github.com/tonychacon/blink 에 프로젝트가 복사된다. 이 프로젝트는 본인 프로젝트이고 수정할 수 있다. 이 프로젝트를 로컬에 Clone 해서 토픽 브랜치를 만들고 코드를 수정하고 나서 GitHub에 다시 Push 한다.\n\nFork 한 개인 저장소를 로컬에 Clone 한다.\n\n무슨 일인지 설명이 되는 이름의 토픽 브랜치를 만든다.\n\nGitHub의 개인 저장소에 토픽 브랜치를 Push 한다.\n\nFork 한 내 저장소에 가면 GitHub은 토픽 브랜치가 하나 Push 됐다는 것을 알려주고 원 저장소에 Pull Request를 보낼 수 있는 큰 녹색 버튼을 보여준다.\n\n아니면 저장소의 “브랜치” 페이지로(https://github.com/<user>/<project>/branches) 가서 해당 브랜치의 \"New pull request\" 버튼을 이용한다.\n\n녹색 버튼을 클릭하면 Pull Request의 제목과 설명을 입력하는 화면이 보인다. 항샹 프로젝트 소유자가 판단을 내릴 수 있을 정도로 공을 들여 작성해야 한다. 왜 수정했는지 얼마나 가치 있는지 설명해서 관리자를 설득해야 한다.\n\n그리고 “ahead” 토픽 브랜치가 master 브랜치에서 달라진 커밋도 보여주고 수정된 내용을 “unified diff” 형식으로 보여준다. 이 수정 내용이 프로젝트 관리자가 Merge 할 내용이다.\n\n화면에 있는 'Create pull request' 버튼을 클릭하면 프로젝트 원소유자는 누군가 코드를 보냈다는 알림을 받는다. 그 알림에는 해당 Pull Request에 대한 모든 것을 보여주는 페이지의 링크가 들어 있다.\n\nPull Request는 보통 공개 프로젝트에서 사용한다. 기여자는 수정하고 나서 원 저장소에 Pull Request를 연다. 개발 초창기에는 프로젝트 내부에서도 많이 사용한다. 이미 Pull Request를 열어 놓은 토픽 브랜치라고 할지라도 계속 Push 할 수 있다. 마지막이 아니라 처음부터 Pull Request를 열면 어떤 주제를 가지고 팀 동료와 함께 토론할 수 있어서 좋다.\n\nPull Request가 오면 프로젝트 소유자는 변경 점이 무엇인지 확인한 후, Merge 혹은 거절하거나 코멘트를 달 수 있다. 소유자가 아이디어 자체를 마음에 들어 한다면 빛을 보기까지 좀 더 공을 들여야 한다.\n\n이런 소통을 이메일로 하는 워크플로는 분산 환경에서의 Git에 설명했었다. GitHub에서는 온라인에서 한다. 프로젝트 소유자는 'unified diff' 형식의 변경사항을 검토하고 즉각 해당 라인에 코멘트를 달 수 있다.\n\n관리자가 코멘트를 달면 Pull Request를 만든 사람에게 알림이 간다. 실제로는 저장소를 'Watch’하는 사람 모두에게 알림이 간다. 알림 정책은 설정할 수 있지만, 다음에 검토한다. 알림을 받는 Tony가 이메일 알림을 켜놨다면 이메일 알림도 받는다.\n\n누구나 Pull Request에 코멘트를 달 수 있다. Pull Request 토론 페이지를 보면 프로젝트 소유자가 코드에 코멘트를 달거나 Pull Request 자체에 코멘트를 달면서 토론하는 것을 보여 준다. 코드 코멘트도 맥락을 이루어 커뮤니케이션 할 수 있다.\n\n이 토론을 보고 기여자는 자신이 무엇을 해야 자신의 코드가 받아들여질지 알 수 있다. 다행히 매우 직관적이다. 만약 이 일을 이메일로 하고자 한다면 관련 커밋을 다시 말아서 메일링 리스트에 다시 보내야 한다. 하지만, GitHub에서는 해당 토픽 브랜치에 이어서 커밋하고 Push 하면 된다. 최종 Pull Request에서 Push로 업데이트한 PR의 코드를 보면 예전 코드에 달렸던 코멘트는 나오지 않는다. 추가된 커밋으로 인해 코드가 수정되었기 때문이다.\n\n기존 PR에 이어서 Push를 하면 알림이 가지 않는다. 그래서 Tony는 자신이 작업한 내용을 코멘트로 남겼다. 그러면 프로젝트 소유자는 무슨 일이 있었는지 쉽게 알 수 있다.\n\n꼭 짚고 넘어가야 할 것이 있다. 이 Pull Request의 “Files Changed” 탭을 클릭하면 “unified” diff를 볼 수 있다. 이 Pull Request가 주 브랜치에 Merge 되면 어떻게 달라지는지 보여준다. git diff 명령을 빌어 표현하자면 git diff master…<branch> 와 같은 명령이 실행되는 거고 <branch> 는 Pull Request의 브랜치를 의미한다. 무슨 내용인지 확인하기에서 자세히 설명한다.\n\n그 외 알아두면 좋은 것은 GitHub은 Pull Request가 Merge 될 수 있는지 검사해서 서버에서 Merge 할 수 있도록 Merge 버튼을 제공한다. 이 버튼은 저장소에 쓰기 권한이 있는 사람만 볼 수 있고 이 버튼으로 Merge 하면 Merge 커밋이 생긴다(Trivial Merge). “fast-forward” Merge가 가능할 때도 “non-fast-forwrd” 로 Merge 한다.\n\n로컬에 Pull Request 브랜치를 당겨와서 Merge 해도 된다. master 브랜치에 Merge 해서 GitHub에 Push 하면 자동으로 해당 Pull Request가 닫힌다.\n\n이런 방식이 대부분의 GitHub 프로젝트가 사용하는 기본 워크플로다. 토픽 브랜치를 만들고 Pull Request를 연다. 거기서 토론을 계속 하고 그 브랜치에 커밋을 하기도 한다. 마지막에는 Merge하고 Request를 닫는다.\n\n한 저장소의 두 브랜치를 두고도 Pull Request를 열 수 있다. 한 저장소에 쓰기 권한이 있는 동료 둘이서 어떤 기능을 추가하려고 하고 있다면 토픽 브랜치를 만들고 Push 한다. 그리고 나서 같은 저장소의 master 브랜치에 대해 Pull Request를 만들어 코드 리뷰와 토론을 시작한다. Fork는 필수가 아니다.\n\n• 프로젝트를 Fork 한다.\n• master 기반으로 토픽 브랜치를 만든다.\n• 뭔가 수정해서 커밋한다.\n• 자신의 GitHub 프로젝트에 브랜치를 Push 한다.\n• GitHub에 Pull Request를 생성한다.\n• 토론하면서 그에 따라 계속 커밋한다.\n• 프로젝트 소유자는 Pull Request를 Merge 하고 닫는다.\n\n• Fork 한 개인 저장소를 로컬에 Clone 한다.\n• 무슨 일인지 설명이 되는 이름의 토픽 브랜치를 만든다.\n• 잘 고쳤는지 확인한다.\n• 토픽 브랜치에 커밋한다.\n• GitHub의 개인 저장소에 토픽 브랜치를 Push 한다.\n\n노트 | Pull Request는 보통 공개 프로젝트에서 사용한다. 기여자는 수정하고 나서 원 저장소에 Pull Request를 연다. 개발 초창기에는 프로젝트 내부에서도 많이 사용한다. 이미 Pull Request를 열어 놓은 토픽 브랜치라고 할지라도 계속 Push 할 수 있다. 마지막이 아니라 처음부터 Pull Request를 열면 어떤 주제를 가지고 팀 동료와 함께 토론할 수 있어서 좋다.\n\n노트 | Fork는 옵션 한 저장소의 두 브랜치를 두고도 Pull Request를 열 수 있다. 한 저장소에 쓰기 권한이 있는 동료 둘이서 어떤 기능을 추가하려고 하고 있다면 토픽 브랜치를 만들고 Push 한다. 그리고 나서 같은 저장소의 master 브랜치에 대해 Pull Request를 만들어 코드 리뷰와 토론을 시작한다. Fork는 필수가 아니다.\n\n[Note] 노트 Pull Request는 보통 공개 프로젝트에서 사용한다. 기여자는 수정하고 나서 원 저장소에 Pull Request를 연다. 개발 초창기에는 프로젝트 내부에서도 많이 사용한다. 이미 Pull Request를 열어 놓은 토픽 브랜치라고 할지라도 계속 Push 할 수 있다. 마지막이 아니라 처음부터 Pull Request를 열면 어떤 주제를 가지고 팀 동료와 함께 토론할 수 있어서 좋다.\n\n[Note] 노트 Fork는 옵션 한 저장소의 두 브랜치를 두고도 Pull Request를 열 수 있다. 한 저장소에 쓰기 권한이 있는 동료 둘이서 어떤 기능을 추가하려고 하고 있다면 토픽 브랜치를 만들고 Push 한다. 그리고 나서 같은 저장소의 master 브랜치에 대해 Pull Request를 만들어 코드 리뷰와 토론을 시작한다. Fork는 필수가 아니다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git clone https://github.com/tonychacon/blink(1)Cloning into 'blink'...\n\n$ cd blink\n$ git checkout -b slow-blink(2)Switched to a new branch 'slow-blink'\n\n$ sed -i '' 's/1000/3000/' blink.ino (macOS)(3)# If you're on a Linux system, do this instead:\n# $ sed -i 's/1000/3000/' blink.ino(3)$ git diff --word-diff(4)diff --git a/blink.ino b/blink.ino\nindex 15b9911..a6cc5a5 100644\n--- a/blink.ino\n+++ b/blink.ino\n@@ -18,7 +18,7 @@ void setup() {\n// the loop routine runs over and over again forever:\nvoid loop() {\n  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)\n  [-delay(1000);-]{+delay(3000);+}               // wait for a second\n  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW\n  [-delay(1000);-]{+delay(3000);+}               // wait for a second\n}\n\n$ git commit -a -m 'three seconds is better'(5)[slow-blink 5ca509d] three seconds is better\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n$ git push origin slow-blink(6)Username for 'https://github.com': tonychacon\nPassword for 'https://tonychacon@github.com':\nCounting objects: 5, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 340 bytes | 0 bytes/s, done.\nTotal 3 (delta 1), reused 0 (delta 0)\nTo https://github.com/tonychacon/blink\n * [new branch]      slow-blink -> slow-blink\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 31,
          "content_length": 4817
        }
      },
      {
        "header": "Pull Request 팁",
        "content": "GitHub에서 프로젝트에 기여하는 방법 중 가장 기본적인 방법을 살펴봤다. Pull Request를 사용할 때 도움이 되는 유용한 팁을 몇 가지 살펴보자.\n\n보통 프로젝트에서는 Pull Request의 Patch가 완벽하고 큐처럼 꼭 순서대로 적용돼야 한다고 생각하지 않는다. 메일링 리스트를 사용하던 프로젝트에서는 Patch 순서가 의미가 있다고 생각한다. GitHub의 Pull Request는 어떤 주제를 두고 논의하는 자리다. 논의가 다 무르익으면 Merge 한다.\n\n이 차이는 매우 중요하다. 일반적으로 처음부터 완벽한 코드를 보낼 수 없어서 메일링 리스트로 Patch를 보낼 일은 별로 없다. Pull Request는 초기부터 프로젝트 관리자와 소통할 수 있도록 해주기 때문에 혼자 답을 찾는 게 아니라 커뮤니티에서 함께 찾을 수 있다. 누군가 Pull Request를 열면 관리자와 커뮤니티는 어떻게 수정하는 게 좋을지 의견을 낸다. Patch를 처음부터 다시 전체를 작성하지 않아도 된다. 수정한 만큼만 해당 브랜치에 커밋하고 하던 일과 대화를 계속 해 나가면 된다.\n\n최종 Pull Request로 돌아가서 다시 보면 기여자가 커밋을 Rebase 하거나 Pull Request를 다시 열지 않았다는 것을 확인할 수 있다. 그냥 기존 브랜치에 좀 더 커밋하고 Push 했을 뿐이다. 나중에 시간이 지나서 이 Pull Request를 다시 읽으면 왜 이런 방향으로 결정했는지에 대한 맥락을 쉽게 알 수 있다. 웹사이트에서 “Merge” 버튼을 누르면 Merge 커밋을 일부러 남기겠다는 뜻이 된다. 이 Merge 커밋에는 Pull Request 정보가 들어가기 때문에 필요하면 언제든지 맥락을 확인할 수 있다.\n\nPull Request가 만든 지 오래됐거나 깨끗하게 Merge 되지 않으면 메인테이너가 쉽게 Merge 할 수 있게 수정한다. GitHub은 자동으로 Merge 할 수 있는 Pull Request인지 아닌지 Pull Request 페이지 하단에서 알려준다.\n\n깨끗하게 Merge 할 수 없는 Pull Request 같은 메시지를 보면 해당 브랜치를 고쳐서 녹색으로 만든다. 메인테이너가 고치지 않아도 되도록 한다.\n\n이 문제를 해결하는 방법은 두 가지가 있다. 대상 브랜치(보통은 master 브랜치)를 기준으로 Rebase 하는 방법이 있고 대상 브랜치를 Pull Request 브랜치에 Merge 하는 방법이 있다.\n\nGitHub을 사용하는 개발자는 대부분 후자를 고른다. 앞서 살펴봤던 것과 같은 이유다. Rebase 하면 히스토리는 깨끗해지지만 훨씬 더 어렵고 에러 나기 쉽다.\n\nPull Request가 Merge 될 수 있도록 대상 브랜치를 Merge 하려면 먼저 원 저장소를 리모트로 추가한다. 그리고 나서 Fetch 하고 그 저장소의 대상 브랜치를 해당 토픽 브랜치에 Merge 한다. 문제를 해결하고 그 브랜치에 도로 Push 한다.\n\n“tonychacon” 예제에 이 워크플로를 적용해보자. 원저자가 뭔가 수정을 했는데 Pull Request와 충돌이 난다. 여기부터 살펴보자.\n\n원 저장소를 “upstream” 이라는 이름의 리모트로 추가한다\n\n리모트에서 최신 데이터를 Fetch 한다\n\n대상 브랜치를 토픽 브랜치에 Merge 한다\n\n동일한 토픽 브랜치에 도로 Push 한다\n\n이렇게 하면 Pull Request는 자동으로 업데이트되고 깨끗하게 Merge 할 수 있는지 재확인된다.\n\n연속성은 Git의 장기 중 하나다. 오랫동안 무엇인가 만들고 있다면 최신으로 유지하기 위해 대상 브랜치를 쉽게 Merge 해 올 수 있다. 다 마칠 때까지 하고 또 하고 할 수 있다. Merge 할 때 발생하는 충돌만 해결하면 되고 지속적으로 개발 프로세스를 관리할 수 있다.\n\n브랜치를 꼭 깨끗하게 유지하고 싶어서 Rebase 해야 한다고 생각한다면 이미 열어 놓은 Pull Request에 대고 Push 하지 말아야 한다. 그럼 이 브랜치를 가져다 Merge 해 놓은 사람들은 Rebase 의 위험성에 설명했듯이 충격에 빠질 것이다. 대신 브랜치를 새로 만들어 Push 한다. 그리고 Pull Request도 새로 여는데 원 Pull Request가 뭔지 알 수 있도록 참조를 달고 원래 것은 닫는다.\n\n그럼 바로 “어떻게 Pull Request를 참조시키지?” 라는 의문이 들겠지만, 방법은 매우 많다. GitHub에 쓰기 가능한 곳 어디에서나 참조를 달 수 있다.\n\n먼저 Issue와 Pull Request를 서로 참조시키는 방법부터 살펴보자. 모든 Pull Request와 Issue에는 프로젝트 내에서 유일한 번호를 하나 할당한다. 예를 들어, #3인 Pull Request와 #3인 Issue는 동시에 있을 수 없다. #<num> 과 같은 형태로 코멘트가나 설명에 Pull Request와 Issue를 참조시킬 수 있다. 이 방법은 단일 프로젝트 범위에서만 유효하다. Fork 저장소의 Issue나 Pull Request를 참조시키려고 한다면 username#<num> 라고 쓰고 아예 다른 저장소면 username/repo#<num> 라고 써야 한다.\n\n설명을 위해 이미 브랜치를 Rebase 했고 Pull Request를 새로 만들었다고 하자. 그럼 예전 Pull Request가 뭔지 알 수 있도록 새것에서 예전 것을 참조하게 해보고 Pull Request의 상호 참조 편집.같이 Fork 한 저장소의 이슈나 아예 다른 저장소의 이슈도 참조하게 해보자.\n\n이 Pull Request를 보내면 Pull Request의 상호 참조.처럼 보인다.\n\nGitHub URL을 전부 입력해도 딱 필요한 만큼으로 줄어든다.\n\n그리고 원래 있던 Pull Request를 닫으면 새 Pull Request에는 기존 Pull Request가 닫혔다고 언급된다. GitHub은 Pull Request 타임라인에 트랙백 이벤트를 자동으로 만든다. 그래서 이 Pull Request에 방문하는 사람은 예전 Pull Request가 닫혔는지 알 수 있고 그 링크가 있어서 바로 클릭해서 예전 것을 볼 수 있다. 이 링크는 닫은 Pull Request의 트랙백처럼 생겼다.\n\n이슈뿐만 아니라 커밋의 SHA도 참조할 수 있다. 40자 SHA를 적으면 GitHub은 자동으로 해당 커밋에 링크를 걸어 준다. Fork 저장소나 아예 다른 저장소의 커밋도 이슈와 동일한 방식으로 링크시킬 수 있다.\n\n• 원 저장소를 “upstream” 이라는 이름의 리모트로 추가한다\n• 리모트에서 최신 데이터를 Fetch 한다\n• 대상 브랜치를 토픽 브랜치에 Merge 한다\n• 동일한 토픽 브랜치에 도로 Push 한다",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git remote add upstream https://github.com/schacon/blink(1)$ git fetch upstream(2)remote: Counting objects: 3, done.\nremote: Compressing objects: 100% (3/3), done.\nUnpacking objects: 100% (3/3), done.\nremote: Total 3 (delta 0), reused 0 (delta 0)\nFrom https://github.com/schacon/blink\n * [new branch]      master     -> upstream/master\n\n$ git merge upstream/master(3)Auto-merging blink.ino\nCONFLICT (content): Merge conflict in blink.ino\nAutomatic merge failed; fix conflicts and then commit the result.\n\n$ vim blink.ino(4)$ git add blink.ino\n$ git commit\n[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \\\n    into slower-blink\n\n$ git push origin slow-blink(5)Counting objects: 6, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (6/6), done.\nWriting objects: 100% (6/6), 682 bytes | 0 bytes/s, done.\nTotal 6 (delta 2), reused 0 (delta 0)\nTo https://github.com/tonychacon/blink\n   ef4725c..3c8d735  slower-blink -> slow-blink\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 24,
          "content_length": 3258
        }
      },
      {
        "header": "GitHub Flavored Markdown",
        "content": "다른 이슈를 링크하는 것은 GitHub 글쓰기의 첫걸음에 불과하다. “GitHub Flavored Markdown” 이라는 형식으로 이슈나 Pull Request의 설명, 코멘트, 코드 주석 등에서 글을 쓸 수 있다. Markdown 형식으로 글을 쓰면 그냥 텍스트로 쓴 글이지만 형식을 갖춰 미끈하고 아름답게 렌더링된다.\n\nGitHub Flavored Markdown 예제.는 Markdown으로 쓴 글이 어떻게 렌더링되는지 보여준다.\n\nGitHub Flavored Markdown(이하 GFM)은 기본 Markdown을 확장했다. GFM은 Pull Request나 이슈 등의 글을 쓸 때 매우 유용하다.\n\nGFM이 확장한 것 기능 중 타스크 리스트가 있는데 Pull Request에서 사용하면 좋다. 간단히 말해서 타스크 리스트는 완료했다고 표시할 수 있는 체크박스의 목록이다. 이슈나 Pull Request에서 다 했다고 표기하고 싶을 때 사용한다.\n\n타스크 리스트는 아래와 같이 사용한다.:\n\n이 타스크 리스트를 이슈나 Pull Request에 사용하면 타스크 리스트.처럼 렌더링된다.\n\nPull Request를 Merge 하기 전에 꼭 처리해야 하는 일의 목록을 표현할 때 타스크 리스트를 사용한다. Markdown을 직접 고치지 않고 체크박스만 클릭해도 해당 타스크가 완료됐다고 업데이트되기 때문에 상당히 좋은 기능이다.\n\nGitHub은 이슈나 Pull Requests에 있는 타스크 리스트를 집계해서 목록 화면에서 보여준다. 예를 들어, 타스크들이 정리된 Pull Request가 있으면 Pull Request 요약 페이지에서 얼마나 진행됐는지 볼 수 있다. 그래서 Pull Request를 타스크 여러 개로 쪼개 두면 그 브랜치가 얼마나 진행됐는지 알기 쉽다. Pull Request 목록 화면에서 보여주는 타스크 현황.를 보자.\n\nPull Request부터 열어 두고 일을 하면 해당 기능이 얼마나 진행됐는지 쉽게 알 수 있다.\n\n코멘트에 코드 조각도 넣을 수 있다. 실제로 구현해서 브랜치에 커밋하기 전에 뭔가 아이디어를 코드로 표현해 볼 때 좋다. 그 외에도 단순히 코드 예제를 보여주기 위해서 사용하거나 해당 Pull Request에서 구현한 것이 무엇인지 보여줄 때도 사용한다.\n\n백틱으로 된 “Fence” 안에 코드 조각을 넣는다.\n\n코드 조각에 언어 이름을 쓰면 GitHub은 구문강조(Syntax Highlight)도 해준다. 구문강조로 미끈해진 코드.는 언어 이름을 넣어서 구문 강조된 결과다.\n\n아주 긴 글에서 딱 한 부분만 집어서 논의하고 싶을 때 > 문자로 해당 부분을 인용하고 그 밑에 코멘트를 단다. 이 방법은 매우 흔히 사용하는 방법이라, 상당히 유용하고, 단축키도 지원한다. 인용하고 싶은 텍스트를 선택하고 r 키를 누르면 바로 코멘트 상자에 해당 텍스트가 인용된다.\n\n이 텍스트는 인용 예제.처럼 렌더링된다.\n\n마지막으로 소개하는 것은 글에 Emoji를 넣을 수 있다는 것이다. Emoji는 GitHub 이슈나 Pull Request에서 정말 많이 사용된다. GitHub은 Emoji를 쉽게 사용할 수 있도록 돕는다. 코멘트를 쓸 때 : 문자로 Emoji 입력을 시작하면 선택해서 자동완성할 수 있도록 Emoji 목록을 보여준다.\n\nEmoji는 :<name>: 형식으로 생겼다. 아래 예제를 보자.\n\n렌더링되면 Emoji를 많이 쓴 글.처럼 보인다.\n\nEmoji는 정보 전달하는 데도 좋지만 얼마나 재밌고 기쁜지 같은 표현도 가능하다.\n\nEmoji 문자를 사용하는 웹 서비스가 정말 많다. 어떤 Emoji 문자가 있는지 쉽게 찾아볼 수 있는 치트시트가 있어서 두고두고 참고할 수 있다.\n\nhttp://www.emoji-cheat-sheet.com\n\nGitHub이 제공하는 글에 이미지를 포함시키는 기능은 기술적으로 GFM이 아니지만 엄청 유용하다. Markdown 형식으로 이미지를 첨부하고 싶을 때 일반적인 방법으로는 이미지를 올리고 그 URL을 찾아서 일일이 입력해야 하는데 번거롭다. GitHub에서는 그냥 이미지를 바로 Drag-and-Drop으로 붙여 넣을 수 있다.\n\n끌어다 놓기로 이미지 자동 붙이기.로 돌아가서 보면 Text Area 위에 “Parsed As Markdown” 이라는 표시를 볼 수 있다. 그 링크를 클릭하면 GitHub에서 Markdown을 어떻게 사용하는지 알려주는 치트시트를 보여준다.\n\n노트 | Emoji 문자를 사용하는 웹 서비스가 정말 많다. 어떤 Emoji 문자가 있는지 쉽게 찾아볼 수 있는 치트시트가 있어서 두고두고 참고할 수 있다. http://www.emoji-cheat-sheet.com\n\n[Note] 노트 Emoji 문자를 사용하는 웹 서비스가 정말 많다. 어떤 Emoji 문자가 있는지 쉽게 찾아볼 수 있는 치트시트가 있어서 두고두고 참고할 수 있다. http://www.emoji-cheat-sheet.com",
        "code_examples": [
          "```bash\n- [X] Write the code\n- [ ] Write all the tests\n- [ ] Document the code\n```",
          "```bash\n```java\nfor(int i=0 ; i < 5 ; i++)\n{\n   System.out.println(\"i is : \" + i);\n}\n```\n```",
          "```bash\n> Whether 'tis Nobler in the mind to suffer\n> The Slings and Arrows of outrageous Fortune,\n\nHow big are these slings and in particular, these arrows?\n```",
          "```bash\nI :eyes: that :bug: and I :cold_sweat:.\n\n:trophy: for :microscope: it.\n\n:+1: and :sparkles: on this :ship:, it's :fire::poop:!\n\n:clap::tada::panda_face:\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 22,
          "content_length": 2413
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/GitHub-GitHub-프로젝트에-기여하기",
    "doc_type": "git",
    "total_sections": 5
  },
  {
    "title": "6.3 GitHub - GitHub 프로젝트 관리하기",
    "summary": "GitHub 프로젝트 관리하기 지금까지 남의 프로젝트에 기여하는 법을 살펴보았고 이번에는 직접 프로젝트를 운영하는 법을 살펴보자. 프로젝트를 생성해서 관리하는 방식 말이다. 새 저장소 만들기 저장소를 새로 만들고 프로젝트 코드를 공유해 보자. 대시보드 오른쪽에 있는 “New repository” 버튼을 클릭하면 저장소를 만드는 폼으로 이동한다. 맨 위 툴바의 사용자이름 옆에 있는 + 버튼을 클릭해도 된다. 그림 110. “Your repositories” 박스. 그림 111. 사용자이름 옆 “New repository” 메뉴. 위 버튼을 누르면 “새 저장소” 를 만드는 화면으로 이동한다. 그림 112. “새 저장소” 만들기. 프로젝트 이름을 넣는 것만 필수다. 다른 것은 생략해도 된다. “Create Repository” 버튼을 클릭하면 '뿅’하고 <user>/<project_name> 위치에 GitHub 저장소가 생긴다. 아직 저장소에 코드가 하나도 없어서, GitHub는 Git ",
    "sections": [
      {
        "header": "GitHub 프로젝트 관리하기",
        "content": "지금까지 남의 프로젝트에 기여하는 법을 살펴보았고 이번에는 직접 프로젝트를 운영하는 법을 살펴보자. 프로젝트를 생성해서 관리하는 방식 말이다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 79
        }
      },
      {
        "header": "새 저장소 만들기",
        "content": "저장소를 새로 만들고 프로젝트 코드를 공유해 보자. 대시보드 오른쪽에 있는 “New repository” 버튼을 클릭하면 저장소를 만드는 폼으로 이동한다. 맨 위 툴바의 사용자이름 옆에 있는 + 버튼을 클릭해도 된다.\n\n위 버튼을 누르면 “새 저장소” 를 만드는 화면으로 이동한다.\n\n프로젝트 이름을 넣는 것만 필수다. 다른 것은 생략해도 된다. “Create Repository” 버튼을 클릭하면 '뿅’하고 <user>/<project_name> 위치에 GitHub 저장소가 생긴다.\n\n아직 저장소에 코드가 하나도 없어서, GitHub는 Git 저장소를 만드는 방법이나 기존 Git 프로젝트를 넣는 방법을 보여준다. 이 내용을 다시 살펴보고 싶다면 Git의 기초를 보라. 여기서 또 설명하지 않는다.\n\nGitHub에 프로젝트를 올렸으면 다른 사람들에게 프로젝트 URL을 알려주고 공유할 수 있다. 모든 프로젝트의 HTTPS URL은 https://github.com/<user>/<project_name> 처럼 생겼고 SSH는 git@github.com:<user>/<project_name> 처럼 생겼다. Git은 이 두 URL을 통해서 Fetch 하고 Push 할 수 있지만, 인증 방식은 사용하는 프로토콜에 따라 다르다.\n\nGitHub 계정 없이 Clone 할 수 있기 때문에 공개 프로젝트를 공유할 때는 SSH보다 HTTP URL를 더 많이 공유한다. SSH URL을 사용하려면 계정도 있어야 하고 SSH 키도 GitHub에 등록해야 한다. 브라우저에서 프로젝트 페이지에 접속할 때도 저장소 URL로 사용하는 HTTP URL을 그대로 사용한다.\n\n노트 | GitHub 계정 없이 Clone 할 수 있기 때문에 공개 프로젝트를 공유할 때는 SSH보다 HTTP URL를 더 많이 공유한다. SSH URL을 사용하려면 계정도 있어야 하고 SSH 키도 GitHub에 등록해야 한다. 브라우저에서 프로젝트 페이지에 접속할 때도 저장소 URL로 사용하는 HTTP URL을 그대로 사용한다.\n\n[Note] 노트 GitHub 계정 없이 Clone 할 수 있기 때문에 공개 프로젝트를 공유할 때는 SSH보다 HTTP URL를 더 많이 공유한다. SSH URL을 사용하려면 계정도 있어야 하고 SSH 키도 GitHub에 등록해야 한다. 브라우저에서 프로젝트 페이지에 접속할 때도 저장소 URL로 사용하는 HTTP URL을 그대로 사용한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 6,
          "content_length": 1192
        }
      },
      {
        "header": "동료 추가하기",
        "content": "저장소에 커밋 권한을 주고 싶은 동료가 있으면 “Collaborator” 로 추가해야 한다. Ben과 Jeff, Louise라는 동료가 있는데 그들이 내 저장소에 Push 할 수 있도록 하고 싶으면 내 프로젝트에 GitHub 계정들을 추가해야 한다. 계정이 추가된 사람은 해당 프로젝트와 Git 저장소에 “Push” 할 수 있을 뿐만 아니라 읽고 쓰기도 가능하다.\n\n오른쪽 밑에 있는 ` Settings ` 링크를 클릭한다.\n\n왼쪽 메뉴에서 “Collaborators” 를 선택한다. 텍스트 박스에 사용자이름을 입력하고 “Add collaborator” 를 클릭한다. 필요한 사람을 모두 추가할 때까지 반복한다. 그리고 오른쪽에 있는 “X” 를 클릭하면 권한이 회수된다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 375
        }
      },
      {
        "header": "Pull Request 관리하기",
        "content": "프로젝트를 만들고 코드도 넣고 동료가 Push 할 수 있게 했다. 이제 Pull Request가 왔을 때 어떻게 해야 하는지 보자.\n\nPull Request는 같은 저장소나 Fork 한 저장소에서 브랜치를 보내오는 것이다. 그 둘의 차이는 권한에 있다. Fork 한 저장소는 다른 사람의 저장소이기 때문에 그 보내온 브랜치에 Push 할 권한이 없다. 하지만, 같은 저장소의 브랜치에는 Push 할 수 있다.\n\n“tonychacon” 이라는 사람이 “fade” 라는 Arduino 프로젝트를 만든 상황을 살펴보자.\n\n어떤 사람이 코드를 수정해서 Pull Request를 보내왔다. 그러면 새로운 Pull Request가 왔다는 메일이 담당자에게 간다. 새 Pull Request에 대한 이메일 알림. 같은 메일이 보내진다.\n\n이 이메일은 무엇이 달라진 것인지 간략히 보여준다. 해당 Pull Request에서 어떤 파일이 얼마나 변경됐는지 보여준다. 그리고 Pull Request 페이지 링크도 있고 CLI로 Merge 하는 방법과 URL도 간략히 보여준다.\n\ngit pull <url> patch-1 라는 명령이 궁금할 텐데 이렇게 하면 리모트 브랜치를 간단히 Merge 할 수 있다. 저장소를 리모트로 추가하지 않아도 된다. 필요하면 토픽 브랜치를 만들고 리모트 브랜치로부터 통합하기에서 배운 명령어로 Pull Request로 직접 Merge 해도 된다.\n\n그리고 눈치챘을 테지만 .diff 와 .patch URL은 Pull Request의 'Unified Diff’와 Patch 버전의 URL이다. 이 URL로 아래와 같이 Pull Request를 Merge 할 수 있다.\n\nGitHub 플로우에서 설명했듯이 Pull Request를 만든 사람과 토론할 수 있다. GFM을 사용하여 특정 커밋을 선택하거나, 특정 라인을 지정하거나, 혹은 전체 Pull Request 자체에도 코멘트를 남길 수 있다.\n\n일단 대화에 참여하고 나면 누군가 코멘트할 때마다 이메일 알림이 계속 온다. 그 이메일에는 Pull Request 페이지의 링크가 포함돼 있기 때문에 어떤 일이 일어나고 있는지 쉽게 알 수 있다. 그리고 답 메일을 보내면 Pull Request의 코멘트로 달린다.\n\n보내온 코드가 마음에 들어서 Merge 하고 싶다면 로컬에 가져와서 Merge 할 수 있다. git pull <url> <branch> 명령으로 Merge 하면 되는데 먼저 Fork 한 저장소를 리모트로 추가하고 Fetch 해서 Merge 한다.\n\nGitHub 사이트에서 “Merge” 버튼을 누르는 것으로 간편하게 Merge 할 수 있다(Trivial Merge). “fast-forward” 가 가능할 때도 “non-fast-forward” Merge를 하기 때문에 Merge 커밋이 생긴다. 그래서 “Merge” 버튼을 클릭해서 Merge 하면 항상 Merge 커밋이 생긴다. 여기서 어떻게 해야 하는지 'command line' 힌트 링크를 클릭하면 Merge 버튼과 Pull Request를 수동으로 Merge 하기.과 같이 알려준다.\n\n만약 Pull Request를 Merge 하지 않기로 했다면 그냥 닫으면 된다. 그러면 그 Pull Request를 보낸 사람에게 알림이 간다.\n\n일일이 리모트를 등록하고 Pull 하는 것은 Pull Request를 많이 처리하는 사람에게는 고통스럽다. GitHub는 이럴 때 사용하는 방법을 제공한다. 이 내용은 Refspec에서 자세히 설명할 거고 조금 어려울 수 있다.\n\nGitHub는 Pull Request의 브랜치를 서버에 있는 가상 브랜치로 노출해준다. GitHub가 자동으로 해주기 때문에 바로 이용하면 된다.\n\n이걸 해보려면 저수준(“plumbing”) 명령어인 ls-remote 가 필요하다. 이 명령어는 아무래도 매일 쓰는 명령어는 아니지만, 서버에 어떤 Ref가 있는지 보여 준다. “plumbing” 명령어는 Plumbing 명령과 Porcelain 명령에서 자세히 설명한다.\n\n이 명령어로 좀 전의 “blink” 저장소를 살펴보자. 저장소 브랜치뿐만 아니라 태그 등 온갖 Ref를 보여준다.\n\n저장소 안이라면 git ls-remote origin 이라고 실행시켜도 된다. 저장된 리모트 이름을 사용할 수 있다.\n\nGitHub 저장소에 어떤 Pull Request라도 열려있다면 refs/pull/ 로 시작하는 이름으로 Ref가 생성된다. 이것도 브랜치지만 refs/heads/ 로 시작하는 브랜치와는 달리 Clone과 Fetch 할 때 받아지지 않으며 기본적으로 무시된다.\n\nPull Request에는 두 종류의 Ref가 있다. /head 로 끝나는 것은 Pull Request 브랜치가 가리키는 마지막 커밋이다. 누군가 우리 저장소에 bug-fix 라는 브랜치를 Pull Request로 보내는 상황을 살펴보자. 이 브랜치는 a5a775 커밋을 가리킨다. bug-fix 브랜치는 Fork 한 저장소에 있는 브랜치라서 우리 저장소에 없다. 그럼에도 a5a775 를 가리키는 pull/<pr#>/head 형식의 브랜치가 자동으로 생긴다. 그래서 매번 다른 저장소를 리모트로 등록하지 않고서도 Pull Request 브랜치를 쉽게 Pull 할 수 있다.\n\n“리모트의 브랜치 origin 을 refs/pull/958/head 로 Fetch 한다” 는 뜻이다. Git은 충실하게 전부 내려받고 마지막 커밋을 .git/FETCH_HEAD 에 저장한다. git merge FETCH_HEAD 으로 Merge 해서 테스트할 수 있다. 이렇게 Merge 하면 Merge 커밋 메시지가 약간 이상해진다. 또한 많은 Pull Request를 처리해야 하는 경우, 쓸데없는 Merge 커밋도 많아진다.\n\n항상 Pull Request를 전부 가져오게 할 수 있다. .git/config 파일을 열어서 origin 리모트를 찾는다. origin 리모트는 사실 아래와 같은 것을 의미한다.\n\nfetch = 로 시작하는 라인이 “refspec” 이라는 거다. 리모트 이름과 로컬 .git 디렉토리를 어떻게 매핑하는지 나타낸다. 여기서는 해당 리모트에서 refs/heads 에 해당하는 이름이 refs/remotes/origin 디렉토리에 매핑된다는 의미다. Refspec을 새로 추가해보자.\n\n추가한 마지막 라인의 의미는 refs/pull/123/head 같은 Ref를 refs/remotes/origin/pr/123 에 저장'' 한다는 의미다. git fetch 라고 실행하면 새 Refspec의 브랜치도 가져온다.\n\n서버에 있는 모든 Pull Request을 추적하는 트래킹 브린치가 생겼다. 쓰기는 불가능하지만 계속 Fetch 해 올 수 있다. 이렇게 하면 Pull Request를 로컬에 가져와서 작업하는 게 편해진다.\n\nhead 로 끝나는 Refspec에 대해서 살펴봤고 이제 refs/pull/#/merge 처럼 생긴 Refspec을 알아보자. 이 브랜치는 GitHub에서 Merge 버튼으로 Merge 했을 때 적용되는 결과다. GitHub에서 실제로 Merge 하기 전에 로컬로 가져와서 먼저 테스트할 수 있다.\n\nPull Request를 Merge 할 브랜치는 master 가 아니어도 된다. 주 브랜치를 고를 수도 있고 Pull Request를 열 때 다른 브랜치를 골라도 된다. 심지어 다른 Pull Request를 고를 수도 있다.\n\n착착 잘 진행하는 어떤 Pull Request가 있는데 거기에 뭔가 아이디어를 더하고 싶다는 생각이 들었다. 좋은 아이디어라는 확신도 부족하고 무엇보다 Merge 될 브랜치에 Push 권한이 없다. 이럴 땐 Pull Request에 Pull Request를 보낼 수 있다.\n\nPull Request를 만들러 가면 페이지 위쪽에 어떤 저장소의 브랜치를 어떤 저장소의 브랜치로 요청하는 것인지를 보여주는 박스가 있다. “Edit” 버튼을 누르면 Fork 한 저장소 중 하나로 저장소를 변경하고 해당 저장소의 브랜치로 변경할 수 있다.\n\n쉽게 다른 Fork 저장소나 Pull Request의 브랜치를 골라 Pull Request를 열 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ curl http://github.com/tonychacon/fade/pull/1.patch | git am\n```",
          "```bash\n$ git ls-remote https://github.com/schacon/blink\n10d539600d86723087810ec636870a504f4fee4d\tHEAD\n10d539600d86723087810ec636870a504f4fee4d\trefs/heads/master\n6a83107c62950be9453aac297bb0193fd743cd6e\trefs/pull/1/head\nafe83c2d1a70674c9505cc1d8b7d380d5e076ed3\trefs/pull/1/merge\n3c8d735ee16296c242be7a9742ebfbc2665adec1\trefs/pull/2/head\n15c9f4f80973a2758462ab2066b6ad9fe8dcf03d\trefs/pull/2/merge\na5a7751a33b7e86c5e9bb07b26001bb17d775d1a\trefs/pull/4/head\n31a45fc257e8433c8d8804e3e848cf61c9d3166c\trefs/pull/4/merge\n```",
          "```bash\n$ git fetch origin refs/pull/958/head\nFrom https://github.com/libgit2/libgit2\n * branch            refs/pull/958/head -> FETCH_HEAD\n```",
          "```bash\n[remote \"origin\"]\n    url = https://github.com/libgit2/libgit2\n    fetch = +refs/heads/*:refs/remotes/origin/*\n```",
          "```bash\n[remote \"origin\"]\n    url = https://github.com/libgit2/libgit2.git\n    fetch = +refs/heads/*:refs/remotes/origin/*\n    fetch = +refs/pull/*/head:refs/remotes/origin/pr/*\n```",
          "```bash\n$ git fetch\n# …\n * [new ref]         refs/pull/1/head -> origin/pr/1\n * [new ref]         refs/pull/2/head -> origin/pr/2\n * [new ref]         refs/pull/4/head -> origin/pr/4\n# …\n```",
          "```bash\n$ git checkout pr/2\nChecking out files: 100% (3769/3769), done.\nBranch pr/2 set up to track remote branch pr/2 from origin.\nSwitched to a new branch 'pr/2'\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 29,
          "content_length": 3981
        }
      },
      {
        "header": "멘션과 알림",
        "content": "GitHub는 어떤 팀이나 사람에게 질문하거나 피드백을 받을 수 있도록 쉽고 편한 알림 시스템을 제공한다.\n\nGitHub 어디에서나 @ 만 입력해도 동료나 기여자의 사용자이름이 자동완성 된다.\n\n자동완성 메뉴에 없는 사람도 입력할 수 있지만, 자동완성이 편하고 빠르다.\n\nGitHub에서 글을 쓸 때 @멘션 을 하면 해당 사용자에게 알림이 간다. 일일이 의견을 물으러 다니는 것보다 이렇게 토론에 참여시키는 게 훨씬 유용하다. GitHub에서는 멘션으로 팀의 동료나 다른 사람을 이슈나 Pull Request에 참여시킨다.\n\n한번 @멘션 으로 언급되면 그 사람은 “구독 상태(Subscribed)” 가 된다. 그래서 해당 이슈나 Pull Request에서 계속 알림이 온다. 이슈나 Pull Request를 직접 만들었거나, 해당 저장소를 'Watching’하는 상태이거나, 코멘트를 단 경우에도 구독 상태가 된다. 더는 알림을 받고 싶지 않으면 화면의 “Unsubscribe” 버튼으로 멈출 수 있다.\n\nGitHub의 “알림” 은 프로젝트에서 어떤 일이 일어나면 바로 알 수 있도록 안내해 주는 것이다. 이 알림은 원하는 방법으로 설정해 쓸 수 있다. 설정의 “Notification center” 탭에 가면 설정할 수 있는 옵션이 있다.\n\n알림을 이메일로 받을지 웹으로 받을지 선택할 수 있다. 물론 두 가지 방법을 동시에 사용해도 된다. 그리고 그냥 대화에 참여하는 경우와 프로젝트를 'Watching' 하는 경우를 나누어 선택할 수 있다.\n\n웹 알림은 GitHub에서 제공하는 것으로 GitHub 사이트에서만 확인할 수 있다. 이 옵션을 선택하면 알림이 오면 알림 아이콘에 파란 점을 볼 수 있다. Notification center.을 확인해보자.\n\n알림 아이콘을 클릭하면 알림 메시지를 확인할 수 있다. 알림은 프로젝트별로 분류된다. 왼쪽 메뉴에 있는 프로젝트를 선택하면 관련 알림만 걸러서 볼 수 있다. 각 알림에 있는 체크박스를 클릭해서 읽었다고 표시를 할 수 있고 제일 위에 있는 체크박스를 클릭하면 해당 알림에 대해서 전부 읽음 표시를 할 수 있다. 그리고 'Mute' 버튼을 클릭하면 해당 사항에 대해서는 더는 알림이 오지 않는다.\n\n이 기능을 사용하면 쏟아지는 알림들도 매우 효율적으로 처리할 수 있다. GitHub의 파워 유저는 이메일 알림을 꺼놓고 GitHub 사이트에서만 알림을 관리하기도 한다.\n\n이메일 알림을 켜 놓으면 이메일로도 GitHub 알림을 확인할 수 있다. 이메일 알림으로 온 코멘트과 새 Pull Request에 대한 이메일 알림.의 예를 보면 관련 알림들이 이메일 스레드로 잘 분류되는 것을 볼 수 있다. 그래서 이메일 스레드를 잘 지원하는 메일 클라이언트를 사용하는 것이 좋다.\n\nGitHub가 보낸 이메일 헤더를 보면 여러 가지 메타데이터가 들어 있다. 그래서 사용자는 이메일 필터나 룰 같은 자동 관리 기능으로 쉽게 관리할 수 있다.\n\n새 Pull Request에 대한 이메일 알림.에서 보여준 이메일의 헤더는 아래와 같다.\n\n프로젝트에 따라 혹은 Pull Request인지에 따라 분류하거나 다른 주소로 재전송하고 싶다면 Message-ID 를 이용하는 게 좋다. 이 데이터는 <user>/<project>/<type>/<id> 형식으로 돼 있다. 만약 이슈에 대한 데이터면 <type> 부분이 “pull” 이 아니라 “issues” 라고 돼 있을 것이다.\n\nList-Post 와 List-Unsubscribe 필드를 인식하는 메일 클라이언트를 사용하고 있으면 좀 더 편리하게 사용할 수 있다. List-Post 는 이메일로 리스트에 글을 올리는 데 사용하고 List-Unsubscribe 는 이메일 클라이언트에서 알림을 그만 받도록 할 수 있다. 이슈와 Pull Request페이지의 “Unsubscribe” 버튼을 클릭하거나 웹 알림 페이지에서 “Mute” 버튼을 클릭하는 것과 같다.\n\n이메일과 웹 알림이 둘 다 켜져 있으면 알림이 이메일로도 오고 웹으로도 온다. 이메일 클라이언트에서 이미지가 허용되어 있으면, 메일을 읽었을 때 웹에서도 읽었다고 표시된다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nTo: tonychacon/fade <fade@noreply.github.com>\nMessage-ID: <tonychacon/fade/pull/1@github.com>\nSubject: [fade] Wait longer to see the dimming effect better (#1)\nX-GitHub-Recipient: tonychacon\nList-ID: tonychacon/fade <fade.tonychacon.github.com>\nList-Archive: https://github.com/tonychacon/fade\nList-Post: <mailto:reply+i-4XXX@reply.github.com>\nList-Unsubscribe: <mailto:unsub+i-XXX@reply.github.com>,...\nX-GitHub-Recipient-Address: tchacon@example.com\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 16,
          "content_length": 2024
        }
      },
      {
        "header": "특별한 파일",
        "content": "저장소에 있는 파일 중에서 GitHub가 사용하는 몇 가지 특이한 파일들이 있다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 45
        }
      },
      {
        "header": "README",
        "content": "GitHub는 저장소 랜딩 페이지를 보여줄 때 README 파일을 이용해서 보여준다. README 파일 형식에 상관없이 잘 보여준다. README 파일이든 README.md 파일이든 README.asciidoc 파일이든 GitHub가 자동으로 렌더링해서 보여준다.\n\n많은 사람이 이 파일에 저장소나 프로젝트에 처음 방문한 사람들에게 필요한 정보를 정리해 둔다. 보통 아래와 같은 내용을 쓴다.\n\nGitHub는 README 파일을 렌더링하는 것이기 때문에 이미지나 외부 링크를 적어도 된다.\n\n• 설정하고 설치하는 방법\n• 사용법과 실행 결과에 대한 예제",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 309
        }
      },
      {
        "header": "CONTRIBUTING",
        "content": "GitHub는 CONTRIBUTING 파일도 인식한다. README와 마찬가지로 원하는 파일 형식을 사용하면 된다. Pull Request를 열 때 이 파일이 있으면 CONTRIBUTING 파일이 있음을 보여준다.과 같이 링크를 보여준다.\n\n이 파일에는 프로젝트에 기여하는 방법과 Pull Request 규칙 같은 것을 적는다. 그러면 사람들이 Pull Request를 열 때 이 가이드라인을 참고할 수 있다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 229
        }
      },
      {
        "header": "프로젝트 관리",
        "content": "특별히 관리할 만한 게 별로 없지만 알고 있으면 유용한 것들을 소개한다.\n\n기본 브랜치를 “master” 말고 다른 브랜치로 설정할 수 있다. Pull Request를 열 때 설정한 기본 브랜치가 기본으로 선택된다. 기본 브랜치는 저장소 설정 페이지의 “Options” 탭에서 변경한다.\n\n기본 브랜치 변경은 쉽고 정말로 기본으로 쓰인다. 저장소를 Clone 하면 여기서 설정한 브랜치가 기본으로 Checkout된다.\n\n프로젝트 소유자를 다른 사용자나 Organization으로 변경할 수 있다. 저장소 설정 페이지의 “Options” 탭을 보면 페이지 아래쪽에 “Transfer ownership” 항목이 있다. 여기 있는 Transfer 버튼으로 프로젝트를 넘길 수 있다.\n\n맡던 프로젝트를 다른 사람에게 넘겨주거나 프로젝트가 커져서 Organizaiton 계정으로 옮기고 싶을 때 유용하다.\n\n저장소만 옮겨지는 것이 아니라 'Watching’하는 사람이나 'Star’한 사람까지도 함께 옮겨진다. 그리고 URL은 Redirect되는데 웹 접속뿐만 아니라 Clone 이나 Fetch 요청까지도 Redirect된다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 569
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/GitHub-GitHub-프로젝트-관리하기",
    "doc_type": "git",
    "total_sections": 9
  },
  {
    "title": "7.1 Git 도구 - 리비전 조회하기",
    "summary": "지금까지 일상적으로 자주 사용하는 명령들과 몇 가지 워크플로를 배웠다. 파일을 추적하고 커밋하는 등의 기본적인 명령뿐만 아니라 Staging Area가 왜 좋은지도 배웠고 가볍게 토픽 브랜치를 만들고 Merge 하는 방법도 다뤘다. 이제는 Git 저장소로 충분히 소스코드를 관리할 수 있을 것이다.이 장에서는 일상적으로 사용하지는 않지만 위급한 상황에서 반드시 필요한 Git 도구를 살펴본다. 리비전 조회하기 Git은 커밋 하나를 가리키거나 범위를 사용하여 여러 커밋을 가리키는 다양한 방법을 갖고 있다. 그 많은 방법을 아는 것이 필요하진 않지만 알아두면 좋다. 리비전 하나 가리키기 40글자나 되는 긴긴 SHA-1 해시 값으로도 커밋을 외울 수 있지만 사람이 사용하기 좋은 방법이 있다. 이 절에서는 커밋을 가리키거나 표현하는 방법을 몇 가지 설명한다. SHA-1 줄여 쓰기 Git은 해시 값의 앞 몇 글자만으로도 어떤 커밋인지 충분히 식별할 수 있다. 저장소 안에서 해시 값이 중복되지 않",
    "sections": [
      {
        "header": "",
        "content": "지금까지 일상적으로 자주 사용하는 명령들과 몇 가지 워크플로를 배웠다. 파일을 추적하고 커밋하는 등의 기본적인 명령뿐만 아니라 Staging Area가 왜 좋은지도 배웠고 가볍게 토픽 브랜치를 만들고 Merge 하는 방법도 다뤘다. 이제는 Git 저장소로 충분히 소스코드를 관리할 수 있을 것이다.\n\n이 장에서는 일상적으로 사용하지는 않지만 위급한 상황에서 반드시 필요한 Git 도구를 살펴본다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 221
        }
      },
      {
        "header": "리비전 조회하기",
        "content": "Git은 커밋 하나를 가리키거나 범위를 사용하여 여러 커밋을 가리키는 다양한 방법을 갖고 있다. 그 많은 방법을 아는 것이 필요하진 않지만 알아두면 좋다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 86
        }
      },
      {
        "header": "리비전 하나 가리키기",
        "content": "40글자나 되는 긴긴 SHA-1 해시 값으로도 커밋을 외울 수 있지만 사람이 사용하기 좋은 방법이 있다. 이 절에서는 커밋을 가리키거나 표현하는 방법을 몇 가지 설명한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 95
        }
      },
      {
        "header": "SHA-1 줄여 쓰기",
        "content": "Git은 해시 값의 앞 몇 글자만으로도 어떤 커밋인지 충분히 식별할 수 있다. 저장소 안에서 해시 값이 중복되지 않으면 해시 값의 앞 4자만으로도 나타낼 수 있다. 즉 짧은 SHA-1 값이라고 해도 유일해야 한다.\n\n먼저 git log 명령으로 어떤 커밋이 있는지 조회하는 예제를 보자.\n\n위의 내용은 1c002dd… 로 시작하는 커밋에 대해 로그를 살펴보겠다는 말이다. git show 명령을 사용하는 다음 결과는 모두 같다(단 짧은 해시 값이 다른 커밋과 중복되지 않다고 가정).\n\ngit log 명령에 --abbrev-commit 이라는 옵션을 추가하면 짧고 중복되지 않는 해시 값을 보여준다. 기본으로 7자를 보여주고 해시 값이 중복되는 경우 더 긴 해시 값을 보여준다.\n\n보통은 8자에서 10자 내외로도 충분히 유일하게 커밋을 나타낼 수 있다. 2018년 6월 현재 꽤 큰 프로젝트인 Linux 커널은 79만 개 이상의 커밋, 650만 개 이상의 오브젝트가 있다. Linux 커널 프로젝트는 해시 값 11개만 사용해도 충돌이 없다.\n\nGit을 쓰는 사람들은 가능성이 작긴 하지만 언젠가 SHA-1 값이 중복될까 봐 걱정한다. 정말 그렇게 되면 어떤 일이 벌어질까?\n\n이미 있는 SHA-1 값이 Git 데이터베이스에 커밋되면 새로운 개체라고 해도 이미 커밋된 것으로 생각하고 이전의 커밋을 재사용한다. 그래서 해당 SHA-1 값의 커밋을 Checkout 하면 항상 처음 저장한 커밋만 Checkout 된다.\n\n그러나 해시 값이 중복되는 일은 일어나기 어렵다. SHA-1 값의 크기는 20 바이트(160비트)이다. 해시 값이 중복될 확률이 50%가 되는 데 필요한 개체의 수는 280이다. 이 수는 1자 2,000해 ('자’는 '경’의 '억’배 - 1024, 충돌 확률을 구하는 공식은 p = (n(n-1)/2) * (1/2^160) )이다. 즉, 지구에 존재하는 모래알의 수에 1,200을 곱한 수와 맞먹는다.\n\n아직도 SHA-1 해시 값이 중복될까 봐 걱정하는 사람들을 위해 좀 더 덧붙이겠다. 지구에서 약 6억 5천만 명의 인구가 개발하고 각자 매초 Linux 커널 히스토리 전체와(650만 개) 맞먹는 개체를 쏟아 내고 바로 Push 한다고 가정하자. 이런 상황에서 해시 값의 충돌 날 확률이 50%가 되기까지는 약 2년이 걸린다. 그냥 어느 날 동료가 한 순간에 모두 늑대에게 물려 죽을 확률이 훨씬 더 높다.\n\n노트 | SHA-1 해시 값에 대한 단상 Git을 쓰는 사람들은 가능성이 작긴 하지만 언젠가 SHA-1 값이 중복될까 봐 걱정한다. 정말 그렇게 되면 어떤 일이 벌어질까? 이미 있는 SHA-1 값이 Git 데이터베이스에 커밋되면 새로운 개체라고 해도 이미 커밋된 것으로 생각하고 이전의 커밋을 재사용한다. 그래서 해당 SHA-1 값의 커밋을 Checkout 하면 항상 처음 저장한 커밋만 Checkout 된다. 그러나 해시 값이 중복되는 일은 일어나기 어렵다. SHA-1 값의 크기는 20 바이트(160비트)이다. 해시 값이 중복될 확률이 50%가 되는 데 필요한 개체의 수는 280이다. 이 수는 1자 2,000해 ('자’는 '경’의 '억’배 - 1024, 충돌 확률을 구하는 공식은 p = (n(n-1)/2) * (1/2^160) )이다. 즉, 지구에 존재하는 모래알의 수에 1,200을 곱한 수와 맞먹는다. 아직도 SHA-1 해시 값이 중복될까 봐 걱정하는 사람들을 위해 좀 더 덧붙이겠다. 지구에서 약 6억 5천만 명의 인구가 개발하고 각자 매초 Linux 커널 히스토리 전체와(650만 개) 맞먹는 개체를 쏟아 내고 바로 Push 한다고 가정하자. 이런 상황에서 해시 값의 충돌 날 확률이 50%가 되기까지는 약 2년이 걸린다. 그냥 어느 날 동료가 한 순간에 모두 늑대에게 물려 죽을 확률이 훨씬 더 높다.\n\n[Note] 노트 SHA-1 해시 값에 대한 단상 Git을 쓰는 사람들은 가능성이 작긴 하지만 언젠가 SHA-1 값이 중복될까 봐 걱정한다. 정말 그렇게 되면 어떤 일이 벌어질까? 이미 있는 SHA-1 값이 Git 데이터베이스에 커밋되면 새로운 개체라고 해도 이미 커밋된 것으로 생각하고 이전의 커밋을 재사용한다. 그래서 해당 SHA-1 값의 커밋을 Checkout 하면 항상 처음 저장한 커밋만 Checkout 된다. 그러나 해시 값이 중복되는 일은 일어나기 어렵다. SHA-1 값의 크기는 20 바이트(160비트)이다. 해시 값이 중복될 확률이 50%가 되는 데 필요한 개체의 수는 280이다. 이 수는 1자 2,000해 ('자’는 '경’의 '억’배 - 1024, 충돌 확률을 구하는 공식은 p = (n(n-1)/2) * (1/2^160) )이다. 즉, 지구에 존재하는 모래알의 수에 1,200을 곱한 수와 맞먹는다. 아직도 SHA-1 해시 값이 중복될까 봐 걱정하는 사람들을 위해 좀 더 덧붙이겠다. 지구에서 약 6억 5천만 명의 인구가 개발하고 각자 매초 Linux 커널 히스토리 전체와(650만 개) 맞먹는 개체를 쏟아 내고 바로 Push 한다고 가정하자. 이런 상황에서 해시 값의 충돌 날 확률이 50%가 되기까지는 약 2년이 걸린다. 그냥 어느 날 동료가 한 순간에 모두 늑대에게 물려 죽을 확률이 훨씬 더 높다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git log\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri Jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nMerge: 1c002dd... 35cfb2b...\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 15:08:43 2008 -0800\n\n    Merge commit 'phedders/rdocs'\n\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 14:58:32 2008 -\n\n    added some blame and merge stuff\n```",
          "```bash\n$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b\n$ git show 1c002dd4b536e7479f\n$ git show 1c002d\n```",
          "```bash\n$ git log --abbrev-commit --pretty=oneline\nca82a6d changed the version number\n085bb3b removed unnecessary test code\na11bef0 first commit\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 9,
          "content_length": 2560
        }
      },
      {
        "header": "브랜치로 가리키기",
        "content": "커밋을 가리키는 방법 중에 가장 많이 사용하는 방법이 있다. 어떤 커밋이 브랜치의 가장 최신 커밋이라면 간단히 브랜치 이름으로 커밋을 가리킬 수 있다. 브랜치 이름을 Git 명령에 전달하면 브랜치가 가리키는 커밋을 가리키게 된다. 만약 topic1 브랜치의 최근 커밋을 보고 싶으면 아래와 같이 실행한다. topic1 브랜치가 ca82a6d… 를 가리키고 있기 때문에 두 명령의 결과는 같다.\n\n브랜치가 가리키는 개체의 SHA-1 값에 대한 궁금증은 rev-parse 이라는 Plumbing 도구가 해결해 준다. Git의 내부에서 이 뚫어뻥에 대해 시원하게 설명한다. 기본적으로 rev-parse 은 저수준 명령이기 때문에 평소에는 전혀 필요하지 않다. 그래도 한번 사용해보고 어떤 결과가 나오는지 알아 두자.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git show ca82a6dff817ec66f44342007202690a93763949\n$ git show topic1\n```",
          "```bash\n$ git rev-parse topic1\nca82a6dff817ec66f44342007202690a93763949\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 397
        }
      },
      {
        "header": "RefLog로 가리키기",
        "content": "Git은 자동으로 브랜치와 HEAD가 지난 몇 달 동안에 가리켰었던 커밋을 모두 기록하는데 이 로그를 “Reflog” 라고 부른다.\n\ngit reflog 를 실행하면 Reflog를 볼 수 있다.\n\nGit은 브랜치가 가리키는 것이 달라질 때마다 그 정보를 임시 영역에 저장한다. 그래서 예전에 가리키던 것이 무엇인지 확인해 볼 수 있다. @{n} 규칙을 사용하면 아래와 같이 HEAD가 5번 전에 가리켰던 것을 알 수 있다.\n\n순서뿐 아니라 시간도 사용할 수 있다. 어제 날짜의 master 브랜치를 보고 싶으면 아래와 같이 한다.\n\n이 명령은 어제 master 브랜치가 가리키고 있던 것이 무엇인지 보여준다. Reflog에 남아있을 때만 조회할 수 있기 때문에 너무 오래된 커밋은 조회할 수 없다.\n\ngit log -g 명령을 사용하면 git reflog 결과를 git log 명령과 같은 형태로 볼 수 있다.\n\nReflog의 일은 모두 로컬의 일이기 때문에 내 Reflog가 동료의 저장소에는 있을 수 없다. 이제 막 Clone 한 저장소는 아무것도 한 것이 없어서 Reflog가 하나도 없다. git show HEAD@{2.months.ago} 같은 명령은 적어도 두 달 전에 Clone 한 저장소에서나 사용할 수 있다. 그러니까 이 명령을 5분 전에 Clone 한 저장소에 사용하면 아무 결과도 나오지 않는다.\n\nUnix나 Linux 사용 경험이 있는 경우 reflog를 Git의 Shell의 명령 히스토리 기능 버전으로 생각해볼 수 있다. 여기서 중요한 점은 오직 나의 “세션” 에서만 확인할 수 있는 내용이라는 점으로 같은 시스템에 있더라도 다른이와 공유되지 않는 정보라는 점이다.\n\n힌트 | Reflog를 Git의 Shell의 명령 히스토리 기능 버전으로 생각하기\n\n[Tip] 힌트 Reflog를 Git의 Shell의 명령 히스토리 기능 버전으로 생각하기\n\n[Example] Unix나 Linux 사용 경험이 있는 경우 reflog를 Git의 Shell의 명령 히스토리 기능 버전으로 생각해볼 수 있다. 여기서 중요한 점은 오직 나의 “세션” 에서만 확인할 수 있는 내용이라는 점으로 같은 시스템에 있더라도 다른이와 공유되지 않는 정보라는 점이다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git reflog\n734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated\nd921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' strategy.\n1c002dd HEAD@{2}: commit: added some blame and merge stuff\n1c36188 HEAD@{3}: rebase -i (squash): updating HEAD\n95df984 HEAD@{4}: commit: # This is a combination of two commits.\n1c36188 HEAD@{5}: rebase -i (squash): updating HEAD\n7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD\n```",
          "```bash\n$ git show HEAD@{5}\n```",
          "```bash\n$ git show master@{yesterday}\n```",
          "```bash\n$ git log -g master\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nReflog: master@{0} (Scott Chacon <schacon@gmail.com>)\nReflog message: commit: fixed refs handling, added gc auto, updated\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri Jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nReflog: master@{1} (Scott Chacon <schacon@gmail.com>)\nReflog message: merge phedders/rdocs: Merge made by recursive.\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 15:08:43 2008 -0800\n\n    Merge commit 'phedders/rdocs'\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 8,
          "content_length": 1096
        }
      },
      {
        "header": "계통 관계로 가리키기",
        "content": "계통 관계로도 커밋을 표현할 수 있다. 이름 끝에 ^ (캐럿) 기호를 붙이면 Git은 해당 커밋의 부모를 찾는다. 프로젝트 히스토리가 아래와 같을 때는 아래처럼 한다.\n\nHEAD^ 는 바로 “HEAD의 부모” 를 의미하므로 바로 이전 커밋을 보여준다.\n\nWindows에서 실행한 cmd.exe 에서는 ^ 기호가 이미 다른 의미로 사용되고 있어서 Git 에서 사용하려면 좀 다른 방식을 사용해야 한다. 기호 두 개를 연속으로 사용하거나 쌍따옴표 안에서 사용해야 한다.\n\n^ 뒤에 숫자도 사용할 수 있다. 예를 들어 d921970^2 는 “d921970의 두 번째 부모” 를 의미한다. 그래서 두 번째 부모가 있는 Merge 커밋에만 사용할 수 있다. 첫 번째 부모는 Merge 할 때 Checkout 했던 브랜치를 말하고 두 번째 부모는 Merge 한 대상 브랜치를 의미한다.\n\n계통을 표현하는 방법으로 ~ 라는 것도 있다. HEAD~ 와 HEAD^ 는 똑같이 첫 번째 부모를 가리킨다. 하지만, 그 뒤에 숫자를 사용하면 달라진다. HEAD~2 는 명령을 실행할 시점의 “첫 번째 부모의 첫 번째 부모” , 즉 “조부모” 를 가리킨다. 위의 예제에서 HEAD~3 은 아래와 같다.\n\n이것은 HEAD^ 와 같은 표현이다. 부모의 부모의 부모 즉 증조 부모쯤 되겠다.\n\n이 두 표현을 같이 사용할 수도 있다. 위의 예제에서 HEAD~3^2 를 사용하면 증조부모의 Merge 커밋의 부모의 부모를 조회한다.\n\n노트 | Windows에서 캐럿 기호 사용하기\n\n[Example] Windows에서 실행한 cmd.exe 에서는 ^ 기호가 이미 다른 의미로 사용되고 있어서 Git 에서 사용하려면 좀 다른 방식을 사용해야 한다. 기호 두 개를 연속으로 사용하거나 쌍따옴표 안에서 사용해야 한다. $ git show HEAD^ # will NOT work on Windows $ git show HEAD^^ # OK $ git show \"HEAD^\" # OK",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git log --pretty=format:'%h %s' --graph\n* 734713b fixed refs handling, added gc auto, updated tests\n*   d921970 Merge commit 'phedders/rdocs'\n|\\\n| * 35cfb2b Some rdoc changes\n* | 1c002dd added some blame and merge stuff\n|/\n* 1c36188 ignore *.gem\n* 9b29157 add open3_detach to gemspec file list\n```",
          "```bash\n$ git show HEAD^\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nMerge: 1c002dd... 35cfb2b...\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 15:08:43 2008 -0800\n\n    Merge commit 'phedders/rdocs'\n```",
          "```bash\n$ git show HEAD^     # will NOT work on Windows\n$ git show HEAD^^    # OK\n$ git show \"HEAD^\"   # OK\n```",
          "```bash\n$ git show d921970^\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n$ git show d921970^2\ncommit 35cfb2b795a55793d7cc56a6cc2060b4bb732548\nAuthor: Paul Hedderly <paul+git@mjr.org>\nDate:   Wed Dec 10 22:22:03 2008 +0000\n\n    Some rdoc changes\n```",
          "```bash\n$ git show HEAD~3\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nAuthor: Tom Preston-Werner <tom@mojombo.com>\nDate:   Fri Nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n```",
          "```bash\n$ git show HEAD^^^\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nAuthor: Tom Preston-Werner <tom@mojombo.com>\nDate:   Fri Nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 7,
          "content_length": 975
        }
      },
      {
        "header": "범위로 커밋 가리키기",
        "content": "커밋을 하나씩 조회할 수도 있지만, 범위를 주고 여러 커밋을 한꺼번에 조회할 수도 있다. 범위를 사용하여 조회할 수 있으면 브랜치를 관리할 때 유용하다. 상당히 많은 브랜치를 가지고 있고 “왜 이 브랜치들은 아직도 주 브랜치에 Merge도 안 되고 뭐임?” 라는 의문이 들면 범위를 주고 어떤 브랜치인지 쉽게 찾을 수 있다.\n\n범위를 표현하는 문법으로 Double Dot(..)을 많이 쓴다. Double Dot은 어떤 커밋들이 한쪽에는 관련됐고 다른 쪽에는 관련되지 않았는지 Git에게 물어보는 것이다. 예들 들어 범위를 설명하는 데 사용할 예제과 같은 커밋 히스토리가 있다고 가정하자.\n\nexperiment 브랜치의 커밋들 중에서 아직 master 브랜치에 Merge 하지 않은 것들만 보고 싶으면 master..experiment 라고 사용한다. 이 표현은 “master에는 없지만, experiment에는 있는 커밋” 을 의미한다. 여기에서는 설명을 쉽게 하려고 실제 조회 결과가 아니라 그림의 커밋을 의미하는 문자를 사용한다.\n\n반대로 experiment 에는 없고 master 에만 있는 커밋이 궁금하면 브랜치 순서를 거꾸로 사용한다. experiment..master 는 experiment 에는 없고 master 에만 있는 것을 알려준다.\n\nexperiment 브랜치를 Merge 할 때마다 Merge 하기 전에 무엇이 변경됐는지 확인해보고 싶을 것이다. 그리고 리모트 저장소에 Push 할 때도 마찬가지로 차이점을 확인해보고 싶을 것이다. 이럴 때 굉장히 유용하다.\n\n이 명령은 origin 저장소의 master 브랜치에는 없고 현재 Checkout 중인 브랜치에만 있는 커밋을 보여준다. Checkout 한 브랜치가 origin/master 라면 git log origin/master..HEAD 가 보여주는 커밋이 Push 하면 서버에 전송될 커밋들이다. 그리고 한쪽의 Refs를 생략하면 Git은 HEAD 라고 가정하기 때문에 git log origin/master.. 는 git log origin/master..HEAD 와 같다.\n\nDouble Dot은 간단하고 유용하지만 두 개 이상의 브랜치에는 사용할 수 없다. 그러니까 현재 작업 중인 브랜치에는 있지만 다른 여러 브랜치에는 없는 커밋을 보고 싶으면 .. 으로는 확인할 수 없다. Git은 ^ 이나 --not 옵션 뒤에 브랜치 이름을 넣으면 그 브랜치에 없는 커밋을 찾아준다. 아래의 명령 세 가지는 모두 같은 명령이다.\n\n이 옵션들은 Double Dot으로는 할 수 없는, 세 개 이상의 Refs에 사용할 수 있는 장점이 있다. 예를 들어 refA 나 refB 에는 있지만 refC 에는 없는 커밋을 보려면 아래 중 한 명령을 사용한다.\n\n이 조건을 잘 응용하면 작업 중인 브랜치와 다른 브랜치을 매우 상세하게 비교해볼 수 있다.\n\nTriple Dot은 양쪽에 있는 두 Refs 사이에서 공통으로 가지는 것을 제외하고 서로 다른 커밋만 보여준다. 범위를 설명하는 데 사용할 예제의 커밋 히스토리를 다시 보자. 만약 master 와 experiment 의 공통부분은 빼고 다른 커밋만 보고 싶으면 아래와 같이 하면 된다.\n\n우리가 아는 log 명령의 결과를 최근 날짜순으로 보여준다. 이 예제에서는 커밋을 네 개 보여준다.\n\n그리고 log 명령에 --left-right 옵션을 추가하면 각 커밋이 어느 브랜치에 속하는지도 보여주기 때문에 좀 더 이해하기 쉽다.\n\n위와 같은 명령을 사용하면 원하는 커밋을 좀 더 꼼꼼하게 살펴볼 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git log master..experiment\nD\nC\n```",
          "```bash\n$ git log experiment..master\nF\nE\n```",
          "```bash\n$ git log origin/master..HEAD\n```",
          "```bash\n$ git log refA..refB\n$ git log ^refA refB\n$ git log refB --not refA\n```",
          "```bash\n$ git log refA refB ^refC\n$ git log refA refB --not refC\n```",
          "```bash\n$ git log master...experiment\nF\nE\nD\nC\n```",
          "```bash\n$ git log --left-right master...experiment\n< F\n< E\n> D\n> C\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 13,
          "content_length": 1745
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git-도구-리비전-조회하기",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "7.2 Git 도구 - 대화형 명령",
    "summary": "대화형 명령 여기서 소개하는 몇 가지 대화형 명령을 이용하면 바로 전문가처럼 능숙하게 커밋할 수 있다. 스크립트를 통해 커밋할 파일을 고르고 수정된 파일의 일부분만 커밋할 수도 있다. 스크립트는 수정하는 파일이 매우 많아서 통째로 커밋하기 어려울 때 이슈별로 나눠서 커밋하기에 좋다. 이슈별로 나눠서 커밋하면 함께 일하는 동료가 검토하기 쉬워진다. git add 명령에 -i 나 --interactive 옵션을 주고 실행하면 Git은 아래와 같은 대화형 모드로 들어간다. $ git add -i staged unstaged path 1: unchanged +0/-1 TODO 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rb *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now> 이 명령은",
    "sections": [
      {
        "header": "대화형 명령",
        "content": "여기서 소개하는 몇 가지 대화형 명령을 이용하면 바로 전문가처럼 능숙하게 커밋할 수 있다. 스크립트를 통해 커밋할 파일을 고르고 수정된 파일의 일부분만 커밋할 수도 있다. 스크립트는 수정하는 파일이 매우 많아서 통째로 커밋하기 어려울 때 이슈별로 나눠서 커밋하기에 좋다. 이슈별로 나눠서 커밋하면 함께 일하는 동료가 검토하기 쉬워진다.\n\ngit add 명령에 -i 나 --interactive 옵션을 주고 실행하면 Git은 아래와 같은 대화형 모드로 들어간다.\n\n이 명령은 Staging Area의 현재 상태가 어떻고 할 수 있는 일이 무엇인지 보여준다. 기본적으로 git status 명령이 보여주는 것과 같지만 좀 더 간결하고 정돈돼 있다. 왼쪽에는 Staged 상태인 파일들을 보여주고 오른쪽에는 Unstaged 상태인 파일들을 보여준다.\n\n그리고 마지막 “Commands” 부분에서는 할 수 일이 무엇인지 보여준다. 파일들을 Stage하고 Unstage하는 것, Untracked 상태의 파일들을 추가하는 것, Stage한 파일을 Diff할 수 있다. 게다가 수정한 파일의 일부분만 Staging Area에 추가할 수도 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git add -i\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n*** Commands ***\n  1: status     2: update      3: revert     4: add untracked\n  5: patch      6: diff        7: quit       8: help\nWhat now>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 578
        }
      },
      {
        "header": "Staging Area에 파일 추가하고 추가 취소하기",
        "content": "What now> 프롬프트에서 2 나 u 를(update) 입력하면 Staging Area에 추가할 수 있는 파일을 전부 보여준다.\n\nTODO 와 index.html 파일을 Stage 하려면 아래와 같이 입력한다.\n\n* 표시가 붙은 파일은 Stage 하도록 선택한 것이다. 선택하고 Update>> 프롬프트에 아무것도 입력하지 않고 엔터를 치면 Git은 선택한 파일을 Staging Area로 추가한다.\n\n이제 TODO 와 index.html 파일은 Stage했고 simplegit.rb 파일만 아직 Unstaged 상태로 남아 있다. 이제 TODO 파일을 다시 Unstage 하고 싶으면 3 이나 r 을(revert) 입력한다.\n\n다시 status를 선택하면 TODO 파일이 Unstaged 상태인 것을 알 수 있다.\n\nStaged 파일들의 변경내용을 보려면 6 이나 d 를(diff) 입력한다. 그러면 먼저 Staged 상태인 파일들을 보여준다. 그리고 그중에서 파일 하나를 선택한다. 그 결과는 커맨드라인에서 git diff --cached 라고 실행한 결과와 같다.\n\n위와 같이 대화형 추가 모드를 사용하면 Staging Area에 파일들을 좀 더 쉽게 추가할 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nWhat now> 2\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nUpdate>>\n```",
          "```bash\nUpdate>> 1,2\n           staged     unstaged path\n* 1:    unchanged        +0/-1 TODO\n* 2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nUpdate>>\n```",
          "```bash\nUpdate>>\nupdated 2 paths\n\n*** Commands ***\n  1: status     2: update      3: revert     4: add untracked\n  5: patch      6: diff        7: quit       8: help\nWhat now> 1\n           staged     unstaged path\n  1:        +0/-1      nothing TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n```",
          "```bash\n*** Commands ***\n  1: status     2: update      3: revert     4: add untracked\n  5: patch      6: diff        7: quit       8: help\nWhat now> 3\n           staged     unstaged path\n  1:        +0/-1      nothing TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nRevert>> 1\n           staged     unstaged path\n* 1:        +0/-1      nothing TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nRevert>> [enter]\nreverted one path\n```",
          "```bash\n*** Commands ***\n  1: status     2: update      3: revert     4: add untracked\n  5: patch      6: diff        7: quit       8: help\nWhat now> 1\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n```",
          "```bash\n*** Commands ***\n  1: status     2: update      3: revert     4: add untracked\n  5: patch      6: diff        7: quit       8: help\nWhat now> 6\n           staged     unstaged path\n  1:        +1/-1      nothing index.html\nReview diff>> 1\ndiff --git a/index.html b/index.html\nindex 4d07108..4335f49 100644\n--- a/index.html\n+++ b/index.html\n@@ -16,7 +16,7 @@ Date Finder\n\n <p id=\"out\">...</p>\n\n-<div id=\"footer\">contact : support@github.com</div>\n+<div id=\"footer\">contact : email.support@github.com</div>\n\n <script type=\"text/javascript\">\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 603
        }
      },
      {
        "header": "파일의 일부분만 Staging Area에 추가하기",
        "content": "파일의 일부분만 Staging Area에 추가하는 것도 가능하다. 예를 들어 simplegit.rb 파일은 고친 부분이 두 군데이다. 그 중 하나를 추가하고 나머지는 그대로 두고 싶다. Git에서는 이런 작업도 매우 쉽게 할 수 있다. 대화형 프롬프트에서 5, p 를(patch) 입력한다. 그러면 Git은 부분적으로 Staging Area에 추가할 파일이 있는지 묻는다. 파일을 선택하면 파일의 특정 부분을 Staging Area에 추가할 것인지 부분별로 구분하여 묻는다.\n\n여기에서 ? 를 입력하면 선택할 수 있는 명령을 설명해준다.\n\ny 나 n 을 입력하면 각 부분을 Stage 할지 말지 결정할 수 있다. 하지만, 파일을 통째로 Stage 하거나 필요할 때까지 아예 그대로 남겨 두는 것이 다음부터 더 유용할지도 모른다. 어쨌든 파일의 어떤 부분은 Stage 하고 다른 부분은 Unstaged 상태로 남겨놓고 status 명령으로 확인해보면 결과는 아래와 같다.\n\nsimplegit.rb 파일의 상태를 보자. 어떤 라인은 Staged 상태이고 어떤 라인은 Unstaged라고 알려줄 것이다. 이 파일의 일부를 Stage 했다. 이제 대화형 모드를 종료하고 일부분만 Stage 한 파일을 커밋할 수 있다.\n\n대화형 스크립트로만 파일 일부분을 Stage 할 수 있는 것은 아니다. git add -p 나 git add --patch 로도 같은 일을 할 수 있다.\n\ngit reset --patch 명령을 사용해서 파일 일부만 Stage Area에서 내릴 수 있다. 또, git checkout --patch 를 사용해서 파일 일부를 다시 Checkout 받을 수 있다. git stash save --patch 명령으로는 파일 일부만 Stash 할 수 있다. 각 명령에 대해서 더 자세히 알아보자",
        "code_examples": [
          "```bash\nStage this hunk [y,n,a,d,/,j,J,g,e,?]? ?\ny - stage this hunk\nn - do not stage this hunk\na - stage this and all the remaining hunks in the file\nd - do not stage this hunk nor any of the remaining hunks in the file\ng - select a hunk to go to\n/ - search for a hunk matching the given regex\nj - leave this hunk undecided, see next undecided hunk\nJ - leave this hunk undecided, see next hunk\nk - leave this hunk undecided, see previous undecided hunk\nK - leave this hunk undecided, see previous hunk\ns - split the current hunk into smaller hunks\ne - manually edit the current hunk\n? - print help\n```"
        ],
        "usage_examples": [
          "```bash\ndiff --git a/lib/simplegit.rb b/lib/simplegit.rb\nindex dd5ecc4..57399e0 100644\n--- a/lib/simplegit.rb\n+++ b/lib/simplegit.rb\n@@ -22,7 +22,7 @@ class SimpleGit\n   end\n\n   def log(treeish = 'master')\n-    command(\"git log -n 25 #{treeish}\")\n+    command(\"git log -n 30 #{treeish}\")\n   end\n\n   def blame(path)\nStage this hunk [y,n,a,d,/,j,J,g,e,?]?\n```",
          "```bash\nWhat now> 1\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:        +1/-1      nothing index.html\n  3:        +1/-1        +4/-0 lib/simplegit.rb\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 895
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git-도구-대화형-명령",
    "doc_type": "git",
    "total_sections": 3
  },
  {
    "title": "7.3 Git 도구 - Stashing과 Cleaning",
    "summary": "Stashing과 Cleaning 당신이 어떤 프로젝트에서 한 부분을 담당하고 있다고 하자. 그리고 여기에서 뭔가 작업하던 일이 있고 다른 요청이 들어와서 잠시 브랜치를 변경해야 할 일이 생겼다고 치자. 그런데 이런 상황에서 아직 완료하지 않은 일을 커밋하는 것이 껄끄럽다는 것이 문제다. 커밋하지 않고 나중에 다시 돌아와서 작업을 다시 하고 싶을 것이다. 이 문제는 git stash 라는 명령으로 해결할 수 있다. Stash 명령을 사용하면 워킹 디렉토리에서 수정한 파일들만 저장한다. Stash는 Modified이면서 Tracked 상태인 파일과 Staging Area에 있는 파일들을 보관해두는 장소다. 아직 끝내지 않은 수정사항을 스택에 잠시 저장했다가 나중에 다시 적용할 수 있다(브랜치가 달라져도 말이다). 노트 git stash push 로의 이동 2017년 10월 말 Git 메일링 리스트에는 엄청난 논의가 있었습니다. 논의는 git stash save 명령을 은퇴시키고 git",
    "sections": [
      {
        "header": "Stashing과 Cleaning",
        "content": "당신이 어떤 프로젝트에서 한 부분을 담당하고 있다고 하자. 그리고 여기에서 뭔가 작업하던 일이 있고 다른 요청이 들어와서 잠시 브랜치를 변경해야 할 일이 생겼다고 치자. 그런데 이런 상황에서 아직 완료하지 않은 일을 커밋하는 것이 껄끄럽다는 것이 문제다. 커밋하지 않고 나중에 다시 돌아와서 작업을 다시 하고 싶을 것이다. 이 문제는 git stash 라는 명령으로 해결할 수 있다.\n\nStash 명령을 사용하면 워킹 디렉토리에서 수정한 파일들만 저장한다. Stash는 Modified이면서 Tracked 상태인 파일과 Staging Area에 있는 파일들을 보관해두는 장소다. 아직 끝내지 않은 수정사항을 스택에 잠시 저장했다가 나중에 다시 적용할 수 있다(브랜치가 달라져도 말이다).\n\n2017년 10월 말 Git 메일링 리스트에는 엄청난 논의가 있었습니다. 논의는 git stash save 명령을 은퇴시키고 git stash push 로 대체하는 내용에 대한 것이었습니다. git stash push 명령의 경우 pathspec 으로 선택하여 Stash하는 옵션이 추가되었는데 git stash save 명령이 지원하지 못하는 것이었습니다.\n\ngit stash save 명령이 곧바로 삭제되는 것은 아니기에 아직 이 명령을 쓰는 것에 대해 걱정할 필요는 없지만 git stash push 명령으로 대체하는 것에 대해 생각해볼 필요가 있습니다.\n\n노트 | git stash push 로의 이동 2017년 10월 말 Git 메일링 리스트에는 엄청난 논의가 있었습니다. 논의는 git stash save 명령을 은퇴시키고 git stash push 로 대체하는 내용에 대한 것이었습니다. git stash push 명령의 경우 pathspec 으로 선택하여 Stash하는 옵션이 추가되었는데 git stash save 명령이 지원하지 못하는 것이었습니다. git stash save 명령이 곧바로 삭제되는 것은 아니기에 아직 이 명령을 쓰는 것에 대해 걱정할 필요는 없지만 git stash push 명령으로 대체하는 것에 대해 생각해볼 필요가 있습니다.\n\n[Note] 노트 git stash push 로의 이동 2017년 10월 말 Git 메일링 리스트에는 엄청난 논의가 있었습니다. 논의는 git stash save 명령을 은퇴시키고 git stash push 로 대체하는 내용에 대한 것이었습니다. git stash push 명령의 경우 pathspec 으로 선택하여 Stash하는 옵션이 추가되었는데 git stash save 명령이 지원하지 못하는 것이었습니다. git stash save 명령이 곧바로 삭제되는 것은 아니기에 아직 이 명령을 쓰는 것에 대해 걱정할 필요는 없지만 git stash push 명령으로 대체하는 것에 대해 생각해볼 필요가 있습니다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 4,
          "content_length": 1384
        }
      },
      {
        "header": "하던 일을 Stash 하기",
        "content": "예제 프로젝트를 하나 살펴보자. 파일을 두 개 수정하고 그 중 하나는 Staging Area에 추가한다. 그리고 git status 명령을 실행하면 아래와 같은 결과를 볼 수 있다.\n\n이제 브랜치를 변경해 보자. 아직 작업 중인 파일은 커밋할 게 아니라서 모두 Stash 한다. git stash 나 git stash save 를 실행하면 스택에 새로운 Stash가 만들어진다.\n\n이제 아무 브랜치나 골라서 쉽게 바꿀 수 있다. 수정하던 것을 스택에 저장했다. 아래와 같이 git stash list 를 사용하여 저장한 Stash를 확인한다.\n\nStash 두 개는 원래 있었다. 그래서 현재 총 세 개의 Stash를 사용할 수 있다. 이제 git stash apply 를 사용하여 Stash를 다시 적용할 수 있다. git stash 명령을 실행하면 Stash를 다시 적용하는 방법도 알려줘서 편리하다. git stash apply stash@{2} 처럼 Stash 이름을 입력하면 골라서 적용할 수 있다. 이름이 없으면 Git은 가장 최근의 Stash를 적용한다.\n\nGit은 Stash에 저장할 때 수정했던 파일들을 복원해준다. 복원할 때의 워킹 디렉토리는 Stash 할 때의 그 브랜치이고 워킹 디렉토리도 깨끗한 상태였다. 하지만 꼭 깨끗한 워킹 디렉토리나 Stash 할 때와 같은 브랜치에 적용해야 하는 것은 아니다. 어떤 브랜치에서 Stash 하고 다른 브랜치로 옮기고서 거기에 Stash를 복원할 수 있다. 그리고 꼭 워킹 디렉토리가 깨끗한 상태일 필요도 없다. 워킹 디렉토리에 수정하고 커밋하지 않은 파일들이 있을 때도 Stash를 적용할 수 있다. 만약 충돌이 있으면 알려준다.\n\nGit은 Stash를 적용할 때 Staged 상태였던 파일을 자동으로 다시 Staged 상태로 만들어 주지 않는다. 그래서 git stash apply 명령을 실행할 때 --index 옵션을 주어 Staged 상태까지 적용한다. 그래야 원래 작업하던 상태로 돌아올 수 있다.\n\napply 옵션은 단순히 Stash를 적용하는 것뿐이다. Stash는 여전히 스택에 남아 있다. git stash drop 명령을 사용하여 해당 Stash를 제거한다.\n\n그리고 git stash pop 이라는 명령도 있는데 이 명령은 Stash를 적용하고 나서 바로 스택에서 제거해준다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git status\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n  modified:   index.html\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n  modified:   lib/simplegit.rb\n```",
          "```bash\n$ git stash\nSaved working directory and index state \\\n  \"WIP on master: 049d078 added the index file\"\nHEAD is now at 049d078 added the index file\n(To restore them type \"git stash apply\")\n```",
          "```bash\n$ git status\n# On branch master\nnothing to commit, working directory clean\n```",
          "```bash\n$ git stash list\nstash@{0}: WIP on master: 049d078 added the index file\nstash@{1}: WIP on master: c264051 Revert \"added file_size\"\nstash@{2}: WIP on master: 21d80a5 added number to log\n```",
          "```bash\n$ git stash apply\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n  modified:   index.html\n  modified:   lib/simplegit.rb\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```",
          "```bash\n$ git stash apply --index\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n  modified:   index.html\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n  modified:   lib/simplegit.rb\n```",
          "```bash\n$ git stash list\nstash@{0}: WIP on master: 049d078 added the index file\nstash@{1}: WIP on master: c264051 Revert \"added file_size\"\nstash@{2}: WIP on master: 21d80a5 added number to log\n$ git stash drop stash@{0}\nDropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1151
        }
      },
      {
        "header": "Stash를 만드는 새로운 방법",
        "content": "Stash를 만드는 방법은 여러 가지다. 주로 사용하는 옵션으로 stash save 명령과 같이 쓰는 --keep-index 이다. 이 옵션을 이용하면 이미 Staging Area에 들어 있는 파일을 Stash 하지 않는다.\n\n추적하지 않는 파일과 추적 중인 파일을 같이 Stash 하는 일도 꽤 빈번하다. 기본적으로 git stash 는 추적 중인 파일만 저장한다. 추적 중이지 않은 파일을 같이 저장하려면 Stash 명령을 사용할 때 --include-untracked 나 -u 옵션을 붙여준다.\n\n끝으로 --patch 옵션을 붙이면 Git은 수정된 모든 사항을 저장하지 않는다. 대신 대화형 프롬프트가 뜨며 변경된 데이터 중 저장할 것과 저장하지 않을 것을 지정할 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git status -s\nM  index.html\n M lib/simplegit.rb\n\n$ git stash --keep-index\nSaved working directory and index state WIP on master: 1b65b17 added the index file\nHEAD is now at 1b65b17 added the index file\n\n$ git status -s\nM  index.html\n```",
          "```bash\n$ git status -s\nM  index.html\n M lib/simplegit.rb\n?? new-file.txt\n\n$ git stash -u\nSaved working directory and index state WIP on master: 1b65b17 added the index file\nHEAD is now at 1b65b17 added the index file\n\n$ git status -s\n$\n```",
          "```bash\n$ git stash --patch\ndiff --git a/lib/simplegit.rb b/lib/simplegit.rb\nindex 66d332e..8bb5674 100644\n--- a/lib/simplegit.rb\n+++ b/lib/simplegit.rb\n@@ -16,6 +16,10 @@ class SimpleGit\n         return `#{git_cmd} 2>&1`.chomp\n       end\n     end\n+\n+    def show(treeish = 'master')\n+      command(\"git show #{treeish}\")\n+    end\n\n end\n test\nStash this hunk [y,n,q,a,d,/,e,?]? y\n\nSaved working directory and index state WIP on master: 1b65b17 added the index file\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 380
        }
      },
      {
        "header": "Stash를 적용한 브랜치 만들기",
        "content": "보통 Stash에 저장하면 한동안 그대로 유지한 채로 그 브랜치에서 계속 새로운 일을 한다. 그러면 이제 저장한 Stash를 적용하는 것이 문제가 된다. 수정한 파일에 Stash를 적용하면 충돌이 일어날 수도 있고 그러면 또 충돌을 해결해야 한다. 필요한 것은 Stash 한 것을 쉽게 다시 테스트하는 것이다. git stash branch <브랜치> 명령을 실행하면 Stash 할 당시의 커밋을 Checkout 한 후 새로운 브랜치를 만들고 여기에 적용한다. 이 모든 것이 성공하면 Stash를 삭제한다.\n\n이 명령은 브랜치를 새로 만들고 Stash를 복원해주는 매우 편리한 도구다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git stash branch testchanges\nM index.html\nM lib/simplegit.rb\nSwitched to a new branch 'testchanges'\nOn branch testchanges\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n  modified:   index.html\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n  modified:   lib/simplegit.rb\n\nDropped refs/stash@{0} (29d385a81d163dfd45a452a2ce816487a6b8b014)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 327
        }
      },
      {
        "header": "워킹 디렉토리 청소하기",
        "content": "작업하고 있던 파일을 Stash 하지 않고 단순히 그 파일들을 치워버리고 싶을 때가 있다. git clean 명령이 그 일을 한다.\n\n보통은 Merge나 외부 도구가 만들어낸 파일을 지우거나 이전 빌드 작업으로 생성된 각종 파일을 지우는 데 필요하다.\n\n이 명령을 사용할 때는 신중해야 한다. 이 명령을 사용하면 워킹 디렉토리 안의 추적하고 있지 않은 모든 파일이 지워지기 때문이다. 명령을 실행하고 나서 후회해도 소용없다. 지워진 파일은 돌아오지 않는다. git stash –all 명령을 이용하면 지우는 건 똑같지만, 먼저 모든 파일을 Stash 하므로 좀 더 안전하다.\n\n워킹 디렉토리의 불필요한 파일들을 전부 지우려면 git clean 을 사용한다. 추적 중이지 않은 모든 정보를 워킹 디렉토리에서 지우고 싶다면 git clean -f -d 명령을 사용하자. 이 명령은 하위 디렉토리까지 모두 지워버린다. -f 옵션은 강제(force)의 의미이며 \"진짜로 그냥 해라\"라는 뜻이다.\n\n이 명령을 실행했을 때 어떤 일이 일어날지 미리 보고 싶다면 -n 옵션을 사용한다. -n 옵션은 “가상으로 실행해보고 어떤 파일들이 지워질지 알려달라” 라는 뜻이다.\n\ngit clean 명령은 추적 중이지 않은 파일만 지우는 게 기본 동작이다. .gitignore 에 명시했거나 해서 무시되는 파일은 지우지 않는다. 무시된 파일까지 함께 지우려면 -x 옵션이 필요하다. 그래서 .o 파일 같은 빌드 파일까지도 지울 수 있다.\n\ngit clean 이 무슨 짓을 할지 확신이 안들 때는 항상 -n 옵션을 붙여서 먼저 실행해보자. clean 명령을 대화형으로 실행하려면 -i 옵션을 붙이면 된다.\n\n대화형으로 실행한 clean 명령의 모습은 아래와 같다.\n\n대화형으로 실행하면 파일마다 지우지 말지 결정하거나 특정 패턴으로 걸러서 지울 수도 있다.\n\n작업하던 저장소가 완전 지저분해져서 Git에게 진짜로 강제로 정리하도록 해야 하는 경우가 생길 수 있다. 예를 들어 Git 버전관리 데이터가 포함된 디렉토리를 복사해왔거나 서브모듈 디렉토리에 문제가 생겼거나 하는 경우 git clean -fd 옵션으로 실행한 명령이라도 디렉토리 삭제가 되지 않는 경우가 있다. 이런 경우에는 -f 옵션을 한번 더 사용하여 강제성을 추가로 주어야 한다.\n\n노트 | 작업하던 저장소가 완전 지저분해져서 Git에게 진짜로 강제로 정리하도록 해야 하는 경우가 생길 수 있다. 예를 들어 Git 버전관리 데이터가 포함된 디렉토리를 복사해왔거나 서브모듈 디렉토리에 문제가 생겼거나 하는 경우 git clean -fd 옵션으로 실행한 명령이라도 디렉토리 삭제가 되지 않는 경우가 있다. 이런 경우에는 -f 옵션을 한번 더 사용하여 강제성을 추가로 주어야 한다.\n\n[Note] 노트 작업하던 저장소가 완전 지저분해져서 Git에게 진짜로 강제로 정리하도록 해야 하는 경우가 생길 수 있다. 예를 들어 Git 버전관리 데이터가 포함된 디렉토리를 복사해왔거나 서브모듈 디렉토리에 문제가 생겼거나 하는 경우 git clean -fd 옵션으로 실행한 명령이라도 디렉토리 삭제가 되지 않는 경우가 있다. 이런 경우에는 -f 옵션을 한번 더 사용하여 강제성을 추가로 주어야 한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git clean -d -n\nWould remove test.o\nWould remove tmp/\n```",
          "```bash\n$ git status -s\n M lib/simplegit.rb\n?? build.TMP\n?? tmp/\n\n$ git clean -n -d\nWould remove build.TMP\nWould remove tmp/\n\n$ git clean -n -d -x\nWould remove build.TMP\nWould remove test.o\nWould remove tmp/\n```",
          "```bash\n$ git clean -x -i\nWould remove the following items:\n  build.TMP  test.o\n*** Commands ***\n    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit\n    6: help\nWhat now>\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 10,
          "content_length": 1579
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git-도구-Stashing과-Cleaning",
    "doc_type": "git",
    "total_sections": 5
  },
  {
    "title": "7.4 Git 도구 - 내 작업에 서명하기",
    "summary": "내 작업에 서명하기 Git은 암호학적으로 안전하다. 하지만, 그냥 되는 건 아니다. 저장소에 아무나 접근하지 못하게 하고 진짜로 확인된 사람에게서만 커밋을 받으려면 GPG를 이용한다. GPG 소개 우선 뭔가를 서명 하려면, GPG 설정도 하고 개인키도 설치해야 한다. $ gpg --list-keys /Users/schacon/.gnupg/pubring.gpg --------------------------------- pub 2048R/0A46826A 2014-06-04 uid Scott Chacon (Git signing key) <schacon@gmail.com> sub 2048R/874529A9 2014-06-04 가진 키가 없으면 키를 새로 만들어야 한다. 키를 만들려면 gpg --genkey 명령을 실행한다. $ gpg --gen-key 서명에 사용할 수 있는 개인키가 이미 있다면 Git 설정 중에 user.signingkey 로 설정해서 사용할 수 있다. $ git con",
    "sections": [
      {
        "header": "내 작업에 서명하기",
        "content": "Git은 암호학적으로 안전하다. 하지만, 그냥 되는 건 아니다. 저장소에 아무나 접근하지 못하게 하고 진짜로 확인된 사람에게서만 커밋을 받으려면 GPG를 이용한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 91
        }
      },
      {
        "header": "GPG 소개",
        "content": "우선 뭔가를 서명 하려면, GPG 설정도 하고 개인키도 설치해야 한다.\n\n가진 키가 없으면 키를 새로 만들어야 한다. 키를 만들려면 gpg --genkey 명령을 실행한다.\n\n서명에 사용할 수 있는 개인키가 이미 있다면 Git 설정 중에 user.signingkey 로 설정해서 사용할 수 있다.\n\n설정하고 나면 이제 Git은 태그와 커밋에 서명할 때 등록한 키를 사용한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ gpg --list-keys\n/Users/schacon/.gnupg/pubring.gpg\n---------------------------------\npub   2048R/0A46826A 2014-06-04\nuid                  Scott Chacon (Git signing key) <schacon@gmail.com>\nsub   2048R/874529A9 2014-06-04\n```",
          "```bash\n$ gpg --gen-key\n```",
          "```bash\n$ git config --global user.signingkey 0A46826A\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 209
        }
      },
      {
        "header": "태그 서명하기",
        "content": "GPG 개인키 설정을 마쳤으면 새로 만드는 태그들에 서명할 수 있다. 서명하려면 -a 대신 -s 만 쓰면 된다.\n\n태그를 git show 명령으로 보면, GPG 서명이 붙어 있는 걸 볼 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git tag -s v1.5 -m 'my signed 1.5 tag'\n\nYou need a passphrase to unlock the secret key for\nuser: \"Ben Straub <ben@straub.cc>\"\n2048-bit RSA key, ID 800430EB, created 2014-05-04\n```",
          "```bash\n$ git show v1.5\ntag v1.5\nTagger: Ben Straub <ben@straub.cc>\nDate:   Sat May 3 20:29:41 2014 -0700\n\nmy signed 1.5 tag\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQEcBAABAgAGBQJTZbQlAAoJEF0+sviABDDrZbQH/09PfE51KPVPlanr6q1v4/Ut\nLQxfojUWiLQdg2ESJItkcuweYg+kc3HCyFejeDIBw9dpXt00rY26p05qrpnG+85b\nhM1/PswpPLuBSr+oCIDj5GMC2r2iEKsfv2fJbNW8iWAXVLoWZRF8B0MfqX/YTMbm\necorc4iXzQu7tupRihslbNkfvfciMnSDeSvzCpWAHl7h8Wj6hhqePmLm9lAYqnKp\n8S5B/1SSQuEAjRZgI4IexpZoeKGVDptPHxLLS38fozsyi0QyDyzEgJxcJQVMXxVi\nRUysgqjcpT8+iQM1PblGfHR4XAhuOqN5Fx06PSaFZhqvWFezJ28/CLyX5q+oIVk=\n=EFTF\n-----END PGP SIGNATURE-----\n\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 109
        }
      },
      {
        "header": "태그 확인하기",
        "content": "git tag -v <tag-name> 명령을 이용해 태그에 서명한 사람이 정말 그 사람이 맞는지 확인한다. 이 명령은 서명을 확인하기 위해 GPG를 사용한다. 확인 작업을 하려면 서명한 사람의 GPG 공개키를 키 관리 시스템에 등록해두어야 한다.\n\n서명한 사람의 공개키가 없으면 아래와 같은 메시지가 나타난다.",
        "code_examples": [
          "```bash\ngpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A\ngpg: Can't check signature: public key not found\nerror: could not verify the tag 'v1.4.2.1'\n```"
        ],
        "usage_examples": [
          "```bash\n$ git tag -v v1.4.2.1\nobject 883653babd8ee7ea23e6a5c392bb739348b1eb61\ntype commit\ntag v1.4.2.1\ntagger Junio C Hamano <junkio@cox.net> 1158138501 -0700\n\nGIT 1.4.2.1\n\nMinor fixes since 1.4.2, including git-mv and git-http with alternates.\ngpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A\ngpg: Good signature from \"Junio C Hamano <junkio@cox.net>\"\ngpg:                 aka \"[jpeg image of size 1513]\"\nPrimary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 174
        }
      },
      {
        "header": "커밋에 서명하기",
        "content": "최신 버전(v1.7.9 이상)의 Git은 커밋에도 서명할 수 있다. 커밋에 서명하고 싶으면 git commit 명령에 -S 옵션만 붙여주면 된다.\n\n서명을 확인하려면 git log 명령에 --show-signature 옵션을 붙여주자.\n\ngit log 로 출력한 로그에서 커밋에 대한 서명 정보를 알려면 %G? 포맷을 이용한다.\n\n위 로그에서 제일 최근 커밋만 올바르게 서명한 커밋이라는 것을 확인할 수 있다. 다른 커밋들은 서명하지 않았다.\n\n1.8.3 버전 이후의 Git에서는 git merge 와 git pull 에서 GPG 서명 정보를 이용해 Merge를 허용하지 않을 수 있다. --verify-signatures 옵션으로 이 기능을 사용할 수 있다.\n\nMerge 할 때 --verify-signatures 옵션을 붙이면 Merge 할 커밋 중 서명하지 않았거나 신뢰할 수 없는 사람이 서명한 커밋이 있으면 Merge 되지 않는다.\n\nMerge 할 커밋 전부가 신뢰할 수 있는 사람에 의해 서명된 커밋이면 모든 서명을 출력하고 Merge를 수행한다.\n\ngit merge 명령에도 -S 옵션을 붙일 수 있다. 이 옵션을 붙이면 Merge 커밋을 서명하겠다는 의미이다. 아래 예제에서 Merge 할 모든 커밋이 올바르게 서명됐는지 확인하고 Merge 커밋에도 서명을 하는 것을 보자.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git commit -a -S -m 'signed commit'\n\nYou need a passphrase to unlock the secret key for\nuser: \"Scott Chacon (Git signing key) <schacon@gmail.com>\"\n2048-bit RSA key, ID 0A46826A, created 2014-06-04\n\n[master 5c3386c] signed commit\n 4 files changed, 4 insertions(+), 24 deletions(-)\n rewrite Rakefile (100%)\n create mode 100644 lib/git.rb\n```",
          "```bash\n$ git log --show-signature -1\ncommit 5c3386cf54bba0a33a32da706aa52bc0155503c2\ngpg: Signature made Wed Jun  4 19:49:17 2014 PDT using RSA key ID 0A46826A\ngpg: Good signature from \"Scott Chacon (Git signing key) <schacon@gmail.com>\"\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Wed Jun 4 19:49:17 2014 -0700\n\n    signed commit\n```",
          "```bash\n$ git log --pretty=\"format:%h %G? %aN  %s\"\n\n5c3386c G Scott Chacon  signed commit\nca82a6d N Scott Chacon  changed the version number\n085bb3b N Scott Chacon  removed unnecessary test code\na11bef0 N Scott Chacon  first commit\n```",
          "```bash\n$ git merge --verify-signatures non-verify\nfatal: Commit ab06180 does not have a GPG signature.\n```",
          "```bash\n$ git merge --verify-signatures signed-branch\nCommit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) <schacon@gmail.com>\nUpdating 5c3386c..13ad65e\nFast-forward\n README | 2 ++\n 1 file changed, 2 insertions(+)\n```",
          "```bash\n$ git merge --verify-signatures -S  signed-branch\nCommit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) <schacon@gmail.com>\n\nYou need a passphrase to unlock the secret key for\nuser: \"Scott Chacon (Git signing key) <schacon@gmail.com>\"\n2048-bit RSA key, ID 0A46826A, created 2014-06-04\n\nMerge made by the 'recursive' strategy.\n README | 2 ++\n 1 file changed, 2 insertions(+)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 665
        }
      },
      {
        "header": "모두가 서명하게 하려면",
        "content": "태그와 커밋에 서명하는 것은 멋지지만 실제로 서명 기능을 사용하려면 팀의 모든 사람이 서명 기능을 이해하고 사용해야만 한다. 만약 그렇지 않으면 팀원들에게 커밋을 어떻게 서명된 커밋으로 재생성하는지 가르치느라 세월을 보내게 될 것이다. 반드시 작업에 적용하기 전에 GPG 서명 기능을 이해하고 이 기능이 가지는 장점을 완전히 파악하고 있어야만 한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 195
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git-도구-내-작업에-서명하기",
    "doc_type": "git",
    "total_sections": 6
  },
  {
    "title": "7.5 Git 도구 - 검색",
    "summary": "검색 프로젝트가 크든 작든 함수의 정의나 함수가 호출되는 곳을 검색해야 하는 경우가 많다. 함수의 히스토리를 찾아보기도 한다. Git은 데이터베이스에 저장된 코드나 커밋에서 원하는 부분을 빠르고 쉽게 검색하는 도구가 여러 가지 있으며 앞으로 함께 살펴보자. Git Grep Git의 grep 명령을 이용하면 커밋 트리의 내용이나 워킹 디렉토리의 내용을 문자열이나 정규표현식을 이용해 쉽게 찾을 수 있다. Git 소스를 예로 들어 명령을 어떻게 사용하는지 알아보자. 기본적으로 대상을 지정하지 않으면 워킹 디렉토리의 파일에서 찾는다. 명령을 실행할 때 -n 또는 --line-number 옵션을 추가하면 찾을 문자열이 위치한 라인 번호도 같이 출력한다. $ git grep -n gmtime_r compat/gmtime.c:3:#undef gmtime_r compat/gmtime.c:8: return git_gmtime_r(timep, &result); compat/gmtime.c:11:str",
    "sections": [
      {
        "header": "검색",
        "content": "프로젝트가 크든 작든 함수의 정의나 함수가 호출되는 곳을 검색해야 하는 경우가 많다. 함수의 히스토리를 찾아보기도 한다. Git은 데이터베이스에 저장된 코드나 커밋에서 원하는 부분을 빠르고 쉽게 검색하는 도구가 여러 가지 있으며 앞으로 함께 살펴보자.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 140
        }
      },
      {
        "header": "Git Grep",
        "content": "Git의 grep 명령을 이용하면 커밋 트리의 내용이나 워킹 디렉토리의 내용을 문자열이나 정규표현식을 이용해 쉽게 찾을 수 있다. Git 소스를 예로 들어 명령을 어떻게 사용하는지 알아보자.\n\n기본적으로 대상을 지정하지 않으면 워킹 디렉토리의 파일에서 찾는다. 명령을 실행할 때 -n 또는 --line-number 옵션을 추가하면 찾을 문자열이 위치한 라인 번호도 같이 출력한다.\n\ngit grep 명령에서 쓸만한 몇 가지 옵션을 좀 더 살펴보자.\n\n예를 들어 위의 결과 대신 어떤 파일에서 몇 개나 찾았는지만 알고 싶다면 -c 또는 --count 옵션을 이용한다.\n\n매칭되는 라인이 있는 함수나 메서드를 찾고 싶다면 -p 또는 --show-function 옵션을 준다.\n\ngmtime_r 함수를 date.c 파일에서 match_multi_number, match_digit 함수에서 호출하고 있다는 걸 확인할 수 있다(세 번째로 호출하는 결과는 주석 안에 있는 것을 확인할 수 있다).\n\n--and 옵션을 이용해서 여러 단어가 한 라인에 동시에 나타나는 줄 찾기 같은 복잡한 조합으로 검색할 수 있다. 예를 들어 “LINK” 나 “BUF_MAX” 둘 중 하나를 포함한 상수 정의를 1.8.0 이전 버전의 Git 소스 코드에서 검색하는 것을 할 수 있다(--break 와 --heading 옵션을 붙여 더 읽기 쉬운 형태로 잘라서 출력할 수도 있다).\n\ngit grep 명령은 grep 이나 ack 같은 일반적인 검색 도구보다 몇 가지 좋은 점이 있다. 우선 매우 빠르다. 또한, 워킹 디렉토리만이 아니라 Git 히스토리 내의 어떠한 정보라도 찾아낼 수 있다. 위의 예제에서 이전 버전의 소스에서도 특정 단어를 찾아낸 것을 볼 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git grep -n gmtime_r\ncompat/gmtime.c:3:#undef gmtime_r\ncompat/gmtime.c:8:      return git_gmtime_r(timep, &result);\ncompat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm *result)\ncompat/gmtime.c:16:     ret = gmtime_r(timep, result);\ncompat/mingw.c:826:struct tm *gmtime_r(const time_t *timep, struct tm *result)\ncompat/mingw.h:206:struct tm *gmtime_r(const time_t *timep, struct tm *result);\ndate.c:482:             if (gmtime_r(&now, &now_tm))\ndate.c:545:             if (gmtime_r(&time, tm)) {\ndate.c:758:             /* gmtime_r() in match_digit() may have clobbered it */\ngit-compat-util.h:1138:struct tm *git_gmtime_r(const time_t *, struct tm *);\ngit-compat-util.h:1140:#define gmtime_r git_gmtime_r\n```",
          "```bash\n$ git grep --count gmtime_r\ncompat/gmtime.c:4\ncompat/mingw.c:1\ncompat/mingw.h:1\ndate.c:3\ngit-compat-util.h:2\n```",
          "```bash\n$ git grep -p gmtime_r *.c\ndate.c=static int match_multi_number(timestamp_t num, char c, const char *date,\ndate.c:         if (gmtime_r(&now, &now_tm))\ndate.c=static int match_digit(const char *date, struct tm *tm, int *offset, int *tm_gmt)\ndate.c:         if (gmtime_r(&time, tm)) {\ndate.c=int parse_date_basic(const char *date, timestamp_t *timestamp, int *offset)\ndate.c:         /* gmtime_r() in match_digit() may have clobbered it */\n```",
          "```bash\n$ git grep --break --heading \\\n    -n -e '#define' --and \\( -e LINK -e BUF_MAX \\) v1.8.0\nv1.8.0:builtin/index-pack.c\n62:#define FLAG_LINK (1u<<20)\n\nv1.8.0:cache.h\n73:#define S_IFGITLINK  0160000\n74:#define S_ISGITLINK(m)       (((m) & S_IFMT) == S_IFGITLINK)\n\nv1.8.0:environment.c\n54:#define OBJECT_CREATION_MODE OBJECT_CREATION_USES_HARDLINKS\n\nv1.8.0:strbuf.c\n326:#define STRBUF_MAXLINK (2*PATH_MAX)\n\nv1.8.0:symlinks.c\n53:#define FL_SYMLINK  (1 << 2)\n\nv1.8.0:zlib.c\n30:/* #define ZLIB_BUF_MAX ((uInt)-1) */\n31:#define ZLIB_BUF_MAX ((uInt) 1024 * 1024 * 1024) /* 1GB */\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 860
        }
      },
      {
        "header": "Git 로그 검색",
        "content": "어떤 변수가 어디에 있는지를 찾아보는 게 아니라, 히스토리에서 언제 추가되거나 변경됐는지 찾아볼 수도 있다. git log 명령을 이용하면 Diff 내용도 검색하여 어떤 커밋에서 찾고자 하는 내용을 추가했는지 찾을 수 있다.\n\nZLIB_BUF_MAX 라는 상수가 가장 처음 나타난 때를 찾는 문제라면 -S 옵션(“pickaxe(곡괭이)” 옵션이라 한다)을 이용해 해당 문자열이 추가된 커밋과 없어진 커밋만 검색할 수 있다.\n\n위 두 커밋의 변경 사항을 살펴보면 ef49a7a 에서 ZLIB_BUF_MAX 상수가 처음 나오고 e01503b 에서는 변경된 것을 알 수 있다.\n\n더 세세한 조건을 걸어 찾고 싶다면 로그를 검색할 때 -G 옵션으로 정규표현식을 써서 검색하면 된다.\n\n진짜 미친 듯이 좋은 로그 검색 도구가 또 있다. 라인 히스토리 검색이다. git log 를 쓸 때 -L 옵션을 붙이면 어떤 함수나 한 라인의 히스토리를 볼 수 있다.\n\n예를 들어, zlib.c 파일에 있는 git_deflate_bound 함수의 모든 변경 사항들을 보길 원한다고 생각해보자. git log -L :git_deflate_bound:zlib.c 라고 명령 실행하면 된다. 이 명령을 실행하면 함수의 시작과 끝을 인식해서 함수에서 일어난 모든 히스토리를 함수가 처음 만들어진 때부터 Patch를 나열하여 보여준다.\n\nGit이 함수의 처음과 끝을 인식하지 못할 때는 정규표현식으로 인식하게 할 수도 있다. git log -L '/unsigned long git_deflate_bound/',/^}/:zlib.c 명령으로 위와 같은 결과를 볼 수 있다. 한 라인의 히스토리만 검색할 수도 있고 여러 라인에 걸친 히스토리를 검색할 수도 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git log -S ZLIB_BUF_MAX --oneline\ne01503b zlib: allow feeding more than 4GB in one go\nef49a7a zlib: zlib can only process 4GB at a time\n```",
          "```bash\n$ git log -L :git_deflate_bound:zlib.c\ncommit ef49a7a0126d64359c974b4b3b71d7ad42ee3bca\nAuthor: Junio C Hamano <gitster@pobox.com>\nDate:   Fri Jun 10 11:52:15 2011 -0700\n\n    zlib: zlib can only process 4GB at a time\n\ndiff --git a/zlib.c b/zlib.c\n--- a/zlib.c\n+++ b/zlib.c\n@@ -85,5 +130,5 @@\n-unsigned long git_deflate_bound(z_streamp strm, unsigned long size)\n+unsigned long git_deflate_bound(git_zstream *strm, unsigned long size)\n {\n-       return deflateBound(strm, size);\n+       return deflateBound(&strm->z, size);\n }\n\n\ncommit 225a6f1068f71723a910e8565db4e252b3ca21fa\nAuthor: Junio C Hamano <gitster@pobox.com>\nDate:   Fri Jun 10 11:18:17 2011 -0700\n\n    zlib: wrap deflateBound() too\n\ndiff --git a/zlib.c b/zlib.c\n--- a/zlib.c\n+++ b/zlib.c\n@@ -81,0 +85,5 @@\n+unsigned long git_deflate_bound(z_streamp strm, unsigned long size)\n+{\n+       return deflateBound(strm, size);\n+}\n+\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 854
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git-도구-검색",
    "doc_type": "git",
    "total_sections": 3
  },
  {
    "title": "7.6 Git 도구 - 히스토리 단장하기",
    "summary": "히스토리 단장하기 Git으로 일하다 보면 어떤 이유로든 로컬 커밋 히스토리를 수정해야 할 때가 있다. 결정을 나중으로 미룰 수 있던 것은 Git의 장점이다. Staging Area로 커밋할 파일을 고르는 일을 커밋하는 순간으로 미룰 수 있고 Stash 명령으로 하던 일을 미룰 수 있다. 게다가 이미 커밋해서 결정한 내용을 수정할 수 있다. 그리고 수정할 수 있는 것도 매우 다양하다. 커밋들의 순서도 변경할 수 있고 커밋 메시지와 커밋한 파일도 변경할 수 있다. 여러 개의 커밋을 하나로 합치거나 반대로 커밋 하나를 여러 개로 분리할 수도 있다. 아니면 커밋 전체를 삭제할 수도 있다. 하지만, 이 모든 것은 다른 사람과 코드를 공유하기 전에 해야 한다. 이 절에서는 사람들과 코드를 공유하기 전에 커밋 히스토리를 예쁘게 단장하는 방법에 대해서 설명한다. 노트 Git이 동작하는 기본 원리 중 하나는 Git은 로컬에 모든 버전관리 데이터를 로컬에 복사(Clone) 해두고 있다는 점이다. 이 ",
    "sections": [
      {
        "header": "히스토리 단장하기",
        "content": "Git으로 일하다 보면 어떤 이유로든 로컬 커밋 히스토리를 수정해야 할 때가 있다. 결정을 나중으로 미룰 수 있던 것은 Git의 장점이다. Staging Area로 커밋할 파일을 고르는 일을 커밋하는 순간으로 미룰 수 있고 Stash 명령으로 하던 일을 미룰 수 있다. 게다가 이미 커밋해서 결정한 내용을 수정할 수 있다. 그리고 수정할 수 있는 것도 매우 다양하다. 커밋들의 순서도 변경할 수 있고 커밋 메시지와 커밋한 파일도 변경할 수 있다. 여러 개의 커밋을 하나로 합치거나 반대로 커밋 하나를 여러 개로 분리할 수도 있다. 아니면 커밋 전체를 삭제할 수도 있다. 하지만, 이 모든 것은 다른 사람과 코드를 공유하기 전에 해야 한다.\n\n이 절에서는 사람들과 코드를 공유하기 전에 커밋 히스토리를 예쁘게 단장하는 방법에 대해서 설명한다.\n\nGit이 동작하는 기본 원리 중 하나는 Git은 로컬에 모든 버전관리 데이터를 로컬에 복사(Clone) 해두고 있다는 점이다. 이 때문에 자유롭게 히스토리를 로컬에서 수정해 볼 수 있는 자유도 누릴 수 있다. 다만 로컬의 버전관리 데이터 혹은 커밋이 외부로 Push가 된 후라면 이야기는 완전 딴판이된다. Push된 데이터는 수정에 대해선 완전이 끝난 것이다. 고쳐야 할 이유가 생겼더라도 새로 수정작업을 추가해야지 이전 커밋 자체를 수정할 수는 없다. 그렇기에 온전하게 수정 작업을 마무리했다는 확신 없이 작업 내용을 공유하는 저장소로 보내는(Push) 것은 피해야 할 행동이다.\n\n노트 | Git이 동작하는 기본 원리 중 하나는 Git은 로컬에 모든 버전관리 데이터를 로컬에 복사(Clone) 해두고 있다는 점이다. 이 때문에 자유롭게 히스토리를 로컬에서 수정해 볼 수 있는 자유도 누릴 수 있다. 다만 로컬의 버전관리 데이터 혹은 커밋이 외부로 Push가 된 후라면 이야기는 완전 딴판이된다. Push된 데이터는 수정에 대해선 완전이 끝난 것이다. 고쳐야 할 이유가 생겼더라도 새로 수정작업을 추가해야지 이전 커밋 자체를 수정할 수는 없다. 그렇기에 온전하게 수정 작업을 마무리했다는 확신 없이 작업 내용을 공유하는 저장소로 보내는(Push) 것은 피해야 할 행동이다.\n\n[Note] 노트 Git이 동작하는 기본 원리 중 하나는 Git은 로컬에 모든 버전관리 데이터를 로컬에 복사(Clone) 해두고 있다는 점이다. 이 때문에 자유롭게 히스토리를 로컬에서 수정해 볼 수 있는 자유도 누릴 수 있다. 다만 로컬의 버전관리 데이터 혹은 커밋이 외부로 Push가 된 후라면 이야기는 완전 딴판이된다. Push된 데이터는 수정에 대해선 완전이 끝난 것이다. 고쳐야 할 이유가 생겼더라도 새로 수정작업을 추가해야지 이전 커밋 자체를 수정할 수는 없다. 그렇기에 온전하게 수정 작업을 마무리했다는 확신 없이 작업 내용을 공유하는 저장소로 보내는(Push) 것은 피해야 할 행동이다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 3,
          "content_length": 1410
        }
      },
      {
        "header": "마지막 커밋을 수정하기",
        "content": "히스토리를 단장하는 일 중에서는 마지막 커밋을 수정하는 것이 가장 자주 하는 일이다. 기본적으로 두 가지로 나눌 수 있는데 하나는 단순히 커밋 메시지만를 수정하는 것이고 다른 하나는 나중에 수정한 파일을 마지막 커밋 안에 밀어넣는 것이다.\n\n커밋 메시지를 수정하는 방법은 매우 간단하다.\n\n이 명령은 자동으로 텍스트 편집기를 실행시켜서 마지막 커밋 메시지를 열어준다. 여기에 메시지를 바꾸고 편집기를 닫으면 편집기는 바뀐 메시지로 마지막 커밋을 수정한다.\n\n반대로 커밋 메시지가 아니라 프로젝트 내용을 수정한 경우가 있다. 커밋하고 난 후 새로 만든 파일이나 수정한 파일을 가장 최근 커밋에 집어넣을 수 있다. 기본적으로 방법은 같다. 파일을 수정하고 git add 명령으로 Staging Area에 넣는다. 그리고 git commit --amend 명령으로 커밋하면 커밋 자체가 수정되면서 추가로 수정사항을 밀어넣을 수 있다.\n\n이때 SHA-1 값이 바뀌기 때문에 과거의 커밋을 변경할 때 주의해야 한다. Rebase와 같이 이미 Push 한 커밋은 수정하면 안 된다.\n\n커밋을 고치는 것은 커밋 메시지를 고치는 것일수도 있고 또는 커밋 담고 있는 변경 내용을 고치는 것 일수도 있다. 커밋의 고치는데 있어 추가된 변경 내용이 상당히 있을 경우 커밋 메시지가 충실하게 담고 있는지 확인해 볼 필요가 있다.\n\n반대로 커밋을 고치는 내용이 오타를 살짝 고치거나 실수로 빠뜨린 것을 넣는 등 아주 사소하거나 이미 커밋 메시지가 충분히 이를 반영하고 있을 수 있다. 이런 경우 다음과 같이 --no-edit 옵션을 사용하면 커밋 메시지를 수정하도록 편집기가 실행되지는 않는다.\n\n힌트 | 커밋을 고치는 작업은 커밋 메시지 고치를 덩달아 이끌 수 있음 커밋을 고치는 것은 커밋 메시지를 고치는 것일수도 있고 또는 커밋 담고 있는 변경 내용을 고치는 것 일수도 있다. 커밋의 고치는데 있어 추가된 변경 내용이 상당히 있을 경우 커밋 메시지가 충실하게 담고 있는지 확인해 볼 필요가 있다. 반대로 커밋을 고치는 내용이 오타를 살짝 고치거나 실수로 빠뜨린 것을 넣는 등 아주 사소하거나 이미 커밋 메시지가 충분히 이를 반영하고 있을 수 있다. 이런 경우 다음과 같이 --no-edit 옵션을 사용하면 커밋 메시지를 수정하도록 편집기가 실행되지는 않는다. $ git commit --amend --no-edit\n\n[Tip] 힌트 커밋을 고치는 작업은 커밋 메시지 고치를 덩달아 이끌 수 있음 커밋을 고치는 것은 커밋 메시지를 고치는 것일수도 있고 또는 커밋 담고 있는 변경 내용을 고치는 것 일수도 있다. 커밋의 고치는데 있어 추가된 변경 내용이 상당히 있을 경우 커밋 메시지가 충실하게 담고 있는지 확인해 볼 필요가 있다. 반대로 커밋을 고치는 내용이 오타를 살짝 고치거나 실수로 빠뜨린 것을 넣는 등 아주 사소하거나 이미 커밋 메시지가 충분히 이를 반영하고 있을 수 있다. 이런 경우 다음과 같이 --no-edit 옵션을 사용하면 커밋 메시지를 수정하도록 편집기가 실행되지는 않는다. $ git commit --amend --no-edit",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git commit --amend\n```",
          "```bash\n$ git commit --amend --no-edit\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 7,
          "content_length": 1527
        }
      },
      {
        "header": "커밋 메시지를 여러 개 수정하기",
        "content": "최근 커밋이 아니라 예전 커밋을 수정하려면 다른 도구가 필요하다. 히스토리 수정하기 위해 만들어진 도구는 없지만 rebase 명령을 이용하여 수정할 수 있다. 현재 작업하는 브랜치에서 각 커밋을 하나하나 수정하는 것이 아니라 어느 시점부터 HEAD까지의 커밋을 한 번에 Rebase 한다. 대화형 Rebase 도구를 사용하면 커밋을 처리할 때마다 잠시 멈춘다. 그러면 각 커밋의 메시지를 수정하거나 파일을 추가하고 변경하는 등의 일을 진행할 수 있다. git rebase 명령에 -i 옵션을 추가하면 대화형 모드로 Rebase 할 수 있다. 어떤 시점부터 HEAD까지 Rebase 할 것인지 인자로 넘기면 된다.\n\n마지막 커밋 메시지 세 개를 모두 수정하거나 그 중 몇 개를 수정하는 시나리오를 살펴보자. git rebase -i 의 인자로 편집하려는 마지막 커밋의 부모를 HEAD~2^ 나 HEAD~3 로 해서 넘긴다. 마지막 세 개의 커밋을 수정하는 것이기 때문에 ~3 이 좀 더 기억하기 쉽다. 그렇지만, 실질적으로 가리키게 되는 것은 수정하려는 커밋의 부모인 네 번째 이전 커밋이다.\n\n이 명령은 Rebase 하는 것이기 때문에 메시지의 수정 여부에 관계없이 HEAD~3..HEAD 범위에 있는 모든 커밋을 수정한다. 다시 강조하지만 이미 중앙서버에 Push 한 커밋은 절대 고치지 말아야 한다. Push 한 커밋을 Rebase 하면 결국 같은 내용을 두 번 Push 하는 것이기 때문에 다른 개발자들이 혼란스러워 할 것이다.\n\n실행하면 Git은 수정하려는 커밋 목록이 첨부된 스크립트를 텍스트 편집기로 열어준다.\n\n이 커밋은 모두 log 명령과는 정반대의 순서로 나열된다. log 명령을 실행하면 아래와 같은 결과를 볼 수 있다.\n\n위 결과의 역순임을 기억하자. 대화형 Rebase는 스크립트에 적혀 있는 순서대로 HEAD~3 부터 적용하기 시작하고 위에서 아래로 각각의 커밋을 순서대로 수정한다. 순서대로 적용하는 것이기 때문에 제일 위에 있는 것이 최신이 아니라 가장 오래된 것이다.\n\n특정 커밋에서 실행을 멈추게 하려면 스크립트를 수정해야 한다. pick 이라는 단어를 'edit’로 수정하면 그 커밋에서 멈춘다. 가장 오래된 커밋 메시지를 수정하려면 아래와 같이 편집한다.\n\n저장하고 편집기를 종료하면 Git은 목록에 있는 커밋 중에서 가장 오래된 커밋으로 이동하고, 아래와 같은 메시지를 보여주고, 명령 프롬프트를 보여준다.\n\n명령 프롬프트가 나타날 때 Git은 Rebase 과정에서 현재 정확히 뭘 해야 하는지 메시지로 알려준다. 아래와 같은 명령을 실행하고\n\n커밋 메시지를 수정하고 텍스트 편집기를 종료하고 나서 아래 명령을 실행한다.\n\n이렇게 나머지 두 개의 커밋에 적용하면 끝이다. 다른 것도 pick을 edit로 수정해서 이 작업을 몇 번이든 반복할 수 있다. 매번 Git이 멈출 때마다 커밋을 정정할 수 있고 완료할 때까지 계속 할 수 있다.",
        "code_examples": [
          "```bash\npick f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n# Rebase 710f0f8..a5f4a0d onto 710f0f8\n#\n# Commands:\n#  p, pick = use commit\n#  r, reword = use commit, but edit the commit message\n#  e, edit = use commit, but stop for amending\n#  s, squash = use commit, but meld into previous commit\n#  f, fixup = like \"squash\", but discard this commit's log message\n#  x, exec = run command (the rest of the line) using shell\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n```",
          "```bash\nedit f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n```"
        ],
        "usage_examples": [
          "```bash\n$ git rebase -i HEAD~3\n```",
          "```bash\n$ git log --pretty=format:\"%h %s\" HEAD~3..HEAD\na5f4a0d added cat-file\n310154e updated README formatting and added blame\nf7f3f6d changed my name a bit\n```",
          "```bash\n$ git rebase -i HEAD~3\nStopped at f7f3f6d... changed my name a bit\nYou can amend the commit now, with\n\n       git commit --amend\n\nOnce you’re satisfied with your changes, run\n\n       git rebase --continue\n```",
          "```bash\n$ git commit --amend\n```",
          "```bash\n$ git rebase --continue\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 11,
          "content_length": 1439
        }
      },
      {
        "header": "커밋 순서 바꾸기",
        "content": "대화형 Rebase 도구로 커밋 전체를 삭제하거나 순서를 조정할 수 있다. “added cat-file” 커밋을 삭제하고 다른 두 커밋의 순서를 변경하려면 아래와 같은 Rebase 스크립트를\n\n수정한 내용을 저장하고 편집기를 종료하면 Git은 브랜치를 이 커밋의 부모로 이동시키고서 310154e 와 f7f3f6d 를 순서대로 적용한다. 명령이 끝나고 나면 커밋 순서가 변경됐고 “added cat-file” 커밋이 제거된 것을 확인할 수 있다.",
        "code_examples": [
          "```bash\npick f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n```",
          "```bash\npick 310154e updated README formatting and added blame\npick f7f3f6d changed my name a bit\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 249
        }
      },
      {
        "header": "커밋 합치기",
        "content": "대화형 Rebase 명령을 이용하여 여러 개의 커밋을 꾹꾹 눌러서 커밋 하나로 만들어 버릴 수 있다. Rebase 스크립트에 자동으로 포함된 도움말에 설명이 있다.\n\n“pick” 이나 “edit” 말고 “squash” 를 입력하면 Git은 해당 커밋과 바로 이전 커밋을 합칠 것이고 커밋 메시지도 Merge 한다. 그래서 3개의 커밋을 모두 합치려면 스크립트를 아래와 같이 수정한다.\n\n저장하고 나서 편집기를 종료하면 Git은 3개의 커밋 메시지를 Merge 할 수 있도록 에디터를 바로 실행해준다.\n\n이 메시지를 저장하면 3개의 커밋이 모두 합쳐진 커밋 한 개만 남는다.",
        "code_examples": [
          "```bash\n#\n# Commands:\n#  p, pick = use commit\n#  r, reword = use commit, but edit the commit message\n#  e, edit = use commit, but stop for amending\n#  s, squash = use commit, but meld into previous commit\n#  f, fixup = like \"squash\", but discard this commit's log message\n#  x, exec = run command (the rest of the line) using shell\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n```",
          "```bash\npick f7f3f6d changed my name a bit\nsquash 310154e updated README formatting and added blame\nsquash a5f4a0d added cat-file\n```",
          "```bash\n# This is a combination of 3 commits.\n# The first commit's message is:\nchanged my name a bit\n\n# This is the 2nd commit message:\n\nupdated README formatting and added blame\n\n# This is the 3rd commit message:\n\nadded cat-file\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 320
        }
      },
      {
        "header": "커밋 분리하기",
        "content": "커밋을 분리한다는 것은 기존의 커밋을 해제하고(혹은 되돌려 놓고) Stage를 여러 개로 분리하고 나서 그것을 원하는 횟수만큼 다시 커밋하는 것이다. 예로 들었던 커밋 세 개 중에서 가운데 것을 분리해보자. 이 커밋의 “updated README formatting and added blame” 을 “updated README formatting” 과 “added blame” 으로 분리하는 것이다. rebase -i 스크립트에서 해당 커밋을 \"edit\"로 변경한다.\n\n저장하고 나서 명령 프롬프트로 넘어간 다음에 그 커밋을 해제하고 그 내용을 다시 두 개로 나눠서 커밋하면 된다. 저장하고 편집기를 종료하면 Git은 제일 오래된 커밋의 부모로 이동하고서 f7f3f6d 과 310154e 을 처리하고 콘솔 프롬프트를 보여준다. 여기서 커밋을 해제하는 git reset HEAD^ 라는 명령으로 커밋을 해제한다. 그러면 수정했던 파일은 Unstaged 상태가 된다. 그다음에 파일을 Stage 한 후 커밋하는 일을 원하는 만큼 반복하고 나서 git rebase --continue 라는 명령을 실행하면 남은 Rebase 작업이 끝난다.\n\n나머지 a5f4a0d 커밋도 처리되면 히스토리는 아래와 같다.\n\n다시 강조하지만 Rebase 하면 목록에 있는 모든 커밋의 SHA-1 값은 변경된다. 절대로 이미 서버에 Push 한 커밋을 수정하면 안 된다.",
        "code_examples": [
          "```bash\npick f7f3f6d changed my name a bit\nedit 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n```"
        ],
        "usage_examples": [
          "```bash\n$ git reset HEAD^\n$ git add README\n$ git commit -m 'updated README formatting'\n$ git add lib/simplegit.rb\n$ git commit -m 'added blame'\n$ git rebase --continue\n```",
          "```bash\n$ git log -4 --pretty=format:\"%h %s\"\n1c002dd added cat-file\n9b29157 added blame\n35cfb2b updated README formatting\nf3cc40e changed my name a bit\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 697
        }
      },
      {
        "header": "filter-branch는 포크레인",
        "content": "수정해야 하는 커밋이 너무 많아서 Rebase 스크립트로 수정하기 어려울 것 같으면 다른 방법을 사용하는 것이 좋다. 모든 커밋의 이메일 주소를 변경하거나 어떤 파일을 삭제하는 경우를 살펴보자. filter-branch 라는 명령으로 수정할 수 있는데 Rebase가 삽이라면 이 명령은 포크레인이라고 할 수 있다. filter-branch 도 역시 수정하려는 커밋이 이미 공개돼서 다른 사람과 함께 공유하는 중이라면 사용하지 말아야 한다. 하지만, 잘 쓰면 꽤 유용하다. filter-branch 가 유용한 경우를 예로 들어 설명하기 때문에 여기에서 대충 어떤 경우에 유용할지 배울 수 있다.\n\n갑자기 누군가 생각 없이 git add . 같은 명령을 실행해서 공룡 똥 덩어리를 커밋했거나 실수로 암호가 포함된 파일을 커밋해서 이런 파일을 다시 삭제해야 하는 상황을 살펴보자. 이런 상황은 생각보다 자주 발생한다. filter-branch 는 히스토리 전체에서 필요한 것만 골라내는 데 사용하는 도구다. filter-branch 의 --tree-filter 라는 옵션을 사용하면 히스토리에서 passwords.txt 파일을 아예 제거할 수 있다.\n\n--tree-filter 옵션은 프로젝트를 Checkout 한 후에 각 커밋에 명시한 명령을 실행시키고 그 결과를 다시 커밋한다. 이 경우에는 각 스냅샷에 passwords.txt 파일이 있으면 그 파일을 삭제한다. 실수로 편집기의 백업파일을 커밋했으면 git filter-branch --tree-filter 'rm -f *~' HEAD 라고 실행해서 삭제할 수 있다.\n\n이 명령은 모든 파일과 커밋을 정리하고 브랜치 포인터를 다시 복원해준다. 이런 작업은 테스팅 브랜치에서 실험하고 나서 master 브랜치에 적용하는 게 좋다. filter-branch 명령에 --all 옵션을 추가하면 모든 브랜치에 적용할 수 있다.\n\n다른 VCS에서 코드를 임포트하면 그 VCS만을 위한 디렉토리가 있을 수 있다. SVN에서 코드를 임포트하면 trunk, tags, branch 디렉토리가 포함된다. 모든 커밋에 대해 trunk 디렉토리를 프로젝트 루트 디렉토리로 만들 때도 filter-branch 명령이 유용하다.\n\n이제 trunk 디렉토리를 루트 디렉토리로 만들었다. Git은 입력한 디렉토리와 관련이 없는 커밋을 자동으로 삭제한다.\n\n프로젝트를 오픈소스로 공개할 때 아마도 회사 이메일 주소로 커밋된 것을 개인 이메일 주소로 변경해야 한다. 아니면 아예 git config 로 이름과 이메일 주소를 설정하는 것을 잊었을 수도 있다. 자신의 이메일 주소만 변경하도록 조심해야 한다. filter-branch 명령의 --commit-filter 옵션을 사용하여 해당 커밋만 골라서 이메일 주소를 수정할 수 있다.\n\n이메일 주소를 새 주소로 변경했다. 모든 커밋은 부모의 SHA-1 값을 가지고 있기 때문에 조건에 만족하는 커밋의 SHA-1값만 바뀌는 것이 아니라 모든 커밋의 SHA-1 값이 바뀐다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD\nRewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)\nRef 'refs/heads/master' was rewritten\n```",
          "```bash\n$ git filter-branch --subdirectory-filter trunk HEAD\nRewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)\nRef 'refs/heads/master' was rewritten\n```",
          "```bash\n$ git filter-branch --commit-filter '\n        if [ \"$GIT_AUTHOR_EMAIL\" = \"schacon@localhost\" ];\n        then\n                GIT_AUTHOR_NAME=\"Scott Chacon\";\n                GIT_AUTHOR_EMAIL=\"schacon@example.com\";\n                git commit-tree \"$@\";\n        else\n                git commit-tree \"$@\";\n        fi' HEAD\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1478
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git-도구-히스토리-단장하기",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "7.7 Git 도구 - Reset 명확히 알고 가기",
    "summary": "Reset 명확히 알고 가기 Git의 다른 특별한 도구를 더 살펴보기 보기 전에 reset 과 checkout 에 대해 이야기를 해보자. 이 두 명령은 Git을 처음 사용하는 사람을 가장 헷갈리게 하는 부분이다. 제대로 이해하고 사용할 수 없을 것으로 보일 정도로 많은 기능을 지녔다. 이해하기 쉽게 간단한 비유를 들어 설명해보자. 세 개의 트리 Git을 서로 다른 세 트리를 관리하는 컨텐츠 관리자로 생각하면 reset 과 checkout 을 좀 더 쉽게 이해할 수 있다. 여기서 “트리” 란 실제로는 “파일의 묶음” 이다. 자료구조의 트리가 아니다 세 트리 중 Index는 트리도 아니지만, 이해를 쉽게 하려고 일단 트리라고 한다. Git은 일반적으로 세 가지 트리를 관리하는 시스템이다. 트리 역할 HEAD 마지막 커밋 스냅샷, 다음 커밋의 부모 커밋 Index 다음에 커밋할 스냅샷 워킹 디렉토리 샌드박스 HEAD HEAD는 현재 브랜치를 가리키는 포인터이며, 브랜치는 브랜치에 담긴 커",
    "sections": [
      {
        "header": "Reset 명확히 알고 가기",
        "content": "Git의 다른 특별한 도구를 더 살펴보기 보기 전에 reset 과 checkout 에 대해 이야기를 해보자. 이 두 명령은 Git을 처음 사용하는 사람을 가장 헷갈리게 하는 부분이다. 제대로 이해하고 사용할 수 없을 것으로 보일 정도로 많은 기능을 지녔다. 이해하기 쉽게 간단한 비유를 들어 설명해보자.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 169
        }
      },
      {
        "header": "세 개의 트리",
        "content": "Git을 서로 다른 세 트리를 관리하는 컨텐츠 관리자로 생각하면 reset 과 checkout 을 좀 더 쉽게 이해할 수 있다. 여기서 “트리” 란 실제로는 “파일의 묶음” 이다. 자료구조의 트리가 아니다 세 트리 중 Index는 트리도 아니지만, 이해를 쉽게 하려고 일단 트리라고 한다.\n\nGit은 일반적으로 세 가지 트리를 관리하는 시스템이다.\n\n마지막 커밋 스냅샷, 다음 커밋의 부모 커밋\n\nHEAD는 현재 브랜치를 가리키는 포인터이며, 브랜치는 브랜치에 담긴 커밋 중 가장 마지막 커밋을 가리킨다. 지금의 HEAD가 가리키는 커밋은 바로 다음 커밋의 부모가 된다. 단순하게 생각하면 HEAD는 *현재 브랜치 마지막 커밋의 스냅샷*이다.\n\nHEAD가 가리키는 스냅샷을 살펴보기는 쉽다. 아래는 HEAD 스냅샷의 디렉토리 리스팅과 각 파일의 SHA-1 체크섬을 보여주는 예제다.\n\ncat-file 와 ls-tree 명령은 일상적으로는 잘 사용하지 않는 저수준 명령이다. 이런 저수준 명령을 “plumbing” 명령이라고 한다. Git이 실제로 무슨 일을 하는지 볼 때 유용하다.\n\nIndex는 바로 다음에 커밋할 것들이다. 이미 앞에서 우리는 이런 개념을 “Staging Area” 라고 배운 바 있다. “Staging Area” 는 사용자가 git commit 명령을 실행했을 때 Git이 처리할 것들이 있는 곳이다.\n\n먼저 Index는 워킹 디렉토리에서 마지막으로 Checkout 한 브랜치의 파일 목록과 파일 내용으로 채워진다. 이후 파일 변경작업을 하고 변경한 내용으로 Index를 업데이트 할 수 있다. 이렇게 업데이트 하고 git commit 명령을 실행하면 Index는 새 커밋으로 변환된다.\n\n또 다른 저수준 git ls-files 명령은 훨씬 더 장막 뒤에 가려져 있는 명령으로 이를 실행하면 현재 Index가 어떤 상태인지를 확인할 수 있다.\n\nIndex는 엄밀히 말해 트리구조는 아니다. 사실 Index는 평평한 구조로 구현되어 있다. 여기에서는 쉽게 이해할 수 있도록 그냥 트리라고 설명한다.\n\n마지막으로 워킹 디렉토리를 살펴보자. 위의 두 트리는 파일과 그 내용을 효율적인 형태로 .git 디렉토리에 저장한다. 하지만, 사람이 알아보기 어렵다. 워킹 디렉토리는 실제 파일로 존재한다. 바로 눈에 보이기 때문에 사용자가 편집하기 수월하다. 워킹 디렉토리는 샌드박스로 생각하자. 커밋하기 전에는 Index(Staging Area)에 올려놓고 얼마든지 변경할 수 있다.\n\n트리 | 역할\n--- | ---\nHEAD | 마지막 커밋 스냅샷, 다음 커밋의 부모 커밋\nIndex | 다음에 커밋할 스냅샷\n워킹 디렉토리 | 샌드박스",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git cat-file -p HEAD\ntree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\nauthor Scott Chacon  1301511835 -0700\ncommitter Scott Chacon  1301511835 -0700\n\ninitial commit\n\n$ git ls-tree -r HEAD\n100644 blob a906cb2a4a904a152...   README\n100644 blob 8f94139338f9404f2...   Rakefile\n040000 tree 99f1a6d12cb4b6f19...   lib\n```",
          "```bash\n$ git ls-files -s\n100644 a906cb2a4a904a152e80877d4088654daad0c859 0\tREADME\n100644 8f94139338f9404f26296befa88755fc2598c289 0\tRakefile\n100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0\tlib/simplegit.rb\n```",
          "```bash\n$ tree\n.\n├── README\n├── Rakefile\n└── lib\n    └── simplegit.rb\n\n1 directory, 3 files\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 11,
          "content_length": 1312
        }
      },
      {
        "header": "워크플로",
        "content": "Git의 주목적은 프로젝트의 스냅샷을 지속적으로 저장하는 것이다. 이 트리 세 개를 사용해 더 나은 상태로 관리한다.\n\n이 과정을 시각화해보자. 파일이 하나 있는 디렉토리로 이동한다. 이걸 파일의 v1이라고 하고 파란색으로 표시한다. git init 명령을 실행하면 Git 저장소가 생기고 HEAD는 아직 없는 브랜치를 가리킨다(master 는 아직 없다).\n\n이 시점에서는 워킹 디렉토리 트리에만 데이터가 있다.\n\n이제 파일을 커밋해보자. git add 명령으로 워킹 디렉토리의 내용을 Index로 복사한다.\n\n그리고 git commit 명령을 실행한다. 그러면 Index의 내용을 스냅샷으로 영구히 저장하고 그 스냅샷을 가리키는 커밋 객체를 만든다. 그리고는 master 가 그 커밋 객체를 가리키도록 한다.\n\n이때 git status 명령을 실행하면 아무런 변경 사항이 없다고 나온다. 세 트리 모두가 같기 때문이다.\n\n다시 파일 내용을 바꾸고 커밋해보자. 위에서 했던 것과 과정은 비슷하다. 먼저 워킹 디렉토리의 파일을 고친다. 이를 이 파일의 v2라고 하자. 이건 빨간색으로 표시한다.\n\ngit status 명령을 바로 실행하면 “Changes not staged for commit,” 아래에 빨간색으로 된 파일을 볼 수 있다. Index와 워킹 디렉토리가 다른 내용을 담고 있기 때문에 그렇다. git add 명령을 실행해서 변경 사항을 Index에 올려주자.\n\n이 시점에서 git status 명령을 실행하면 “Changes to be committed” 아래에 파일 이름이 녹색으로 변한다. Index와 HEAD의 다른 파일들이 여기에 표시된다. 즉 다음 커밋할 것과 지금 마지막 커밋이 다르다는 말이다. 마지막으로 git commit 명령을 실행해 커밋한다.\n\n이제 git status 명령을 실행하면 아무것도 출력하지 않는다. 세 개의 트리의 내용이 다시 같아졌기 때문이다.\n\n브랜치를 바꾸거나 Clone 명령도 내부에서는 비슷한 절차를 밟는다. 브랜치를 Checkout 하면, HEAD가 새로운 브랜치를 가리키도록 바뀌고, 새로운 커밋의 스냅샷을 Index에 놓는다. 그리고 Index의 내용을 워킹 디렉토리로 복사한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 11,
          "content_length": 1087
        }
      },
      {
        "header": "Reset 의 역할",
        "content": "위의 트리 세 개를 이해하면 reset 명령이 어떻게 동작하는지 쉽게 알 수 있다.\n\n예로 들어 file.txt 파일 하나를 수정하고 커밋한다. 이것을 세 번 반복한다. 그러면 히스토리는 아래와 같이 된다.\n\n자 이제 reset 명령이 정확히 어떤 일을 하는지 낱낱이 파헤쳐보자. reset 명령은 이 세 트리를 간단하고 예측 가능한 방법으로 조작한다. 트리를 조작하는 동작은 세 단계 이하로 이루어진다.\n\nreset 명령이 하는 첫 번째 일은 HEAD 브랜치를 이동시킨다. checkout 명령처럼 HEAD가 가리키는 브랜치를 바꾸지는 않는다. HEAD는 계속 현재 브랜치를 가리키고 있고, 현재 브랜치가 가리키는 커밋을 바꾼다. HEAD가 master 브랜치를 가리키고 있다면(즉 master 브랜치를 Checkout 하고 작업하고 있다면) git reset 9e5e6a4 명령은 master 브랜치가 9e5e6a4 를 가리키게 한다.\n\nreset 명령에 커밋을 넘기고 실행하면 언제나 이런 작업을 수행한다. reset --soft 옵션을 사용하면 딱 여기까지 진행하고 동작을 멈춘다.\n\n이제 위의 다이어그램을 보고 어떤 일이 일어난 것인지 생각해보자. reset 명령은 가장 최근의 git commit 명령을 되돌린다. git commit 명령을 실행하면 Git은 새로운 커밋을 생성하고 HEAD가 가리키는 브랜치가 새로운 커밋을 가리키도록 업데이트한다. reset 명령 뒤에 HEAD~ (HEAD의 부모 커밋)를 주면 Index나 워킹 디렉토리는 그대로 놔두고 브랜치가 가리키는 커밋만 이전으로 되돌린다. Index를 업데이트한 다음에 git commit 명령를 실행하면 git commit --amend 명령의 결과와 같아진다(마지막 커밋을 수정하기를 참조).\n\n여기서 git status 명령을 실행하면 Index와 reset 명령으로 이동시킨 HEAD의 다른 점이 녹색으로 출력된다.\n\nreset 명령은 여기서 한 발짝 더 나아가 Index를 현재 HEAD가 가리키는 스냅샷으로 업데이트할 수 있다.\n\n--mixed 옵션을 주고 실행하면 reset 명령은 여기까지 하고 멈춘다. reset 명령을 실행할 때 아무 옵션도 주지 않으면 기본적으로 --mixed 옵션으로 동작한다(예제와 같이 git reset HEAD~ 처럼 명령을 실행하는 경우).\n\n위의 다이어그램을 보고 어떤 일이 일어날지 한 번 더 생각해보자. 가리키는 대상을 가장 최근의 커밋 으로 되돌리는 것은 같다. 그러고 나서 Staging Area 를 비우기까지 한다. git commit 명령도 되돌리고 git add 명령까지 되돌리는 것이다.\n\nreset 명령은 세 번째로 워킹 디렉토리까지 업데이트한다. --hard 옵션을 사용하면 reset 명령은 이 단계까지 수행한다.\n\n이 과정은 어떻게 동작하는지 가늠해보자. reset 명령을 통해 git add 와 git commit 명령으로 생성한 마지막 커밋을 되돌린다. 그리고 워킹 디렉토리의 내용까지도 되돌린다.\n\n이 --hard 옵션은 매우 매우 중요하다. reset 명령을 위험하게 만드는 유일한 옵션이다. Git에는 데이터를 실제로 삭제하는 방법이 별로 없다. 이 삭제하는 방법은 그 중 하나다. reset 명령을 어떻게 사용하더라도 간단히 결과를 되돌릴 수 있다. 하지만 --hard 옵션은 되돌리는 것이 불가능하다. 이 옵션을 사용하면 워킹 디렉토리의 파일까지 강제로 덮어쓴다. 이 예제는 파일의 v3버전을 아직 Git이 커밋으로 보관하고 있기 때문에 reflog 를 이용해서 다시 복원할 수 있다. 만약 커밋한 적 없다면 Git이 덮어쓴 데이터는 복원할 수 없다.\n\nreset 명령은 정해진 순서대로 세 개의 트리를 덮어써 나가다가 옵션에 따라 지정한 곳에서 멈춘다.\n\nHEAD가 가리키는 브랜치를 옮긴다. (--soft 옵션이 붙으면 여기까지)\n\nIndex를 HEAD가 가리키는 상태로 만든다. (--hard 옵션이 붙지 않았으면 여기까지)\n\n워킹 디렉토리를 Index의 상태로 만든다.\n\n• HEAD가 가리키는 브랜치를 옮긴다. (--soft 옵션이 붙으면 여기까지)\n• Index를 HEAD가 가리키는 상태로 만든다. (--hard 옵션이 붙지 않았으면 여기까지)\n• 워킹 디렉토리를 Index의 상태로 만든다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 17,
          "content_length": 2104
        }
      },
      {
        "header": "경로를 주고 Reset 하기",
        "content": "지금까지 reset 명령을 실행하는 기본 형태와 사용 방법을 살펴봤다. reset 명령을 실행할 때 경로를 지정하면 1단계를 건너뛰고 정해진 경로의 파일에만 나머지 reset 단계를 적용한다. 이는 당연한 이야기다. HEAD는 포인터인데 경로에 따라 파일별로 기준이 되는 커밋을 부분적으로 적용하는 건 불가능하다. 하지만, Index나 워킹 디렉토리는 일부분만 갱신할 수 있다. 따라서 2, 3단계는 가능하다.\n\n예를 들어 git reset file.txt 명령을 실행한다고 가정하자. 이 형식은(커밋의 해시 값이나 브랜치도 표기하지 않고 --soft 나 --hard 도 표기하지 않은) git reset --mixed HEAD file.txt 를 짧게 쓴 것이다.\n\nHEAD의 브랜치를 옮긴다. (건너뜀)\n\nIndex를 HEAD가 가리키는 상태로 만든다. (여기서 멈춤)\n\n본질적으로는 file.txt 파일을 HEAD에서 Index로 복사하는 것뿐이다.\n\n이 명령은 해당 파일을 Unstaged 상태로 만든다. 이 명령의 다이어그램과 git add 명령을 비교해보면 정확히 반대인 것을 알 수 있다.\n\n이것이 git status 명령에서 이 명령을 보여주는 이유다. 이 명령으로 파일을 Unstaged 상태로 만들 수 있다. (더 자세한 내용은 파일 상태를 Unstage로 변경하기를 참고한다.)\n\n특정 커밋을 명시하면 Git은 “HEAD에서 파일을 가져오는” 것이 아니라 그 커밋에서 파일을 가져온다. `git reset eb43bf file.txt 명령과 같이 실행한다.\n\n이 명령을 실행한 것과 같은 결과를 만들려면 워킹 디렉토리의 파일을 v1으로 되돌리고 git add 명령으로 Index를 v1으로 만들고 나서 다시 워킹 디렉토리를 v3로 되돌려야 한다(결과만 같다는 얘기다). 이 상태에서 git commit 명령을 실행하면 v1으로 되돌린 파일 내용을 기록한다. 워킹 디렉토리를 사용하지 않았다.\n\ngit add 명령처럼 reset 명령도 Hunk 단위로 사용할 수 있다. --patch 옵션을 사용해서 Staging Area에서 Hunk 단위로 Unstaged 상태로 만들 수 있다. 이렇게 선택적으로 Unstaged 상태로 만들거나 내리거나 이전 버전으로 복원시킬 수 있다.\n\n• HEAD의 브랜치를 옮긴다. (건너뜀)\n• Index를 HEAD가 가리키는 상태로 만든다. (여기서 멈춤)",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 1178
        }
      },
      {
        "header": "합치기(Squash)",
        "content": "여러 커밋을 커밋 하나로 합치는 재밌는 도구를 알아보자.\n\n“oops.” 나 “WIP”, “forgot this file” 같은 깃털같이 가벼운 커밋들이 있다고 해보자. 이럴 때는 reset 명령으로 커밋들을 하나로 합쳐서 남들에게 똑똑한 척할 수 있다. (커밋 합치기를 하는 명령어가 따로 있지만, 여기서는 reset 명령을 쓰는 것이 더 간단할 때도 있다는 것을 보여준다.)\n\n이런 프로젝트가 있다고 생각해보자. 첫 번째 커밋은 파일 하나를 추가했고, 두 번째 커밋은 기존 파일을 수정하고 새로운 파일도 추가했다. 세 번째 커밋은 첫 번째 파일을 다시 수정했다. 두 번째 커밋은 아직 작업 중인 커밋으로 이 커밋을 세 번째 커밋과 합치고 싶은 상황이다.\n\ngit reset --soft HEAD~2 명령을 실행하여 HEAD 포인터를 이전 커밋으로 되돌릴 수 있다(히스토리에서 그대로 유지할 처음 커밋 말이다).\n\n이 상황에서 git commit 명령을 실행한다.\n\n이제 사람들에게 공개할만한 히스토리가 만들어졌다. file-a.txt 파일이 있는 v1 커밋이 하나 그대로 있고, 두 번째 커밋에는 v3버전의 file-a.txt 파일과 새로 추가된 file-b.txt 파일이 있다. v2 버전은 더는 히스토리에 없다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 626
        }
      },
      {
        "header": "Checkout",
        "content": "아마도 checkout 명령과 reset 명령에 어떤 차이가 있는지 궁금할 것이다. reset 명령과 마찬가지로 checkout 명령도 위의 세 트리를 조작한다. checkout 명령도 파일 경로를 쓰느냐 안 쓰느냐에 따라 동작이 다르다.\n\ngit checkout [branch] 명령은 git reset --hard [branch] 명령과 비슷하게 [branch] 스냅샷을 기준으로 세 트리를 조작한다. 하지만, 두 가지 사항이 다르다.\n\n첫 번째로 reset --hard 명령과는 달리 checkout 명령은 워킹 디렉토리를 안전하게 다룬다. 저장하지 않은 것이 있는지 확인해서 날려버리지 않는다는 것을 보장한다. 사실 보기보다 좀 더 똑똑하게 동작한다. 워킹 디렉토리에서 Merge 작업을 한번 시도해보고 변경하지 않은 파일만 업데이트한다. 반면 reset --hard 명령은 확인하지 않고 단순히 모든 것을 바꿔버린다.\n\n두 번째 중요한 차이점은 어떻게 checkout 명령이 HEAD를 업데이트 하는가이다. reset 명령은 HEAD가 가리키는 브랜치를 움직이지만(브랜치 Refs를 업데이트하지만), checkout 명령은 HEAD 자체를 다른 브랜치로 옮긴다.\n\n예를 들어 각각 다른 커밋을 가리키는 master 와 develop 브랜치가 있고 현재 워킹 디렉토리는 develop 브랜치라고 가정해보자(즉 HEAD는 develop 브랜치를 가리킨다). git reset master 명령을 실행하면 develop 브랜치는 master 브랜치가 가리키는 커밋과 같은 커밋을 가리키게 된다. 반면 git checkout master 명령을 실행하면 develop 브랜치가 가리키는 커밋은 바뀌지 않고 HEAD가 master 브랜치를 가리키도록 업데이트된다. 이제 HEAD는 master 브랜치를 가리키게 된다.\n\n그래서 위 두 경우 모두 HEAD는 결과적으로 A 커밋을 가리키게 되지만 방식은 완전히 다르다. reset 명령은 HEAD가 가리키는 브랜치의 포인터를 옮겼고 checkout 명령은 HEAD 자체를 옮겼다.\n\ncheckout 명령을 실행할 때 파일 경로를 줄 수도 있다. reset 명령과 비슷하게 HEAD는 움직이지 않는다. 동작은 git reset [branch] file 명령과 비슷하다. Index의 내용이 해당 커밋 버전으로 변경될 뿐만 아니라 워킹 디렉토리의 파일도 해당 커밋 버전으로 변경된다. 완전히 git reset --hard [branch] file 명령의 동작이랑 같다. 워킹 디렉토리가 안전하지도 않고 HEAD도 움직이지 않는다.\n\ngit reset 이나 git add 명령처럼 checkout 명령도 --patch 옵션을 사용해서 Hunk 단위로 되돌릴 수 있다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1348
        }
      },
      {
        "header": "요약",
        "content": "reset 명령이 좀 더 쉬워졌을 거라고 생각한다. 아직 checkout 명령과 정확하게 무엇이 다른지 혼란스럽거나 정확한 사용법을 다 익히지 못했을 수도 있지만 괜찮다.\n\n아래에 어떤 명령이 어떤 트리에 영향을 주는지에 대한 요약표를 준비했다. 명령이 HEAD가 가리키는 브랜치를 움직인다면 “HEAD” 열에 “REF” 라고 적혀 있고 HEAD 자체가 움직인다면 “HEAD” 라고 적혀 있다. 'WD Safe?' 열을 꼭 보자. 여기에 *NO*라고 적혀 있다면 워킹 디렉토리에 저장하지 않은 내용이 안전하지 않기 때문에 해당 명령을 실행하기 전에 한 번쯤 더 생각해보아야 한다.\n\nreset --soft [commit]\n\nreset --hard [commit]\n\nreset [commit] <paths>\n\ncheckout [commit] <paths>\n\nHEAD | Index | Workdir | WD Safe?\n--- | --- | --- | ---\nCommit Level\nreset --soft [commit] | REF | NO | NO | YES\nreset [commit] | REF | YES | NO | YES\nreset --hard [commit] | REF | YES | YES | NO\ncheckout <commit> | HEAD | YES | YES | YES\nFile Level\nreset [commit] <paths> | NO | YES | NO | YES\ncheckout [commit] <paths> | NO | YES | YES | NO",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 6,
          "content_length": 765
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git-도구-Reset-명확히-알고-가기",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "7.8 Git 도구 - 고급 Merge",
    "summary": "고급 Merge Git의 Merge은 진짜 가볍다. Git에서는 브랜치끼리 몇 번이고 Merge 하기가 쉽다. 오랫동안 합치지 않은 두 브랜치를 한 번에 Merge 하면 거대한 충돌이 발생한다. 조그마한 충돌을 자주 겪고 그걸 풀어나감으로써 브랜치를 최신으로 유지한다. 하지만, 가끔 까다로운 충돌도 발생한다. 다른 버전 관리 시스템과 달리 Git은 충돌이 나면 모호한 상황까지 해결하려 들지 않는다. Git의 철학은 Merge가 잘될지 아닐지 판단하는 것을 잘 하자이다. 충돌이 나도 자동으로 해결하려고 노력하지 않는다. 오랫동안 따로 유지한 두 브랜치를 Merge 하려면 몇 가지 해야 할 일이 있다. 이 절에서는 어떤 Git 명령을 사용해서 무슨 일을 해야 하는지 알아보자. 그 외에도 특수한 상황에서 사용하는 Merge 방법과 Merge를 잘 마무리하는 방법을 소개한다. Merge 충돌 충돌의 기초에서 기초적인 Merge 충돌 해결에 대해서 다뤘다. Git은 복잡한 Merge 충돌이 ",
    "sections": [
      {
        "header": "고급 Merge",
        "content": "Git의 Merge은 진짜 가볍다. Git에서는 브랜치끼리 몇 번이고 Merge 하기가 쉽다. 오랫동안 합치지 않은 두 브랜치를 한 번에 Merge 하면 거대한 충돌이 발생한다. 조그마한 충돌을 자주 겪고 그걸 풀어나감으로써 브랜치를 최신으로 유지한다.\n\n하지만, 가끔 까다로운 충돌도 발생한다. 다른 버전 관리 시스템과 달리 Git은 충돌이 나면 모호한 상황까지 해결하려 들지 않는다. Git의 철학은 Merge가 잘될지 아닐지 판단하는 것을 잘 하자이다. 충돌이 나도 자동으로 해결하려고 노력하지 않는다. 오랫동안 따로 유지한 두 브랜치를 Merge 하려면 몇 가지 해야 할 일이 있다.\n\n이 절에서는 어떤 Git 명령을 사용해서 무슨 일을 해야 하는지 알아보자. 그 외에도 특수한 상황에서 사용하는 Merge 방법과 Merge를 잘 마무리하는 방법을 소개한다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 428
        }
      },
      {
        "header": "Merge 충돌",
        "content": "충돌의 기초에서 기초적인 Merge 충돌 해결에 대해서 다뤘다. Git은 복잡한 Merge 충돌이 났을 때 필요한 도구도 가지고 있다. 무슨 일이 일어났고 어떻게 해결하는 게 나은지 알 수 있다.\n\nMerge 할 때는 충돌이 날 수 있어서 Merge 하기 전에 워킹 디렉토리를 깔끔히 정리하는 것이 좋다. 워킹 디렉토리에 작업하던 게 있다면 임시 브랜치에 커밋하거나 Stash 해둔다. 그래야 어떤 일이 일어나도 다시 되돌릴 수 있다. 작업 중인 파일을 저장하지 않은 채로 Merge 하면 작업했던 일부를 잃을 수도 있다.\n\n매우 간단한 예제를 따라가 보자. 현재 'hello world’를 출력하는 Ruby 파일을 하나 가지고 있다.\n\n저장소에 whitespace 브랜치를 생성하고 모든 Unix 개행을 DOS 개행으로 바꾸어 커밋한다. 파일의 모든 라인이 바뀌었지만, 공백만 바뀌었다. 그 후 “hello world” 문자열을 “hello mundo” 로 바꾼 다음에 커밋한다.\n\nmaster 브랜치로 다시 이동한 다음에 함수에 대한 설명을 추가한다.\n\n이때 whitespace 브랜치를 Merge 하면 공백변경 탓에 충돌이 난다.\n\nMerge 중에 발생한 충돌을 해결하는 방법은 몇 가지가 있다. 첫 번째는 그저 이 상황을 벗어나는 것이다. 예상하고 있던 일도 아니고 지금 당장 처리할 일도 아니라면 git merge --abort 명령으로 간단히 Merge 하기 전으로 되돌린다.\n\ngit merge --abort 명령은 Merge 하기 전으로 되돌린다. 완전히 뒤로 되돌리지 못하는 유일한 경우는 Merge 전에 워킹 디렉토리에서 Stash 하지 않았거나 커밋하지 않은 파일이 존재하고 있었을 때뿐이다. 그 외에는 잘 돌아간다.\n\n어떤 이유로든 Merge를 처음부터 다시 하고 싶다면 git reset --hard HEAD 명령으로 되돌릴 수 있다. 이 명령은 워킹 디렉토리를 그 시점으로 완전히 되돌려서 저장하지 않은 것은 사라진다는 점에 주의하자.\n\n공백 때문에 충돌이 날 때도 있다. 단순한 상황이고 실제로 충돌난 파일을 살펴봤을 때 한 쪽의 모든 라인이 지워지고 다른 쪽에는 추가됐기 때문에 간단하다고 할 수 있다. 기본적으로 Git은 이런 모든 라인이 변경됐다고 인지하여 Merge 할 수 없다.\n\n기본 Merge 전략은 공백의 변화는 무시하도록 하는 옵션을 주는 것이다. Merge 할 때 무수한 공백 때문에 문제가 생기면 그냥 Merge를 취소한 다음 -Xignore-all-space 나 -Xignore-space-change 옵션을 주어 다시 Merge 한다. 첫 번째 옵션은 모든 공백을 무시하고 두 번째 옵션은 뭉쳐 있는 공백을 하나로 취급한다.\n\n위 예제는 모든 공백 변경 사항을 무시하면 실제 파일은 충돌 나지 않고 모든 Merge가 잘 실행된다.\n\n팀원 중 누군가 스페이스를 탭으로 바꾸거나 탭을 스페이스로 바꾸는 짓을 했을 때 이 옵션이 그대를 구원해 준다.\n\nMerge 작업할 때 공백 처리 옵션을 사용하면 Git이 꽤 잘해준다. 하지만, Git이 자동으로 해결하지 못하는 때도 있다. 이럴 때는 외부 도구의 도움을 받아 해결한다. 예를 들어 Git이 자동으로 해결해주지 못하는 상황에 부닥치면 직접 손으로 해결해야 한다.\n\n파일을 dos2unix 로 변환하고 Merge 하면 된다. 이걸 Git에서 어떻게 하는지 살펴보자.\n\n먼저 Merge 충돌 상태에 있다고 치자. 현 시점의 파일과 Merge 할 파일, 공통 조상의 파일이 필요하다. 이 파일들로 어쨌든 잘 Merge 되도록 수정하고 다시 Merge를 시도해야 한다.\n\n우선 세 가지 버전의 파일을 얻는 건 쉽다. Git은 세 버전의 모든 파일에 “stages” 숫자를 붙여서 Index에 다 가지고 있다. Stage 1는 공통 조상 파일, Stage 2는 현재 개발자의 버전에 해당하는 파일, Stage 3은 MERGE_HEAD 가 가리키는 커밋의 파일이다.\n\ngit show 명령으로 각 버전의 파일을 꺼낼 수 있다.\n\n좀 더 저수준으로 파고들자면 ls-files -u 명령을 사용한다. 이 명령은 Plumbing 명령으로 각 파일을 나타내는 Git Blob의 SHA-1를 얻을 수 있다.\n\n:1:hello.rb 는 그냥 Blob SHA-1를 지칭하는 줄임말이다.\n\n이제 워킹 디렉토리에 세 버전의 파일을 모두 가져왔다. 공백 문제를 수동으로 고친 다음에 다시 Merge 한다. Merge 할 때는 'git merge-file' 명령을 이용한다.\n\n이렇게 해서 멋지게 Merge가 완료된 파일을 얻었다. 사실 이것이 ignore-all-space 옵션을 사용하는 것보다 더 나은 방법이다. 왜냐면 공백을 무시하지 않고 실제로 고쳤기 때문이다. ignore-all-space 옵션을 사용한 Merge 에서는 여전히 DOS의 개행 문자가 남아서 한 파일에 두 형식의 개행문자가 뒤섞인다.\n\nMerge 커밋을 완료하기 전에 양쪽 부모에 대해서 무엇이 바뀌었는지 확인하려면 git diff 를 사용한다. 이 명령을 이용하면 Merge 의 결과로 워킹 디렉토리에 무엇이 바뀌었는지 알 수 있다. 한번 자세히 살펴보자.\n\nMerge 후의 결과를 Merge 하기 전의 브랜치와 비교하려면, 다시 말해 무엇이 합쳐졌는지 알려면 git diff --ours 명령을 실행한다.\n\n위의 결과에서 Merge를 했을 때 현재 브랜치에서는 무엇을 추가했는지를 알 수 있다.\n\nMerge 할 파일을 가져온 쪽과 비교해서 무엇이 바뀌었는지 보려면 git diff --theirs 를 실행한다. 아래 예제에서는 공백을 빼고 비교하기 위해 -b 옵션을 같이 써주었다.\n\n마지막으로 git diff --base 를 사용해서 양쪽 모두와 비교하여 바뀐 점을 알아본다.\n\n수동 Merge를 위해서 만들었던 각종 파일은 이제 필요 없으니 git clean 명령을 실행해서 지워준다.\n\n앞서 살펴본 여러가지 방법으로 충돌을 해결했지만 바라던 결과가 아닐 수도 있고 심지어 결과가 잘 동작하지 않아 충돌을 직접 수동으로 더 많은 정보를 살펴보며 해결해야 하는 경우도 있다.\n\n예제를 조금 바꿔보자. 이번 예제에서는 긴 호흡의 브랜치 두 개가 있다. 각 브랜치에는 몇 개의 커밋이 있는데 양쪽은 Merge 할 때 반드시 충돌이 날 만한 내용이 들어 있다.\n\nmaster 에만 있는 세 개의 커밋과 mundo 브랜치에만 존재하는 또 다른 세 개의 커밋이 있다. master 브랜치에서 mundo 브랜치를 Merge 하면 충돌이 난다.\n\n해당 파일을 열어서 충돌이 발생한 내용을 보면 아래와 같다.\n\n양쪽 브랜치에서 추가된 부분이 이 파일에 다 적용됐다. 적용한 커밋 중 파일의 같은 부분을 수정해서 위와 같은 충돌이 생긴다.\n\n충돌을 해결하는 몇 가지 도구에 대해 알아보자. 어쩌면 이 충돌을 어떻게 해결해야 하는지 명확하지 않을 수도 있다. 맥락을 좀 더 살펴봐야 하는 상황 말이다.\n\ngit checkout 명령에 --conflict 옵션을 붙여 사용하는 게 좋은 방법이 될 수 있다. 이 명령은 파일을 다시 Checkout 받아서 충돌 표시된 부분을 교체한다. 충돌 난 부분은 원래의 코드로 되돌리고 다시 고쳐보려고 할 때 알맞은 도구다.\n\n--conflict 옵션에는 diff3 나 merge 를 넘길 수 있고 merge 가 기본 값이다. --conflict 옵션에 diff3 를 사용하면 Git은 약간 다른 모양의 충돌 표시를 남긴다. “ours” 나 “theirs” 말고도 “base” 버전의 내용까지 제공한다.\n\n위 명령을 실행하면 아래와 같은 결과가 나타난다.\n\n이런 형태의 충돌 표시를 계속 보고 싶다면 기본으로 사용하도록 merge.conflictstyle 설정 값을 diff3 로 설정한다.\n\ngit checkout 명령도 --ours 와 --theirs 옵션을 지원한다. 이 옵션은 Merge 하지 않고 둘 중 한쪽만을 선택할 때 사용한다.\n\n이 옵션은 바이너리 파일이 충돌 나서 한쪽을 선택해야 하는 상황이나 한쪽 브랜치의 온전한 파일을 원할 때 사용할 수 있다. 일단 Merge 하고 나서 특정 파일만 Checkout 한 후에 커밋하는 방법도 있다.\n\ngit log 명령은 충돌을 해결할 때도 도움이 된다. 로그에는 충돌을 해결할 때 도움이 될만한 정보가 있을 수 있다. 과거를 살짝 들춰보면 개발 당시에 같은 곳을 고쳐야만 했던 이유를 밝혀내는 데 도움이 된다.\n\n“Triple Dot” 문법을 이용하면 Merge 에 사용한 양 브랜치의 모든 커밋의 목록을 얻을 수 있다. 자세한 문법은 Triple Dot를 참고한다.\n\n위와 같이 총 6개의 커밋을 볼 수 있다. 커밋이 어떤 브랜치에서 온 것인지 보여준다.\n\n맥락에 따라 필요한 결과만 추려 볼 수도 있다. git log 명령에 --merge 옵션을 추가하면 충돌이 발생한 파일이 속한 커밋만 보여준다.\n\n--merge 대신 -p 를 사용하면 충돌 난 파일의 변경사항만 볼 수 있다. 이건 왜 충돌이 났는지 또 이를 해결하기 위해 어떻게 해야 하는지 이해하는 데 진짜로 유용하다.\n\nMerge가 성공적으로 끝난 파일은 Staging Area에 올려놓았다. 이 상태에서 충돌 난 파일들이 그대로 있을 때 git diff 명령을 실행하면 충돌 난 파일이 무엇인지 알 수 있다. 어떤 걸 더 고쳐야 하는지 아는 데에 도움이 된다.\n\nMerge 하다가 충돌이 났을 때 git diff 명령을 실행하면 꽤 생소한 Diff 결과를 보여준다.\n\n이런 형식을 “Combined Diff” 라고 한다. 각 라인은 두 개의 컬럼으로 구분할 수 있다. 첫 번째 컬럼은 “ours” 브랜치와 워킹 디렉토리의 차이(추가 또는 삭제)를 보여준다. 두 번째 컬럼은 “theirs” 와 워킹 디렉토리사이의 차이를 나타낸다.\n\n이 예제에서 <<<<<<< 와 >>>>>>> 충돌 마커 표시는 어떤 쪽에도 존재하지 않고 추가된 코드라는 것을 알 수 있다. 이 표시는 Merge 도구가 만들어낸 코드이기 때문이다. 물론 이 표시는 지워야 하는 라인이다.\n\n충돌을 다 해결하고 git diff 명령을 다시 실행하면 아래와 같이 보여준다. 이 결과도 유용하다.\n\n이 결과는 세 가지 사실을 보여준다. “hola world” 는 Our 브랜치에 있었지만 워킹 디렉토리에는 없다. “hello mundo” 는 Their 브랜치에 있었지만 워킹 디렉토리에는 없다. “hola mundo” 는 어느 쪽 브랜치에도 없고 워킹 디렉토리에는 있다. 충돌을 해결하고 마지막으로 확인하고 나서 커밋하는 데 유용하다.\n\n이 정보를 git log 명령을 통해서도 얻을 수 있다. Merge 후에 무엇이 어떻게 바뀌었는지 알아야 할 때 유용하다. Merge 커밋에 대해서 git show 명령을 실행하거나 git log -p 에 --cc 옵션을 추가해도 같은 결과를 얻을 수 있다. git log -p 명령은 기본적으로 Merge 커밋이 아닌 커밋의 Patch를 출력한다.",
        "code_examples": [
          "```bash\n#! /usr/bin/env ruby\n\ndef hello\n  puts 'hello world'\nend\n\nhello()\n```"
        ],
        "usage_examples": [
          "```bash\n$ git checkout -b whitespace\nSwitched to a new branch 'whitespace'\n\n$ unix2dos hello.rb\nunix2dos: converting file hello.rb to DOS format ...\n$ git commit -am 'converted hello.rb to DOS'\n[whitespace 3270f76] converted hello.rb to DOS\n 1 file changed, 7 insertions(+), 7 deletions(-)\n\n$ vim hello.rb\n$ git diff -b\ndiff --git a/hello.rb b/hello.rb\nindex ac51efd..e85207e 100755\n--- a/hello.rb\n+++ b/hello.rb\n@@ -1,7 +1,7 @@\n #! /usr/bin/env ruby\n\n def hello\n-  puts 'hello world'\n+  puts 'hello mundo'^M\n end\n\n hello()\n\n$ git commit -am 'hello mundo change'\n[whitespace 6d338d2] hello mundo change\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```",
          "```bash\n$ git checkout master\nSwitched to branch 'master'\n\n$ vim hello.rb\n$ git diff\ndiff --git a/hello.rb b/hello.rb\nindex ac51efd..36c06c8 100755\n--- a/hello.rb\n+++ b/hello.rb\n@@ -1,5 +1,6 @@\n #! /usr/bin/env ruby\n\n+# prints out a greeting\n def hello\n   puts 'hello world'\n end\n\n$ git commit -am 'document the function'\n[master bec6336] document the function\n 1 file changed, 1 insertion(+)\n```",
          "```bash\n$ git merge whitespace\nAuto-merging hello.rb\nCONFLICT (content): Merge conflict in hello.rb\nAutomatic merge failed; fix conflicts and then commit the result.\n```",
          "```bash\n$ git status -sb\n## master\nUU hello.rb\n\n$ git merge --abort\n\n$ git status -sb\n## master\n```",
          "```bash\n$ git merge -Xignore-space-change whitespace\nAuto-merging hello.rb\nMerge made by the 'recursive' strategy.\n hello.rb | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```",
          "```bash\n$ git show :1:hello.rb > hello.common.rb\n$ git show :2:hello.rb > hello.ours.rb\n$ git show :3:hello.rb > hello.theirs.rb\n```",
          "```bash\n$ git ls-files -u\n100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1\thello.rb\n100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2\thello.rb\n100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3\thello.rb\n```",
          "```bash\n$ dos2unix hello.theirs.rb\ndos2unix: converting file hello.theirs.rb to Unix format ...\n\n$ git merge-file -p \\\n    hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb\n\n$ git diff -b\ndiff --cc hello.rb\nindex 36c06c8,e85207e..0000000\n--- a/hello.rb\n+++ b/hello.rb\n@@@ -1,8 -1,7 +1,8 @@@\n  #! /usr/bin/env ruby\n\n +# prints out a greeting\n  def hello\n-   puts 'hello world'\n+   puts 'hello mundo'\n  end\n\n  hello()\n```",
          "```bash\n$ git diff --ours\n* Unmerged path hello.rb\ndiff --git a/hello.rb b/hello.rb\nindex 36c06c8..44d0a25 100755\n--- a/hello.rb\n+++ b/hello.rb\n@@ -2,7 +2,7 @@\n\n # prints out a greeting\n def hello\n-  puts 'hello world'\n+  puts 'hello mundo'\n end\n\n hello()\n```",
          "```bash\n$ git diff --theirs -b\n* Unmerged path hello.rb\ndiff --git a/hello.rb b/hello.rb\nindex e85207e..44d0a25 100755\n--- a/hello.rb\n+++ b/hello.rb\n@@ -1,5 +1,6 @@\n #! /usr/bin/env ruby\n\n+# prints out a greeting\n def hello\n   puts 'hello mundo'\n end\n```",
          "```bash\n$ git diff --base -b\n* Unmerged path hello.rb\ndiff --git a/hello.rb b/hello.rb\nindex ac51efd..44d0a25 100755\n--- a/hello.rb\n+++ b/hello.rb\n@@ -1,7 +1,8 @@\n #! /usr/bin/env ruby\n\n+# prints out a greeting\n def hello\n-  puts 'hello world'\n+  puts 'hello mundo'\n end\n\n hello()\n```",
          "```bash\n$ git clean -f\nRemoving hello.common.rb\nRemoving hello.ours.rb\nRemoving hello.theirs.rb\n```",
          "```bash\n$ git log --graph --oneline --decorate --all\n* f1270f7 (HEAD, master) update README\n* 9af9d3b add a README\n* 694971d update phrase to hola world\n| * e3eb223 (mundo) add more tests\n| * 7cff591 add testing script\n| * c3ffff1 changed text to hello mundo\n|/\n* b7dcc89 initial hello world code\n```",
          "```bash\n$ git merge mundo\nAuto-merging hello.rb\nCONFLICT (content): Merge conflict in hello.rb\nAutomatic merge failed; fix conflicts and then commit the result.\n```",
          "```bash\n#! /usr/bin/env ruby\n\ndef hello\n<<<<<<< HEAD\n  puts 'hola world'\n=======\n  puts 'hello mundo'\n>>>>>>> mundo\nend\n\nhello()\n```",
          "```bash\n$ git checkout --conflict=diff3 hello.rb\n```",
          "```bash\n#! /usr/bin/env ruby\n\ndef hello\n<<<<<<< ours\n  puts 'hola world'\n||||||| base\n  puts 'hello world'\n=======\n  puts 'hello mundo'\n>>>>>>> theirs\nend\n\nhello()\n```",
          "```bash\n$ git config --global merge.conflictstyle diff3\n```",
          "```bash\n$ git log --oneline --left-right HEAD...MERGE_HEAD\n< f1270f7 update README\n< 9af9d3b add a README\n< 694971d update phrase to hola world\n> e3eb223 add more tests\n> 7cff591 add testing script\n> c3ffff1 changed text to hello mundo\n```",
          "```bash\n$ git log --oneline --left-right --merge\n< 694971d update phrase to hola world\n> c3ffff1 changed text to hello mundo\n```",
          "```bash\n$ git diff\ndiff --cc hello.rb\nindex 0399cd5,59727f0..0000000\n--- a/hello.rb\n+++ b/hello.rb\n@@@ -1,7 -1,7 +1,11 @@@\n  #! /usr/bin/env ruby\n\n  def hello\n++<<<<<<< HEAD\n +  puts 'hola world'\n++=======\n+   puts 'hello mundo'\n++>>>>>>> mundo\n  end\n\n  hello()\n```",
          "```bash\n$ vim hello.rb\n$ git diff\ndiff --cc hello.rb\nindex 0399cd5,59727f0..0000000\n--- a/hello.rb\n+++ b/hello.rb\n@@@ -1,7 -1,7 +1,7 @@@\n  #! /usr/bin/env ruby\n\n  def hello\n-   puts 'hola world'\n -  puts 'hello mundo'\n++  puts 'hola mundo'\n  end\n\n  hello()\n```",
          "```bash\n$ git log --cc -p -1\ncommit 14f41939956d80b9e17bb8721354c33f8d5b5a79\nMerge: f1270f7 e3eb223\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri Sep 19 18:14:49 2014 +0200\n\n    Merge branch 'mundo'\n\n    Conflicts:\n        hello.rb\n\ndiff --cc hello.rb\nindex 0399cd5,59727f0..e1d0799\n--- a/hello.rb\n+++ b/hello.rb\n@@@ -1,7 -1,7 +1,7 @@@\n  #! /usr/bin/env ruby\n\n  def hello\n-   puts 'hola world'\n -  puts 'hello mundo'\n++  puts 'hola mundo'\n  end\n\n  hello()\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 52,
          "content_length": 5342
        }
      },
      {
        "header": "Merge 되돌리기",
        "content": "지금까지 Merge 하는 방법을 배웠으나 Merge 할 때 실수할 수도 있다. Git에서는 실수해도 된다. 실수해도 (대부분 간단하게) 되돌릴 수 있다.\n\nMerge 커밋도 예외는 아니다. 토픽 브랜치에서 일을 하다가 master 로 잘못 Merge 했다고 생각해보자. 커밋 히스토리는 아래와 같다.\n\n접근 방식은 원하는 결과에 따라 두 가지로 나눌 수 있다.\n\n실수로 생긴 Merge 커밋이 로컬 저장소에만 있을 때는 브랜치를 원하는 커밋을 가리키도록 옮기는 것이 쉽고 빠르다. 잘못 Merge 하고 나서 git reset --hard HEAD~ 명령으로 브랜치를 되돌리면 된다.\n\nreset 에 대해서는 이미 앞의 Reset 명확히 알고 가기에서 다뤘었기 때문에 이 내용이 그리 어렵진 않을 것이다. 간단하게 복습해보자. reset --hard 명령은 아래의 세 단계로 수행한다.\n\nHEAD의 브랜치를 지정한 위치로 옮긴다. 이 경우엔 master 브랜치를 Merge 커밋(C6) 이전으로 되돌린다.\n\nIndex를 HEAD의 내용으로 바꾼다.\n\n워킹 디렉토리를 Index의 내용으로 바꾼다.\n\n이 방법의 단점은 히스토리를 다시 쓴다는 것이다. 다른 사람들과 공유된 저장소에서 히스토리를 덮어쓰면 문제가 생길 수 있다. 무슨 문제가 일어나는지 알고 싶다면 Rebase 의 위험성를 참고하자. 간단히 말해 다시 쓰는 커밋이 이미 다른 사람들과 공유한 커밋이라면 reset 하지 않는 게 좋다. 이 방법은 Merge 하고 나서 다른 커밋을 생성했다면 제대로 동작하지 않는다. HEAD를 이동시키면 Merge 이후에 만든 커밋을 잃어버린다.\n\n브랜치를 옮기는 것을 할 수 없는 경우는 모든 변경사항을 취소하는 새로운 커밋을 만들 수도 있다. Git에서 이 기능을 “revert” 라고 부른다. 지금의 경우엔 아래처럼 실행한다.\n\n-m 1 옵션은 부모가 보호되어야 하는 “mainline” 이라는 것을 나타낸다. HEAD 로 Merge를 했을 때(git merge topic1) Merge 커밋은 두 개의 부모 커밋을 가진다. 첫 번째 부모 커밋은 HEAD (C6)이고 두 번째 부모 커밋은 Merge 대상 브랜치(C4)이다. 두 번째 부모 커밋(C4)에서 받아온 모든 변경사항을 되돌리고 첫 번째 부모(C6)로부터 받아온 변경사항은 남겨두고자 하는 상황이다.\n\n변경사항을 되돌린 커밋은 히스토리에서 아래와 같이 보인다.\n\n새로 만든 커밋 ^M 은 C6 과 내용이 완전히 똑같다. 잘못 Merge 한 커밋까지 HEAD 의 히스토리에서 볼 수 있다는 것 말고는 Merge 하지 않은 것과 같다. topic 브랜치를 master 브랜치에 다시 Merge 하면 Git은 아래와 같이 어리둥절해한다.\n\n이미 Merge 했던 topic 브랜치에는 더는 master 브랜치로 Merge 할 내용이 없다. 상황을 더 혼란스럽게 하는 경우는 topic 에서 뭔가 더 일을 하고 다시 Merge를 하는 경우이다. Git은 Merge 이후에 새로 만들어진 커밋만 가져온다.\n\n이러면 가장 좋은 방법은 되돌렸던 Merge 커밋을 다시 되돌리는 것이다. 이후에 추가한 내용을 새 Merge 커밋으로 만드는 게 좋다.\n\n위 예제에서는 M 과 ^M 이 상쇄됐다. ^^M 는 C3 와 C4 의 변경 사항을 담고 있고 C8 은 C7 의 내용을 훌륭하게 Merge 했다. 이리하여 현재 topic 브랜치를 완전히 Merge 한 상태가 됐다.\n\n• HEAD의 브랜치를 지정한 위치로 옮긴다. 이 경우엔 master 브랜치를 Merge 커밋(C6) 이전으로 되돌린다.\n• Index를 HEAD의 내용으로 바꾼다.\n• 워킹 디렉토리를 Index의 내용으로 바꾼다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git revert -m 1 HEAD\n[master b1d8379] Revert \"Merge branch 'topic'\"\n```",
          "```bash\n$ git merge topic\nAlready up-to-date.\n```",
          "```bash\n$ git revert ^M\n[master 09f0126] Revert \"Revert \"Merge branch 'topic'\"\"\n$ git merge topic\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 16,
          "content_length": 1804
        }
      },
      {
        "header": "다른 방식의 Merge",
        "content": "지금까지 두 브랜치를 평범하게 Merge 하는 방법에 대해 알아보았다. Merge는 보통 “recursive” 전략을 사용한다. 브랜치를 한 번에 Merge 하는 방법은 여러 가지다. 그 중 몇 개만 간단히 알아보자.\n\n먼저 일반적인 “recursive” 전략을 사용하는 Merge 작업을 할 때 유용한 옵션을 소개한다. 앞에서 ignore-all-space 와 ignore-space-change 기능을 -X 옵션에 붙여 쓰는 것을 보았다. 이 -X 옵션은 충돌이 났을 때 어떤 한 쪽을 선택할 때도 사용한다.\n\n아무 옵션도 지정하지 않고 두 브랜치를 Merge 하면 Git은 코드에 충돌 난 곳을 표시하고 해당 파일을 충돌 난 파일로 표시해준다. 충돌을 직접 해결하는 게 아니라 미리 Git에게 충돌이 났을 때 두 브랜치 중 한쪽을 선택하라고 알려줄 수 있다. merge 명령을 사용할 때 -Xours 나 Xtheirs 옵션을 추가하면 된다.\n\nGit에 이 옵션을 주면 충돌 표시가 남지 않는다. Merge가 가능하면 Merge 될 것이고 충돌이 나면 사용자가 명시한 쪽의 내용으로 대체한다. 바이너리 파일도 똑같다.\n\n“hello world” 예제로 돌아가서 다시 Merge를 해보자. Merge를 하면 충돌이 나는 것을 볼 수 있다.\n\n하지만 -Xours 나 -Xtheirs 옵션을 주면 충돌이 났다는 소리가 없다.\n\n한쪽 파일에는 “hello mundo” 가 있고 다른 파일에는 “hola world” 가 있다. 이 Merge에서 충돌 표시를 하는 대신 간단히 “hola world” 를 선택한다. 충돌 나지 않은 나머지는 잘 Merge 된다.\n\n이 옵션은 git merge-file 명령에도 사용할 수 있다. 앞에서 이미 git merge-file --ours 같이 실행해서 파일을 따로따로 Merge 했다.\n\n이런 식의 동작을 원하지만 애초에 Git이 Merge 시도조차 하지 않는 자비 없는 옵션도 있다. “ours” Merge 전략 이다. 이 전략은 Recursive Merge 전략의 “ours” 옵션 과는 다르다.\n\n이 작업은 기본적으로 거짓으로 Merge 한다. 그리고 양 브랜치를 부모로 삼는 새 Merge 커밋을 만든다. 하지만, Their 브랜치는 참고하지 않는다. Our 브랜치의 코드를 그대로 사용하고 Merge 한 것처럼 기록할 뿐이다.\n\n지금 있는 브랜치와 Merge 결과가 다르지 않다는 것을 알 수 있다.\n\n이 ours 전략을 이용해 이미 Merge가 되었다고 Git을 속이고 실제로는 Merge를 나중에 수행한다. 예를 들어 release 브랜치을 만들고 여기에도 코드를 추가했다. 언젠가 이것을 master 브랜치에도 Merge 해야 하지만 아직은 하지 않았다. 그리고 master 브랜치에서 bugfix 브랜치를 만들어 버그를 수정하고 이것을 release 브랜치에도 적용(Backport)해야 한다. bugfix 브랜치를 release 브랜치로 Merge 하고 이미 포함된 master 브랜치에도 merge -s ours 명령으로 Merge 해 둔다. 이렇게 하면 나중에 release 브랜치를 Merge 할 때 버그 수정에 대한 커밋으로 충돌이 일어나지 않게끔 할 수 있다.\n\n서브트리 Merge 의 개념은 프로젝트 두 개가 있을 때 한 프로젝트를 다른 프로젝트의 하위 디렉토리로 매핑하여 사용하는 것이다. Merge 전략으로 서브트리(Subtree)를 사용하는 경우 Git은 매우 똑똑하게 서브트리를 찾아서 메인 프로젝트로 서브프로젝트의 내용을 Merge 한다.\n\n한 저장소에 완전히 다른 프로젝트의 리모트 저장소를 추가하고 데이터를 가져와서 Merge 까지 하는 과정을 살펴보자.\n\n먼저 Rack 프로젝트 현재 프로젝트에 추가한다. Rack 프로젝트의 리모트 저장소를 현재 프로젝트의 리모트로 추가하고 Rack 프로젝트의 브랜치와 히스토리를 가져와(Fetch) 확인한다.\n\n(역주 - git fetch rack_remote 명령의 결과에서 warning: no common commits 메시지를 주목해야 한다.) Rack 프로젝트의 브랜치인 rack_branch 를 만들었다. 원 프로젝트는 master 브랜치에 있다. checkout 명령으로 두 브랜치를 이동하면 전혀 다른 두 프로젝트가 한 저장소에 있는 것처럼 보인다.\n\n상당히 요상한 방식으로 Git을 활용한다. 저장소의 브랜치가 꼭 같은 프로젝트가 아닐 수도 있다. Git에서는 전혀 다른 브랜치를 쉽게 만들 수 있다. 물론 이렇게 사용하는 경우는 드물다.\n\nRack 프로젝트를 master 브랜치의 하위 디렉토리로 만들 수 있다. 이는 git read-tree 명령을 사용한다. read-tree 명령과 같이 저수준 명령에 관련된 많은 내용은 Git의 내부에서 다룬다. 간단히 말하자면 read-tree 명령은 어떤 브랜치로부터 루트 트리를 읽어서 현재 Staging Area나 워킹 디렉토리로 가져온다. master 브랜치로 다시 Checkout 하고 rack_branch 브랜치를 rack 이라는 master 브랜치의 하위 디렉토리로 만들어보자.\n\n이제 커밋하면 Rack 프로젝트의 모든 파일이 Tarball 압축파일을 풀어서 소스코드를 포함한 것 같이 커밋에 새로 추가된다. 이렇게 쉽게 한 브랜치의 내용을 다른 브랜치에 Merge 시킬 수 있다는 점이 흥미롭지 않은가? Rack 프로젝트가 업데이트되면 Pull 해서 master 브랜치도 적용할 수 있을까?\n\n위의 명령을 실행하고 업데이트된 결과를 master 브랜치로 다시 Merge 한다. Recursive Merge 전략 옵션인 -Xsubtree 옵션과 --squash 옵션을 함께 사용하면 동일한 커밋 메시지로 업데이트할 수 있다. (Recursive 전략이 기본 전략이지만 설명을 위해서 사용한다)\n\n위 명령을 실행하면 Rack 프로젝트에서 변경된 모든 부분이 master 브랜치로 반영되고 커밋할 준비가 완료된다. 반대로 rack 하위 디렉토리에서 변경한 내용을 rack_branch 로 Merge 하는 것도 가능하다. 변경한 것을 메인테이너에게 보내거나 Upstream에 Push 한다.\n\n이런 방식은 서브모듈(서브모듈에서 자세하게 다룬다)을 사용하지 않고 서브모듈을 관리하는 또 다른 워크플로이다. 한 저장소 안에 다른 프로젝트까지 유지하면서 서브트리 Merge 전략으로 업데이트도 할 수 있다. 프로젝트에 필요한 코드를 한 저장소에서 관리할 수 있다. 다만, 이렇게 저장소를 관리하는 방법은 저장소를 다루기 좀 복잡하고 통합할 때 실수하기 쉽다. 엉뚱한 저장소로 Push 해버릴 가능성도 있다.\n\ndiff 명령으로 rack 하위 디렉토리와 rack_branch 의 차이를 볼 때도 이상하다. Merge 하기 전에 두 차이를 보고 싶어도 diff 명령을 사용할 수 없다. 대신 git diff-tree 명령이 준비돼 있다.\n\n혹은 rack 하위 디렉토리가 Rack 프로젝트의 리모트 저장소의 master 브랜치와 어떤 차이가 있는지 살펴보고 싶을 수도 있다. 마지막으로 Fetch 한 리모트의 master 브랜치와 비교하려면 아래와 같은 명령을 사용한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git merge mundo\nAuto-merging hello.rb\nCONFLICT (content): Merge conflict in hello.rb\nResolved 'hello.rb' using previous resolution.\nAutomatic merge failed; fix conflicts and then commit the result.\n```",
          "```bash\n$ git merge -Xours mundo\nAuto-merging hello.rb\nMerge made by the 'recursive' strategy.\n hello.rb | 2 +-\n test.sh  | 2 ++\n 2 files changed, 3 insertions(+), 1 deletion(-)\n create mode 100644 test.sh\n```",
          "```bash\n$ git merge -s ours mundo\nMerge made by the 'ours' strategy.\n$ git diff HEAD HEAD~\n$\n```",
          "```bash\n$ git remote add rack_remote https://github.com/rack/rack\n$ git fetch rack_remote --no-tags\nwarning: no common commits\nremote: Counting objects: 3184, done.\nremote: Compressing objects: 100% (1465/1465), done.\nremote: Total 3184 (delta 1952), reused 2770 (delta 1675)\nReceiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.\nResolving deltas: 100% (1952/1952), done.\nFrom https://github.com/rack/rack\n * [new branch]      build      -> rack_remote/build\n * [new branch]      master     -> rack_remote/master\n * [new branch]      rack-0.4   -> rack_remote/rack-0.4\n * [new branch]      rack-0.9   -> rack_remote/rack-0.9\n$ git checkout -b rack_branch rack_remote/master\nBranch rack_branch set up to track remote branch refs/remotes/rack_remote/master.\nSwitched to a new branch \"rack_branch\"\n```",
          "```bash\n$ ls\nAUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib\nCOPYING         README         bin           example         test\n$ git checkout master\nSwitched to branch \"master\"\n$ ls\nREADME\n```",
          "```bash\n$ git read-tree --prefix=rack/ -u rack_branch\n```",
          "```bash\n$ git checkout rack_branch\n$ git pull\n```",
          "```bash\n$ git checkout master\n$ git merge --squash -s recursive -Xsubtree=rack rack_branch\nSquash commit -- not updating HEAD\nAutomatic merge went well; stopped before committing as requested\n```",
          "```bash\n$ git diff-tree -p rack_branch\n```",
          "```bash\n$ git diff-tree -p rack_remote/master\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 24,
          "content_length": 3493
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git-도구-고급-Merge",
    "doc_type": "git",
    "total_sections": 4
  },
  {
    "title": "10.1 Git의 내부 - Plumbing 명령과 Porcelain 명령",
    "summary": "여기까지 다 읽고 왔든지 바로 여기부터 보기 시작했던지 간에 이제 마지막 장이다. 이번 장은 Git이 어떻게 구현돼 있고 내부적으로 어떻게 동작하는지 설명한다. Git이 얼마나 유용하고 강력한지 이해하려면 이 장의 내용을 꼭 알아야 한다. 이 장은 초보자에게 너무 혼란스럽고 불필요한 내용이라고 이야기하는 사람들도 있다. 그래서 필자는 본 내용을 책의 가장 마지막에 두었고 독자가 스스로 먼저 볼지 나중에 볼지 선택할 수 있도록 했다.자 이제 본격적으로 살펴보자. 우선 Git은 기본적으로 Content-addressable 파일 시스템이고 그 위에 VCS 사용자 인터페이스가 있는 구조다. 뭔가 깔끔한 정의는 아니지만, 이 말이 무슨 의미인지는 차차 알게 된다.Git 초기에는 (1.5 이전 버전) 사용자 인터페이스가 훨씬 복잡했었다. VCS가 아니라 파일 시스템을 강조했기 때문이었다. 최근 몇 년간 Git은 다른 VCS처럼 쉽고 간결하게 사용자 인터페이스를 다듬어 왔다. 하지만, 여전히 ",
    "sections": [
      {
        "header": "",
        "content": "여기까지 다 읽고 왔든지 바로 여기부터 보기 시작했던지 간에 이제 마지막 장이다. 이번 장은 Git이 어떻게 구현돼 있고 내부적으로 어떻게 동작하는지 설명한다. Git이 얼마나 유용하고 강력한지 이해하려면 이 장의 내용을 꼭 알아야 한다. 이 장은 초보자에게 너무 혼란스럽고 불필요한 내용이라고 이야기하는 사람들도 있다. 그래서 필자는 본 내용을 책의 가장 마지막에 두었고 독자가 스스로 먼저 볼지 나중에 볼지 선택할 수 있도록 했다.\n\n자 이제 본격적으로 살펴보자. 우선 Git은 기본적으로 Content-addressable 파일 시스템이고 그 위에 VCS 사용자 인터페이스가 있는 구조다. 뭔가 깔끔한 정의는 아니지만, 이 말이 무슨 의미인지는 차차 알게 된다.\n\nGit 초기에는 (1.5 이전 버전) 사용자 인터페이스가 훨씬 복잡했었다. VCS가 아니라 파일 시스템을 강조했기 때문이었다. 최근 몇 년간 Git은 다른 VCS처럼 쉽고 간결하게 사용자 인터페이스를 다듬어 왔다. 하지만, 여전히 복잡하고 배우기 어렵다는 선입견이 있다.\n\n우선 Content-addressable 파일 시스템은 정말 대단한 것이므로 먼저 다룬다. 그리고 나서 데이터 전송 원리를 배우고 마지막에는 저장소를 관리하는 법까지 배운다.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 625
        }
      },
      {
        "header": "Plumbing 명령과 Porcelain 명령",
        "content": "이 책은 checkout, branch, remote 같은 30여가지의 명령어로 Git를 어떻게 사용하는지 설명한다. Git은 원래 사용하기 쉽게 만든 VCS라기보다는 VCS를 위한 툴킷이다. 기본적으로 매우 많은 저수준 명령어로 구성돼 있고 이 명령어들을 UNIX 스타일로 엮어서 실행하거나 스크립트로 만들어 사용하도록 설계했다. 이러한 저수준의 명령어는 “Plumbing” 명령어라고 부르고 좀 더 사용자에게 친숙한 사용자용 명령어는 “Porcelain” 명령어라고 부른다.\n\n이 책의 앞 아홉 장은 주로 Porcelain 명령어만 사용했다. 하지만, 이 장에서는 저수준 명령인 Plumbing 명령어를 주로 사용한다. 이 명령으로 Git의 내부구조에 접근할 수 있고 실제로 왜, 그렇게 작동하는지도 살펴볼 수 있다. Plumbing 명령어는 직접 커맨드라인에서 실행하기보다 새로운 도구를 만들거나 각자 필요한 스크립트를 작성할 때 사용한다.\n\n새로 만든 디렉토리나 이미 파일이 있는 디렉토리에서 git init 명령을 실행하면 Git은 데이터를 저장하고 관리하는 .git 디렉토리를 만든다. 이 디렉토리를 복사하기만 해도 저장소가 백업 된다. 이 장은 기본적으로 이 디렉토리에 대한 내용을 설명한다. 새로 저장소를 만들면 .git 디렉토리 구조는 다음과 같다:\n\n이 외에 다른 파일들이 더 있지만, 이 상태가 git init 명령을 실행한 직후에 보이는 새 저장소의 모습이다. description 파일은 기본적으로 GitWeb 프로그램에서만 사용하기 때문에 이 파일은 신경쓰지 않아도 된다. config 파일에는 해당 프로젝트에만 적용되는 설정 옵션이 들어 있다. info 디렉토리는 .gitignore 파일처럼 무시할 파일의 패턴을 적어 두는 곳이다. 하지만 .gitignore 파일과는 달리 Git으로 관리되지 않는다. hooks 디렉토리에는 클라이언트 훅이나 서버 훅이 위치한다. 관련 내용은 Git Hooks 에서 설명한다.\n\n이제 남은 네 가지 항목은 모두 중요한 항목이다. HEAD 파일, index 파일, objects 디렉토리, refs 디렉토리가 남았다. 이 네 항목이 Git의 핵심이다. objects 디렉토리는 모든 컨텐트를 저장하는 데이터베이스이고 refs 디렉토리에는 커밋 개체의 포인터(브랜치, 태그, 리모트 등)를 저장한다. HEAD 파일은 현재 Checkout 한 브랜치를 가리키고 index 파일은 Staging Area의 정보를 저장한다. 각 절마다 주제를 나눠서 Git이 어떻게 동작하는지 자세히 설명한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ ls -F1\nconfig\ndescription\nHEAD\nhooks/\ninfo/\nobjects/\nrefs/\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1258
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git의-내부-Plumbing-명령과-Porcelain-명령",
    "doc_type": "git",
    "total_sections": 2
  },
  {
    "title": "10.2 Git의 내부 - Git 개체",
    "summary": "Git 개체 Git은 Content-addressable 파일시스템이다. 이게 무슨 말이냐 하면 Git의 핵심은 단순한 Key-Value(역주 - 예, 파일 이름과 파일 데이터) 데이터 저장소라는 것이다. 어떤 형식의 데이터라도 집어넣을 수 있고 해당 Key로 언제든지 데이터를 다시 가져올 수 있다. 이 개념을 설명하기 위해 한 Plumbing 명령어를 예로 들면 git hash-object 명령이 있다. 이 명령에 데이터를 주면 .git/objects 디렉토리(object 즉 개체 데이터베이스)에 저장하고 그 데이터에 접근할 수 있는 key를 알려주며 이 key는 저장소 내에서 유일하다. 우선 Git 저장소를 새로 만들어 보자. 당연히 objects 디렉토리에 뭐가 들어 있는지 확인해 보면 새 저장소이기 때문에 아무 것이 없을 것이다. $ git init test Initialized empty Git repository in /tmp/test/.git/ $ cd test $ fi",
    "sections": [
      {
        "header": "Git 개체",
        "content": "Git은 Content-addressable 파일시스템이다. 이게 무슨 말이냐 하면 Git의 핵심은 단순한 Key-Value(역주 - 예, 파일 이름과 파일 데이터) 데이터 저장소라는 것이다. 어떤 형식의 데이터라도 집어넣을 수 있고 해당 Key로 언제든지 데이터를 다시 가져올 수 있다.\n\n이 개념을 설명하기 위해 한 Plumbing 명령어를 예로 들면 git hash-object 명령이 있다. 이 명령에 데이터를 주면 .git/objects 디렉토리(object 즉 개체 데이터베이스)에 저장하고 그 데이터에 접근할 수 있는 key를 알려주며 이 key는 저장소 내에서 유일하다.\n\n우선 Git 저장소를 새로 만들어 보자. 당연히 objects 디렉토리에 뭐가 들어 있는지 확인해 보면 새 저장소이기 때문에 아무 것이 없을 것이다.\n\n아직 빈 디렉토리일 뿐 파일은 아무것도 없다. Git은 init 명령으로 저장소를 초기화할 때 objects 디렉토리를 만들고 그 밑에 pack 과 info 디렉토리도 만든다. git hash-object 명령을 사용하여 Git 데이터베이스에 새 데이터 개체를 직접 저장해보자.\n\ngit hash-object 명령은 주어지는 데이터를 저장하고 이 데이터에 접근하기 위한 key를 반환한다. -w 옵션을 줘야 실제로 저장한다. -w 가 없으면 저장하지 않고 key만 보여준다. 그리고 --stdin 옵션을 주면 표준입력으로 입력되는 데이터를 읽는다. 이 옵션이 없으면 파일 경로를 알려줘야 한다.\n\ngit hash-object 명령이 출력하는 것은 40자 길이의 체크섬 해시다. 이 해시는 헤더 정보와 데이터 모두에 대한 SHA-1 해시이다. 헤더 정보는 차차 자세히 살펴볼 것이다. Git이 저장한 데이터를 알아보자.\n\nobjects 디렉토리에 파일이 하나 새로 생겼다. 데이터는 새로 만든 파일에 저장하며 Git은 데이터를 저장할 때 데이터와 헤더로 생성한 SHA-1 체크섬으로 파일 이름을 짓는다. 해시의 처음 두 글자를 따서 디렉토리 이름에 사용하고 나머지 38글자를 파일 이름에 사용한다.\n\n앞에서와 같이 Git 데이터베이스에 개체를 저장하고 나면 이후에는 git cat-file 명령으로 저장한 데이터를 불러올 수 있다. 이 명령은 Git 개체를 살펴보고 싶을 때 맥가이버칼처럼 사용할 수 있다. git cat-file 명령에 -p 옵션을 주면 파일 내용이 출력된다.\n\n다시 한 번 데이터를 Git 저장소에 추가하고 불러와 보자. Git이 파일 버전을 관리하는 방식을 이해할 수 있도록 가상의 상황을 만들어 살펴본다. 우선 새 파일을 하나 만들고 Git 저장소에 저장한다:\n\n그리고 그 파일을 수정하고 다시 저장한다.\n\n이제 데이터베이스에는 데이터가 두 가지 버전으로 저장돼 있다.\n\n이와 같이 되면 이제 로컬 디렉토리의 test.txt 파일을 지우더라도 Git을 사용하여 test.txt 파일을 첫 번째 버전의 내용으로 되돌릴 수 있다.\n\n파일의 SHA-1 키를 외워서 사용하는 것은 너무 어렵다. 게다가 원래 파일의 이름은 저장하지도 않았다. 단지 파일 내용만 저장했을 뿐이다. 이런 종류의 개체를 Blob 개체라고 부른다. git cat-file -t 명령으로 SHA-1 key를 입력하면 가리키는 해당 개체가 무슨 개체인지 확인할 수 있다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git init test\nInitialized empty Git repository in /tmp/test/.git/\n$ cd test\n$ find .git/objects\n.git/objects\n.git/objects/info\n.git/objects/pack\n$ find .git/objects -type f\n```",
          "```bash\n$ echo 'test content' | git hash-object -w --stdin\nd670460b4b4aece5915caf5c68d12f560a9fe3e4\n```",
          "```bash\n$ find .git/objects -type f\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\n```",
          "```bash\n$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4\ntest content\n```",
          "```bash\n$ echo 'version 1' > test.txt\n$ git hash-object -w test.txt\n83baae61804e65cc73a7201a7252750c76066a30\n```",
          "```bash\n$ echo 'version 2' > test.txt\n$ git hash-object -w test.txt\n1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\n```",
          "```bash\n$ find .git/objects -type f\n.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a\n.git/objects/83/baae61804e65cc73a7201a7252750c76066a30\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4\n```",
          "```bash\n$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt\n$ cat test.txt\nversion 1\n```",
          "```bash\n$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt\n$ cat test.txt\nversion 2\n```",
          "```bash\n$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\nblob\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 13,
          "content_length": 1621
        }
      },
      {
        "header": "Tree 개체",
        "content": "다음은 Tree 개체를 살펴보자. 이 Tree 개체에 파일 이름을 저장한다. 파일 여러 개를 한꺼번에 저장할 수도 있다. Git은 유닉스 파일 시스템과 비슷한 방법으로 저장하지만 좀 더 단순하다. 모든 것을 Tree와 Blob 개체로 저장한다. Tree는 유닉스의 디렉토리에 대응되고 Blob은 Inode나 일반 파일에 대응된다. Tree 개체 하나는 항목을 여러 개 가질 수 있다. 그리고 그 항목에는 Blob 개체나 하위 Tree 개체를 가리키는 SHA-1 포인터, 파일 모드, 개체 타입, 파일 이름이 들어 있다. simplegit 프로젝트의 마지막 Tree 개체를 살펴보자.\n\nmaster^{tree} 구문은 master 브랜치가 가리키는 Tree 개체를 말한다. lib 항목은 디렉토리인데 Blob 개체가 아니고 다른 Tree 개체다.\n\n여러분이 사용하는 쉘이 어떤 것인가에 따라 master^{tree} 표현식이 오류를 일으킬 수도 있다.\n\nWindows 에서 CMD는 ^ 문자는 이스케이프 기호로 사용한다. ^ 문자를 제대로 사용하려면 git cat-file -p master^^{tree} 과 같은 형태로 사용해야 한다. PowerShell을 사용한다면 {} 문자를 사용하는 파라미터의 경우 따옴표 ' 를 사용해야 제대로 된 입력이 가능하다. git cat-file -p 'master^{tree}' 과 같은 형태로 사용해야 한다.\n\nZSH 쉘을 사용한다면 ^ 문자는 Glob 패턴으로 사용되기 때문에 git cat-file -p \"master^{tree}\" 과 같은 형태로 사용해야 한다.\n\nGit이 저장하는 데이터는 대강 아래 그림과 같다.\n\n직접 Tree 개체를 만들어 보자. Git은 일반적으로 Staging Area(Index)의 상태대로 Tree 개체를 만들고 기록한다. 그래서 Tree 개체를 만들려면 우선 Staging Area에 파일을 추가해서 Index를 만들어야 한다. 우선 Plumbing 명령인 update-index 명령으로 test.txt 파일만 들어 있는 Index를 만든다. 이 명령어는 파일을 인위적으로 Staging Area에 추가하는 명령이다. 아직 Staging Area에 없는 파일이기 때문에 --add 옵션을 꼭 줘야 한다(사실 아직 Staging Area도 설정하지 않았다). 그리고 디렉토리에 있는 파일이 아니라 데이터베이스에 있는 파일을 추가하는 것이기 때문에 --cacheinfo 옵션이 필요하다. 파일 모드, SHA-1 해시, 파일 이름 정보도 입력한다.\n\n여기서 파일 모드는 보통의 파일을 나타내는 100644 로 지정했다. 실행파일이라면 100755 로 지정하고 심볼릭 링크라면 120000 으로 지정한다. 이런 파일 모드는 유닉스에서 가져오긴 했지만, 유닉스 모드를 전부 사용하지는 않는다. Blob 파일에는 이 세 가지 모드만 사용한다. 디렉토리나 서브모듈에는 다른 모드를 사용한다.\n\nStaging Area를 Tree 개체로 저장할 때는 git write-tree 명령을 사용한다. write-tree 명령은 Tree 개체가 없으면 자동으로 생성하므로 -w 옵션이 필요 없다.\n\n다음과 같은 git cat-file 명령으로 이 개체가 Tree 개체라는 것을 확인할 수 있다.\n\n파일을 새로 하나 추가하고 test.txt 파일도 두 번째 버전을 만든다. 그리고 나서 Tree 개체를 만든다.\n\n새 파일인 new.txt 파일과 새로운 버전의 test.txt 파일까지 Staging Area에 추가했다. 현재 상태의 Staging Area를 새로운 Tree 개체로 기록하면 어떻게 보이는지 살펴보자.\n\n이 Tree 개체에는 파일이 두 개 있고 test.txt 파일의 SHA 값도 두 번째 버전인 1f7a7a1 이다. 재미난 걸 해보자. 처음에 만든 Tree 개체를 하위 디렉토리로 만들 수 있다. git read-tree 명령으로 Tree 개체를 읽어 Staging Area에 추가한다. --prefix 옵션을 주면 Tree 개체를 하위 디렉토리로 추가할 수 있다.\n\n이 Tree 개체로 워킹 디렉토리를 만들면 파일 두 개와 bak 이라는 하위 디렉토리가 생긴다. 그리고 bak 디렉토리 안에는 test.txt 파일의 처음 버전이 들어 있다. 아래와 그림과 같은 구조로 데이터가 저장된다.\n\n노트 | 여러분이 사용하는 쉘이 어떤 것인가에 따라 master^{tree} 표현식이 오류를 일으킬 수도 있다. Windows 에서 CMD는 ^ 문자는 이스케이프 기호로 사용한다. ^ 문자를 제대로 사용하려면 git cat-file -p master^^{tree} 과 같은 형태로 사용해야 한다. PowerShell을 사용한다면 {} 문자를 사용하는 파라미터의 경우 따옴표 ' 를 사용해야 제대로 된 입력이 가능하다. git cat-file -p 'master^{tree}' 과 같은 형태로 사용해야 한다. ZSH 쉘을 사용한다면 ^ 문자는 Glob 패턴으로 사용되기 때문에 git cat-file -p \"master^{tree}\" 과 같은 형태로 사용해야 한다.\n\n[Note] 노트 여러분이 사용하는 쉘이 어떤 것인가에 따라 master^{tree} 표현식이 오류를 일으킬 수도 있다. Windows 에서 CMD는 ^ 문자는 이스케이프 기호로 사용한다. ^ 문자를 제대로 사용하려면 git cat-file -p master^^{tree} 과 같은 형태로 사용해야 한다. PowerShell을 사용한다면 {} 문자를 사용하는 파라미터의 경우 따옴표 ' 를 사용해야 제대로 된 입력이 가능하다. git cat-file -p 'master^{tree}' 과 같은 형태로 사용해야 한다. ZSH 쉘을 사용한다면 ^ 문자는 Glob 패턴으로 사용되기 때문에 git cat-file -p \"master^{tree}\" 과 같은 형태로 사용해야 한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git cat-file -p master^{tree}\n100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README\n100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile\n040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib\n```",
          "```bash\n$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0\n100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb\n```",
          "```bash\n$ git update-index --add --cacheinfo 100644 \\\n  83baae61804e65cc73a7201a7252750c76066a30 test.txt\n```",
          "```bash\n$ git write-tree\nd8329fc1cc938780ffdd9f94e0d364e0ea74f579\n$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579\n100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt\n```",
          "```bash\n$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579\ntree\n```",
          "```bash\n$ echo 'new file' > new.txt\n$ git update-index --add --cacheinfo 100644 \\\n  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt\n$ git update-index --add new.txt\n```",
          "```bash\n$ git write-tree\n0155eb4229851634a0f03eb265b69f5a2d56f341\n$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341\n100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\n100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt\n```",
          "```bash\n$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579\n$ git write-tree\n3c4e9cd789d88d8d89c1073707c3585e41b0e614\n$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614\n040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak\n100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\n100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 14,
          "content_length": 2854
        }
      },
      {
        "header": "커밋 개체",
        "content": "각기 다른 스냅샷을 나타내는 Tree 개체를 세 개 만들었다. 아직 남은 어려운 점은 여전히 이 스냅샷을 불러오려면 SHA-1 값을 기억하고 있어야 한다는 점이다. 스냅샷을 누가, 언제, 왜 저장했는지에 대한 정보는 아예 없다. 이런 정보는 커밋 개체에 저장된다.\n\n커밋 개체는 commit-tree 명령으로 만든다. 이 명령에 커밋 개체에 대한 설명과 Tree 개체의 SHA-1 값 한 개를 넘긴다. 앞서 저장한 첫 번째 Tree를 가지고 아래와 같이 만들어 본다.\n\n물론 위의 명령을 실행한 시간이나 Author 정보가 다르기 때문에 Hash 값은 다를 것이다. 이어지는 내용에서 커밋과 태그에 사용하는 해시 값을 위의 값을 그대로 사용하지 말고 독자가 실행해서 얻은 해시 값을 사용해야 한다. 새로 생긴 커밋 개체를 git cat-file 명령으로 확인해보자.\n\n커밋 개체의 형식은 간단하다. 해당 스냅샷에서 최상단 Tree를(역주 - 루트 디렉토리 같은) 하나 가리킨다. 그리고 user.name 과 user.email 설정에서 가져온 Author/Committer 정보, 시간 정보, 그리고 한 라인 띄운 다음 커밋 메시지가 들어간다.\n\n이제 커밋 개체를 두 개 더 만들어 보자. 각 커밋 개체는 이전 개체를 가리키도록 한다.\n\n세 커밋 개체는 각각 해당 스냅샷을 나타내는 Tree 개체를 하나씩 가리키고 있다. 이상해 보이겠지만 우리는 진짜 Git 히스토리를 만들었다. 마지막 커밋 개체의 SHA-1 값을 주고 git log 명령을 실행하면 아래와 같이 출력한다.\n\n놀랍지 않은가! 방금 우리는 고수준 명령어 없이 저수준의 명령으로만 Git 히스토리를 만들었다. 지금 한 일이 git add 와 git commit 명령을 실행했을 때 Git 내부에서 일어나는 일이다. Git은 변경된 파일을 Blob 개체로 저장하고 현 Index에 따라서 Tree 개체를 만든다. 그리고 이전 커밋 개체와 최상위 Tree 개체를 참고해서 커밋 개체를 만든다. 즉 Blob, Tree, 커밋 개체가 Git의 주요 개체이고 이 개체는 전부 .git/objects 디렉토리에 저장된다. 이 예제에서 생성한 개체는 아래와 같다.\n\n내부의 포인터를 따라가면 아래와 같은 그림이 그려진다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ echo 'first commit' | git commit-tree d8329f\nfdf4fc3344e67ab068f836878b6c4951e3b15f3d\n```",
          "```bash\n$ git cat-file -p fdf4fc3\ntree d8329fc1cc938780ffdd9f94e0d364e0ea74f579\nauthor Scott Chacon <schacon@gmail.com> 1243040974 -0700\ncommitter Scott Chacon <schacon@gmail.com> 1243040974 -0700\n\nfirst commit\n```",
          "```bash\n$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3\ncac0cab538b970a37ea1e769cbbde608743bc96d\n$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab\n1a410efbd13591db07496601ebc7a059dd55cfe9\n```",
          "```bash\n$ git log --stat 1a410e\ncommit 1a410efbd13591db07496601ebc7a059dd55cfe9\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri May 22 18:15:24 2009 -0700\n\n    third commit\n\n bak/test.txt | 1 +\n 1 file changed, 1 insertion(+)\n\ncommit cac0cab538b970a37ea1e769cbbde608743bc96d\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri May 22 18:14:29 2009 -0700\n\n    second commit\n\n new.txt  | 1 +\n test.txt | 2 +-\n 2 files changed, 2 insertions(+), 1 deletion(-)\n\ncommit fdf4fc3344e67ab068f836878b6c4951e3b15f3d\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri May 22 18:09:34 2009 -0700\n\n    first commit\n\n test.txt | 1 +\n 1 file changed, 1 insertion(+)\n```",
          "```bash\n$ find .git/objects -type f\n.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2\n.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3\n.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2\n.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3\n.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1\n.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'\n.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1\n.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt\n.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1104
        }
      },
      {
        "header": "개체 저장소",
        "content": "내용과 함께 헤더도 저장한다고 얘기했다. 잠시 Git이 개체를 어떻게 저장하는지부터 살펴보자. 대화형 Ruby 쉘을 이용하여 “what is up, doc?” 이라는 문자열을 저장하는 방법을 흉내 내 본다.\n\nGit은 개체의 타입을 Blob으로 만들면서 이를 시작으로 헤더를 만든다. 그 다음에 공백 문자 하나, 내용의 크기, 마지막에 널 문자를 추가한다.\n\nGit은 헤더와 원래 내용을 합쳐서 SHA-1 체크섬을 계산한다. Ruby에서도 require 로 SHA1 라이브러리를 가져다가 흉내 낼 수 있다. require 로 라이브러리를 포함하고 나서 Digest::SHA1.hexdigest() 를 호출한다.\n\n이 내용을 git hash-object 명령을 실행한 결과와 비교해보자. echo -n 명령에 -n 옵션을 사용한 이유는 입력을 전달할 때 개행을 자동으로 넣지 않기 위함이다.\n\nGit은 또 zlib으로 내용을 압축한다. Ruby에도 zlib 라이브러리가 있으니 Ruby에서도 할 수 있다. 라이브러리를 포함하고 Zlib::Deflate.deflate() 를 호출한다.\n\n마지막으로 zlib으로 압축한 내용을 개체로 저장한다. SHA-1 값 중에서 맨 앞에 있는 두 자를 가져다 하위 디렉토리 이름으로 사용하고 나머지 38자를 그 디렉토리 안에 있는 파일이름으로 사용한다. Ruby에서는 FileUtils.mkdir_p() 로 디렉토리를 (없으면) 만들고 File.open() 으로 파일을 연다. 그리고 그 파일에 zlib으로 압축한 내용을 write() 함수로 저장한다.\n\ngit cat-file 명령으로 저장한 개체의 내용을 확인해보자.\n\n다 됐다. 이제 Git Blob 개체를 손으로 만들었다.\n\nGit 개체는 모두 이 방식으로 저장하며 단지 종류만 다르다. 헤더가 blob 이 아니라 그냥 commit 이나 tree 로 시작하게 되는 것뿐이다. Blob 개체는 여기서 보여준 것과 거의 같지만 커밋이 개체나 Tree 개체는 각기 다른 형식을 사용한다.",
        "code_examples": [
          "```bash\n>> header = \"blob #{content.length}\\0\"\n=> \"blob 16\\u0000\"\n```",
          "```bash\n>> store = header + content\n=> \"blob 16\\u0000what is up, doc?\"\n>> require 'digest/sha1'\n=> true\n>> sha1 = Digest::SHA1.hexdigest(store)\n=> \"bd9dbf5aae1a3862dd1526723246b20206e5fc37\"\n```",
          "```bash\n>> require 'zlib'\n=> true\n>> zlib_content = Zlib::Deflate.deflate(store)\n=> \"x\\x9CK\\xCA\\xC9OR04c(\\xCFH,Q\\xC8,V(-\\xD0QH\\xC9O\\xB6\\a\\x00_\\x1C\\a\\x9D\"\n```"
        ],
        "usage_examples": [
          "```bash\n$ irb\n>> content = \"what is up, doc?\"\n=> \"what is up, doc?\"\n```",
          "```bash\n$ echo -n \"what is up, doc?\" | git hash-object --stdin\nbd9dbf5aae1a3862dd1526723246b20206e5fc37\n```",
          "```bash\n>> path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]\n=> \".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37\"\n>> require 'fileutils'\n=> true\n>> FileUtils.mkdir_p(File.dirname(path))\n=> \".git/objects/bd\"\n>> File.open(path, 'w') { |f| f.write zlib_content }\n=> 32\n```",
          "```bash\n---\n$ git cat-file -p bd9dbf5aae1a3862dd1526723246b20206e5fc37\nwhat is up, doc?\n---\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 991
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git의-내부-Git-개체",
    "doc_type": "git",
    "total_sections": 4
  },
  {
    "title": "10.3 Git의 내부 - Git Refs",
    "summary": "Git Refs 어떤 커밋 1a410e 이전의 모든 히스토리를 보려면 git log 1a410e 라고 실행하면 히스토리를 볼 수 있지만, 여전히 1a410e 를 기억해야 한다. 이 커밋은 마지막 커밋이기 때문에 히스토리를 따라 모든 개체를 조회할 수 있다. SHA-1 값을 날로 사용하기보다 쉬운 이름으로 된 포인터가 있으면 그걸 사용하는 게 더 좋다. 외우기 쉬운 이름으로 된 파일에 SHA-1 값을 저장한다. Git에서는 이런 것을 “References” 또는 “Refs” 라고 부른다. 이 SHA-1 값을 저장하는 파일은 .git/refs 디렉토리에 있다. 예제의 프로젝트에는 아직 .git/refs 디렉토리 안에 파일은 없고 디렉토리만 몇 개 있다. $ find .git/refs .git/refs .git/refs/heads .git/refs/tags $ find .git/refs -type f Refs가 있으면 커밋을 찾기 쉬워진다. 사실 내부는 아래처럼 단순하다. $ echo 1",
    "sections": [
      {
        "header": "Git Refs",
        "content": "어떤 커밋 1a410e 이전의 모든 히스토리를 보려면 git log 1a410e 라고 실행하면 히스토리를 볼 수 있지만, 여전히 1a410e 를 기억해야 한다. 이 커밋은 마지막 커밋이기 때문에 히스토리를 따라 모든 개체를 조회할 수 있다. SHA-1 값을 날로 사용하기보다 쉬운 이름으로 된 포인터가 있으면 그걸 사용하는 게 더 좋다. 외우기 쉬운 이름으로 된 파일에 SHA-1 값을 저장한다.\n\nGit에서는 이런 것을 “References” 또는 “Refs” 라고 부른다. 이 SHA-1 값을 저장하는 파일은 .git/refs 디렉토리에 있다. 예제의 프로젝트에는 아직 .git/refs 디렉토리 안에 파일은 없고 디렉토리만 몇 개 있다.\n\nRefs가 있으면 커밋을 찾기 쉬워진다. 사실 내부는 아래처럼 단순하다.\n\nSHA-1 값 대신에 지금 만든 Refs를 사용할 수 있다.\n\nRefs 파일을 직접 고치는 것이 좀 못마땅하다. Git에는 좀 더 안전하게 바꿀 수 있는 git update-ref 명령이 있다.\n\nGit 브랜치의 역할이 바로 이거다. 브랜치는 어떤 작업 중 마지막 작업을 가리키는 포인터 또는 Refs이다. 간단히 두 번째 커밋을 가리키는 브랜치를 만들어 보자.\n\n브랜치는 직접 가리키는 커밋과 그 커밋으로 따라갈 수 있는 모든 커밋을 포함한다.\n\n이제 Git 데이터베이스는 아래 그림처럼 보인다.\n\ngit branch <branch> 명령을 실행하면 Git은 내부적으로 update-ref 명령을 실행한다. 입력받은 브랜치 이름과 현 브랜치의 마지막 커밋의 SHA-1 값을 가져다 update-ref 명령을 실행한다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ find .git/refs\n.git/refs\n.git/refs/heads\n.git/refs/tags\n$ find .git/refs -type f\n```",
          "```bash\n$ echo 1a410efbd13591db07496601ebc7a059dd55cfe9 > .git/refs/heads/master\n```",
          "```bash\n$ git log --pretty=oneline master\n1a410efbd13591db07496601ebc7a059dd55cfe9 third commit\ncac0cab538b970a37ea1e769cbbde608743bc96d second commit\nfdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit\n```",
          "```bash\n$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9\n```",
          "```bash\n$ git update-ref refs/heads/test cac0ca\n```",
          "```bash\n$ git log --pretty=oneline test\ncac0cab538b970a37ea1e769cbbde608743bc96d second commit\nfdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 805
        }
      },
      {
        "header": "HEAD",
        "content": "git branch <branch> 명령을 실행할 때 Git은 어떻게 마지막 커밋의 SHA-1 값을 아는 걸까? HEAD 파일은 현 브랜치를 가리키는 간접(symbolic) Refs다.\n\n간접 Refs라서 다른 것과 다르다. 이 Refs는 다른 Refs를 가리키는 것이라서 SHA-1 값이 없다. 파일을 열어 보면 아래와 같이 생겼다.\n\ngit checkout test 를 실행하면 Git은 HEAD 파일을 아래와 같이 바꾼다.\n\ngit commit 을 실행하면 커밋 개체가 만들어지는데, 지금 HEAD가 가리키고 있던 커밋의 SHA-1 값이 그 커밋 개체의 부모로 사용된다.\n\n이 파일도 손으로 직접 편집할 수 있지만 git symbolic-ref 라는 명령어가 있어서 좀 더 안전하게 사용할 수 있다. 이 명령으로 HEAD의 값을 읽을 수 있다.\n\nrefs 형식에 맞지 않으면 수정할 수 없다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ cat .git/HEAD\nref: refs/heads/master\n```",
          "```bash\n$ cat .git/HEAD\nref: refs/heads/test\n```",
          "```bash\n$ git symbolic-ref HEAD\nrefs/heads/master\n```",
          "```bash\n$ git symbolic-ref HEAD refs/heads/test\n$ cat .git/HEAD\nref: refs/heads/test\n```",
          "```bash\n$ git symbolic-ref HEAD test\nfatal: Refusing to point HEAD outside of refs/\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 446
        }
      },
      {
        "header": "태그",
        "content": "중요한 개체 세 가지는 모두 살펴봤고(Blob, Tree, 커밋) 살펴볼 개체가 하나가 남았다. 태그 개체는 커밋 개체랑 매우 비슷하다. 커밋 개체처럼 누가, 언제 태그를 달았는지 태그 메시지는 무엇이고 어떤 커밋을 가리키는지에 대한 정보가 포함된다. 태그 개체는 Tree 개체가 아니라 커밋 개체를 가리키는 것이 그 둘의 차이다. 브랜치처럼 커밋 개체를 가리키지만 옮길 수는 없다. 태그 개체는 늘 그 이름이 뜻하는 커밋만 가리킨다.\n\nGit의 기초 에서 배웠듯 태그는 Annotated 태그와 Lightweight 태그 두 종류로 나뉜다. 먼저 아래와 같이 Lightweight 태그를 만들어 보자.\n\nLightwieght 태그는 만들기 쉽다. 브랜치랑 비슷하지만 브랜치처럼 옮길 수는 없다. 이에 비해 Annotated 태그는 좀 더 복잡하다. Annotated 태그를 만들면 Git은 태그 개체를 만들고 거기에 커밋을 가리키는 Refs를 저장한다. Annotated 태그는 커밋을 직접 가리키지 않고 태그 개체를 가리킨다. -a 옵션을 주고 Annotated 태그를 만들어 확인해보자.\n\n태그 개체의 SHA-1 값을 확인한다.\n\ngit cat-file -p 명령으로 해당 SHA-1 값의 내용을 조회한다.\n\nobject 부분에 있는 SHA-1 값이 실제로 태그가 가리키는 커밋이다. 커밋 개체뿐만 아니라 모든 Git 개체에 태그를 달 수 있다. 커밋 개체에 태그를 다는 것이 아니라 Git 개체에 태그를 다는 것이다. Git을 개발하는 프로젝트에서는 관리자가 자신의 GPG 공개키를 Blob 개체로 추가하고 그 파일에 태그를 달았다. 아래 명령으로 그 공개키를 확인할 수 있다.\n\nLinux Kernel 저장소에도 커밋이 아닌 다른 개체를 가리키는 태그 개체가 있다. 그 태그는 저장소에 처음으로 소스 코드를 임포트했을 때 그 첫 Tree 개체를 가리킨다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d\n```",
          "```bash\n$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'\n```",
          "```bash\n$ cat .git/refs/tags/v1.1\n9585191f37f7b0fb9444f35a9bf50de191beadc2\n```",
          "```bash\n$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2\nobject 1a410efbd13591db07496601ebc7a059dd55cfe9\ntype commit\ntag v1.1\ntagger Scott Chacon <schacon@gmail.com> Sat May 23 16:48:58 2009 -0700\n\ntest tag\n```",
          "```bash\n$ git cat-file blob junio-gpg-pub\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 931
        }
      },
      {
        "header": "리모트",
        "content": "리모트 Refs라는 것도 있다. 리모트를 추가하고 Push 하면 Git은 각 브랜치마다 Push 한 마지막 커밋이 무엇인지 refs/remotes 디렉토리에 저장한다. 예를 들어, origin 이라는 리모트를 추가하고 master 브랜치를 Push 한다.\n\norigin 의 master 브랜치에서 서버와 마지막으로 교환한 커밋이 어떤 것인지 refs/remotes/origin/master 파일에서 확인할 수 있다.\n\nrefs/heads 에 있는 Refs인 브랜치와 달리 리모트 Refs는 Checkout 할 수 없고 읽기 용도로만 쓸 수 있는 브랜치인 것이다. 이 리모트 Refs는 서버의 브랜치가 가리키는 커밋이 무엇인지 적어둔 일종의 북마크이다.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git remote add origin git@github.com:schacon/simplegit-progit.git\n$ git push origin master\nCounting objects: 11, done.\nCompressing objects: 100% (5/5), done.\nWriting objects: 100% (7/7), 716 bytes, done.\nTotal 7 (delta 2), reused 4 (delta 1)\nTo git@github.com:schacon/simplegit-progit.git\n  a11bef0..ca82a6d  master -> master\n```",
          "```bash\n$ cat .git/refs/remotes/origin/master\nca82a6dff817ec66f44342007202690a93763949\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 364
        }
      }
    ],
    "url": "https://git-scm.com/book/ko/v2/Git의-내부-Git-Refs",
    "doc_type": "git",
    "total_sections": 4
  },
  {
    "title": "What is version control?",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "Version control, also known as source control, is the practice of tracking and managing changes to software code. Version control systems are software tools that help software teams manage changes to source code over time. As development environments have accelerated, version control systems help software teams work faster and smarter. They are especially useful for DevOps teams since they help them to reduce development time and increase successful deployments.\n\nVersion control software keeps track of every modification to the code in a special kind of database. If a mistake is made, developers can turn back the clock and compare earlier versions of the code to help fix the mistake while minimizing disruption to all team members.\n\nFor almost all software projects, the source code is like the crown jewels - a precious asset whose value must be protected. For most software teams, the source code is a repository of the invaluable knowledge and understanding about the problem domain that the developers have collected and refined through careful effort. Version control protects source code from both catastrophe and the casual degradation of human error and unintended consequences.\n\nSoftware developers working in teams are continually writing new source code and changing existing source code. The code for a project, app or software component is typically organized in a folder structure or \"file tree\". One developer on the team may be working on a new feature while another developer fixes an unrelated bug by changing code, each developer may make their changes in several parts of the file tree.\n\nVersion control helps teams solve these kinds of problems, tracking every individual change by each contributor and helping prevent concurrent work from conflicting. Changes made in one part of the software can be incompatible with those made by another developer working at the same time. This problem should be discovered and solved in an orderly manner without blocking the work of the rest of the team. Further, in all software development, any change can introduce new bugs on its own and new software can't be trusted until it's tested. So testing and development proceed together until a new version is ready.\n\nGood version control software supports a developer's preferred workflow without imposing one particular way of working. Ideally it also works on any platform, rather than dictate what operating system or tool chain developers must use. Great version control systems facilitate a smooth and continuous flow of changes to the code rather than the frustrating and clumsy mechanism of file locking - giving the green light to one developer at the expense of blocking the progress of others.\n\nSoftware teams that do not use any form of version control often run into problems like not knowing which changes that have been made are available to users or the creation of incompatible changes between two unrelated pieces of work that must then be painstakingly untangled and reworked. If you're a developer who has never used version control you may have added versions to your files, perhaps with suffixes like \"final\" or \"latest\" and then had to later deal with a new final version. Perhaps you've commented out code blocks because you want to disable certain functionality without deleting the code, fearing that there may be a use for it later. Version control is a way out of these problems.\n\nVersion control software is an essential part of the every-day of the modern software team's professional practices. Individual software developers who are accustomed to working with a capable version control system in their teams typically recognize the incredible value version control also gives them even on small solo projects. Once accustomed to the powerful benefits of version control systems, many developers wouldn't consider working without it even for non-software projects.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 3912
        }
      },
      {
        "header": "Benefits of version control systems",
        "content": "Using version control software is a best practice for high performing software and DevOps teams. Version control also helps developers move faster and allows software teams to preserve efficiency and agility as the team scales to include more developers.\n\nVersion Control Systems (VCS) have seen great improvements over the past few decades and some are better than others. VCS are sometimes known as SCM (Source Code Management) tools or RCS (Revision Control System). One of the most popular VCS tools in use today is called Git. Git is a Distributed VCS, a category known as DVCS, more on that later. Like many of the most popular VCS systems available today, Git is free and open source. Regardless of what they are called, or which system is used, the primary benefits you should expect from version control are as follows.\n\n1. A complete long-term change history of every file. This means every change made by many individuals over the years. Changes include the creation and deletion of files as well as edits to their contents. Different VCS tools differ on how well they handle renaming and moving of files. This history should also include the author, date and written notes on the purpose of each change. Having the complete history enables going back to previous versions to help in root cause analysis for bugs and it is crucial when needing to fix problems in older versions of software. If the software is being actively worked on, almost everything can be considered an \"older version\" of the software.\n\n2. Branching and merging. Having team members work concurrently is a no-brainer, but even individuals working on their own can benefit from the ability to work on independent streams of changes. Creating a \"branch\" in VCS tools keeps multiple streams of work independent from each other while also providing the facility to merge that work back together, enabling developers to verify that the changes on each branch do not conflict. Many software teams adopt a practice of branching for each feature or perhaps branching for each release, or both. There are many different workflows that teams can choose from when they decide how to make use of branching and merging facilities in VCS.\n\n3. Traceability. Being able to trace each change made to the software and connect it to project management and bug tracking software such as Jira, and being able to annotate each change with a message describing the purpose and intent of the change can help not only with root cause analysis and other forensics. Having the annotated history of the code at your fingertips when you are reading the code, trying to understand what it is doing and why it is so designed can enable developers to make correct and harmonious changes that are in accord with the intended long-term design of the system. This can be especially important for working effectively with legacy code and is crucial in enabling developers to estimate future work with any accuracy.\n\nWhile it is possible to develop software without using any version control, doing so subjects the project to a huge risk that no professional team would be advised to accept. So the question is not whether to use version control but which version control system to use.\n\nThere are many choices, but here we are going to focus on just one, Git. Learn more about other types of version control software.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 3364
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/what-is-version-control",
    "doc_type": "git",
    "total_sections": 4
  },
  {
    "title": "What is Git?",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "By far, the most widely used modern version control system in the world today is Git. Git is a mature, actively maintained open source project originally developed in 2005 by Linus Torvalds, the famous creator of the Linux operating system kernel.\n\nA staggering number of software projects rely on Git for version control, including commercial projects as well as open source. Developers who have worked with Git are well represented in the pool of available software development talent and it works well on a wide range of operating systems and IDEs (Integrated Development Environments).\n\nHaving a distributed architecture, Git is an example of a DVCS (hence Distributed Version Control System). Rather than have only one single place for the full version history of the software as is common in once-popular version control systems like CVS or Subversion (also known as SVN), in Git, every developer's working copy of the code is also a repository that can contain the full history of all changes.\n\nIn addition to being distributed, Git has been designed with performance, security and flexibility in mind.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1109
        }
      },
      {
        "header": "Performance",
        "content": "The raw performance characteristics of Git are very strong when compared to many alternatives. Committing new changes, branching, merging and comparing past versions are all optimized for performance. The algorithms implemented inside Git take advantage of deep knowledge about common attributes of real source code file trees, how they are usually modified over time and what the access patterns are.\n\nUnlike some version control software, Git is not fooled by the names of the files when determining what the storage and version history of the file tree should be, instead, Git focuses on the file content itself. After all, source code files are frequently renamed, split, and rearranged. The object format of Git's repository files uses a combination of delta encoding (storing content differences), compression and explicitly stores directory contents and version metadata objects.\n\nBeing distributed enables significant performance benefits as well.\n\nFor example, say a developer, Alice, makes changes to source code, adding a feature for the upcoming 2.0 release, then commits those changes with descriptive messages. She then works on a second feature and commits those changes too. Naturally these are stored as separate pieces of work in the version history. Alice then switches to the version 1.3 branch of the same software to fix a bug that affects only that older version. The purpose of this is to enable Alice's team to ship a bug fix release, version 1.3.1, before version 2.0 is ready. Alice can then return to the 2.0 branch to continue working on new features for 2.0 and all of this can occur without any network access and is therefore fast and reliable. She could even do it on an airplane. When she is ready to send all of the individually committed changes to the remote repository, Alice can \"push\" them in one command.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1845
        }
      },
      {
        "header": "Security",
        "content": "Git has been designed with the integrity of managed source code as a top priority. The content of the files as well as the true relationships between files and directories, versions, tags and commits, all of these objects in the Git repository are secured with a cryptographically secure hashing algorithm called SHA1. This protects the code and the change history against both accidental and malicious change and ensures that the history is fully traceable.\n\nWith Git, you can be sure you have an authentic content history of your source code.\n\nSome other version control systems have no protections against secret alteration at a later date. This can be a serious information security vulnerability for any organization that relies on software development.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 758
        }
      },
      {
        "header": "Flexibility",
        "content": "One of Git's key design objectives is flexibility. Git is flexible in several respects: in support for various kinds of nonlinear development workflows, in its efficiency in both small and large projects and in its compatibility with many existing systems and protocols.\n\nGit has been designed to support branching and tagging as first-class citizens (unlike SVN) and operations that affect branches and tags (such as merging or reverting) are also stored as part of the change history. Not all version control systems feature this level of tracking.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 550
        }
      },
      {
        "header": "Version control with Git",
        "content": "Git is the best choice for most software teams today. While every team is different and should do their own analysis, here are the main reasons why version control with Git is preferred over alternatives:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 204
        }
      },
      {
        "header": "Git is good",
        "content": "Git has the functionality, performance, security and flexibility that most teams and individual developers need. These attributes of Git are detailed above. In side-by-side comparisons with most other alternatives, many teams find that Git is very favorable.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 258
        }
      },
      {
        "header": "Git is a de facto standard",
        "content": "Git is the most broadly adopted tool of its kind. This makes Git attractive for the following reasons. At Atlassian, nearly all of our project source code is managed in Git.\n\nVast numbers of developers already have Git experience and a significant proportion of college graduates may have experience with only Git. While some organizations may need to climb the learning curve when migrating to Git from another version control system, many of their existing and future developers do not need to be trained on Git.\n\nIn addition to the benefits of a large talent pool, the predominance of Git also means that many third party software tools and services are already integrated with Git including IDEs, and our own tools like DVCS desktop client Sourcetree, issue and project tracking software, Jira, and code hosting service, Bitbucket.\n\nIf you are an inexperienced developer wanting to build up valuable skills in software development tools, when it comes to version control, Git should be on your list.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1003
        }
      },
      {
        "header": "Git is a quality open source project",
        "content": "Git is a very well supported open source project with over a decade of solid stewardship. The project maintainers have shown balanced judgment and a mature approach to meeting the long term needs of its users with regular releases that improve usability and functionality. The quality of the open source software is easily scrutinized and countless businesses rely heavily on that quality.\n\nGit enjoys great community support and a vast user base. Documentation is excellent and plentiful, including books, tutorials and dedicated web sites. There are also podcasts and video tutorials.\n\nBeing open source lowers the cost for hobbyist developers as they can use Git without paying a fee. For use in open-source projects, Git is undoubtedly the successor to the previous generations of successful open source version control systems, SVN and CVS.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 845
        }
      },
      {
        "header": "Criticism of Git",
        "content": "One common criticism of Git is that it can be difficult to learn. Some of the terminology in Git will be novel to newcomers and for users of other systems, the Git terminology may be different, for example, revert in Git has a different meaning than in SVN or CVS. Nevertheless, Git is very capable and provides a lot of power to its users. Learning to use that power can take some time, however once it has been learned, that power can be used by the team to increase their development speed.\n\nFor those teams coming from a non-distributed VCS, having a central repository may seem like a good thing that they don't want to lose. However, while Git has been designed as a distributed version control system (DVCS), with Git, you can still have an official, canonical repository where all changes to the software must be stored. With Git, because each developer's repository is complete, their work doesn't need to be constrained by the availability and performance of the \"central\" server. During outages or while offline, developers can still consult the full project history. Because Git is flexible as well as being distributed, you can work the way you are accustomed to but gain the additional benefits of Git, some of which you may not even realise you're missing.\n\nNow that you understand what version control is, what Git is and why software teams should use it, read on to discover the benefits Git can provide across the whole organization.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1451
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/what-is-git",
    "doc_type": "git",
    "total_sections": 11
  },
  {
    "title": "How to install Git",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "Install Git on Mac OS X",
        "content": "There are several ways to install Git on a Mac. In fact, if you've installed XCode (or it's Command Line Tools), Git may already be installed. To find out, open a terminal and enter git --version.\n\nApple actually maintain and ship their own fork of Git, but it tends to lag behind mainstream Git by several major versions. You may want to install a newer version of Git using one of the methods below:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git --versiongit version 2.7.0 (Apple Git-66)\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 401
        }
      },
      {
        "header": "Git for Mac Installer",
        "content": "The easiest way to install Git on a Mac is via the stand-alone installer:\n\n1. Download the latest Git for Mac installer.\n\n2. Follow the prompts to install Git.\n\n3. Open a terminal and verify the installation was successful by typing git --version:\n\n4. Configure your Git username and email using the following commands, replacing Emma's name with your own. These details will be associated with any commits that you create:\n\n5. (Optional) To make Git remember your username and password when working with HTTPS repositories, configure the git-credential-osxkeychain helper.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git --versiongit version 2.9.2\n```",
          "```bash\n$ git config --global user.name \"Emma Paris\"$ git config --global user.email \"eparis@atlassian.com\"\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 573
        }
      },
      {
        "header": "Install Git with Homebrew",
        "content": "If you have installed Homebrew to manage packages on OS X, you can follow these instructions to install Git:\n\n1. Open your terminal and install Git using Homebrew:\n\n2. Verify the installation was successful by typing which git --version:\n\n3. Configure your Git username and email using the following commands, replacing Emma's name with your own. These details will be associated with any commits that you create:\n\n4. (Optional) To make Git remember your username and password when working with HTTPS repositories, install the git-credential-osxkeychain helper.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ brew install git\n```",
          "```bash\n$ git --versiongit version 2.9.2\n```",
          "```bash\n$ git config --global user.name \"Emma Paris\"$ git config --global user.email \"eparis@atlassian.com\"\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 561
        }
      },
      {
        "header": "Install Git with MacPorts",
        "content": "If you have installed MacPorts to manage packages on OS X, you can follow these instructions to install Git:\n\n1. Open your terminal and update MacPorts:\n\n2. Search for the latest available Git ports and variants:\n\n3. Install Git with bash completion, the OS X keychain helper, and the docs:\n\n4. Configure your Git username and email using the following commands, replacing Emma's name with your own. These details will be associated with any commits that you create:\n\n5. (Optional) To make Git remember your username and password when working with HTTPS repositories, configure the git-credential-osxkeychain helper.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ sudo port selfupdate\n```",
          "```bash\n$ port search git$ port variants git\n```",
          "```bash\n$ sudo port install git +bash_completion +credential_osxkeychain +doc\n```",
          "```bash\n$ git config --global user.name \"Emma Paris\"$ git config --global user.email \"eparis@atlassian.com\"\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 616
        }
      },
      {
        "header": "Install the git-credential-osxkeychain helper",
        "content": "Bitbucket supports pushing and pulling your Git repositories over both SSH and HTTPS. To work with a private repository over HTTPS, you must supply a username and password each time you push or pull. The git-credential-osxkeychain helper allows you to cache your username and password in the OSX keychain, so you don't have to retype it each time.\n\n1. If you followed the MacPorts or Homebrew instructions above, the helper should already be installed. Otherwise you'll need to download and install it. Open a terminal window and check:\n\nIf you receive a usage statement, skip to step 4. If the helper is not installed, go to step 2.\n\n2. Use curl to download git-credential-osxkeychain (or download it via your browser) and move it to /usr/local/bin:\n\n3. Make the file an executable:\n\n4. Configure git to use the osxkeychain credential helper.\n\nThe next time Git prompts you for a username and password, it will cache them in your keychain for future use.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git credential-osxkeychainusage: git credential-osxkeychain <get|store|erase>\n```",
          "```bash\n$ curl -O http://github-media-downloads.s3.amazonaws.com/osx/git-credential-osxkeychain$ sudo mv git-credential-osxkeychain /usr/local/bin/\n```",
          "```bash\n$ chmod u+x /usr/local/bin/git-credential-osxkeychain\n```",
          "```bash\n$ git config --global credential.helper osxkeychain\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 955
        }
      },
      {
        "header": "Install Git with Atlassian Sourcetree",
        "content": "Sourcetree, a free visual Git client for Mac, comes with its own bundled version of Git. You can download Sourcetree here.\n\nTo learn how to use Git with Sourcetree (and how to host your Git repositories on Bitbucket) you can follow our comprehensive Git tutorial with Bitbucket and Sourcetree.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 293
        }
      },
      {
        "header": "Build Git from source on OS X",
        "content": "Building Git can be a little tricky on Mac due to certain libraries moving around between OS X releases. On El Capitan (OS X 10.11), follow these instructions to build Git:\n\n1. From your terminal install XCode's Command Line Tools (if you haven't already):\n\n2. Install Homebrew.\n\n3. Using Homebrew, install openssl:\n\n4. Clone the Git source (or if you don't yet have a version of Git installed, download and extract it):\n\n5. To build Git run make with the following flags:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ xcode-select --install\n```",
          "```bash\n$ brew install openssl\n```",
          "```bash\n$ git clone https://github.com/git/git.git\n```",
          "```bash\n$ NO_GETTEXT=1 make CFLAGS=\"-I/usr/local/opt/openssl/include\" LDFLAGS=\"-L/usr/local/opt/openssl/lib\"\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 472
        }
      },
      {
        "header": "Git for Windows stand-alone installer",
        "content": "1. Download the latest Git for Windows installer.\n\n2. When you've successfully started the installer, you should see the Git Setup wizard screen. Follow the Next and Finish prompts to complete the installation. The default options are pretty sensible for most users.\n\n3. Open a Command Prompt (or Git Bash if during installation you elected not to use Git from the Windows Command Prompt).\n\n4. Run the following commands to configure your Git username and email using the following commands, replacing Emma's name with your own. These details will be associated with any commits that you create:\n\n5. Optional: Install the Git credential helper on Windows\n\nBitbucket supports pushing and pulling over HTTP to your remote Git repositories on Bitbucket. Every time you interact with the remote repository, you must supply a username/password combination. You can store these credentials, instead of supplying the combination every time, with the Git Credential Manager for Windows.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git config --global user.name \"Emma Paris\"$ git config --global user.email \"eparis@atlassian.com\"\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 978
        }
      },
      {
        "header": "Install Git with Atlassian Sourcetree",
        "content": "Sourcetree, a free visual Git client for Windows, comes with its own bundled version of Git. You can download Sourcetree here.\n\nTo learn how to use Git with Sourcetree (and how to host your Git repositories on Bitbucket) you can follow our comprehensive Git tutorial with Bitbucket and Sourcetree.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 297
        }
      },
      {
        "header": "Debian / Ubuntu (apt-get)",
        "content": "Git packages are available via apt:\n\n1. From your shell, install Git using apt-get:\n\n2. Verify the installation was successful by typing git --version:\n\n3. Configure your Git username and email using the following commands, replacing Emma's name with your own. These details will be associated with any commits that you create:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ sudo apt-get update$ sudo apt-get install git\n```",
          "```bash\n$ git --versiongit version 2.9.2\n```",
          "```bash\n$ git config --global user.name \"Emma Paris\"$ git config --global user.email \"eparis@atlassian.com\"\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 327
        }
      },
      {
        "header": "Fedora (dnf/yum)",
        "content": "Git packages are available via both yum and dnf:\n\n1. From your shell, install Git using dnf (or yum, on older versions of Fedora):\n\n2. Verify the installation was successful by typing git --version:\n\n3. Configure your Git username and email using the following commands, replacing Emma's name with your own. These details will be associated with any commits that you create",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ sudo dnf install git\n```",
          "```bash\n$ sudo yum install git\n```",
          "```bash\n$ git --versiongit version 2.9.2\n```",
          "```bash\n$ git config --global user.name \"Emma Paris\"$ git config --global user.email \"eparis@atlassian.com\"\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 373
        }
      },
      {
        "header": "Build Git from source on Linux",
        "content": "Git requires the several dependencies to build on Linux. These are available via apt:\n\n1. From your shell, install the necessary dependencies using apt-get:\n\n2. Clone the Git source (or if you don't yet have a version of Git installed, download and extract it):\n\n3. To build Git and install it under /usr, run make:\n\nGit requires the several dependencies to build on Linux. These are available via both yum and dnf:\n\n1. From your shell, install the necessary build dependencies using dnf (or yum, on older versions of Fedora):\n\nor using yum. For yum, you may need to install the Extra Packages for Enterprise Linux (EPEL) repository first:\n\n2. Symlink docbook2X to the filename that the Git build expects:\n\n3. Clone the Git source (or if you don't yet have a version of Git installed, download and extract it):\n\n4. To build Git and install it under /usr, run make:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ sudo apt-get update$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev asciidoc xmlto docbook2x\n```",
          "```bash\n$ git clone https://git.kernel.org/pub/scm/git/git.git\n```",
          "```bash\n$ make all doc info prefix=/usr$ sudo make install install-doc install-html install-info install-man prefix=/usr\n```",
          "```bash\n$ sudo dnf install curl-devel expat-devel gettext-devel openssl-devel perl-devel zlib-devel asciidoc xmlto docbook2X\n```",
          "```bash\n$ sudo yum install epel-release$ sudo yum install curl-devel expat-devel gettext-devel openssl-devel perl-devel zlib-devel asciidoc xmlto docbook2X\n```",
          "```bash\n$ sudo ln -s /usr/bin/db2x_docbook2texi /usr/bin/docbook2x-texi\n```",
          "```bash\n$ git clone https://git.kernel.org/pub/scm/git/git.git\n```",
          "```bash\n$ make all doc prefix=/usr$ sudo make install install-doc install-html install-man prefix=/usr\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 864
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/install-git",
    "doc_type": "git",
    "total_sections": 14
  },
  {
    "title": "How to Use git init to Create a Git Repo",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "This tutorial provides an overview of how to set up a repository (repo) under Git version control. This resource will walk you through initializing a Git repository for a new or existing project. Included below are workflow examples of repositories both created locally and cloned from remote repositories. This guide assumes a basic familiarity with a command-line interface.\n\nThe high level points this guide will cover are:\n\nBy the end of this module, you should be able to create a Git repo, use common Git commands, commit a modified file, view your project’s history and configure a connection to a Git hosting service (Bitbucket).\n\n• Initializing a new Git repo\n• Cloning an existing Git repo\n• Committing a modified version of a file to the repo\n• Configuring a Git repo for remote collaboration\n• Common Git version control commands",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 841
        }
      },
      {
        "header": "What is a Git repository?",
        "content": "A Git repository is a virtual storage of your project. It allows you to save versions of your code, which you can access when needed.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 133
        }
      },
      {
        "header": "How to initialize a new Git repo with git init",
        "content": "To create a new repo, you'll use the git init command. git init is a one-time command you use during the initial setup of a new repo. Executing this command will create a new .git subdirectory in your current working directory. This will also create a new main branch.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 268
        }
      },
      {
        "header": "Versioning an existing project with a new git repository",
        "content": "This example assumes you already have an existing project folder that you would like to create a repo within. You'll first cd to the root project folder and then execute the git init command.\n\nPointing git init to an existing project directory will execute the same initialization setup as mentioned above, but scoped to that project directory.\n\nVisit the git init page for a more detailed resource on git init.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ncd /path/to/your/existing/codegit init\n```",
          "```bash\ngit init <project directory>\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 411
        }
      },
      {
        "header": "How to clone an existing Git repo with git clone",
        "content": "If a project has already been set up in a central repository, the clone command is the most common way for users to obtain a local development clone. Like git init, cloning is generally a one-time operation. Once a developer has obtained a working copy, all version control operations are managed through their local repository.\n\ngit clone is used to create a copy or clone of remote repositories. You pass git clone a repository URL. Git supports a few different network protocols and corresponding URL formats. In this example, we'll be using the Git SSH protocol. Git SSH URLs follow a template of: git@HOSTNAME:USERNAME/REPONAME.git\n\nAn example Git SSH URL would be: git@bitbucket.org:rhyolight/javascript-data-store.git where the template values match:\n\nWhen executed, the latest version of the remote repo files on the main branch will be pulled down and added to a new folder. The new folder will be named after the REPONAME in this case javascript-data-store. The folder will contain the full history of the remote repository and a newly created main branch.\n\nFor more documentation on git clone usage and supported Git URL formats, visit the git clone Page.\n\n• HOSTNAME: bitbucket.org\n• USERNAME: rhyolight\n• REPONAME: javascript-data-store",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit clone <repo url>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1249
        }
      },
      {
        "header": "Saving changes to the repository: git add and git commit",
        "content": "Now that you have a repository cloned or initialized, you can commit file version changes to it. The following example assumes you have set up a project at /path/to/project. The steps being taken in this example are:\n\nAfter executing this example, your repo will now have CommitTest.txt added to the history and will track future updates to the file.\n\nThis example introduced two additional git commands: add and commit. This was a very limited example, but both commands are covered more in depth on the git add and git commit pages. Another common use case for git add is the --all option. Executing git add --all will take any changed and untracked files in the repo and add them to the repo and update the repo's working tree.\n\n• Change directories to /path/to/project\n• Create a new file CommitTest.txt with contents ~\"test content for git tutorial\"~\n• git add CommitTest.txt to the repository staging area\n• Create a new commit with a message describing what work was done in the commit",
        "code_examples": [],
        "usage_examples": [
          "```bash\ncd /path/to/projectecho \"test content for git tutorial\" >> CommitTest.txtgit add CommitTest.txtgit commit -m \"added CommitTest.txt to the repo\"\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 992
        }
      },
      {
        "header": "Repo-to-repo collaboration: git push",
        "content": "It’s important to understand that Git’s idea of a “working copy” is very different from the working copy you get by checking out source code from an SVN repository. Unlike SVN, Git makes no distinction between the working copies and the central repository—they're all full-fledged Git repositories.\n\nThis makes collaborating with Git fundamentally different than with SVN. Whereas SVN depends on the relationship between the central repository and the working copy, Git’s collaboration model is based on repository-to-repository interaction. Instead of checking a working copy into SVN’s central repository, you push or pull commits from one repository to another.\n\nOf course, there’s nothing stopping you from giving certain Git repos special meaning. For example, by simply designating one Git repo as the “central” repository, it’s possible to replicate a centralized workflow using Git. This is accomplished through conventions rather than being hardwired into the VCS itself.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 980
        }
      },
      {
        "header": "Bare vs. cloned repositories",
        "content": "If you used git clone in the previous \"Initializing a new Repository\" section to set up your local repository, your repository is already configured for remote collaboration. git clone will automatically configure your repo with a remote pointed to the Git URL you cloned it from. This means that once you make changes to a file and commit them, you can git push those changes to the remote repository.\n\nIf you used git init to make a fresh repo, you'll have no remote repo to push changes to. A common pattern when initializing a new repo is to go to a hosted Git service like Bitbucket and create a repo there. The service will provide a Git URL that you can then add to your local Git repository and git push to the hosted repo. Once you have created a remote repo with your service of choice you will need to update your local repo with a mapping. We discuss this process in the Configuration & Set Up guide below.\n\nIf you prefer to host your own remote repo, you'll need to set up a \"Bare Repository.\" Both git init and git clone accept a --bare argument. The most common use case for bare repo is to create a remote central Git repository",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1144
        }
      },
      {
        "header": "Configuration & set up: git config",
        "content": "Once you have a remote repo setup, you will need to add a remote repo url to your local git config, and set an upstream branch for your local branches. The git remote command offers such utility.\n\nThis command will map remote repository at ＜remote_repo_url＞ to a ref in your local repo under ＜remote_name＞. Once you have mapped the remote repo you can push local branches to it.\n\nThis command will push the local repo branch under < local_branch_name > to the remote repo at < remote_name >.\n\nFor more in-depth look at git remote, see the Git remote page.\n\nIn addition to configuring a remote repo URL, you may also need to set global Git configuration options such as username, or email. The git config command lets you configure your Git installation (or an individual repository) from the command line. This command can define everything from user info, to preferences, to the behavior of a repository. Several common configuration options are listed below.\n\nGit stores configuration options in three separate files, which lets you scope options to individual repositories (local), user (Global), or the entire system (system):\n\nDefine the author name to be used for all commits in the current repository. Typically, you’ll want to use the --global flag to set configuration options for the current user.\n\nDefine the author name to be used for all commits by the current user.\n\nAdding the --local option or not passing a config level option at all, will set the user.name for the current local repository.\n\nDefine the author email to be used for all commits by the current user.\n\nCreate a shortcut for a Git command. This is a powerful utility to create custom shortcuts for commonly used git commands. A simplistic example would be:\n\nThis creates a ci command that you can execute as a shortcut to git commit. To learn more about git aliases visit the git config page.\n\nDefine the text editor used by commands like git commit for all users on the current machine. The < editor > argument should be the command that launches the desired editor (e.g., vi). This example introduces the --system option. The --system option will set the configuration for the entire system, meaning all users and repos on a machine. For more detailed information on configuration levels visit the git config page.\n\nOpen the global configuration file in a text editor for manual editing. An in-depth guide on how to configure a text editor for git to use can be found on the Git config page.\n\n• Local: /.git/config – Repository-specific settings.\n• Global: /.gitconfig – User-specific settings. This is where options set with the --global flag are stored.\n• System: $(prefix)/etc/gitconfig – System-wide settings.",
        "code_examples": [
          "```bash\nit config --system core.editor <editor>\n```"
        ],
        "usage_examples": [
          "```bash\ngit remote add <remote_name> <remote_repo_url>\n```",
          "```bash\ngit push -u <remote_name> <local_branch_name>\n```",
          "```bash\ngit config --global user.name <name>\n```",
          "```bash\ngit config --local user.email <email>\n```",
          "```bash\ngit config --global alias.<alias-name> <git-command>\n```",
          "```bash\ngit config --global alias.ci commit\n```",
          "```bash\ngit config --global --edit\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 14,
          "content_length": 2695
        }
      },
      {
        "header": "Discussion",
        "content": "All configuration options are stored in plaintext files, so the git config command is really just a convenient command-line interface. Typically, you’ll only need to configure a Git installation the first time you start working on a new development machine, and for virtually all cases, you'll want to use the --global flag. One important exception is to override the author email address. You may wish to set your personal email address for personal and open source repositories, and your professional email address for work-related repositories.\n\nGit stores configuration options in three separate files, which lets you scope options to individual repositories, users, or the entire system:\n\nWhen options in these files conflict, local settings override user settings, which override system-wide. If you open any of these files, you’ll see something like the following:\n\nYou can manually edit these values to the exact same effect as git config.\n\n• /.git/config – Repository-specific settings.\n• ~/.gitconfig – User-specific settings. This is where options set with the --global flag are stored.\n• $(prefix)/etc/gitconfig – System-wide settings.",
        "code_examples": [
          "```bash\n[user] name = John Smith email = john@example.com [alias] st = status co = checkout br = branch up = rebase ci = commit [core] editor = vim\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1147
        }
      },
      {
        "header": "Example",
        "content": "The first thing you’ll want to do after installing Git is tell it your name/email and customize some of the default settings. A typical initial configuration might look something like the following:\n\nTell Git who you are git config\n\nSelect your favorite text editor\n\nAdd some SVN-like aliases\n\nThis will produce the ~ /.gitconfig file from the previous section. Take a more in-depth look at git config on the git config page.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit --global user.name \"John Smith\" git config --global user.email john@example.com\n```",
          "```bash\ngit config --global core.editor vim\n```",
          "```bash\ngit config --global alias.st statusgit config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.up rebasegit config --global alias.ci commit\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 425
        }
      },
      {
        "header": "Summary",
        "content": "Here we demonstrated how to create a git repository using two methods: git init and git clone. This guide can be applied to manage software source code or other content that needs to be versioned. Git add, git commit, git push, and git remote were also introduced and utilized at a high level.\n\nRead our guide about which code repository system is right for your team!",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 368
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/setting-up-a-repository",
    "doc_type": "git",
    "total_sections": 14
  },
  {
    "title": "Git init",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "This page will explore the git init command in depth. By the end of this page you will be informed on the core functionality and extended feature set of git init. This exploration includes:\n\nThe git init command creates a new Git repository. It can be used to convert an existing, unversioned project to a Git repository or initialize a new, empty repository. Most other Git commands are not available outside of an initialized repository, so this is usually the first command you'll run in a new project.\n\nExecuting git init creates a .git subdirectory in the current working directory, which contains all of the necessary Git metadata for the new repository. This metadata includes subdirectories for objects, refs, and template files. A HEAD file is also created which points to the currently checked out commit.\n\nAside from the .git directory, in the root directory of the project, an existing project remains unaltered (unlike SVN, Git doesn't require a .git subdirectory in every subdirectory).\n\nBy default, git init will initialize the Git configuration to the .git subdirectory path. The subdirectory path can be modified and customized if you would like it to live elsewhere. You can set the $GIT_DIR environment variable to a custom path and git init will initialize the Git configuration files there. Additionally you can pass the --separate-git-dir argument for the same result. A common use case for a separate .git subdirectory is to keep your system configuration \"dotfiles\" (.bashrc, .vimrc, etc.) in the home directory while keeping the .git folder elsewhere.\n\n• git init options and usage\n• .git directory overview\n• custom git init directory environment values\n• git init vs. git clone\n• git init bare repositories\n• git init templates",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1754
        }
      },
      {
        "header": "Usage",
        "content": "Compared to SVN, the git init command is an incredibly easy way to create new version-controlled projects. Git doesn’t require you to create a repository, import files, and check out a working copy. Additionally, Git does not require any pre-existing server or admin privileges. All you have to do is cd into your project subdirectory and run git init, and you'll have a fully functional Git repository.\n\nTransform the current directory into a Git repository. This adds a .git subdirectory to the current directory and makes it possible to start recording revisions of the project.\n\nCreate an empty Git repository in the specified directory. Running this command will create a new subdirectory called ＜directory＞ containing nothing but the .git subdirectory.\n\nIf you've already run git init on a project directory and it contains a .git subdirectory, you can safely run git init again on the same project directory. It will not override an existing .git configuration.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit init\n```",
          "```bash\ngit init <directory>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 968
        }
      },
      {
        "header": "git init vs. git clone",
        "content": "A quick note: git init and git clone can be easily confused. At a high level, they can both be used to \"initialize a new git repository.\" However, git clone is dependent on git init. git clone is used to create a copy of an existing repository. Internally, git clone first calls git init to create a new repository. It then copies the data from the existing repository, and checks out a new set of working files. Learn more on the git clone page.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 446
        }
      },
      {
        "header": "Bare repositories --- git init --bare",
        "content": "Initialize an empty Git repository, but omit the working directory. Shared repositories should always be created with the --bare flag (see discussion below). Conventionally, repositories initialized with the --bare flag end in .git. For example, the bare version of a repository called my-project should be stored in a directory called my-project.git.\n\nThe --bare flag creates a repository that doesn’t have a working directory, making it impossible to edit files and commit changes in that repository. You would create a bare repository to git push and git pull from, but never directly commit to it. Central repositories should always be created as bare repositories because pushing branches to a non-bare repository has the potential to overwrite changes. Think of --bare as a way to mark a repository as a storage facility, as opposed to a development environment. This means that for virtually all Git workflows, the central repository is bare, and developers local repositories are non-bare.\n\nThe most common use case for git init --bare is to create a remote central repository:\n\nFirst, you SSH into the server that will contain your central repository. Then, you navigate to wherever you’d like to store the project. Finally, you use the --bare flag to create a central storage repository. Developers would then clone my-project.git to create a local copy on their development machine.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit init --bare <directory>\n```",
          "```bash\nssh <user>@<host> cd path/above/repo git init --bare my-project.git\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1393
        }
      },
      {
        "header": "git init templates",
        "content": "Initializes a new Git repository and copies files from the ＜template_directory＞ into the repository.\n\nTemplates allow you to initialize a new repository with a predefined .git subdirectory. You can configure a template to have default directories and files that will get copied to a new repository's .git subdirectory. The default Git templates usually reside in a `/usr/share/git-core/templates` directory but may be a different path on your machine.\n\nThe default templates are a good reference and example of how to utilize template features. A powerful feature of templates that's exhibited in the default templates is Git Hook configuration. You can create a template with predefined Git hooks and initialize your new git repositories with common hooks ready to go. Learn more about Git Hooks at the Git Hook page.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit init <directory> --template=<template_directory>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 818
        }
      },
      {
        "header": "Configuration",
        "content": "All configurations of git init take a ＜directory＞ argument. If you provide the , the command is run inside it. If this directory does not exist, it will be created. In addition to the options and configuration already discussed, Git init has a few other command line options. A full list of them follows:\n\nOnly prints \"critical level\" messages, Errors, and Warnings. All other output is silenced.\n\nCreates a bare repository. (See the \"Bare Repositories\" section above.)\n\nSpecifies the directory from which templates will be used. (See the \"Git Init Templates\" section above.)\n\nCreates a text file containing the path to . This file acts as a link to the .git directory. This is useful if you would like to store your .git directory on a separate location or drive from your project's working files. Some common use cases for --separate-git-dir are:\n\nYou can call git init --separate-git-dir on an existing repository and the .git dir will be moved to the specified path.\n\nSet access permissions for the new repository. This specifies which users and groups using Unix-level permissions are allowed to push/pull to the repository.\n\n• To keep your system configuration \"dotfiles\" (.bashrc, .vimrc, etc.) in the home directory while keeping the .git folder elsewhere\n• Your Git history has grown very large in disk size and you need to move it elsewhere to a separate high-capacity drive\n• You want to have a Git project in a publicly accessible directory like `www:root`",
        "code_examples": [
          "```bash\n--SHARED[=(FALSE|TRUE|UMASK|GROUP|ALL|WORLD|EVERYBODY|0XXX)]\n```"
        ],
        "usage_examples": [
          "```bash\ngit init <directory> --template=<template_directory>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1468
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-init",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "Git clone",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "Here we'll examine the git clone command in depth. git clone is a Git command line utility which is used to target an existing repository and create a clone, or copy of the target repository. In this page we'll discuss extended configuration options and common use cases of git clone. Some points we'll cover here are:\n\nOn the setting up a repository guide, we covered a basic use case of git clone. This page will explore more complex cloning and configuration scenarios.\n\n• Cloning a local or remote repository\n• Cloning a bare repository\n• Using shallow options to partially clone repositories\n• Git URL syntax and supported protocols",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 637
        }
      },
      {
        "header": "Purpose: repo-to-repo collaboration development copy",
        "content": "If a project has already been set up in a central repository, the git clone command is the most common way for users to obtain a development copy. Like git init, cloning is generally a one-time operation. Once a developer has obtained a working copy, all version control operations and collaborations are managed through their local repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 344
        }
      },
      {
        "header": "Repo-to-repo collaboration",
        "content": "It’s important to understand that Git’s idea of a “working copy” is very different from the working copy you get by checking out code from an SVN repository. Unlike SVN, Git makes no distinction between the working copy and the central repository—they're all full-fledged Git repositories.\n\nThis makes collaborating with Git fundamentally different than with SVN. Whereas SVN depends on the relationship between the central repository and the working copy, Git’s collaboration model is based on repository-to-repository interaction. Instead of checking a working copy into SVN’s central repository, you push or pull commits from one repository to another.\n\nOf course, there’s nothing stopping you from giving certain Git repos special meaning. For example, by simply designating one Git repo as the “central” repository, it’s possible to replicate a centralized workflow using Git. The point is, this is accomplished through conventions rather than being hardwired into the VCS itself.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 985
        }
      },
      {
        "header": "Usage",
        "content": "git clone is primarily used to point to an existing repo and make a clone or copy of that repo at in a new directory, at another location. The original repository can be located on the local filesystem or on remote machine accessible supported protocols. The git clone command copies an existing Git repository. This is sort of like SVN checkout, except the “working copy” is a full-fledged Git repository—it has its own history, manages its own files, and is a completely isolated environment from the original repository.\n\nAs a convenience, cloning automatically creates a remote connection called \"origin\" pointing back to the original repository. This makes it very easy to interact with a central repository. This automatic connection is established by creating Git refs to the remote branch heads under refs/remotes/origin and by initializing remote.origin.url and remote.origin.fetch configuration variables.\n\nAn example demonstrating using git clone can be found on the setting up a repository guide. The example below demonstrates how to obtain a local copy of a central repository stored on a server accessible at example.com using the SSH username john:\n\nThe first command initializes a new Git repository in the my-project folder on your local machine and populates it with the contents of the central repository. Then, you can cd into the project and start editing files, committing snapshots, and interacting with other repositories. Also note that the .git extension is omitted from the cloned repository. This reflects the non-bare status of the local copy.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit clone ssh://john@example.com/path/to/my-project.gitcd my-project# Start working on the project\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1573
        }
      },
      {
        "header": "Cloning to a specific folder",
        "content": "Clone the repository located at ＜repo＞ into the folder called ~＜directory＞! on the local machine.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit clone <repo> <directory>\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 97
        }
      },
      {
        "header": "Cloning a specific tag",
        "content": "Clone the repository located at ＜repo＞ and only clone the ref for ＜tag＞.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit clone --branch <tag> <repo>\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 72
        }
      },
      {
        "header": "Shallow clone",
        "content": "Clone the repository located at ＜repo＞ and only clone the history of commits specified by the option depth=1. In this example a clone of ＜repo＞ is made and only the most recent commit is included in the new cloned Repo. Shallow cloning is most useful when working with repos that have an extensive commit history. An extensive commit history may cause scaling problems such as disk space usage limits and long wait times when cloning. A Shallow clone can help alleviate these scaling issues.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit clone -depth=1 <repo>\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 491
        }
      },
      {
        "header": "git clone -branch",
        "content": "The -branch argument lets you specify a specific branch to clone instead of the branch the remote HEAD is pointing to, usually the main branch. In addition you can pass a tag instead of branch for the same effect.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit clone --branch\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 213
        }
      },
      {
        "header": "git clone -mirror vs. git clone -bare",
        "content": "Similar to git init --bare, when the -bare argument is passed to git clone, a copy of the remote repository will be made with an omitted working directory. This means that a repository will be set up with the history of the project that can be pushed and pulled from, but cannot be edited directly. In addition, no remote branches for the repo will be configured with the -bare repository. Like git init --bare, this is used to create a hosted repository that developers will not edit directly.\n\nPassing the --mirror argument implicitly passes the --bare argument as well. This means the behavior of --bare is inherited by --mirror. Resulting in a bare repo with no editable working files. In addition, --mirror will clone all the extended refs of the remote repository, and maintain remote branch tracking configuration. You can then run git remote update on the mirror and it will overwrite all refs from the origin repo. Giving you exact 'mirrored' functionality.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 966
        }
      },
      {
        "header": "Other configuration options",
        "content": "For a comprehensive list of other git clone options visit the official Git documentation. In this document, we'll touch on some other common options.\n\nClones the repo at ＜repo location＞ and applies the template from ＜template directory＞ to the newly created local branch. A thorough reference on Git templates can be found on our git init page.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit clone --template=<template_directory> <repo location>\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 344
        }
      },
      {
        "header": "Git URLs",
        "content": "Git has its own URL syntax which is used to pass remote repository locations to Git commands. Because git clone is most commonly used on remote repositories we will examine Git URL syntax here.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 193
        }
      },
      {
        "header": "Git URL protocols",
        "content": "Secure Shell (SSH) is a ubiquitous authenticated network protocol that is commonly configured by default on most servers. Because SSH is an authenticated protocol, you'll need to establish credentials with the hosting server before connecting. ssh://[user@]host.xz[:port]/path/to/repo.git/\n\nA protocol unique to git. Git comes with a daemon that runs on port (9418). The protocol is similar to SSH however it has NO AUTHENTICATION. git://host.xz[:port]/path/to/repo.git/\n\nHyper text transfer protocol. The protocol of the web, most commonly used for transferring web page HTML data over the Internet. Git can be configured to communicate over HTTP http[s]://host.xz[:port]/path/to/repo.git/",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 690
        }
      },
      {
        "header": "Summary",
        "content": "In this document we took a deep look at git clone. The most important takeaways are: 1. git clone is used to create a copy of a target repo\n\n2. The target repo can be local or remote\n\n3. Git supports a few network protocols to connect to remote repos\n\n4. There are many different configuration options available that change the content of the clone\n\nFor further, deeper reference on git clone functionality, consult the official Git documentation. We also cover practical examples of git clone in our setting up a repository guide.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 531
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-clone",
    "doc_type": "git",
    "total_sections": 15
  },
  {
    "title": "Git config",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "In this document, we'll take an in-depth look at the git config command. We briefly discussed git config usage on our Setting up a Repository page.\n\nThe git config command is a convenience function that is used to set Git configuration values on a global or local project level. These configuration levels correspond to .gitconfig text files. Executing git config will modify a configuration text file.\n\nWe'll be covering common configuration settings like email, username, and editor. We'll discuss Git aliases, which allow you to create shortcuts for frequently used Git operations. Becoming familiar with git config and the various Git configuration settings will help you create a powerful, customized Git workflow.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 719
        }
      },
      {
        "header": "Usage",
        "content": "The most basic use case for git config is to invoke it with a configuration name, which will display the set value at that name. Configuration names are dot delimited strings composed of a 'section' and a 'key' based on their hierarchy. For example: user.email\n\nIn this example, email is a child property of the user configuration block. This will return the configured email address, if any, that Git will associate with locally created commits.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit config user.email\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 446
        }
      },
      {
        "header": "git config levels and files",
        "content": "Before we further discuss git config usage, let's take a moment to cover configuration levels. The git config command can accept arguments to specify which configuration level to operate on. The following configuration levels are available:\n\nBy default, git config will write to a local level if no configuration option is passed. Local level configuration is applied to the context repository git config gets invoked in. Local configuration values are stored in a file that can be found in the repo's .git directory: .git/config\n\nGlobal level configuration is user-specific, meaning it is applied to an operating system user. Global configuration values are stored in a file that is located in a user's home directory. ~ /.gitconfig on unix systems and C:\\Users\\\\.gitconfig on windows\n\nSystem-level configuration is applied across an entire machine. This covers all users on an operating system and all repos. The system level configuration file lives in a gitconfig file off the system root path. $(prefix)/etc/gitconfig on unix systems. On windows this file can be found at C:\\Documents and Settings\\All Users\\Application Data\\Git\\config on Windows XP, and in C:\\ProgramData\\Git\\config on Windows Vista and newer.\n\nThus the order of priority for configuration levels is: local, global, system. This means when looking for a configuration value, Git will start at the local level and bubble up to the system level.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1416
        }
      },
      {
        "header": "Writing a value",
        "content": "Expanding on what we already know about git config, let's look at an example in which we write a value:\n\nThis example writes the value your_email@example.com to the configuration name user.email. It uses the --global flag so this value is set for the current operating system user.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit config --global user.email \"your_email@example.com\"\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 281
        }
      },
      {
        "header": "git config editor - core.editor",
        "content": "Many Git commands will launch a text editor to prompt for further input. One of the most common use cases for git config is configuring which editor Git should use. Listed below is a table of popular editors and matching git config commands:\n\nEditor | config command\n--- | ---\nAtom | config command ~ git config --global core.editor \"atom --wait\"~\nemacs | config command ~ git config --global core.editor \"emacs\"~\nnano | config command ~ git config --global core.editor \"nano -w\"~\nvim | config command ~ git config --global core.editor \"vim\"~\nSublime Text (Mac) | config command ~ git config --global core.editor \"subl -n -w\"~\nSublime Text (Win, 32-bit install) | config command ~ git config --global core.editor \"'c:/program files (x86)/sublime text 3/sublimetext.exe' -w\"~\nSublime Text (Win, 64-bit install) | config command ~ git config --global core.editor \"'c:/program files/sublime text 3/sublimetext.exe' -w\"~\nTextmate | config command ~ git config --global core.editor \"mate -w\"~",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 1,
          "content_length": 987
        }
      },
      {
        "header": "Editor",
        "content": "~ git config --global core.editor \"atom --wait\"~\n\n~ git config --global core.editor \"emacs\"~\n\n~ git config --global core.editor \"nano -w\"~\n\n~ git config --global core.editor \"vim\"~\n\n~ git config --global core.editor \"subl -n -w\"~\n\nSublime Text (Win, 32-bit install)\n\n~ git config --global core.editor \"'c:/program files (x86)/sublime text 3/sublimetext.exe' -w\"~\n\nSublime Text (Win, 64-bit install)\n\n~ git config --global core.editor \"'c:/program files/sublime text 3/sublimetext.exe' -w\"~\n\n~ git config --global core.editor \"mate -w\"~",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 535
        }
      },
      {
        "header": "Merge tools",
        "content": "In the event of a merge conflict, Git will launch a \"merge tool.\" By default, Git uses an internal implementation of the common Unix diff program. The internal Git diff is a minimal merge conflict viewer. There are many external third party merge conflict resolutions that can be used instead. For an overview of various merge tools and configuration, see our guide on tips and tools to resolve conflits with Git.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit config --global merge.tool kdiff3\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 413
        }
      },
      {
        "header": "Colored outputs",
        "content": "Git supports colored terminal output which helps with rapidly reading Git output. You can customize your Git output to use a personalized color theme. The git config command is used to set these color values.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 208
        }
      },
      {
        "header": "color.ui",
        "content": "This is the master variable for Git colors. Setting it to false will disable all Git's colored terminal output.\n\nBy default, color.ui is set to auto which will apply colors to the immediate terminal output stream. The auto setting will omit color code output if the output stream is redirected to a file or piped to another process.\n\nYou can set the color.ui value to always which will also apply color code output when redirecting the output stream to files or pipes. This can unintentionally cause problems since the receiving pipe may not be expecting color-coded input.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git config --global color.ui false\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 573
        }
      },
      {
        "header": "Git color values",
        "content": "In addition to color.ui, there are many other granular color settings. Like color.ui, these color settings can all be set to false, auto, or always. These color settings can also have a specific color value set. Some examples of supported color values are:\n\nColors may also be specified as hexadecimal color codes like #ff0000, or ANSI 256 color values if your terminal supports it.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 382
        }
      },
      {
        "header": "Git color configuration settings",
        "content": "2. color.branch.<slot>\n\n4. color.diff.<slot>\n\n5. color.decorate.<slot>\n\n7. color.grep. <slot>\n\n8. color.interactive\n\n9. color.interactive.<slot>\n\n11. color.showBranch\n\n13. color.status.<slot>\n\nUsed to specify custom color for specified git status elements. <slot> supports the following values:\n\n• Configures the output color of the Git branch command\n\n• This value is also applicable to Git branch output. <slot> is one of the following: 1. current: the current branch 2. local: a local branch 3. remote: a remote branch ref in refs/remotes 4. upstream: an upstream tracking branch 5. plain: any other ref\n\n• 1. current: the current branch\n• 2. local: a local branch\n• 3. remote: a remote branch ref in refs/remotes\n• 4. upstream: an upstream tracking branch\n• 5. plain: any other ref\n\n• Applies colors to git diff, git log, and git show output\n\n• Configuring a <slot> value under color.diff tells git which part of the patch to use a specific color on. 1. context: The context text of the diff. Git context is the lines of text content shown in a diff or patch that highlights changes. 2. plain: a synonym for context 3. meta: applies color to the meta information of the diff 4. frag: applies color to the \"hunk header\" or \"function in hunk header\" 5. old: applies a color to the removed lines in the diff 6. new: colors the added lines of the diff 7. commit: colors commit headers within the diff 8. whitespace: sets a color for any whitespace errors in a diff\n\n• 1. context: The context text of the diff. Git context is the lines of text content shown in a diff or patch that highlights changes.\n• 2. plain: a synonym for context\n• 3. meta: applies color to the meta information of the diff\n• 4. frag: applies color to the \"hunk header\" or \"function in hunk header\"\n• 5. old: applies a color to the removed lines in the diff\n• 6. new: colors the added lines of the diff\n• 7. commit: colors commit headers within the diff\n• 8. whitespace: sets a color for any whitespace errors in a diff\n\n• Customize the color for git log --decorate output. The supported <slot> values are: branch, remoteBranch, tag, stash, or HEAD. They are respectively applicable to local branches, remote-tracking branches, tags, stashed changes and HEAD.\n\n• Applies color to the output of git grep.\n\n• Also applicable to git grep. The <slot> variable specifies which part of the grep output to apply color. 1. context: non-matching text in context lines 2. filename: filename prefix 3. function: function name lines 4. linenumber: line number prefix 5. match: matching text 6. matchContext: matching text in context lines 7. matchSelected: matching text in selected lines 8. selected: non-matching text in selected lines 9. separator: separators between fields on a line (:, -, and =) and between hunks (--)\n\n• 1. context: non-matching text in context lines\n• 2. filename: filename prefix\n• 3. function: function name lines\n• 4. linenumber: line number prefix\n• 5. match: matching text\n• 6. matchContext: matching text in context lines\n• 7. matchSelected: matching text in selected lines\n• 8. selected: non-matching text in selected lines\n• 9. separator: separators between fields on a line (:, -, and =) and between hunks (--)\n\n• This variable applies color for interactive prompts and displays. Examples are git add --interactive and git clean --interactive\n\n• The <slot> variable can be specified to target more specific \"interactive output\". The available <slot> values are: prompt, header, help, error; and each act on the corresponding interactive output.\n\n• Enables or disables colored output when the pager is in use\n\n• Enables or disables color output for the git show branch command\n\n• A boolean value that enables or disables color output for Git status\n\n• Targets the header text of the status area\n\n• Both target files which are added but not committed\n\n• Targets files that are modified but not added to the git index\n\n• Targets files which are not tracked by Git\n\n• Applies color to the current branch\n\n• The color the \"no branch\" warning is shown in\n\n• Colors files which have unmerged changes",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 4086
        }
      },
      {
        "header": "Aliases",
        "content": "You may be familiar with the concept of aliases from your operating system command-line; if not, they're custom shortcuts that define which command will expand to longer or combined commands. Aliases save you the time and energy cost of typing frequently used commands. Git provides its own alias system. A common use case for Git aliases is shortening the commit command. Git aliases are stored in Git configuration files. This means you can use the git config command to configure aliases.\n\nThis example creates a ci alias for the git commit command. You can then invoke git commit by executing git ci. Aliases can also reference other aliases to create powerful combos.\n\nThis example creates an alias amend which composes the ci alias into a new alias that uses --amend flag.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit config --global alias.ci commit\n```",
          "```bash\ngit config --global alias.amend ci --amend\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 778
        }
      },
      {
        "header": "Formatting & whitespace",
        "content": "Git has several \"whitespace\" features that can be configured to highlight whitespace issues when using git diff. The whitespace issues will be highlighted using the configured color color.diff.whitespace\n\nThe following features are enabled by default:\n\nThe following features are disabled by default\n\n• blank-at-eol highlights orphan whitespaces at the line endings\n• space-before-tab highlights a space character that appears before a tab character when indenting a line\n• blank-at-eof highlights blank lines inserted at the end of a file\n\n• indent-with-non-tab highlights a line that is indented with spaces instead of tabs\n• tab-in-indent highlights an initial tab indent as an error\n• trailing-space is shorthand for both blank-at-eol and blank-at-eof\n• cr-at-eol highlights a carriage-return at the line endings\n• tabwidth= defines how many character positions a tab occupies. The default value is 8. Allowed values are 1-63",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 929
        }
      },
      {
        "header": "Summary",
        "content": "In this article, we covered the use of the git config command. We discussed how the command is a convince method for editing raw git config files on the filesystem. We looked at basic read and write operations for configuration options. We took a look at common config patterns:\n\nOverall, git config is a helper tool that provides a shortcut to editing raw git config files on disk. We covered in depth personal customization options. Basic knowledge of git configuration options is a prerequisite for setting up a repository. See our guide there for a demonstration of the basics.\n\n• How to configure the Git editor\n• How to override configuration levels\n• How to reset configuration defaults\n• How to customize git colors",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 723
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-config",
    "doc_type": "git",
    "total_sections": 16
  },
  {
    "title": "Saving changes in Git",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "When working in Git, or other version control systems, the concept of \"saving\" is a more nuanced process than saving in a word processor or other traditional file editing applications. The traditional software expression of \"saving\" is synonymous with the Git term \"committing\". A commit is the Git equivalent of a \"save\". Traditional saving should be thought of as a file system operation that is used to overwrite an existing file or write a new file. Alternatively, Git committing is an operation that acts upon a collection of files and directories.\n\nSaving changes in Git vs SVN is also a different process. SVN Commits or 'check-ins' are operations that make a remote push to a centralized server. This means an SVN commit needs Internet access in order to fully 'save' project changes. Git commits can be captured and built up locally, then pushed to a remote server as needed using the git push -u origin main command. The difference between the two methods is a fundamental difference between architecture designs. Git is a distributed application model whereas SVN is a centralized model. Distributed applications are generally more robust as they do not have a single point of failure like a centralized server.\n\nThe commands: git add, git status, and git commit are all used in combination to save a snapshot of a Git project's current state.\n\nGit has an additional saving mechanism called 'the stash'. The stash is an ephemeral storage area for changes that are not ready to be committed. The stash operates on the working directory, the first of the three trees and has extensive usage options. To learn more visit the git stash page.\n\nA Git repository can be configured to ignore specific files or directories. This will prevent Git from saving changes to any ignored content. Git has multiple methods of configuration that manage the ignore list. Git ignore configure is discussed in further detail on the git ignore page.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1938
        }
      },
      {
        "header": "git add",
        "content": "The git add command adds a change in the working directory to the staging area. It tells Git that you want to include updates to a particular file in the next commit. However, git add doesn't really affect the repository in any significant way—changes are not actually recorded until you run git commit.\n\nIn conjunction with these commands, you'll also need git status to view the state of the working directory and the staging area.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 433
        }
      },
      {
        "header": "How it works",
        "content": "The git add and git commit commands compose the fundamental Git workflow. These are the two commands that every Git user needs to understand, regardless of their team’s collaboration model. They are the means to record versions of a project into the repository’s history.\n\nDeveloping a project revolves around the basic edit/stage/commit pattern. First, you edit your files in the working directory. When you’re ready to save a copy of the current state of the project, you stage changes with git add. After you’re happy with the staged snapshot, you commit it to the project history with git commit. The git reset command is used to undo a commit or staged snapshot.\n\nIn addition to git add and git commit, a third command git push is essential for a complete collaborative Git workflow. git push is utilized to send the committed changes to remote repositories for collaboration. This enables other team members to access a set of saved changes.\n\nThe git add command should not be confused with svn add, which adds a file to the repository. Instead, git add works on the more abstract level of changes. This means that git add needs to be called every time you alter a file, whereas svn add only needs to be called once for each file. It may sound redundant, but this workflow makes it much easier to keep a project organized.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1328
        }
      },
      {
        "header": "The staging area",
        "content": "The primary function of the git add command, is to promote pending changes in the working directory, to the git staging area. The staging area is one of Git's more unique features, and it can take some time to wrap your head around it if you’re coming from an SVN (or even a Mercurial) background. It helps to think of it as a buffer between the working directory and the project history. The staging area is considered one of the \"three trees\" of Git, along with, the working directory, and the commit history.\n\nInstead of committing all of the changes you've made since the last commit, the stage lets you group related changes into highly focused snapshots before actually committing it to the project history. This means you can make all sorts of edits to unrelated files, then go back and split them up into logical commits by adding related changes to the stage and commit them piece-by-piece. As in any revision control system, it’s important to create atomic commits so that it’s easy to track down bugs and revert changes with minimal impact on the rest of the project.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 1078
        }
      },
      {
        "header": "Common options",
        "content": "Stage all changes in <file> for the next commit.\n\nStage all changes in <directory> for the next commit.\n\nBegin an interactive staging session that lets you choose portions of a file to add to the next commit. This will present you with a chunk of changes and prompt you for a command. Use y to stage the chunk, n to ignore the chunk, s to split it into smaller chunks, e to manually edit the chunk, and q to exit.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit add <file>\n```",
          "```bash\ngit add <directory>\n```",
          "```bash\ngit add -p\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 413
        }
      },
      {
        "header": "Examples",
        "content": "When you’re starting a new project, git add serves the same function as svn import. To create an initial commit of the current directory, use the following two commands:\n\nOnce you’ve got your project up-and-running, new files can be added by passing the path to git add:\n\nThe above commands can also be used to record changes to existing files. Again, Git doesn’t differentiate between staging changes in new files vs. changes in files that have already been added to the repository.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit add .git commit\n```",
          "```bash\ngit add hello.pygit commit\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 483
        }
      },
      {
        "header": "Summary",
        "content": "In review, git add is the first command in a chain of operations that directs Git to \"save\" a snapshot of the current project state, into the commit history. When used on its own, git add will promote pending changes from the working directory to the staging area. The git status command is used to examine the current state of the repository and can be used to confirm a git add promotion. The git reset command is used to undo a git add. The git commit command is then used to Commit a snapshot of the staging directory to the repositories commit history.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 557
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/saving-changes",
    "doc_type": "git",
    "total_sections": 9
  },
  {
    "title": "Saving changes in Git",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "When working in Git, or other version control systems, the concept of \"saving\" is a more nuanced process than saving in a word processor or other traditional file editing applications. The traditional software expression of \"saving\" is synonymous with the Git term \"committing\". A commit is the Git equivalent of a \"save\". Traditional saving should be thought of as a file system operation that is used to overwrite an existing file or write a new file. Alternatively, Git committing is an operation that acts upon a collection of files and directories.\n\nSaving changes in Git vs SVN is also a different process. SVN Commits or 'check-ins' are operations that make a remote push to a centralized server. This means an SVN commit needs Internet access in order to fully 'save' project changes. Git commits can be captured and built up locally, then pushed to a remote server as needed using the git push -u origin main command. The difference between the two methods is a fundamental difference between architecture designs. Git is a distributed application model whereas SVN is a centralized model. Distributed applications are generally more robust as they do not have a single point of failure like a centralized server.\n\nThe commands: git add, git status, and git commit are all used in combination to save a snapshot of a Git project's current state.\n\nGit has an additional saving mechanism called 'the stash'. The stash is an ephemeral storage area for changes that are not ready to be committed. The stash operates on the working directory, the first of the three trees and has extensive usage options. To learn more visit the git stash page.\n\nA Git repository can be configured to ignore specific files or directories. This will prevent Git from saving changes to any ignored content. Git has multiple methods of configuration that manage the ignore list. Git ignore configure is discussed in further detail on the git ignore page.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1938
        }
      },
      {
        "header": "git add",
        "content": "The git add command adds a change in the working directory to the staging area. It tells Git that you want to include updates to a particular file in the next commit. However, git add doesn't really affect the repository in any significant way—changes are not actually recorded until you run git commit.\n\nIn conjunction with these commands, you'll also need git status to view the state of the working directory and the staging area.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 433
        }
      },
      {
        "header": "How it works",
        "content": "The git add and git commit commands compose the fundamental Git workflow. These are the two commands that every Git user needs to understand, regardless of their team’s collaboration model. They are the means to record versions of a project into the repository’s history.\n\nDeveloping a project revolves around the basic edit/stage/commit pattern. First, you edit your files in the working directory. When you’re ready to save a copy of the current state of the project, you stage changes with git add. After you’re happy with the staged snapshot, you commit it to the project history with git commit. The git reset command is used to undo a commit or staged snapshot.\n\nIn addition to git add and git commit, a third command git push is essential for a complete collaborative Git workflow. git push is utilized to send the committed changes to remote repositories for collaboration. This enables other team members to access a set of saved changes.\n\nThe git add command should not be confused with svn add, which adds a file to the repository. Instead, git add works on the more abstract level of changes. This means that git add needs to be called every time you alter a file, whereas svn add only needs to be called once for each file. It may sound redundant, but this workflow makes it much easier to keep a project organized.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1328
        }
      },
      {
        "header": "The staging area",
        "content": "The primary function of the git add command, is to promote pending changes in the working directory, to the git staging area. The staging area is one of Git's more unique features, and it can take some time to wrap your head around it if you’re coming from an SVN (or even a Mercurial) background. It helps to think of it as a buffer between the working directory and the project history. The staging area is considered one of the \"three trees\" of Git, along with, the working directory, and the commit history.\n\nInstead of committing all of the changes you've made since the last commit, the stage lets you group related changes into highly focused snapshots before actually committing it to the project history. This means you can make all sorts of edits to unrelated files, then go back and split them up into logical commits by adding related changes to the stage and commit them piece-by-piece. As in any revision control system, it’s important to create atomic commits so that it’s easy to track down bugs and revert changes with minimal impact on the rest of the project.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 1078
        }
      },
      {
        "header": "Common options",
        "content": "Stage all changes in <file> for the next commit.\n\nStage all changes in <directory> for the next commit.\n\nBegin an interactive staging session that lets you choose portions of a file to add to the next commit. This will present you with a chunk of changes and prompt you for a command. Use y to stage the chunk, n to ignore the chunk, s to split it into smaller chunks, e to manually edit the chunk, and q to exit.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit add <file>\n```",
          "```bash\ngit add <directory>\n```",
          "```bash\ngit add -p\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 413
        }
      },
      {
        "header": "Examples",
        "content": "When you’re starting a new project, git add serves the same function as svn import. To create an initial commit of the current directory, use the following two commands:\n\nOnce you’ve got your project up-and-running, new files can be added by passing the path to git add:\n\nThe above commands can also be used to record changes to existing files. Again, Git doesn’t differentiate between staging changes in new files vs. changes in files that have already been added to the repository.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit add .git commit\n```",
          "```bash\ngit add hello.pygit commit\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 483
        }
      },
      {
        "header": "Summary",
        "content": "In review, git add is the first command in a chain of operations that directs Git to \"save\" a snapshot of the current project state, into the commit history. When used on its own, git add will promote pending changes from the working directory to the staging area. The git status command is used to examine the current state of the repository and can be used to confirm a git add promotion. The git reset command is used to undo a git add. The git commit command is then used to Commit a snapshot of the staging directory to the repositories commit history.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 557
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/saving-changes/git-add",
    "doc_type": "git",
    "total_sections": 9
  },
  {
    "title": "Git commit",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "The git commit command captures a snapshot of the project's currently staged changes. Committed snapshots can be thought of as “safe” versions of a project—Git will never change them unless you explicitly ask it to.\n\nPrior to the execution of git commit, the git add command is used to promote or 'stage' changes to the project that will be stored in a commit. These two commands git commit and git add are two of the most frequently used.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 439
        }
      },
      {
        "header": "Git commit vs SVN commit",
        "content": "While they share the same name, git commit is nothing like svn commit. This shared term can be a point of confusion for Git newcomers who have a svn background, and it is important to emphasize the difference. To compare git commit vs svn commit is to compare a centralized application model (svn) vs a distributed application model (Git). In SVN, a commit pushes changes from the local SVN client, to a remote centralized shared SVN repository. In Git, repositories are distributed, Snapshots are committed to the local repository, and this requires absolutely no interaction with other Git repositories. Git commits can later be pushed to arbitrary remote repositories.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 671
        }
      },
      {
        "header": "How it works",
        "content": "At a high-level, Git can be thought of as a timeline management utility. Commits are the core building block units of a Git project timeline. Commits can be thought of as snapshots or milestones along the timeline of a Git project. Commits are created with the git commit command to capture the state of a project at that point in time. Git Snapshots are always committed to the local repository. This is fundamentally different from SVN, wherein the working copy is committed to the central repository. In contrast, Git doesn’t force you to interact with the central repository until you’re ready. Just as the staging area is a buffer between the working directory and the project history, each developer’s local repository is a buffer between their contributions and the central repository.\n\nThis changes the basic development model for Git users. Instead of making a change and committing it directly to the central repo, Git developers have the opportunity to accumulate commits in their local repo. This has many advantages over SVN-style collaboration: it makes it easier to split up a feature into atomic commits, keep related commits grouped together, and clean up local history before publishing it to the central repository. It also lets developers work in an isolated environment, deferring integration until they’re at a convenient point to merge with other users. While isolation and deferred integration are individually beneficial, it is in a team's best interest to integrate frequently and in small units. For more information regarding best practices for Git team collaboration read how teams structure their Git workflow.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 1640
        }
      },
      {
        "header": "Snapshots, not differences",
        "content": "Aside from the practical distinctions between SVN and Git, their underlying implementation also follows entirely divergent design philosophies. Whereas SVN tracks differences of a file, Git’s version control model is based on snapshots. For example, a SVN commit consists of a diff compared to the original file added to the repository. Git, on the other hand, records the entire contents of each file in every commit.\n\nThis makes many Git operations much faster than SVN, since a particular version of a file doesn’t have to be “assembled” from its diffs—the complete revision of each file is immediately available from Git's internal database.\n\nGit's snapshot model has a far-reaching impact on virtually every aspect of its version control model, affecting everything from its branching and merging tools to its collaboration work-flows.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 840
        }
      },
      {
        "header": "Common options",
        "content": "Commit the staged snapshot. This will launch a text editor prompting you for a commit message. After you’ve entered a message, save the file and close the editor to create the actual commit.\n\nCommit a snapshot of all changes in the working directory. This only includes modifications to tracked files (those that have been added with git add at some point in their history).\n\nA shortcut command that immediately creates a commit with a passed commit message. By default, git commit will open up the locally configured text editor, and prompt for a commit message to be entered. Passing the -m option will forgo the text editor prompt in-favor of an inline message.\n\nA power user shortcut command that combines the -a and -m options. This combination immediately creates a commit of all the staged changes and takes an inline commit message.\n\nThis option adds another level of functionality to the commit command. Passing this option will modify the last commit. Instead of creating a new commit, staged changes will be added to the previous commit. This command will open up the system's configured text editor and prompt to change the previously specified commit message.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit commit\n```",
          "```bash\ngit commit -a\n```",
          "```bash\ngit commit -m \"commit message\"\n```",
          "```bash\ngit commit -am \"commit message\"\n```",
          "```bash\ngit commit --amend\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1172
        }
      },
      {
        "header": "Saving changes with a commit",
        "content": "The following example assumes you’ve edited some content in a file called hello.py on the current branch, and are ready to commit it to the project history. First, you need to stage the file with git add, then you can commit the staged snapshot.\n\nThis command will add hello.py to the Git staging area. We can examine the result of this action by using the git status command.\n\nThe green output new file: hello.py indicates that hello.py will be saved with the next commit. From the commit is created by executing:\n\nThis will open a text editor (customizable via git config) asking for a commit log message, along with a list of what’s being committed:\n\nGit doesn't require commit messages to follow any specific formatting constraints, but the canonical format is to summarize the entire commit on the first line in less than 50 characters, leave a blank line, then a detailed explanation of what’s been changed. For example:\n\nIt is a common practice to use the first line of the commit message as a subject line, similar to an email. The rest of the log message is considered the body and used to communicate details of the commit change set. Note that many developers also like to use the present tense in their commit messages. This makes them read more like actions on the repository, which makes many of the history-rewriting operations more intuitive.",
        "code_examples": [
          "```bash\nChange the message displayed by hello.py- Update the sayHello() function to output the user's name- Change the sayGoodbye() function to a friendlier message\n```"
        ],
        "usage_examples": [
          "```bash\ngit add hello.py\n```",
          "```bash\ngit statusOn branch mainChanges to be committed:(use \"git reset HEAD <file>...\" to unstage)new file: hello.py\n```",
          "```bash\ngit commit\n```",
          "```bash\n# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.# On branch main# Changes to be committed:# (use \"git reset HEAD ...\" to unstage)##modified: hello.py\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1358
        }
      },
      {
        "header": "How to update (amend) a commit",
        "content": "To continue with the hello.py example above. Let's make further updates to hello.py and execute the following:\n\nThis will once again, open up the configured text editor. This time, however, it will be pre-filled with the commit message we previously entered. This indicates that we are not creating a new commit, but editing the last.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit add hello.pygit commit --amend\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 334
        }
      },
      {
        "header": "Summary",
        "content": "The git commit command is one of the core primary functions of Git. Prior use of the git add command is required to select the changes that will be staged for the next commit. Then git commit is used to create a snapshot of the staged changes along a timeline of a Git projects history. Learn more about git add usage on the accompanying page. The git status command can be used to explore the state of the staging area and pending commit.\n\nThe commit model of SVN and Git are significantly different but often confused, because of the shared terminology. If you are coming to Git from a personal history of SVN usage, it is good to learn that in Git, commits are cheap and should be used frequently. Whereas SVN commits are an expensive operation that makes a remote request, Git commits are done locally and with a more efficient algorithm.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 842
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/saving-changes/git-commit",
    "doc_type": "git",
    "total_sections": 10
  },
  {
    "title": "Git diff",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "Diffing is a function that takes two input data sets and outputs the changes between them. git diff is a multi-use Git command that when executed runs a diff function on Git data sources. These data sources can be commits, branches, files and more. This document will discuss common invocations of git diff and diffing work flow patterns. The git diff command is often used along with git status and git log to analyze the current state of a Git repo.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 451
        }
      },
      {
        "header": "Raw output format",
        "content": "The following examples will be executed in a simple repo. The repo is created with the commands below:\n\nIf we execute git diff at this point, there will be no output. This is expected behavior as there are no changes in the repo to diff. Once the repo is created and we've added the diff_test.txt file, we can change the contents of the file to start experimenting with diff output.\n\nExecuting this command will change the content of the diff_test.txt file. Once modified, we can view a diff and analyze the output. Now executing git diff will produce the following output:\n\nLet us now examine a more detailed breakdown of the diff output.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$:> mkdir diff_test_repo$:> cd diff_test_repo$:> touch diff_test.txt$:> echo \"this is a git diff test example\" > diff_test.txt$:> git init .Initialized empty Git repository in /Users/kev/code/test/.git/$:> git add diff_test.txt$:> git commit -am\"add diff test file\"[main (root-commit) 6f77fc3] add diff test file1 file changed, 1 insertion(+)create mode 100644 diff_test.txt\n```",
          "```bash\n$:> echo \"this is a diff example\" > diff_test.txt\n```",
          "```bash\ndiff --git a/diff_test.txt b/diff_test.txtindex 6b0c6cf..b37e70a 100644--- a/diff_test.txt+++ b/diff_test.txt@@ -1 +1 @@-this is a git diff test example+this is a diff example\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 639
        }
      },
      {
        "header": "1. Comparison input",
        "content": "This line displays the input sources of the diff. We can see that a/diff_test.txt and b/diff_test.txt have been passed to the diff.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ndiff --git a/diff_test.txt b/diff_test.txt\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 131
        }
      },
      {
        "header": "2. Meta data",
        "content": "This line displays some internal Git metadata. You will most likely not need this information. The numbers in this output correspond to Git object version hash identifiers.",
        "code_examples": [
          "```bash\nindex 6b0c6cf..b37e70a 100644\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 172
        }
      },
      {
        "header": "3. Markers for changes",
        "content": "These lines are a legend that assigns symbols to each diff input source. In this case, changes from a/diff_test.txt are marked with a --- and the changes from b/diff_test.txt are marked with the +++ symbol.",
        "code_examples": [
          "```bash\n--- a/diff_test.txt+++ b/diff_test.txt\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 206
        }
      },
      {
        "header": "4. Diff chunks",
        "content": "The remaining diff output is a list of diff 'chunks'. A diff only displays the sections of the file that have changes. In our current example, we only have one chunk as we are working with a simple scenario. Chunks have their own granular output semantics.\n\nThe first line is the chunk header. Each chunk is prepended by a header enclosed within @@ symbols. The content of the header is a summary of changes made to the file. In our simplified example, we have -1 +1 meaning line one had changes. In a more realistic diff, you would see a header like:\n\nIn this header example, 6 lines have been extracted starting from line number 34. Additionally, 8 lines have been added starting at line number 34.\n\nThe remaining content of the diff chunk displays the recent changes. Each changed line is prepended with a + or - symbol indicating which version of the diff input the changes come from. As we previously discussed, - indicates changes from the a/diff_test.txt and + indicates changes from b/diff_test.txt.",
        "code_examples": [
          "```bash\n@@ -34,6 +34,8 @@\n```"
        ],
        "usage_examples": [
          "```bash\n@@ -1 +1 @@-this is a git diff test example+this is a diff example\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1007
        }
      },
      {
        "header": "1. git diff --color-words",
        "content": "git diff also has a special mode for highlighting changes with much better granularity: ‐‐color-words. This mode tokenizes added and removed lines by whitespace and then diffs those.\n\nNow the output displays only the color-coded words that have changed.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$:> git diff --color-wordsdiff --git a/diff_test.txt b/diff_test.txtindex 6b0c6cf..b37e70a 100644--- a/diff_test.txt+++ b/diff_test.txt@@ -1 +1 @@this is agit difftest example\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 253
        }
      },
      {
        "header": "2. git diff-highlight",
        "content": "If you clone the git source, you’ll find a sub-directory called contrib. It contains a bunch of git-related tools and other interesting bits and pieces that haven’t yet been promoted to git core. One of these is a Perl script called diff-highlight. Diff-highlight pairs up matching lines of diff output and highlights sub-word fragments that have changed.\n\nNow we’ve pared down our diff to the smallest possible change.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$:> git diff | /your/local/path/to/git-core/contrib/diff-highlight/diff-highlightdiff --git a/diff_test.txt b/diff_test.txtindex 6b0c6cf..b37e70a 100644--- a/diff_test.txt+++ b/diff_test.txt@@ -1 +1 @@-this is a git diff test example+this is a diff example\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 419
        }
      },
      {
        "header": "Diffing binary files",
        "content": "In addition to the text file utilities we have thus far demonstrated, git diff can be run on binary files. Unfortunately, the default output is not very helpful.\n\nGit does have a feature that allows you to specify a shell command to transform the content of your binary files into text prior to performing the diff. It does require a little set up though. First, you need to specify a textconv filter describing how to convert a certain type of binary to text. We're using a simple utility called pdftohtml (available via homebrew) to convert my PDFs into human readable HTML. You can set this up for a single repository by editing your .git/config file, or globally by editing ~ /.gitconfig\n\nThen all you need to do is associate one or more file patterns with our pdfconv filter. You can do this by creating a .gitattributes file in the root of your repository.\n\nOnce configured, git diff will first run the binary file through the configured converter script and diff the converter output. The same technique can be applied to get useful diffs from all sorts of binary files, for example: zips, jars and other archives: using unzip -l (or similar) in place of pdf2html will show you paths that have been added or removed between commits images: exiv2 can be used to show metadata changes such as image dimensions documents: conversion tools exist for transforming .odf, .doc and other document formats to plain text. In a pinch, strings will often work for binary files where no formal converter exists.",
        "code_examples": [
          "```bash\n[diff \"pdfconv\"]textconv=pdftohtml -stdout\n```",
          "```bash\n*.pdf diff=pdfconv\n```"
        ],
        "usage_examples": [
          "```bash\n$:> git diffBinary files a/script.pdf and b/script.pdf differ\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1505
        }
      },
      {
        "header": "Comparing files: git diff file",
        "content": "The git diff command can be passed an explicit file path option. When a file path is passed to git diff the diff operation will be scoped to the specified file. The below examples demonstrate this usage.\n\nThis example is scoped to ./path/to/file when invoked, it will compare the specific changes in the working directory, against the index, showing the changes that are not staged yet. By default git diff will execute the comparison against HEAD. Omitting HEAD in the example above git diff ./path/to/file has the same effect.\n\nWhen git diff is invoked with the --cached option the diff will compare the staged changes with the local repository. The --cached option is synonymous with --staged.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit diff HEAD ./path/to/file\n```",
          "```bash\ngit diff --cached ./path/to/file\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 696
        }
      },
      {
        "header": "Comparing all changes",
        "content": "Invoking git diff without a file path will compare changes across the entire repository. The above, file specific examples, can be invoked without the ./path/to/file argument and have the same output results across all files in the local repo.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 243
        }
      },
      {
        "header": "Changes since last commit",
        "content": "By default git diff will show you any uncommitted changes since the last commit.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit diff\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 80
        }
      },
      {
        "header": "Comparing files between two different commits",
        "content": "git diff can be passed Git refs to commits to diff. Some example refs are, HEAD, tags, and branch names. Every commit in Git has a commit ID which you can get when you execute GIT LOG. You can also pass this commit ID to git diff.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log --pretty=oneline957fbc92b123030c389bf8b4b874522bdf2db72c add featurece489262a1ee34340440e55a0b99ea6918e19e7a rename some classes6b539f280d8b0ec4874671bae9c6bed80b788006 refactor some code for feature646e7863348a427e1ed9163a9a96fa759112f102 add some copy to body$:> git diff 957fbc92b123030c389bf8b4b874522bdf2db72c ce489262a1ee34340440e55a0b99ea6918e19e7a\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 230
        }
      },
      {
        "header": "Comparing two branches",
        "content": "Branches are compared like all other ref inputs to git diff\n\nThis example introduces the dot operator. The two dots in this example indicate the diff input is the tips of both branches. The same effect happens if the dots are omitted and a space is used between the branches. Additionally, there is a three dot operator:\n\nThe three dot operator initiates the diff by changing the first input parameter branch1. It changes branch1 into a ref of the shared common ancestor commit between the two diff inputs, the shared ancestor of branch1 and other-feature-branch. The last parameter input parameter remains unchanged as the tip of other-feature-branch.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit diff branch1..other-feature-branch\n```",
          "```bash\ngit diff branch1...other-feature-branch\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 652
        }
      },
      {
        "header": "Comparing files from two branches",
        "content": "To compare a specific file across branches, pass in the path of the file as the third argument to git diff",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit diff main new_branch ./diff_test.txt\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 106
        }
      },
      {
        "header": "Summary",
        "content": "This page disscused the Git diffing process and the git diff command. We discussed how to read git diff output and the various data included in the output. Examples were provided on how to alter the git diff output with highlighting and colors. We discussed different diffing strategies such as how to diff files in branches and specific commits. In addition to the git diff command, we also used git log and git checkout.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 422
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/saving-changes/git-diff",
    "doc_type": "git",
    "total_sections": 18
  },
  {
    "title": "Git stash",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "git stash temporarily shelves (or stashes) changes you've made to your working copy so you can work on something else, and then come back and re-apply them later on. Stashing is handy if you need to quickly switch context and work on something else, but you're mid-way through a code change and aren't quite ready to commit.\n\n• Git Stash Stashing your work Re-applying your stashed changes Stashing untracked or ignored files Managing multiple stashes Viewing stash diffs Partial stashes Creating a branch from your stash Cleaning up your stash How git stash works\n\n• Stashing your work\n• Re-applying your stashed changes\n• Stashing untracked or ignored files\n• Managing multiple stashes\n• Viewing stash diffs\n• Partial stashes\n• Creating a branch from your stash\n• Cleaning up your stash\n• How git stash works",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 810
        }
      },
      {
        "header": "Stashing your work",
        "content": "The git stash command takes your uncommitted changes (both staged and unstaged), saves them away for later use, and then reverts them from your working copy. For example:\n\nAt this point you're free to make changes, create new commits, switch branches, and perform any other Git operations; then come back and re-apply your stash when you're ready.\n\nNote that the stash is local to your Git repository; stashes are not transferred to the server when you push.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git statusOn branch mainChanges to be committed:new file:   style.cssChanges not staged for commit:modified:   index.html$ git stashSaved working directory and index state WIP on main: 5002d47 our new homepageHEAD is now at 5002d47 our new homepage$ git statusOn branch mainnothing to commit, working tree clean\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 458
        }
      },
      {
        "header": "Re-applying your stashed changes",
        "content": "You can reapply previously stashed changes with git stash pop:\n\nPopping your stash removes the changes from your stash and reapplies them to your working copy.\n\nAlternatively, you can reapply the changes to your working copy and keep them in your stash with git stash apply:\n\nThis is useful if you want to apply the same stashed changes to multiple branches.\n\nNow that you know the basics of stashing, there is one caveat with git stash you need to be aware of: by default Git won't stash changes made to untracked or ignored files.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git statusOn branch mainnothing to commit, working tree clean$ git stash popOn branch mainChanges to be committed:new file:   style.cssChanges not staged for commit:modified:   index.htmlDropped refs/stash@{0} (32b3aa1d185dfe6d57b3c3cc3b32cbf3e380cc6a)\n```",
          "```bash\n$ git stash applyOn branch mainChanges to be committed:new file:   style.cssChanges not staged for commit:modified:   index.html\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 532
        }
      },
      {
        "header": "Stashing untracked or ignored files",
        "content": "By default, running git stash will stash:\n\nBut it will not stash:\n\nSo if we add a third file to our example above, but don't stage it (i.e. we don't run git add), git stash won't stash it.\n\nAdding the -u option (or --include-untracked) tells git stash to also stash your untracked files:\n\nYou can include changes to ignored files as well by passing the -a option (or --all) when running git stash.\n\n• changes that have been added to your index (staged changes)\n• changes made to files that are currently tracked by Git (unstaged changes)\n\n• new files in your working copy that have not yet been staged\n• files that have been ignored",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ script.js$ git statusOn branch mainChanges to be committed:new file:   style.cssChanges not staged for commit:modified:   index.htmlUntracked files:script.js$ git stashSaved working directory and index state WIP on main: 5002d47 our new homepageHEAD is now at 5002d47 our new homepage$ git statusOn branch mainUntracked files:script.js\n```",
          "```bash\n$ git statusOn branch mainChanges to be committed:new file:   style.cssChanges not staged for commit:modified:   index.htmlUntracked files:script.js$ git stash -uSaved working directory and index state WIP on main: 5002d47 our new homepageHEAD is now at 5002d47 our new homepage$ git statusOn branch mainnothing to commit, working tree clean\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 632
        }
      },
      {
        "header": "Managing multiple stashes",
        "content": "You aren't limited to a single stash. You can run git stash several times to create multiple stashes, and then use git stash list to view them. By default, stashes are identified simply as a \"WIP\" – work in progress – on top of the branch and commit that you created the stash from. After a while it can be difficult to remember what each stash contains:\n\nTo provide a bit more context, it's good practice to annotate your stashes with a description, using git stash save \"message\":\n\nBy default, git stash pop will re-apply the most recently created stash: stash@{0}\n\nYou can choose which stash to re-apply by passing its identifier as the last argument, for example:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git stash liststash@{0}: WIP on main: 5002d47 our new homepagestash@{1}: WIP on main: 5002d47 our new homepagestash@{2}: WIP on main: 5002d47 our new homepage\n```",
          "```bash\n$ git stash save \"add style to our site\"Saved working directory and index state On main: add style to our siteHEAD is now at 5002d47 our new homepage$ git stash liststash@{0}: On main: add style to our sitestash@{1}: WIP on main: 5002d47 our new homepagestash@{2}: WIP on main: 5002d47 our new homepage\n```",
          "```bash\n$ git stash pop stash@{2}\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 667
        }
      },
      {
        "header": "Viewing stash diffs",
        "content": "You can view a summary of a stash with git stash show:\n\nOr pass the -p option (or --patch) to view the full diff of a stash:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git stash showindex.html | 1 +style.css | 3 +++2 files changed, 4 insertions(+)\n```",
          "```bash\n$ git stash show -pdiff --git a/style.css b/style.cssnew file mode 100644index 0000000..d92368b--- /dev/null+++ b/style.css@@ -0,0 +1,3 @@+* {+  text-decoration: blink;+}diff --git a/index.html b/index.htmlindex 9daeafb..ebdcbd2 100644--- a/index.html+++ b/index.html@@ -1 +1,2 @@+<link rel=\"stylesheet\" href=\"style.css\"/>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 124
        }
      },
      {
        "header": "Partial stashes",
        "content": "You can also choose to stash just a single file, a collection of files, or individual changes from within files. If you pass the -p option (or --patch) to git stash, it will iterate through each changed \"hunk\" in your working copy and ask whether you wish to stash it:\n\nYou can hit ? for a full list of hunk commands. Commonly useful ones are:\n\nCommand | Description\n--- | ---\n/ | Description search for a hunk by regex\n? | Description help\nn | Description don't stash this hunk\nq | Description quit (any hunks that have already been selected will be stashed)\ns | Description split this hunk into smaller hunks\ny | Description stash this hunk",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git stash -pdiff --git a/style.css b/style.cssnew file mode 100644index 0000000..d92368b--- /dev/null+++ b/style.css@@ -0,0 +1,3 @@+* {+  text-decoration: blink;+}Stash this hunk [y,n,q,a,d,/,e,?]? ydiff --git a/index.html b/index.htmlindex 9daeafb..ebdcbd2 100644--- a/index.html+++ b/index.html@@ -1 +1,2 @@+<link rel=\"stylesheet\" href=\"style.css\"/>Stash this hunk [y,n,q,a,d,/,e,?]? n\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 2,
          "content_length": 642
        }
      },
      {
        "header": "Command",
        "content": "search for a hunk by regex\n\ndon't stash this hunk\n\nquit (any hunks that have already been selected will be stashed)\n\nsplit this hunk into smaller hunks\n\nThere is no explicit \"abort\" command, but hitting CTRL-C(SIGINT) will abort the stash process.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 247
        }
      },
      {
        "header": "Creating a branch from your stash",
        "content": "If the changes on your branch diverge from the changes in your stash, you may run into conflicts when popping or applying your stash. Instead, you can use git stash branch to create a new branch to apply your stashed changes to:\n\nThis checks out a new branch based on the commit that you created your stash from, and then pops your stashed changes onto it.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git stash branch add-stylesheet stash@{1}Switched to a new branch 'add-stylesheet'On branch add-stylesheetChanges to be committed:new file:   style.cssChanges not staged for commit:modified:   index.htmlDropped refs/stash@{1} (32b3aa1d185dfe6d57b3c3cc3b32cbf3e380cc6a)\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 356
        }
      },
      {
        "header": "Cleaning up your stash",
        "content": "If you decide you no longer need a particular stash, you can delete it with git stash drop:\n\nOr you can delete all of your stashes with:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git stash drop stash@{1}Dropped stash@{1} (17e2697fd8251df6163117cb3d58c1f62a5e7cdb)\n```",
          "```bash\n$ git stash clear\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 136
        }
      },
      {
        "header": "How git stash works",
        "content": "If you just wanted to know how to use git stash, you can stop reading here. But if you're curious about how Git (and git stash) works under the hood, read on!\n\nStashes are actually encoded in your repository as commit objects. The special ref at .git/refs/stash points to your most recently created stash, and previously created stashes are referenced by the stash ref's reflog. This is why you refer to stashes by stash@{n}: you're actually referring to the nth reflog entry for the stash ref. Since a stash is just a commit, you can inspect it with git log:\n\nDepending on what you stashed, a single git stash operation creates either two or three new commits. The commits in the diagram above are:\n\nHow git stash encodes your worktree and index as commits:\n\nWhen you run git stash pop, the changes from the commits above are used to update your working copy and index, and the stash reflog is shuffled to remove the popped commit. Note that the popped commits aren't immediately deleted, but do become candidates for future garbage collection.\n\n• stash@{0}, a new commit to store the tracked files that were in your working copy when you ran git stash\n• stash@{0}'s first parent, the pre-existing commit that was at HEAD when you ran git stash\n• stash@{0}'s second parent, a new commit representing the index when you ran git stash\n• stash@{0}'s third parent, a new commit representing untracked files that were in your working copy when you ran git stash. This third parent only created if: your working copy actually contained untracked files; and you specified the --include-untracked or --all option when invoked git stash.\n\n• your working copy actually contained untracked files; and\n• you specified the --include-untracked or --all option when invoked git stash.\n\n• Before stashing, your worktree may contain changes to tracked files, untracked files, and ignored files. Some of these changes may also be staged in the index.\n\n• Invoking git stash encodes any changes to tracked files as two new commits in your DAG: one for unstaged changes, and one for changes staged in the index. The special refs/stash ref is updated to point to them.\n\n• Using the --include-untracked option also encodes any changes to untracked files as an additional commit.\n\n• Using the --all option includes changes to any ignored files alongside changes to untracked files in the same commit.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 2377
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/saving-changes/git-stash",
    "doc_type": "git",
    "total_sections": 13
  },
  {
    "title": "Git ignore",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "Git sees every file in your working copy as one of three things:\n\n1. tracked - a file which has been previously staged or committed;\n\n2. untracked - a file which has not been staged or committed; or\n\n3. ignored - a file which Git has been explicitly told to ignore.\n\nIgnored files are usually build artifacts and machine generated files that can be derived from your repository source or should otherwise not be committed. Some common examples are:\n\nIgnored files are tracked in a special file named .gitignore that is checked in at the root of your repository. There is no explicit git ignore command: instead the .gitignore file must be edited and committed by hand when you have new files that you wish to ignore. .gitignore files contain patterns that are matched against file names in your repository to determine whether or not they should be ignored.\n\nIn this document, we'll cover:\n\n• dependency caches, such as the contents of /node_modules or /packages\n• compiled code, such as .o, .pyc, and .class files\n• build output directories, such as /bin, /out, or /target\n• files generated at runtime, such as .log, .lock, or .tmp\n• hidden system files, such as .DS_Store or Thumbs.db\n• personal IDE config files, such as .idea/workspace.xml\n\n• Git ignore patterns\n• Shared .gitignore files in your repository\n• Personal Git ignore rules\n• Global Git ignore rules\n• Ignoring a previously committed file\n• Committing an ignored file\n• Stashing an ignored file\n• Debugging .gitignore files",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1489
        }
      },
      {
        "header": "Git ignore patterns",
        "content": ".gitignore uses globbing patterns to match against file names. You can construct your patterns using various symbols:\n\nPattern | Example matches | Explanation*\n--- | --- | ---\n**/logs | Example matches logs/debug.loglogs/monday/foo.barbuild/logs/debug.log | Explanation* You can prepend a pattern with a double asterisk to match directories anywhere in the repository.\n**/logs/debug.log | Example matches logs/debug.logbuild/logs/debug.logbut notlogs/build/debug.log | Explanation* You can also use a double asterisk to match files based on their name and the name of their parent directory.\n*.log | Example matches debug.logfoo.log.loglogs/debug.log | Explanation* An asterisk is a wildcard that matches zero or more characters.\n*.log!important.log | Example matches debug.logbut notlogs/debug.log | Explanation* Prepending an exclamation mark to a pattern negates it. If a file matches a pattern, but also matches a negating pattern defined later in the file, it will not be ignored.\n/debug.log | Example matches debug.logbut notlogs/debug.log | Explanation* Patterns defined after a negating pattern will re-ignore any previously negated files.\ndebug.log | Example matches debug.loglogs/debug.log | Explanation* Prepending a slash matches files only in the repository root.\ndebug?.log | Example matches debug0.logdebugg.logbut notdebug10.log | Explanation* A question mark matches exactly one character.\ndebug[0-9].log | Example matches debug0.logdebug1.logbut notdebug10.log | Explanation* Square brackets can also be used to match a single character from a specified range.\ndebug[01].log | Example matches debug0.logdebug1.logbut notdebug2.logdebug01.log | Explanation* Square brackets match a single character form the specified set.\ndebug[!01].log | Example matches debug2.logbut notdebug0.logdebug1.logdebug01.log | Explanation* An exclamation mark can be used to match any character except one from the specified set.\ndebug[a-z].log | Example matches debuga.logdebugb.logbut notdebug1.log | Explanation* Ranges can be numeric or alphabetic.\nlogs | Example matches logslogs/debug.loglogs/latest/foo.barbuild/logsbuild/logs/debug.log | Explanation* If you don't append a slash, the pattern will match both files and the contents of directories with that name. In the example matches on the left, both directories and files named logs are ignored\nlogs/ | Example matches logs/debug.loglogs/latest/foo.barbuild/logs/foo.barbuild/logs/latest/debug.log | Explanation* Appending a slash indicates the pattern is a directory. The entire contents of any directory in the repository matching that name – including all of its files and subdirectories – will be ignored\nlogs/!logs/important.log | Example matches logs/debug.loglogs/important.log | Explanation* Wait a minute! Shouldn't logs/important.log be negated in the example on the leftNope! Due to a performance-related quirk in Git, you can not negate a file that is ignored due to a pattern matching a directory\nlogs/**/debug.log | Example matches logs/debug.loglogs/monday/debug.loglogs/monday/pm/debug.log | Explanation* A double asterisk matches zero or more directories.\nlogs/*day/debug.log | Example matches logs/monday/debug.loglogs/tuesday/debug.logbut notlogs/latest/debug.log | Explanation* Wildcards can be used in directory names as well.\nlogs/debug.log | Example matches logs/debug.logbut notdebug.logbuild/logs/debug.log | Explanation* Patterns specifying a file in a particular directory are relative to the repository root. (You can prepend a slash if you like, but it doesn't do anything special.)",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 1,
          "content_length": 3569
        }
      },
      {
        "header": "Pattern",
        "content": "logs/debug.loglogs/monday/foo.barbuild/logs/debug.log\n\nYou can prepend a pattern with a double asterisk to match directories anywhere in the repository.\n\nlogs/debug.logbuild/logs/debug.logbut notlogs/build/debug.log\n\nYou can also use a double asterisk to match files based on their name and the name of their parent directory.\n\ndebug.logfoo.log.loglogs/debug.log\n\nAn asterisk is a wildcard that matches zero or more characters.\n\ndebug.logbut notlogs/debug.log\n\nPrepending an exclamation mark to a pattern negates it. If a file matches a pattern, but also matches a negating pattern defined later in the file, it will not be ignored.\n\ndebug.logbut notlogs/debug.log\n\nPatterns defined after a negating pattern will re-ignore any previously negated files.\n\ndebug.loglogs/debug.log\n\nPrepending a slash matches files only in the repository root.\n\ndebug0.logdebugg.logbut notdebug10.log\n\nA question mark matches exactly one character.\n\ndebug0.logdebug1.logbut notdebug10.log\n\nSquare brackets can also be used to match a single character from a specified range.\n\ndebug0.logdebug1.logbut notdebug2.logdebug01.log\n\nSquare brackets match a single character form the specified set.\n\ndebug2.logbut notdebug0.logdebug1.logdebug01.log\n\nAn exclamation mark can be used to match any character except one from the specified set.\n\ndebuga.logdebugb.logbut notdebug1.log\n\nRanges can be numeric or alphabetic.\n\nlogslogs/debug.loglogs/latest/foo.barbuild/logsbuild/logs/debug.log\n\nIf you don't append a slash, the pattern will match both files and the contents of directories with that name. In the example matches on the left, both directories and files named logs are ignored\n\nlogs/debug.loglogs/latest/foo.barbuild/logs/foo.barbuild/logs/latest/debug.log\n\nAppending a slash indicates the pattern is a directory. The entire contents of any directory in the repository matching that name – including all of its files and subdirectories – will be ignored\n\nlogs/!logs/important.log\n\nlogs/debug.loglogs/important.log\n\nWait a minute! Shouldn't logs/important.log be negated in the example on the leftNope! Due to a performance-related quirk in Git, you can not negate a file that is ignored due to a pattern matching a directory\n\nlogs/debug.loglogs/monday/debug.loglogs/monday/pm/debug.log\n\nA double asterisk matches zero or more directories.\n\nlogs/monday/debug.loglogs/tuesday/debug.logbut notlogs/latest/debug.log\n\nWildcards can be used in directory names as well.\n\nlogs/debug.logbut notdebug.logbuild/logs/debug.log\n\nPatterns specifying a file in a particular directory are relative to the repository root. (You can prepend a slash if you like, but it doesn't do anything special.)\n\n** these explanations assume your .gitignore file is in the top level directory of your repository, as is the convention. If your repository has multiple .gitignore files, simply mentally replace \"repository root\" with \"directory containing the .gitignore file\" (and consider unifying them, for the sanity of your team).*\n\nIn addition to these characters, you can use # to include comments in your .gitignore file:\n\nYou can use \\ to escape .gitignore pattern characters if you have files or directories containing them:",
        "code_examples": [
          "```bash\n# ignore all logs*.log\n```",
          "```bash\n# ignore the file literally named foo[01].txtfoo\\[01\\].txt\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 38,
          "content_length": 3180
        }
      },
      {
        "header": "Shared .gitignore files in your repository",
        "content": "Git ignore rules are usually defined in a .gitignore file at the root of your repository. However, you can choose to define multiple .gitignore files in different directories in your repository. Each pattern in a particular .gitignore file is tested relative to the directory containing that file. However the convention, and simplest approach, is to define a single .gitignore file in the root. As your .gitignore file is checked in, it is versioned like any other file in your repository and shared with your teammates when you push. Typically you should only include patterns in .gitignore that will benefit other users of the repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 641
        }
      },
      {
        "header": "Personal Git ignore rules",
        "content": "You can also define personal ignore patterns for a particular repository in a special file at .git/info/exclude. These are not versioned, and not distributed with your repository, so it's an appropriate place to include patterns that will likely only benefit you. For example if you have a custom logging setup, or special development tools that produce files in your repository's working directory, you could consider adding them to .git/info/exclude to prevent them from being accidentally committed to your repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 521
        }
      },
      {
        "header": "Global Git ignore rules",
        "content": "In addition, you can define global Git ignore patterns for all repositories on your local system by setting the Git core.excludesFile property. You'll have to create this file yourself. If you're unsure where to put your global .gitignore file, your home directory isn't a bad choice (and makes it easy to find later). Once you've created the file, you'll need to configure its location with git config:\n\nYou should be careful what patterns you choose to globally ignore, as different file types are relevant for different projects. Special operating system files (e.g. .DS_Store and thumbs.db) or temporary files created by some developer tools are typical candidates for ignoring globally.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ touch ~/.gitignore$ git config --global core.excludesFile ~/.gitignore\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 691
        }
      },
      {
        "header": "Ignoring a previously committed file",
        "content": "If you want to ignore a file that you've committed in the past, you'll need to delete the file from your repository and then add a .gitignore rule for it. Using the --cached option with git rm means that the file will be deleted from your repository, but will remain in your working directory as an ignored file.\n\nYou can omit the --cached option if you want to delete the file from both the repository and your local file system.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ echo debug.log >> .gitignore$ git rm --cached debug.logrm 'debug.log'$ git commit -m \"Start ignoring debug.log\"\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 430
        }
      },
      {
        "header": "Committing an ignored file",
        "content": "It is possible to force an ignored file to be committed to the repository using the -f (or --force) option with git add:\n\nYou might consider doing this if you have a general pattern (like *.log) defined, but you want to commit a specific file. However a better solution is to define an exception to the general rule:\n\nThis approach is more obvious, and less confusing, for your teammates.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ cat .gitignore*.log$ git add -f debug.log$ git commit -m \"Force adding debug.log\"\n```",
          "```bash\n$ echo !debug.log >> .gitignore$ cat .gitignore*.log!debug.log$ git add debug.log$ git commit -m \"Adding debug.log\"\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 388
        }
      },
      {
        "header": "Stashing an ignored file",
        "content": "git stash is a powerful Git feature for temporarily shelving and reverting local changes, allowing you to re-apply them later on. As you'd expect, by default git stash ignores ignored files and only stashes changes to files that are tracked by Git. However, you can invoke git stash with the --all option to stash changes to ignored and untracked files as well.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 361
        }
      },
      {
        "header": "Debugging .gitignore files",
        "content": "If you have complicated .gitignore patterns, or patterns spread over multiple .gitignore files, it can be difficult to track down why a particular file is being ignored. You can use the git check-ignore command with the -v (or --verbose) option to determine which pattern is causing a particular file to be ignored:\n\nYou can pass multiple file names to git check-ignore if you like, and the names themselves don't even have to correspond to files that exist in your repository.",
        "code_examples": [
          "```bash\n<file containing the pattern> : <line number of the pattern> : <pattern>    <file name>\n```"
        ],
        "usage_examples": [
          "```bash\n$ git check-ignore -v debug.log.gitignore:3:*.log  debug.log\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 477
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/saving-changes/gitignore",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Inspecting a repository",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "git status",
        "content": "The git status command displays the state of the working directory and the staging area. It lets you see which changes have been staged, which haven’t, and which files aren’t being tracked by Git. Status output does not show you any information regarding the committed project history. For this, you need to use git log.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 320
        }
      },
      {
        "header": "Related git commands",
        "content": "• git tag Tags are ref's that point to specific points in Git history. git tag is generally used to capture a point in history that is used for a marked version release (i.e. v1.0.1).\n• git blame The high-level function of git blame is the display of author metadata attached to specific committed lines in a file. This is used to explore the history of specific code and answer questions about what, how, and why the code was added to a repository.\n• git log The git log command displays committed snapshots. It lets you list the project history, filter it, and search for specific changes.\n\n• Tags are ref's that point to specific points in Git history. git tag is generally used to capture a point in history that is used for a marked version release (i.e. v1.0.1).\n\n• The high-level function of git blame is the display of author metadata attached to specific committed lines in a file. This is used to explore the history of specific code and answer questions about what, how, and why the code was added to a repository.\n\n• The git log command displays committed snapshots. It lets you list the project history, filter it, and search for specific changes.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 1160
        }
      },
      {
        "header": "Usage",
        "content": "List which files are staged, unstaged, and untracked.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit status\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 53
        }
      },
      {
        "header": "Discussion",
        "content": "The git status command is a relatively straightforward command. It simply shows you what's been going on with git add and git commit. Status messages also include relevant instructions for staging/unstaging files. Sample output showing the three main categories of a git status call is included below:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# On branch main# Changes to be committed:# (use \"git reset HEAD <file>...\" to unstage)##modified: hello.py## Changes not staged for commit:# (use \"git add <file>...\" to update what will be committed)# (use \"git checkout -- <file>...\" to discard changes in working directory)##modified: main.py## Untracked files:# (use \"git add <file>...\" to include in what will be committed)##hello.pyc\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 301
        }
      },
      {
        "header": "Ignoring Files",
        "content": "Untracked files typically fall into two categories. They're either files that have just been added to the project and haven't been committed yet, or they're compiled binaries like .pyc, .obj, .exe, etc. While it's definitely beneficial to include the former in the git status output, the latter can make it hard to see what’s actually going on in your repository.\n\nFor this reason, Git lets you completely ignore files by placing paths in a special file called .gitignore. Any files that you'd like to ignore should be included on a separate line, and the * symbol can be used as a wildcard. For example, adding the following to a .gitignore file in your project root will prevent compiled Python modules from appearing in git status:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 734
        }
      },
      {
        "header": "Example",
        "content": "It's good practice to check the state of your repository before committing changes so that you don't accidentally commit something you don't mean to. This example displays the repository status before and after staging and committing a snapshot:\n\nThe first status output will show the file as unstaged. The git add action will be reflected in the second git status, and the final status output will tell you that there is nothing to commit—the working directory matches the most recent commit. Some Git commands (e.g., git merge) require the working directory to be clean so that you don't accidentally overwrite changes.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# Edit hello.pygit status# hello.py is listed under \"Changes not staged for commit\"git add hello.pygit status# hello.py is listed under \"Changes to be committed\"git commitgit status# nothing to commit (working directory clean)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 621
        }
      },
      {
        "header": "git log",
        "content": "The git log command displays committed snapshots. It lets you list the project history, filter it, and search for specific changes. While git status lets you inspect the working directory and the staging area, git log only operates on the committed history.\n\nLog output can be customized in several ways, from simply filtering commits to displaying them in a completely user-defined format. Some of the most common configurations of git log are presented below.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 461
        }
      },
      {
        "header": "Usage",
        "content": "Display the entire commit history using the default formatting. If the output takes up more than one screen, you can use Space to scroll and q to exit.\n\nLimit the number of commits by . For example, git log -n 3 will display only 3 commits.\n\nCondense each commit to a single line. This is useful for getting a high-level overview of the project history.\n\nAlong with the ordinary git log information, include which files were altered and the relative number of lines that were added or deleted from each of them.\n\nDisplay the patch representing each commit. This shows the full diff of each commit, which is the most detailed view you can have of your project history.\n\nSearch for commits by a particular author. The ＜pattern＞ argument can be a plain string or a regular expression.\n\nSearch for commits with a commit message that matches ＜pattern＞, which can be a plain string or a regular expression.\n\nShow only commits that occur between < since > and < until >. Both arguments can be either a commit ID, a branch name, HEAD, or any other kind of revision reference.\n\nOnly display commits that include the specified file. This is an easy way to see the history of a particular file.\n\nA few useful options to consider. The --graph flag that will draw a text based graph of the commits on the left hand side of the commit messages. --decorate adds the names of branches or tags of the commits that are shown. --oneline shows the commit information on a single line making it easier to browse through commits at-a-glance.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log\n```",
          "```bash\ngit log -n <limit>\n```",
          "```bash\ngit log --oneline\n```",
          "```bash\ngit log --stat\n```",
          "```bash\ngit log -p\n```",
          "```bash\ngit log --author=\"<pattern>\"\n```",
          "```bash\ngit log --grep=\"<pattern>\"\n```",
          "```bash\ngit log <since>..<until>\n```",
          "```bash\ngit log <file>\n```",
          "```bash\ngit log --graph --decorate --oneline\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 1519
        }
      },
      {
        "header": "Discussion",
        "content": "5. Check the status of the file.\n\nMost of this is pretty straightforward; however, the first line warrants some explanation. The 40-character string after commit is an SHA-1 checksum of the commit’s contents. This serves two purposes. First, it ensures the integrity of the commit—if it was ever corrupted, the commit would generate a different checksum. Second, it serves as a unique ID for the commit.\n\nThis ID can be used in commands like git log .. to refer to specific commits. For instance, git log 3157e..5ab91 will display everything between the commits with ID's 3157e and 5ab91. Aside from checksums, branch names (discussed in the Branch Module) and the HEAD keyword are other common methods for referring to individual commits. HEAD always refers to the current commit, be it a branch or a specific commit.\n\nThe ~ character is useful for making relative references to the parent of a commit. For example, 3157e~1 refers to the commit before 3157e, and HEAD~3 is the great-grandparent of the current commit.",
        "code_examples": [
          "```bash\ncommit 3157ee3718e180a9476bf2e5cab8e3f1e78a73b7Author: John Smith\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1018
        }
      },
      {
        "header": "Example",
        "content": "The Usage section provides many examples of git log, but keep in mind that several options can be combined into a single command:\n\nThis will display a full diff of all the changes John Smith has made to the file hello.py.\n\nThe .. syntax is a very useful tool for comparing branches. The next example displays a brief overview of all the commits that are in some-feature that are not in main.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log --author=\"John Smith\" -p hello.py\n```",
          "```bash\ngit log --oneline main..some-feature\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 391
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/inspecting-a-repository",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Inspecting a repository",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "git status",
        "content": "The git status command displays the state of the working directory and the staging area. It lets you see which changes have been staged, which haven’t, and which files aren’t being tracked by Git. Status output does not show you any information regarding the committed project history. For this, you need to use git log.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 320
        }
      },
      {
        "header": "Related git commands",
        "content": "• git tag Tags are ref's that point to specific points in Git history. git tag is generally used to capture a point in history that is used for a marked version release (i.e. v1.0.1).\n• git blame The high-level function of git blame is the display of author metadata attached to specific committed lines in a file. This is used to explore the history of specific code and answer questions about what, how, and why the code was added to a repository.\n• git log The git log command displays committed snapshots. It lets you list the project history, filter it, and search for specific changes.\n\n• Tags are ref's that point to specific points in Git history. git tag is generally used to capture a point in history that is used for a marked version release (i.e. v1.0.1).\n\n• The high-level function of git blame is the display of author metadata attached to specific committed lines in a file. This is used to explore the history of specific code and answer questions about what, how, and why the code was added to a repository.\n\n• The git log command displays committed snapshots. It lets you list the project history, filter it, and search for specific changes.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 1160
        }
      },
      {
        "header": "Usage",
        "content": "List which files are staged, unstaged, and untracked.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit status\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 53
        }
      },
      {
        "header": "Discussion",
        "content": "The git status command is a relatively straightforward command. It simply shows you what's been going on with git add and git commit. Status messages also include relevant instructions for staging/unstaging files. Sample output showing the three main categories of a git status call is included below:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# On branch main# Changes to be committed:# (use \"git reset HEAD <file>...\" to unstage)##modified: hello.py## Changes not staged for commit:# (use \"git add <file>...\" to update what will be committed)# (use \"git checkout -- <file>...\" to discard changes in working directory)##modified: main.py## Untracked files:# (use \"git add <file>...\" to include in what will be committed)##hello.pyc\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 301
        }
      },
      {
        "header": "Ignoring Files",
        "content": "Untracked files typically fall into two categories. They're either files that have just been added to the project and haven't been committed yet, or they're compiled binaries like .pyc, .obj, .exe, etc. While it's definitely beneficial to include the former in the git status output, the latter can make it hard to see what’s actually going on in your repository.\n\nFor this reason, Git lets you completely ignore files by placing paths in a special file called .gitignore. Any files that you'd like to ignore should be included on a separate line, and the * symbol can be used as a wildcard. For example, adding the following to a .gitignore file in your project root will prevent compiled Python modules from appearing in git status:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 734
        }
      },
      {
        "header": "Example",
        "content": "It's good practice to check the state of your repository before committing changes so that you don't accidentally commit something you don't mean to. This example displays the repository status before and after staging and committing a snapshot:\n\nThe first status output will show the file as unstaged. The git add action will be reflected in the second git status, and the final status output will tell you that there is nothing to commit—the working directory matches the most recent commit. Some Git commands (e.g., git merge) require the working directory to be clean so that you don't accidentally overwrite changes.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# Edit hello.pygit status# hello.py is listed under \"Changes not staged for commit\"git add hello.pygit status# hello.py is listed under \"Changes to be committed\"git commitgit status# nothing to commit (working directory clean)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 621
        }
      },
      {
        "header": "git log",
        "content": "The git log command displays committed snapshots. It lets you list the project history, filter it, and search for specific changes. While git status lets you inspect the working directory and the staging area, git log only operates on the committed history.\n\nLog output can be customized in several ways, from simply filtering commits to displaying them in a completely user-defined format. Some of the most common configurations of git log are presented below.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 461
        }
      },
      {
        "header": "Usage",
        "content": "Display the entire commit history using the default formatting. If the output takes up more than one screen, you can use Space to scroll and q to exit.\n\nLimit the number of commits by . For example, git log -n 3 will display only 3 commits.\n\nCondense each commit to a single line. This is useful for getting a high-level overview of the project history.\n\nAlong with the ordinary git log information, include which files were altered and the relative number of lines that were added or deleted from each of them.\n\nDisplay the patch representing each commit. This shows the full diff of each commit, which is the most detailed view you can have of your project history.\n\nSearch for commits by a particular author. The ＜pattern＞ argument can be a plain string or a regular expression.\n\nSearch for commits with a commit message that matches ＜pattern＞, which can be a plain string or a regular expression.\n\nShow only commits that occur between < since > and < until >. Both arguments can be either a commit ID, a branch name, HEAD, or any other kind of revision reference.\n\nOnly display commits that include the specified file. This is an easy way to see the history of a particular file.\n\nA few useful options to consider. The --graph flag that will draw a text based graph of the commits on the left hand side of the commit messages. --decorate adds the names of branches or tags of the commits that are shown. --oneline shows the commit information on a single line making it easier to browse through commits at-a-glance.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log\n```",
          "```bash\ngit log -n <limit>\n```",
          "```bash\ngit log --oneline\n```",
          "```bash\ngit log --stat\n```",
          "```bash\ngit log -p\n```",
          "```bash\ngit log --author=\"<pattern>\"\n```",
          "```bash\ngit log --grep=\"<pattern>\"\n```",
          "```bash\ngit log <since>..<until>\n```",
          "```bash\ngit log <file>\n```",
          "```bash\ngit log --graph --decorate --oneline\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 1519
        }
      },
      {
        "header": "Discussion",
        "content": "5. Check the status of the file.\n\nMost of this is pretty straightforward; however, the first line warrants some explanation. The 40-character string after commit is an SHA-1 checksum of the commit’s contents. This serves two purposes. First, it ensures the integrity of the commit—if it was ever corrupted, the commit would generate a different checksum. Second, it serves as a unique ID for the commit.\n\nThis ID can be used in commands like git log .. to refer to specific commits. For instance, git log 3157e..5ab91 will display everything between the commits with ID's 3157e and 5ab91. Aside from checksums, branch names (discussed in the Branch Module) and the HEAD keyword are other common methods for referring to individual commits. HEAD always refers to the current commit, be it a branch or a specific commit.\n\nThe ~ character is useful for making relative references to the parent of a commit. For example, 3157e~1 refers to the commit before 3157e, and HEAD~3 is the great-grandparent of the current commit.",
        "code_examples": [
          "```bash\ncommit 3157ee3718e180a9476bf2e5cab8e3f1e78a73b7Author: John Smith\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1018
        }
      },
      {
        "header": "Example",
        "content": "The Usage section provides many examples of git log, but keep in mind that several options can be combined into a single command:\n\nThis will display a full diff of all the changes John Smith has made to the file hello.py.\n\nThe .. syntax is a very useful tool for comparing branches. The next example displays a brief overview of all the commits that are in some-feature that are not in main.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log --author=\"John Smith\" -p hello.py\n```",
          "```bash\ngit log --oneline main..some-feature\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 391
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/inspecting-a-repository/git-status",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Git tag",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "This document will discuss the Git concept of tagging and the git tag command. Tags are ref's that point to specific points in Git history. Tagging is generally used to capture a point in history that is used for a marked version release (i.e. v1.0.1).\n\nA tag is like a branch that doesn’t change. Unlike branches, tags, after being created, have no further history of commits. For more info on branches visit the git branch page.\n\nThis document will cover the different kinds of tags, how to create tags, list all tags, delete tags, use commands like git checkout tag to view a tagged commit, and git push tag to share tags with others.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 637
        }
      },
      {
        "header": "How to create a tag in Git",
        "content": "To create a new tag execute the following command:\n\nReplace < tagname > with a semantic identifier to the state of the repo at the time the tag is being created. A common pattern is to use version numbers like git tag v1.4. Git supports two different types of tags, annotated and lightweight tags. The previous example created a lightweight tag. Lightweight tags and Annotated tags differ in the amount of accompanying meta data they store. A best practice is to consider Annotated tags as public, and Lightweight tags as private. Annotated tags store extra meta data such as: the tagger name, email, and date. This is important data for a public release. Lightweight tags are essentially 'bookmarks' to a commit, they are just a name and a pointer to a commit, useful for creating quick links to relevant commits.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit tag <tagname>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 814
        }
      },
      {
        "header": "Annotated tags",
        "content": "Annotated tags are stored as full objects in the Git database. To reiterate, They store extra meta data such as: the tagger name, email, and date. Similar to commits and commit messages Annotated tags have a tagging message. Additionally, for security, annotated tags can be signed and verified with GNU Privacy Guard (GPG). Suggested best practices for git tagging is to prefer annotated tags over lightweight so you can have all the associated meta-data.\n\nExecuting this command will create a new annotated tag identified with v1.4. The command will then open up the configured default text editor to prompt for further meta data input.\n\nExecuting this command is similar to the previous invocation, however, this version of the command is passed the -m option and a message. This is a convenience method similar to git commit -m that will immediately create a new tag and forgo opening the local text editor in favor of saving the message passed in with the -m option.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit tag -a v1.4\n```",
          "```bash\ngit tag -a v1.4 -m \"my version 1.4\"\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 971
        }
      },
      {
        "header": "Lightweight tags",
        "content": "Executing this command creates a lightweight tag identified as v1.4-lw. Lightweight tags are created with the absence of the -a, -s, or -m options. Lightweight tags create a new tag checksum and store it in the .git/ directory of the project's repo.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit tag v1.4-lw\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 249
        }
      },
      {
        "header": "Listing tags",
        "content": "To list stored tags in a repo execute the following:\n\nThis will output a list of tags:\n\nTo refine the list of tags the -l option can be passed with a wild card expression:\n\nThis previous example uses the -l option and a wildcard expression of -rc which returns a list of all tags marked with a -rc prefix, traditionally used to identify release candidates.",
        "code_examples": [
          "```bash\nv0.10.0v0.10.0-rc1v0.11.0v0.11.0-rc1v0.11.1v0.11.2v0.12.0v0.12.0-rc1v0.12.1v0.12.2v0.13.0v0.13.0-rc1v0.13.0-rc2\n```"
        ],
        "usage_examples": [
          "```bash\ngit tag\n```",
          "```bash\n$ git tag -l *-rc*v0.10.0-rc1v0.11.0-rc1v0.12.0-rc1v0.13.0-rc1v0.13.0-rc2v0.14.0-rc1v0.9.0-rc1v15.0.0-rc.1v15.0.0-rc.2v15.4.0-rc.3\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 356
        }
      },
      {
        "header": "Tagging old commits",
        "content": "The previous tagging examples have demonstrated operations on implicit commits. By default, git tag will create a tag on the commit that HEAD is referencing. Alternatively git tag can be passed as a ref to a specific commit. This will tag the passed commit instead of defaulting to HEAD. To gather a list of older commits, execute the git log command.\n\nExecuting git log will output a list of commits. In this example we will pick the top most commit Merge branch 'feature' for the new tag. We will need to reference to the commit SHA hash to pass to Git:\n\nExecuting the above git tag invocation will create a new annotated commit identified as v1.2 for the commit we selected in the previous git log example.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git log --pretty=oneline15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'feature'a6b4c97498bd301d84096da251c98a07c7723e65 add update method for thing0d52aaab4479697da7686c15f77a3d64d9165190 one more thing6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'\n```",
          "```bash\ngit tag -a v1.2 15027957951b64cf874c3557a0f3547bd83b3ff6\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 709
        }
      },
      {
        "header": "ReTagging/Replacing old tags",
        "content": "If you try to create a tag with the same identifier as an existing tag, Git will throw an error like:\n\nAdditionally if you try to tag an older commit with an existing tag identifier Git will throw the same error.\n\nIn the event that you must update an existing tag, the -f FORCE option must be used.\n\nExecuting the above command will map the 15027957951b64cf874c3557a0f3547bd83b3ff6 commit to the v1.4 tag identifier. It will override any existing content for the v1.4 tag.",
        "code_examples": [
          "```bash\nfatal: tag 'v0.4' already exists\n```"
        ],
        "usage_examples": [
          "```bash\ngit tag -a -f v1.4 15027957951b64cf874c3557a0f3547bd83b3ff6\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 472
        }
      },
      {
        "header": "Sharing: Pushing tags to remote",
        "content": "Sharing tags is similar to pushing branches. By default, git push will not push tags. Tags have to be explicitly passed to git push.\n\nTo push multiple tags simultaneously pass the --tags option to git push command. When another user clones or pulls a repo they will receive the new tags.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git push origin v1.4Counting objects: 14, done.Delta compression using up to 8 threads.Compressing objects: 100% (12/12), done.Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.Total 14 (delta 3), reused 0 (delta 0)To git@bitbucket.com:atlasbro/gittagdocs.git* [new tag]         v1.4 -> v1.4\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 287
        }
      },
      {
        "header": "Checking out tags",
        "content": "You can view the state of a repo at a tag by using the git checkout command.\n\nThe above command will checkout the v1.4 tag. This puts the repo in a detached HEAD state. This means any changes made will not update the tag. They will create a new detached commit. This new detached commit will not be part of any branch and will only be reachable directly by the commits SHA hash. Therefore it is a best practice to create a new branch anytime you're making changes in a detached HEAD state.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout v1.4\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 489
        }
      },
      {
        "header": "Deleting tags",
        "content": "Deleting tags is a straightforward operation. Passing the -d option and a tag identifier to git tag will delete the identified tag.\n\nIn this example git tag is executed to display a list of tags showing v1, v2, v3, Then git tag -d v1 is executed which deletes the v1 tag.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git tagv1v2v3$ git tag -d v1$ git tagv2v3\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 271
        }
      },
      {
        "header": "Summary",
        "content": "To recap, Tagging is an additional mechanism used to create a snap shot of a Git repo. Tagging is traditionally used to create semantic version number identifier tags that correspond to software release cycles. The git tag command is the primary driver of tag: creation, modification and deletion. There are two types of tags; annotated and lightweight. Annotated tags are generally the better practices as they store additional valuable meta data about the tag. Additional Git commands covered in this document were git push, and git checkout. Visit their corresponding pages for discussion on their extended use.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 614
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/inspecting-a-repository/git-tag",
    "doc_type": "git",
    "total_sections": 13
  },
  {
    "title": "Git blame",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "The git blame command is a versatile troubleshooting utility that has extensive usage options. The high-level function of git blame is the display of author metadata attached to specific committed lines in a file. This is used to examine specific points of a file's history and get context as to who the last author was that modified the line. This is used to explore the history of specific code and answer questions about what, how, and why the code was added to a repository.\n\nGit blame is often used with a GUI display. Online Git hosting sites like Bitbucket offer blame views which are UI wrappers to git blame. These views are referenced in collaborative discussions around pull requests and commits. Additionally, most IDE's that have Git integration also have dynamic blame views.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 789
        }
      },
      {
        "header": "How it works",
        "content": "In order to demonstrate git blame we need a repository with some history. We will use the open source project git-blame-example. This open source project is a simple repository that contains a README.md file which has a few commits from different authors. The first step of our git blame usage example is to git clone the example repository.\n\nNow that we have a copy of the example code we can start exploring it with git blame. The state of the example repo can be examined using git log. The commit history should look like the following:\n\ngit blame only operates on individual files. A file-path is required for any useful output. The default execution of git blame will simply output the commands help menu. For this example, we will operate on the README.MD file. It is a common open source software practice to include a README file in the root of a git repository as documentation source for the project.\n\nExecuting the above command will give us our first sample of blame output. The following output is a subset of the full blame output of the README. Additionally, this output is static is reflective of the state of the repo at the time of this writing.\n\nThis is a sample of the first 13 lines of the README.md file. To better understand this output lets break down a line. The following table displays the content of line 3 and the columns of the table indicate the column content.\n\nId | Author | Timestamp | Line Number | Line Content\n--- | --- | --- | --- | ---\n89feb84d | Author Albert So | Timestamp 2018-03-01 00:54:03 +0000 | Line Number 3 | Line Content This repository is an example of a project with multiple contributors making commits.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit clone https://kevzettler@bitbucket.org/kevzettler/git-blame-example.git && cd git-blame-example\n```",
          "```bash\n$ git logcommit 548dabed82e4e5f3734c219d5a742b1c259926b2Author: Juni Mukherjee <jmukherjee@atlassian.com>Date:   Thu Mar 1 19:55:15 2018 +0000Another commit to help git blame track the who, the what, and the whencommit eb06faedb1fdd159d62e4438fc8dbe9c9fe0728bAuthor: Juni Mukherjee <jmukherjee@atlassian.com>Date:   Thu Mar 1 19:53:23 2018 +0000Creating the third commit, along with Kev and Albert, so that Kev can get git blame docs.commit 990c2b6a84464fee153253dbf02e845a4db372bbMerge: 82496ea 89feb84Author: Albert So <aso@atlassian.com>Date:   Thu Mar 1 05:33:01 2018 +0000Merged in albert-so/git-blame-example/albert-so/readmemd-edited-online-with-bitbucket-1519865641474 (pull request #2)README.md edited online with Bitbucketcommit 89feb84d885fe33d1182f2112885c2a64a4206ecAuthor: Albert So <aso@atlassian.com>Date:   Thu Mar 1 00:54:03 2018 +0000README.md edited online with Bitbucket\n```",
          "```bash\ngit blame README.MD\n```",
          "```bash\n$ git blame README.md82496ea3 (kevzettler     2018-02-28 13:37:02 -0800  1) # Git Blame example82496ea3 (kevzettler     2018-02-28 13:37:02 -0800  2)89feb84d (Albert So      2018-03-01 00:54:03 +0000  3) This repository is an example of a project with multiple contributors making commits.82496ea3 (kevzettler     2018-02-28 13:37:02 -0800  4)82496ea3 (kevzettler     2018-02-28 13:37:02 -0800  5) The repo use used elsewhere to demonstrate `git blame`82496ea3 (kevzettler     2018-02-28 13:37:02 -0800  6)89feb84d (Albert So      2018-03-01 00:54:03 +0000  7) Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod TEMPOR incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum89feb84d (Albert So      2018-03-01 00:54:03 +0000  8)eb06faed (Juni Mukherjee 2018-03-01 19:53:23 +0000  9) Annotates each line in the given file with information from the revision which last modified the line. Optionally, start annotating from the given revision.eb06faed (Juni Mukherjee 2018-03-01 19:53:23 +0000 10)548dabed (Juni Mukherjee 2018-03-01 19:55:15 +0000 11) Creating a line to support documentation needs for git blame.548dabed (Juni Mukherjee 2018-03-01 19:55:15 +0000 12)548dabed (Juni Mukherjee 2018-03-01 19:55:15 +0000 13) Also, it is important to have a few of these commits to clearly reflect the who, the what and the when. This will help Kev get good screenshots when he runs the git blame on this README.\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 5,
          "content_length": 1658
        }
      },
      {
        "header": "Id",
        "content": "2018-03-01 00:54:03 +0000\n\nThis repository is an example of a project with multiple contributors making commits.\n\nIf we review the blame output list, we can make some observations. There are three authors listed. In addition to the project's maintainer Kev Zettler, Albert So, and Juni Mukherjee are also listed. Authors are generally the most valuable part of git blame output. The timestamp column is also primarily helpful. What the change was is indicated by line content column.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 483
        }
      },
      {
        "header": "Common options",
        "content": "The -L option will restrict the output to the requested line range. Here we have restricted the output to lines 1 through 5.\n\nThe -e option shows the authors email address instead of username.\n\nThe -w option ignores whitespace changes. If a previous author has modified the spacing of a file by switching from tabs to spaces or adding new lines this, unfortunately, obscures the output of git blame by showing these changes.\n\nThe -M option detects moved or copied lines within in the same file. This will report the original author of the lines instead of the last author that moved or copied the lines.\n\nThe -C option detects lines that were moved or copied from other files. This will report the original author of the lines instead of the last author that moved or copied the lines.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit blame -L 1,5 README.md\n```",
          "```bash\ngit blame -e README.md\n```",
          "```bash\ngit blame -w README.md\n```",
          "```bash\ngit blame -M README.md\n```",
          "```bash\ngit blame -C README.md\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 785
        }
      },
      {
        "header": "Git blame vs git log",
        "content": "While git blame displays the last author that modified a line, often times you will want to know when a line was originally added. This can be cumbersome to achieve using git blame. It requires a combination of the -w, -C, and -M options. It can be far more convenient to use the git log command.\n\nTo list all original commits in-which a specific code piece was added or modified execute git log with the -S option. Append the -S option with the code you are looking for. Let's take one of the lines from the README output above to use as an example. Let us take the text \"CSS3D and WebGL renderers\" from Line 12 of the README output.\n\nThis output shows us that content from the README was added or modified 3 times by 3 different authors. It was originally added in commit cb20237cc by Mr.doob. In this example, git log has also been prepended with the --pretty-format option. This option converts the default output format of git log into one that matches the format of git log. For more information on usage and configuration options visit the git log page.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git log -S\"CSS3D and WebGL renderers.\" --pretty=format:'%h %an %ad %s'e339d3c85 Mario Schuettel Tue Oct 13 16:51:06 2015 +0200 reverted README.md to original content509c2cc35 Daniel Tue Sep 8 13:56:14 2015 +0200 Updated READMEcb20237cc Mr.doob Mon Dec 31 00:22:36 2012 +0100 Removed DOMRenderer. Now with the CSS3DRenderer it has become irrelevant.\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1060
        }
      },
      {
        "header": "Summary",
        "content": "The git blame command is used to examine the contents of a file line by line and see when each line was last modified and who the author of the modifications was. The output format of git blame can be altered with various command line options. Online Git hosting solutions like Bitbucket offer blame views, which offer a superior user experience to command line git blame usage. git blame and git log can be used in combination to help discover the history of a file's contents. The git log command has some similar blame functionality, to learn more visit the git log overview page.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 583
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/inspecting-a-repository/git-blame",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "Inspecting a repository",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "git status",
        "content": "The git status command displays the state of the working directory and the staging area. It lets you see which changes have been staged, which haven’t, and which files aren’t being tracked by Git. Status output does not show you any information regarding the committed project history. For this, you need to use git log.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 320
        }
      },
      {
        "header": "Related git commands",
        "content": "• git tag Tags are ref's that point to specific points in Git history. git tag is generally used to capture a point in history that is used for a marked version release (i.e. v1.0.1).\n• git blame The high-level function of git blame is the display of author metadata attached to specific committed lines in a file. This is used to explore the history of specific code and answer questions about what, how, and why the code was added to a repository.\n• git log The git log command displays committed snapshots. It lets you list the project history, filter it, and search for specific changes.\n\n• Tags are ref's that point to specific points in Git history. git tag is generally used to capture a point in history that is used for a marked version release (i.e. v1.0.1).\n\n• The high-level function of git blame is the display of author metadata attached to specific committed lines in a file. This is used to explore the history of specific code and answer questions about what, how, and why the code was added to a repository.\n\n• The git log command displays committed snapshots. It lets you list the project history, filter it, and search for specific changes.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 1160
        }
      },
      {
        "header": "Usage",
        "content": "List which files are staged, unstaged, and untracked.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit status\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 53
        }
      },
      {
        "header": "Discussion",
        "content": "The git status command is a relatively straightforward command. It simply shows you what's been going on with git add and git commit. Status messages also include relevant instructions for staging/unstaging files. Sample output showing the three main categories of a git status call is included below:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# On branch main# Changes to be committed:# (use \"git reset HEAD <file>...\" to unstage)##modified: hello.py## Changes not staged for commit:# (use \"git add <file>...\" to update what will be committed)# (use \"git checkout -- <file>...\" to discard changes in working directory)##modified: main.py## Untracked files:# (use \"git add <file>...\" to include in what will be committed)##hello.pyc\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 301
        }
      },
      {
        "header": "Ignoring Files",
        "content": "Untracked files typically fall into two categories. They're either files that have just been added to the project and haven't been committed yet, or they're compiled binaries like .pyc, .obj, .exe, etc. While it's definitely beneficial to include the former in the git status output, the latter can make it hard to see what’s actually going on in your repository.\n\nFor this reason, Git lets you completely ignore files by placing paths in a special file called .gitignore. Any files that you'd like to ignore should be included on a separate line, and the * symbol can be used as a wildcard. For example, adding the following to a .gitignore file in your project root will prevent compiled Python modules from appearing in git status:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 734
        }
      },
      {
        "header": "Example",
        "content": "It's good practice to check the state of your repository before committing changes so that you don't accidentally commit something you don't mean to. This example displays the repository status before and after staging and committing a snapshot:\n\nThe first status output will show the file as unstaged. The git add action will be reflected in the second git status, and the final status output will tell you that there is nothing to commit—the working directory matches the most recent commit. Some Git commands (e.g., git merge) require the working directory to be clean so that you don't accidentally overwrite changes.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# Edit hello.pygit status# hello.py is listed under \"Changes not staged for commit\"git add hello.pygit status# hello.py is listed under \"Changes to be committed\"git commitgit status# nothing to commit (working directory clean)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 621
        }
      },
      {
        "header": "git log",
        "content": "The git log command displays committed snapshots. It lets you list the project history, filter it, and search for specific changes. While git status lets you inspect the working directory and the staging area, git log only operates on the committed history.\n\nLog output can be customized in several ways, from simply filtering commits to displaying them in a completely user-defined format. Some of the most common configurations of git log are presented below.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 461
        }
      },
      {
        "header": "Usage",
        "content": "Display the entire commit history using the default formatting. If the output takes up more than one screen, you can use Space to scroll and q to exit.\n\nLimit the number of commits by . For example, git log -n 3 will display only 3 commits.\n\nCondense each commit to a single line. This is useful for getting a high-level overview of the project history.\n\nAlong with the ordinary git log information, include which files were altered and the relative number of lines that were added or deleted from each of them.\n\nDisplay the patch representing each commit. This shows the full diff of each commit, which is the most detailed view you can have of your project history.\n\nSearch for commits by a particular author. The ＜pattern＞ argument can be a plain string or a regular expression.\n\nSearch for commits with a commit message that matches ＜pattern＞, which can be a plain string or a regular expression.\n\nShow only commits that occur between < since > and < until >. Both arguments can be either a commit ID, a branch name, HEAD, or any other kind of revision reference.\n\nOnly display commits that include the specified file. This is an easy way to see the history of a particular file.\n\nA few useful options to consider. The --graph flag that will draw a text based graph of the commits on the left hand side of the commit messages. --decorate adds the names of branches or tags of the commits that are shown. --oneline shows the commit information on a single line making it easier to browse through commits at-a-glance.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log\n```",
          "```bash\ngit log -n <limit>\n```",
          "```bash\ngit log --oneline\n```",
          "```bash\ngit log --stat\n```",
          "```bash\ngit log -p\n```",
          "```bash\ngit log --author=\"<pattern>\"\n```",
          "```bash\ngit log --grep=\"<pattern>\"\n```",
          "```bash\ngit log <since>..<until>\n```",
          "```bash\ngit log <file>\n```",
          "```bash\ngit log --graph --decorate --oneline\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 1519
        }
      },
      {
        "header": "Discussion",
        "content": "5. Check the status of the file.\n\nMost of this is pretty straightforward; however, the first line warrants some explanation. The 40-character string after commit is an SHA-1 checksum of the commit’s contents. This serves two purposes. First, it ensures the integrity of the commit—if it was ever corrupted, the commit would generate a different checksum. Second, it serves as a unique ID for the commit.\n\nThis ID can be used in commands like git log .. to refer to specific commits. For instance, git log 3157e..5ab91 will display everything between the commits with ID's 3157e and 5ab91. Aside from checksums, branch names (discussed in the Branch Module) and the HEAD keyword are other common methods for referring to individual commits. HEAD always refers to the current commit, be it a branch or a specific commit.\n\nThe ~ character is useful for making relative references to the parent of a commit. For example, 3157e~1 refers to the commit before 3157e, and HEAD~3 is the great-grandparent of the current commit.",
        "code_examples": [
          "```bash\ncommit 3157ee3718e180a9476bf2e5cab8e3f1e78a73b7Author: John Smith\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1018
        }
      },
      {
        "header": "Example",
        "content": "The Usage section provides many examples of git log, but keep in mind that several options can be combined into a single command:\n\nThis will display a full diff of all the changes John Smith has made to the file hello.py.\n\nThe .. syntax is a very useful tool for comparing branches. The next example displays a brief overview of all the commits that are in some-feature that are not in main.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log --author=\"John Smith\" -p hello.py\n```",
          "```bash\ngit log --oneline main..some-feature\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 391
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/inspecting-a-repository/git-log",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Undoing Commits & Changes",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "In this section, we will discuss the available 'undo' Git strategies and commands. It is first important to note that Git does not have a traditional 'undo' system like those found in a word processing application. It will be beneficial to refrain from mapping Git operations to any traditional 'undo' mental model. Additionally, Git has its own nomenclature for 'undo' operations that it is best to leverage in a discussion. This nomenclature includes terms like reset, revert, checkout, clean, and more.\n\nA fun metaphor is to think of Git as a timeline management utility. Commits are snapshots of a point in time or points of interest along the timeline of a project's history. Additionally, multiple timelines can be managed through the use of branches. When 'undoing' in Git, you are usually moving back in time, or to another timeline where mistakes didn't happen.\n\nThis tutorial provides all of the necessary skills to work with previous revisions of a software project. First, it shows you how to explore old commits, then it explains the difference between reverting public commits in the project history vs. resetting unpublished changes on your local machine.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1170
        }
      },
      {
        "header": "Finding what is lost: Reviewing old commits",
        "content": "The whole idea behind any version control system is to store “safe” copies of a project so that you never have to worry about irreparably breaking your code base. Once you’ve built up a project history of commits, you can review and revisit any commit in the history. One of the best utilities for reviewing the history of a Git repository is the git log command. In the example below, we use git log to get a list of the latest commits to a popular open-source graphics library.\n\nEach commit has a unique SHA-1 identifying hash. These IDs are used to travel through the committed timeline and revisit commits. By default, git log will only show commits for the currently selected branch. It is entirely possible that the commit you're looking for is on another branch. You can view all commits across all branches by executing git log --branches=*. The command git branch is used to view and visit other branches. Invoking the command, git branch -a will return a list of all known branch names. One of these branch names can then be logged using git log .\n\nWhen you have found a commit reference to the point in history you want to visit, you can utilize the git checkout command to visit that commit. Git checkout is an easy way to “load” any of these saved snapshots onto your development machine. During the normal course of development, the HEAD usually points to main or some other local branch, but when you check out a previous commit, HEAD no longer points to a branch—it points directly to a commit. This is called a “detached HEAD” state, and it can be visualized as the following:\n\nChecking out an old file does not move the HEAD pointer. It remains on the same branch and same commit, avoiding a 'detached head' state. You can then commit the old version of the file in a new snapshot as you would any other changes. So, in effect, this usage of git checkout on a file, serves as a way to revert back to an old version of an individual file. For more information on these two modes visit the git checkout page",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log --onelinee2f9a78fe Replaced FlyControls with OrbitControlsd35ce0178 Editor: Shortcuts panel Safari support.9dbe8d0cf Editor: Sidebar.Controls to Sidebar.Settings.Shortcuts. Clean up.05c5288fc Merge pull request #12612 from TyLindberg/editor-controls-panel0d8b6e74b Merge pull request #12805 from harto/patch-123b20c22e Merge pull request #12801 from gam0022/improve-raymarching-example-v2fe78029f1 Fix typo in documentation7ce43c448 Merge pull request #12794 from WestLangley/dev-x17452bb93 Merge pull request #12778 from OndrejSpanel/unitTestFixesb5c1b5c70 Merge pull request #12799 from dhritzkiv/patch-211b48ff4d2 Updated builds.88adbcdf6 WebVRManager: Clean up.2720fbb08 Merge pull request #12803 from dmarcos/parentPoseObject9ed629301 Check parent of poseObject instead of camera219f3eb13 Update GLTFLoader.js15f13bb3c Update GLTFLoader.js6d9c22a3b Update uniforms only when onWindowResize881b25b58 Update ProjectionMatrix on change aspect\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 2023
        }
      },
      {
        "header": "Viewing an old revision",
        "content": "This example assumes that you’ve started developing a crazy experiment, but you’re not sure if you want to keep it or not. To help you decide, you want to take a look at the state of the project before you started your experiment. First, you’ll need to find the ID of the revision you want to see.\n\nLet’s say your project history looks something like the following:\n\nYou can use git checkout to view the “Make some import changes to hello.txt” commit as follows:\n\nThis makes your working directory match the exact state of the a1e8fb5 commit. You can look at files, compile the project, run tests, and even edit files without worrying about losing the current state of the project. Nothing you do in here will be saved in your repository. To continue developing, you need to get back to the “current” state of your project:\n\nThis assumes that you're developing on the default main branch. Once you’re back in the main branch, you can use either git revert or git reset to undo any undesired changes.",
        "code_examples": [
          "```bash\nb7119f2 Continue doing crazy things872fa7e Try something crazya1e8fb5 Make some important changes to hello.txt435b61d Create hello.txt9773e52 Initial import\n```"
        ],
        "usage_examples": [
          "```bash\ngit log --oneline\n```",
          "```bash\ngit checkout a1e8fb5\n```",
          "```bash\ngit checkout main\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 999
        }
      },
      {
        "header": "Undoing a committed snapshot",
        "content": "There are technically several different strategies to 'undo' a commit. The following examples will assume we have a commit history that looks like:\n\nWe will focus on undoing the 872fa7e Try something crazy commit. Maybe things got a little too crazy.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log --oneline872fa7e Try something crazya1e8fb5 Make some important changes to hello.txt435b61d Create hello.txt9773e52 Initial import\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 250
        }
      },
      {
        "header": "How to undo a commit with git checkout",
        "content": "Using the git checkout command we can checkout the previous commit, a1e8fb5, putting the repository in a state before the crazy commit happened. Checking out a specific commit will put the repo in a \"detached HEAD\" state. This means you are no longer working on any branch. In a detached state, any new commits you make will be orphaned when you change branches back to an established branch. Orphaned commits are up for deletion by Git's garbage collector. The garbage collector runs on a configured interval and permanently destroys orphaned commits. To prevent orphaned commits from being garbage collected, we need to ensure we are on a branch.\n\nFrom the detached HEAD state, we can execute git checkout -b new_branch_without_crazy_commit. This will create a new branch named new_branch_without_crazy_commit and switch to that state. The repo is now on a new history timeline in which the 872fa7e commit no longer exists. At this point, we can continue work on this new branch in which the 872fa7e commit no longer exists and consider it 'undone'. Unfortunately, if you need the previous branch, maybe it was your main branch, this undo strategy is not appropriate. Let's look at some other 'undo' strategies. For more information and examples review our in-depth git checkout discussion.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 1292
        }
      },
      {
        "header": "How to undo a public commit with git revert",
        "content": "Let's assume we are back to our original commit history example. The history that includes the 872fa7e commit. This time let's try a revert 'undo'. If we execute git revert HEAD, Git will create a new commit with the inverse of the last commit. This adds a new commit to the current branch history and now makes it look like:\n\nAt this point, we have again technically 'undone' the 872fa7e commit. Although 872fa7e still exists in the history, the new e2f9a78 commit is an inverse of the changes in 872fa7e. Unlike our previous checkout strategy, we can continue using the same branch. This solution is a satisfactory undo. This is the ideal 'undo' method for working with public shared repositories. If you have requirements of keeping a curated and minimal Git history this strategy may not be satisfactory.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log --onelinee2f9a78 Revert \"Try something crazy\"872fa7e Try something crazya1e8fb5 Make some important changes to hello.txt435b61d Create hello.txt9773e52 Initial import\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 808
        }
      },
      {
        "header": "How to undo a commit with git reset",
        "content": "For this undo strategy we will continue with our working example. git reset is an extensive command with multiple uses and functions. If we invoke git reset --hard a1e8fb5 the commit history is reset to that specified commit. Examining the commit history with git log will now look like:\n\nThe log output shows the e2f9a78 and 872fa7e commits no longer exist in the commit history. At this point, we can continue working and creating new commits as if the 'crazy' commits never happened. This method of undoing changes has the cleanest effect on history. Doing a reset is great for local changes however it adds complications when working with a shared remote repository. If we have a shared remote repository that has the 872fa7e commit pushed to it, and we try to git push a branch where we have reset the history, Git will catch this and throw an error. Git will assume that the branch being pushed is not up to date because of it's missing commits. In these scenarios, git revert should be the preferred undo method.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log --onelinea1e8fb5 Make some important changes to hello.txt435b61d Create hello.txt9773e52 Initial import\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 1019
        }
      },
      {
        "header": "Undoing the last commit",
        "content": "In the previous section, we discussed different strategies for undoing commits. These strategies are all applicable to the most recent commit as well. In some cases though, you might not need to remove or reset the last commit. Maybe it was just made prematurely. In this case you can amend the most recent commit. Once you have made more changes in the working directory and staged them for commit by using git add, you can execute git commit --amend. This will have Git open the configured system editor and let you modify the last commit message. The new changes will be added to the amended commit.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 602
        }
      },
      {
        "header": "Undoing uncommitted changes",
        "content": "Before changes are committed to the repository history, they live in the staging index and the working directory. You may need to undo changes within these two areas. The staging index and working directory are internal Git state management mechanisms. For more detailed information on how these two mechanisms operate, visit the git reset page which explores them in depth.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 374
        }
      },
      {
        "header": "The working directory",
        "content": "The working directory is generally in sync with the local file system. To undo changes in the working directory you can edit files like you normally would using your favorite editor. Git has a couple utilities that help manage the working directory. There is the git clean command which is a convenience utility for undoing changes to the working directory. Additionally, git reset can be invoked with the --mixed or --hard options and will apply a reset to the working directory.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 480
        }
      },
      {
        "header": "The staging index",
        "content": "The git add command is used to add changes to the staging index. Git reset is primarily used to undo the staging index changes. A --mixed reset will move any pending changes from the staging index back into the working directory.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 229
        }
      },
      {
        "header": "Undoing public changes",
        "content": "When working on a team with remote repositories, extra consideration needs to be made when undoing changes. Git reset should generally be considered a 'local' undo method. A reset should be used when undoing changes to a private branch. This safely isolates the removal of commits from other branches that may be in use by other developers. Problems arise when a reset is executed on a shared branch and that branch is then pushed remotely with git push. Git will block the push in this scenario complaining that the branch being pushed is out of date from the remote branch as it is missing commits.\n\nThe preferred method of undoing shared history is git revert. A revert is safer than a reset because it will not remove any commits from a shared history. A revert will retain the commits you want to undo and create a new commit that inverts the undesired commit. This method is safer for shared remote collaboration because a remote developer can then pull the branch and receive the new revert commit which undoes the undesired commit.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 1039
        }
      },
      {
        "header": "Summary",
        "content": "We covered many high-level strategies for undoing things in Git. It's important to remember that there is more than one way to 'undo' in a Git project. Most of the discussion on this page touched on deeper topics that are more thoroughly explained on pages specific to the relevant Git commands. The most commonly used 'undo' tools are git checkout, git revert, and git reset. Some key points to remember are:\n\nIn addition to the primary undo commands, we took a look at other Git utilities: git log for finding lost commits git clean for undoing uncommitted changes git add for modifying the staging index.\n\nEach of these commands has its own in-depth documentation. To learn more about a specific command mentioned here, visit the corresponding links.\n\n• Once changes have been committed they are generally permanent\n• Use git checkout to move around and review the commit history\n• git revert is the best tool for undoing shared public changes\n• git reset is best used for undoing local private changes",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1005
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/undoing-changes",
    "doc_type": "git",
    "total_sections": 15
  },
  {
    "title": "Git clean",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "In this section, we will focus on a detailed discussion of the git clean command. Git clean is to some extent an 'undo' command. Git clean can be considered complementary to other commands like git reset and git checkout. Whereas these other commands operate on files previously added to the Git tracking index, the git clean command operates on untracked files. Untracked files are files that have been created within your repo's working directory but have not yet been added to the repository's tracking index using the git add command.\n\nTo better demonstrate the difference between tracked and untracked files consider the following command line example\n\nThe example creates a new Git repository in the git_clean_test directory. It then proceeds to create a tracked_file which is added to the Git index, additionally, an untracked_file is created, and an untracked_dir. The example then invokes git status which displays output indicating Git's internal state of tracked and untracked changes. With the repository in this state, we can execute the git clean command to demonstrate its intended purpose.\n\nAt this point, executing the default git clean command may produce a fatal error. The example above demonstrates what this may look like. By default, Git is globally configured to require that git clean be passed a \"force\" option to initiate. This is an important safety mechanism. When finally executed git clean is not undo-able. When fully executed, git clean will make a hard filesystem deletion, similar to executing the command line rm utility. Make sure you really want to delete the untracked files before you run it.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ mkdir git_clean_test$ cd git_clean_test/$ git init .Initialized empty Git repository in /Users/kev/code/git_clean_test/.git/$ echo \"tracked\" > ./tracked_file$ git add ./tracked_file$ echo \"untracked\" > ./untracked_file$ mkdir ./untracked_dir && touch ./untracked_dir/file$ git statusOn branch masterInitial commitChanges to be committed: (use \"git rm --cached <file>...\" to unstage)new file: tracked_fileUntracked files: (use \"git add <file>...\" to include in what will be committed) untracked_dir/ untracked_file\n```",
          "```bash\n$ git clean fatal: clean.requireForce defaults to true and neither -i, -n, nor -f given; refusing to clean\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1632
        }
      },
      {
        "header": "Common options and usage",
        "content": "Given the previous explanation of the default git clean behaviors and caveats, the following content demonstrates various git clean use cases and the accompanying command line options required for their operation.\n\nThe -n option will perform a “dry run” of git clean. This will show you which files are going to be removed without actually removing them. It is a best practice to always first perform a dry run of git clean. We can demonstrate this option in the demo repo we created earlier.\n\nThe output tells us that untracked_file will be removed when the git clean command is executed. Notice that the untracked_dir is not reported in the output here. By default git clean will not operate recursively on directories. This is another safety mechanism to prevent accidental permanent deletion.\n\nThe force option initiates the actual deletion of untracked files from the current directory. Force is required unless the clean.requireForce configuration option is set to false. This will not remove untracked folders or files specified by .gitignore. Let us now execute a live git clean in our example repo.\n\nThe command will output the files that are removed. You can see here that untracked_file has been removed. Executing git status at this point or doing a ls will show that untracked_file has been deleted and is nowhere to be found. By default git clean -f will operate on all the current directory untracked files. Additionally, a < path > value can be passed with the -f option that will remove a specific file.\n\nThe -d option tells git clean that you also want to remove any untracked directories, by default it will ignore directories. We can add the -d option to our previous examples:\n\nHere we have executed a 'dry run' using the -dn combination which outputs untracked_dir is up for removal. Then we execute a forced clean, and receive output that untracked_dir is removed.\n\nA common software release pattern is to have a build or distribution directory that is not committed to the repositories tracking index. The build directory will contain ephemeral build artifacts that are generated from the committed source code. This build directory is usually added to the repositories .gitignore file. It can be convenient to also clean this directory with other untracked files. The -x option tells git clean to also include any ignored files. As with previous git clean invocations, it is a best practice to execute a 'dry run' first, before the final deletion. The -x option will act on all ignored files, not just project build specific ones. This could be unintended things like ./.idea IDE configuration files.\n\nLike the -d option -x can be passed and composed with other options. This example demonstrates a combination with -f that will remove untracked files from the current directory as well as any files that Git usually ignores.",
        "code_examples": [
          "```bash\n-f or --force\n```",
          "```bash\n-x force removal of ignored files\n```"
        ],
        "usage_examples": [
          "```bash\n$ git clean -nWould remove untracked_file\n```",
          "```bash\n$ git clean -fRemoving untracked_file\n```",
          "```bash\ngit clean -f <path>-d include directories\n```",
          "```bash\n$ git clean -dnWould remove untracked_dir/$ git clean -dfRemoving untracked_dir/\n```",
          "```bash\ngit clean -xf\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 2850
        }
      },
      {
        "header": "Interactive mode or git clean interactive",
        "content": "In addition to the ad-hoc command line execution we have demonstrated so far, git clean has an \"interactive\" mode that you can initiate by passing the -i option. Let us revisit the example repo from the introduction of this document. In that initial state, we will start an interactive clean session.\n\nWe have initiated the interactive session with the -d option so it will also act upon our untracked_dir. The interactive mode will display a What now> prompt that requests a command to apply to the untracked files. The commands themselves are fairly self explanatory. We'll take a brief look at each in a random order starting with command 6: help. Selecting command 6 will further explain the other commands:\n\nIs straight forward and will exit the interactive session.\n\nWill delete the indicated items. If we were to execute 1: clean at this point untracked_dir/ untracked_file would be removed\n\nwill iterate over each untracked file and display a Y/N prompt for a deletion. It looks like the following:\n\nWill display an additional prompt that takes input used to filter the list of untracked files.\n\nHere we input the *_file wildcard pattern which then restricts the untracked file list to just untracked_dir.\n\nSimilar to command 2, command 3 works to refine the list of untracked file names. The interactive session will prompt for numbers that correspond to an untracked file name.",
        "code_examples": [
          "```bash\nWhat now> 6clean               - start cleaningfilter by pattern   - exclude items from deletionselect by numbers   - select items to be deleted by numbersask each            - confirm each deletion (like \"rm -i\")quit                - stop cleaninghelp                - this screen?                   - help for prompt selection\n```",
          "```bash\n5: quit\n```",
          "```bash\n1: clean\n```",
          "```bash\n4: ask each\n```",
          "```bash\n*** Commands ***1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit                 6: helpWhat now> 4Remove untracked_dir/ [y/N]? NRemove untracked_file [y/N]? N\n```",
          "```bash\n2: filter by pattern\n```",
          "```bash\nWould remove the following items:untracked_dir/  untracked_file*** Commands ***1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit                 6: helpWhat now> 2untracked_dir/  untracked_fileInput ignore patterns>> *_fileuntracked_dir/\n```",
          "```bash\n3: select by numbers\n```",
          "```bash\nWould remove the following items:untracked_dir/  untracked_file*** Commands ***1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit                 6: helpWhat now> 31: untracked_dir/    2: untracked_fileSelect items to delete>> 21: untracked_dir/  * 2: untracked_fileSelect items to delete>>Would remove the following item:untracked_file*** Commands ***1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit                 6: help\n```"
        ],
        "usage_examples": [
          "```bash\n$ git clean -diWould remove the following items:untracked_dir/  untracked_file*** Commands ***1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit                 6: helpWhat now>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1387
        }
      },
      {
        "header": "Summary",
        "content": "To recap, git clean is a convenience method for deleting untracked files in a repo's working directory. Untracked files are those that are in the repo's directory but have not yet been added to the repo's index with git add. Overall the effect of git clean can be accomplished using git status and the operating systems native deletion tools. Git clean can be used alongside git reset to fully undo any additions and commits in a repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 441
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/undoing-changes/git-clean",
    "doc_type": "git",
    "total_sections": 6
  },
  {
    "title": "Git revert",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "The git revert command can be considered an 'undo' type command, however, it is not a traditional undo operation. Instead of removing the commit from the project history, it figures out how to invert the changes introduced by the commit and appends a new commit with the resulting inverse content. This prevents Git from losing history, which is important for the integrity of your revision history and for reliable collaboration.\n\nReverting should be used when you want to apply the inverse of a commit from your project history. This can be useful, for example, if you’re tracking down a bug and find that it was introduced by a single commit. Instead of manually going in, fixing it, and committing a new snapshot, you can use git revert to automatically do all of this for you.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 781
        }
      },
      {
        "header": "How it works",
        "content": "The git revert command is used for undoing changes to a repository's commit history. Other 'undo' commands like, git checkout and git reset, move the HEAD and branch ref pointers to a specified commit. Git revert also takes a specified commit, however, git revert does not move ref pointers to this commit. A revert operation will take the specified commit, inverse the changes from that commit, and create a new \"revert commit\". The ref pointers are then updated to point at the new revert commit making it the tip of the branch.\n\nTo demonstrate let’s create an example repo using the command line examples below:\n\nHere we have initialized a repo in a newly created directory named git_revert_test. We have made 3 commits to the repo in which we have added a file demo_file and modified its content twice. At the end of the repo setup procedure, we invoke git log to display the commit history, showing a total of 3 commits. With the repo in this state, we are ready to initiate a git revert.\n\nGit revert expects a commit ref was passed in and will not execute without one. Here we have passed in the HEAD ref. This will revert the latest commit. This is the same behavior as if we reverted to commit 3602d8815dbfa78cd37cd4d189552764b5e96c58. Similar to a merge, a revert will create a new commit which will open up the configured system editor prompting for a new commit message. Once a commit message has been entered and saved Git will resume operation. We can now examine the state of the repo using git log and see that there is a new commit added to the previous log:\n\nNote that the 3rd commit is still in the project history after the revert. Instead of deleting it, git revert added a new commit to undo its changes. As a result, the 2nd and 4th commits represent the exact same code base and the 3rd commit is still in our history just in case we want to go back to it down the road.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ mkdir git_revert_test$ cd git_revert_test/$ git init .Initialized empty Git repository in /git_revert_test/.git/$ touch demo_file$ git add demo_file$ git commit -am\"initial commit\"[main (root-commit) 299b15f] initial commit1 file changed, 0 insertions(+), 0 deletions(-)create mode 100644 demo_file$ echo \"initial content\" >> demo_file$ git commit -am\"add new content to demo file\"[main 3602d88] add new content to demo filen 1 file changed, 1 insertion(+)$ echo \"prepended line content\" >> demo_file$ git commit -am\"prepend content to demo file\"[main 86bb32e] prepend content to demo file1 file changed, 1 insertion(+)$ git log --oneline86bb32e prepend content to demo file3602d88 add new content to demo file299b15f initial commit\n```",
          "```bash\n$ git revert HEAD[main b9cd081] Revert \"prepend content to demo file\" 1 file changed, 1 deletion(-)\n```",
          "```bash\n$ git log --oneline 1061e79 Revert \"prepend content to demo file\" 86bb32e prepend content to demo file 3602d88 add new content to demo file 299b15f initial commit\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1893
        }
      },
      {
        "header": "Common options",
        "content": "This is a default option and doesn't need to be specified. This option will open the configured system editor and prompts you to edit the commit message prior to committing the revert\n\nThis is the inverse of the -e option. The revert will not open the editor.\n\nPassing this option will prevent git revert from creating a new commit that inverses the target commit. Instead of creating the new commit this option will add the inverse changes to the Staging Index and Working Directory. These are the other trees Git uses to manage the state of the repository. For more info visit the git reset page.",
        "code_examples": [
          "```bash\n-e--edit\n```",
          "```bash\n--no-edit\n```",
          "```bash\n-n--no-commit\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 598
        }
      },
      {
        "header": "Resetting vs. reverting",
        "content": "It's important to understand that git revert undoes a single commit—it does not \"revert\" back to the previous state of a project by removing all subsequent commits. In Git, this is actually called a reset, not a revert.\n\nReverting has two important advantages over resetting. First, it doesn’t change the project history, which makes it a “safe” operation for commits that have already been published to a shared repository. For details about why altering shared history is dangerous, please see the git reset page.\n\nSecond, git revert is able to target an individual commit at an arbitrary point in the history, whereas git reset can only work backward from the current commit. For example, if you wanted to undo an old commit with git reset, you would have to remove all of the commits that occurred after the target commit, remove it, then re-commit all of the subsequent commits. Needless to say, this is not an elegant undo solution. For a more detailed discussion on the differences between git revert and other 'undo' commands see Resetting, Checking Out and Reverting.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1076
        }
      },
      {
        "header": "Summary",
        "content": "The git revert command is a forward-moving undo operation that offers a safe method of undoing changes. Instead of deleting or orphaning commits in the commit history, a revert will create a new commit that inverses the changes specified. Git revert is a safer alternative to git reset in regards to losing work. To demonstrate the effects of git revert we leveraged other commands that have more in-depth documentation on their individual pages: git log, git commit, and git reset.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 482
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/undoing-changes/git-revert",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "Git reset",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "The git reset command is a complex and versatile tool for undoing changes. It has three primary forms of invocation. These forms correspond to command line arguments --soft, --mixed, --hard. The three arguments each correspond to Git's three internal state management mechanism's, The Commit Tree (HEAD), The Staging Index, and The Working Directory.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 350
        }
      },
      {
        "header": "Git reset & three trees of git",
        "content": "To properly understand git reset usage, we must first understand Git's internal state management systems. Sometimes these mechanisms are called Git's \"three trees\". Trees may be a misnomer, as they are not strictly traditional tree data-structures. They are, however, node and pointer-based data structures that Git uses to track a timeline of edits. The best way to demonstrate these mechanisms is to create a changeset in a repository and follow it through the three trees.\n\nTo get started we will create a new repository with the commands below:\n\nThe above example code creates a new git repository with a single empty file, reset_lifecycle_file. At this point, the example repository has a single commit (d386d86) from adding reset_lifecycle_file.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ mkdir git_reset_test$ cd git_reset_test/$ git init .Initialized empty Git repository in /git_reset_test/.git/$ touch reset_lifecycle_file$ git add reset_lifecycle_file$ git commit -m\"initial commit\"[main (root-commit) d386d86] initial commit1 file changed, 0 insertions(+), 0 deletions(-)create mode 100644 reset_lifecycle_file\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 751
        }
      },
      {
        "header": "The working directory",
        "content": "The first tree we will examine is \"The Working Directory\". This tree is in sync with the local filesystem and is representative of the immediate changes made to content in files and directories.\n\nIn our demo repository, we modify and add some content to the reset_lifecycle_file. Invoking git status shows that Git is aware of the changes to the file. These changes are currently a part of the first tree, \"The Working Directory\". Git status can be used to show changes to the Working Directory. They will be displayed in the red with a 'modified' prefix.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ echo 'hello git reset' > reset_lifecycle_file$ git statusOn branch mainChanges not staged for commit:(use \"git add ...\" to update what will be committed)(use \"git checkout -- ...\" to discard changes in working directory)modified: reset_lifecycle_file\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 555
        }
      },
      {
        "header": "Staging index",
        "content": "Next up is the 'Staging Index' tree. This tree is tracking Working Directory changes, that have been promoted with git add, to be stored in the next commit. This tree is a complex internal caching mechanism. Git generally tries to hide the implementation details of the Staging Index from the user.\n\nTo accurately view the state of the Staging Index we must utilize a lesser known Git command git ls-files. The git ls-files command is essentially a debug utility for inspecting the state of the Staging Index tree.\n\nHere we have executed git ls-files with the -s or --stage option. Without the -s option the git ls-files output is simply a list of file names and paths that are currently part of the index. The -s option displays additional metadata for the files in the Staging Index. This metadata is the staged contents' mode bits, object name, and stage number. Here we are interested in the object name, the second value (d7d77c1b04b5edd5acfc85de0b592449e5303770). This is a standard Git object SHA-1 hash. It is a hash of the content of the files. The Commit History stores its own object SHA's for identifying pointers to commits and refs and the Staging Index has its own object SHA's for tracking versions of files in the index.\n\nNext, we will promote the modified reset_lifecycle_file into the Staging Index.\n\nHere we have invoked git add reset_lifecycle_file which adds the file to the Staging Index. Invoking git status now shows reset_lifecycle_file in green under \"Changes to be committed\". It is important to note that git status is not a true representation of the Staging Index. The git status command output displays changes between the Commit History and the Staging Index. Let us examine the Staging Index content at this point.\n\nWe can see that the object SHA for reset_lifecycle_file has been updated from e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 to d7d77c1b04b5edd5acfc85de0b592449e5303770.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit ls-files -s100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0   reset_lifecycle_file\n```",
          "```bash\n$ git add reset_lifecycle_file$ git statusOn branch main Changes to be committed:(use \"git reset HEAD ...\" to unstage)modified: reset_lifecycle_file\n```",
          "```bash\n$ git ls-files -s 100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1913
        }
      },
      {
        "header": "Commit history",
        "content": "The final tree is the Commit History. The git commit command adds changes to a permanent snapshot that lives in the Commit History. This snapshot also includes the state of the Staging Index at the time of commit.\n\nHere we have created a new commit with a message of \"update content of resetlifecyclefile\". The changeset has been added to the Commit History. Invoking git status at this point shows that there are no pending changes to any of the trees. Executing git log will display the Commit History. Now that we have followed this changeset through the three trees we can begin to utilize git reset.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git commit -am\"update content of reset_lifecycle_file\"[main dc67808] update content of reset_lifecycle_file1 file changed, 1 insertion(+)$ git statusOn branch mainnothing to commit, working tree clean\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 604
        }
      },
      {
        "header": "How it works",
        "content": "At a surface level, git reset is similar in behavior to git checkout. Where git checkout solely operates on the HEAD ref pointer, git reset will move the HEAD ref pointer and the current branch ref pointer. To better demonstrate this behavior consider the following example:\n\nThis example demonstrates a sequence of commits on the main branch. The HEAD ref and main branch ref currently point to commit d. Now let us execute and compare, both git checkout b and git reset b.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 474
        }
      },
      {
        "header": "git checkout b",
        "content": "With git checkout, the main ref is still pointing to d. The HEAD ref has been moved, and now points at commit b. The repo is now in a 'detached HEAD' state.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 156
        }
      },
      {
        "header": "git reset b",
        "content": "Comparatively, git reset, moves both the HEAD and branch refs to the specified commit.\n\nIn addition to updating the commit ref pointers, git reset will modify the state of the three trees. The ref pointer modification always happens and is an update to the third tree, the Commit tree. The command line arguments --soft, --mixed, and --hard direct how to modify the Staging Index, and Working Directory trees.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 409
        }
      },
      {
        "header": "Main options",
        "content": "The default invocation of git reset has implicit arguments of --mixed and HEAD. This means executing git reset is equivalent to executing git reset --mixed HEAD. In this form HEAD is the specified commit. Instead of HEAD any Git SHA-1 commit hash can be used.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 259
        }
      },
      {
        "header": "'--hard",
        "content": "This is the most direct, DANGEROUS, and frequently used option. When passed --hard The Commit History ref pointers are updated to the specified commit. Then, the Staging Index and Working Directory are reset to match that of the specified commit. Any previously pending changes to the Staging Index and the Working Directory gets reset to match the state of the Commit Tree. This means any pending work that was hanging out in the Staging Index and Working Directory will be lost.\n\nTo demonstrate this, let's continue with the three tree example repo we established earlier. First let's make some modifications to the repo. Execute the following commands in the example repo:\n\nThese commands have created a new file named new_file and added it to the repo. Additionally, the content of reset_lifecycle_file will be modified. With these changes in place let us now examine the state of the repo using git status.\n\nHere we have invoked git add reset_lifecycle_file which adds the file to the Staging Index. Invoking git status now shows reset_lifecycle_file in green under \"Changes to be committed\". It is important to note that git status is not a true representation of the Staging Index. The git status command output displays changes between the Commit History and the Staging Index. Let us examine the Staging Index content at this point.\n\nWe can see that new_file has been added to the index. We have made updates to reset_lifecycle_file but the Staging Index SHA (d7d77c1b04b5edd5acfc85de0b592449e5303770) remains the same. This is expected behavior because have not used git add to promote these changes to the Staging Index. These changes exist in the Working Directory.\n\nLet us now execute a git reset --hard and examine the new state of the repository.\n\nHere we have executed a \"hard reset\" using the --hard option. Git displays output indicating that HEAD is pointing to the latest commit dc67808. Next, we check the state of the repo with git status. Git indicates there are no pending changes. We also examine the state of the Staging Index and see that it has been reset to a point before new_file was added. Our modifications to reset_lifecycle_file and the addition of new_file have been destroyed. This data loss cannot be undone, this is critical to take note of.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ echo 'new file content' > new_file$ git add new_file$ echo 'changed content' >> reset_lifecycle_file\n```",
          "```bash\n$ git statusOn branch mainChanges to be committed:(use \"git reset HEAD ...\" to unstage)new file: new_fileChanges not staged for commit:(use \"git add ...\" to update what will be committed)(use \"git checkout -- ...\" to discard changes in working directory)modified: reset_lifecycle_file\n```",
          "```bash\n$ git ls-files -s100644 8e66654a5477b1bf4765946147c49509a431f963 0 new_file100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file\n```",
          "```bash\n$ git reset --hardHEAD is now at dc67808 update content of reset_lifecycle_file$ git statusOn branch mainnothing to commit, working tree clean$ git ls-files -s100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 2280
        }
      },
      {
        "header": "'--mixed",
        "content": "This is the default operating mode. The ref pointers are updated. The Staging Index is reset to the state of the specified commit. Any changes that have been undone from the Staging Index are moved to the Working Directory. Let us continue.\n\nIn the example above we have made some modifications to the repository. Again, we have added a new_file and modified the contents of reset_lifecycle_file. These changes are then applied to the Staging Index with git add. With the repo in this state, we will now execute the reset.\n\nHere we have executed a \"mixed reset\". To reiterate, --mixed is the default mode and the same effect as executing git reset. Examining the output from git status and git ls-files, shows that the Staging Index has been reset to a state where reset_lifecycle_file is the only file in the index. The object SHA for reset_lifecycle_file has been reset to the previous version.\n\nThe important things to take note of here is that git status shows us that there are modifications to reset_lifecycle_file and there is an untracked file: new_file. This is the explicit --mixed behavior. The Staging Index has been reset and the pending changes have been moved into the Working Directory. Compare this to the --hard reset case where the Staging Index was reset and the Working Directory was reset as well, losing these updates.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ echo 'new file content' > new_file$ git add new_file$ echo 'append content' >> reset_lifecycle_file$ git add reset_lifecycle_file$ git statusOn branch mainChanges to be committed:(use \"git reset HEAD ...\" to unstage)new file: new_filemodified: reset_lifecycle_file$ git ls-files -s100644 8e66654a5477b1bf4765946147c49509a431f963 0 new_file100644 7ab362db063f9e9426901092c00a3394b4bec53d 0 reset_lifecycle_file\n```",
          "```bash\n$ git reset --mixed$ git statusOn branch mainChanges not staged for commit:(use \"git add ...\" to update what will be committed)(use \"git checkout -- ...\" to discard changes in working directory)modified: reset_lifecycle_fileUntracked files:(use \"git add ...\" to include in what will be committed)new_fileno changes added to commit (use \"git add\" and/or \"git commit -a\")$ git ls-files -s100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1341
        }
      },
      {
        "header": "'--soft",
        "content": "When the --soft argument is passed, the ref pointers are updated and the reset stops there. The Staging Index and the Working Directory are left untouched. This behavior can be hard to clearly demonstrate. Let's continue with our demo repo and prepare it for a soft reset.\n\nHere we have again used git add to promote the modified reset_lifecycle_file into the Staging Index. We confirm that the index has been updated with the git ls-files output. The output from git status now displays the \"Changes to be committed\" in green. The new_file from our previous examples is floating around in the Working Directory as an untracked file. Lets quickly execute rm new_file to delete the file as we will not need it for the upcoming examples.\n\nWith the repository in this state we now execute a soft reset.\n\nWe have executed a 'soft reset'. Examining the repo state with git status and git ls-files shows that nothing has changed. This is expected behavior. A soft reset will only reset the Commit History. By default, git reset is invoked with HEAD as the target commit. Since our Commit History was already sitting on HEAD and we implicitly reset to HEAD nothing really happened.\n\nTo better understand and utilize --soft we need a target commit that is not HEAD. We have reset_lifecycle_file waiting in the Staging Index. Let's create a new commit.\n\nAt this point, our repo should have three commits. We will be going back in time to the first commit. To do this we will need the first commit's ID. This can be found by viewing output from git log.\n\nKeep in mind that Commit History ID's will be unique to each system. This means the commit ID's in this example will be different from what you see on your personal machine. The commit ID we are interested in for this example is 780411da3b47117270c0e3a8d5dcfd11d28d04a4. This is the ID that corresponds to the \"initial commit\". Once we have located this ID we will use it as the target for our soft reset.\n\nBefore we travel back in time lets first check the current state of the repo.\n\nHere we execute a combo command of git status and git ls-files -s this shows us there are pending changes to the repo and reset_lifecycle_file in the Staging Index is at a version of 67cc52710639e5da6b515416fd779d0741e3762e. With this in mind lets execute a soft reset back to our first commit.\n\nThe code above executes a \"soft reset\" and also invokes the git status and git ls-files combo command, which outputs the state of the repository. We can examine the repo state output and note some interesting observations. First, git status indicates there are modifications to reset_lifecycle_file and highlights them indicating they are changes staged for the next commit. Second, the git ls-files output indicates that the Staging Index has not changed and retains the SHA 67cc52710639e5da6b515416fd779d0741e3762e we had earlier.\n\nTo further clarify what has happened in this reset let us examine the git log:\n\nThe log output now shows that there is a single commit in the Commit History. This helps to clearly illustrate what --soft has done. As with all git reset invocations, the first action reset takes is to reset the commit tree. Our previous examples with --hard and --mixed have both been against the HEAD and have not moved the Commit Tree back in time. During a soft reset, this is all that happens.\n\nThis may then be confusing as to why git status indicates there are modified files. --soft does not touch the Staging Index, so the updates to our Staging Index followed us back in time through the commit history. This can be confirmed by the output of git ls-files -s showing that the SHA for reset_lifecycle_file is unchanged. As a reminder, git status does not show the state of 'the three trees', it essentially shows a diff between them. In this case, it is displaying that the Staging Index is ahead of the changes in the Commit History as if we have already staged them.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git add reset_lifecycle_file$ git ls-files -s100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file$ git statusOn branch mainChanges to be committed:(use \"git reset HEAD ...\" to unstage)modified: reset_lifecycle_fileUntracked files:(use \"git add ...\" to include in what will be committed)new_file\n```",
          "```bash\n$ git reset --soft$ git statusOn branch mainChanges to be committed:(use \"git reset HEAD ...\" to unstage)modified: reset_lifecycle_file$ git ls-files -s100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file\n```",
          "```bash\n$ git commit -m\"prepend content to reset_lifecycle_file\"\n```",
          "```bash\n$ git logcommit 62e793f6941c7e0d4ad9a1345a175fe8f45cb9dfAuthor: bitbucketDate: Fri Dec 1 15:03:07 2017 -0800prepend content to reset_lifecycle_filecommit dc67808a6da9f0dec51ed16d3d8823f28e1a72aAuthor: bitbucketDate: Fri Dec 1 10:21:57 2017 -0800update content of reset_lifecycle_filecommit 780411da3b47117270c0e3a8d5dcfd11d28d04a4Author: bitbucketDate: Thu Nov 30 16:50:39 2017 -0800initial commit\n```",
          "```bash\n$ git status && git ls-files -sOn branch mainnothing to commit, working tree clean100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file\n```",
          "```bash\n$git reset --soft 780411da3b47117270c0e3a8d5dcfd11d28d04a4$ git status && git ls-files -sOn branch mainChanges to be committed:(use \"git reset HEAD ...\" to unstage)modified: reset_lifecycle_file100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file\n```",
          "```bash\n$ git log commit 780411da3b47117270c0e3a8d5dcfd11d28d04a4 Author: bitbucket  Date: Thu Nov 30 16:50:39 2017 -0800 initial commit\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 13,
          "content_length": 3919
        }
      },
      {
        "header": "Resetting vs reverting",
        "content": "If git revert is a “safe” way to undo changes, you can think of git reset as the dangerous method. There is a real risk of losing work with git reset. Git reset will never delete a commit, however, commits can become 'orphaned' which means there is no direct path from a ref to access them. These orphaned commits can usually be found and restored using git reflog. Git will permanently delete any orphaned commits after it runs the internal garbage collector. By default, Git is configured to run the garbage collector every 30 days. Commit History is one of the 'three git trees' the other two, Staging Index and Working Directory are not as permanent as Commits. Care must be taken when using this tool, as it’s one of the only Git commands that have the potential to lose your work.\n\nWhereas reverting is designed to safely undo a public commit, git reset is designed to undo local changes to the Staging Index and Working Directory. Because of their distinct goals, the two commands are implemented differently: resetting completely removes a changeset, whereas reverting maintains the original changeset and uses a new commit to apply the undo.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 1150
        }
      },
      {
        "header": "Don't reset public history",
        "content": "You should never use git reset when any snapshots after have been pushed to a public repository. After publishing a commit, you have to assume that other developers are reliant upon it.\n\nRemoving a commit that other team members have continued developing poses serious problems for collaboration. When they try to sync up with your repository, it will look like a chunk of the project history abruptly disappeared. The sequence below demonstrates what happens when you try to reset a public commit. The origin/main branch is the central repository’s version of your local main branch.\n\nAs soon as you add new commits after the reset, Git will think that your local history has diverged from origin/main, and the merge commit required to synchronize your repositories is likely to confuse and frustrate your team.\n\nThe point is, make sure that you’re using git reset ＜commit＞ on a local experiment that went wrong—not on published changes. If you need to fix a public commit, the git revert command was designed specifically for this purpose.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1041
        }
      },
      {
        "header": "Examples",
        "content": "Remove the specified file from the staging area, but leave the working directory unchanged. This unstages a file without overwriting any changes.\n\nReset the staging area to match the most recent commit, but leave the working directory unchanged. This unstages all files without overwriting any changes, giving you the opportunity to re-build the staged snapshot from scratch.\n\nReset the staging area and the working directory to match the most recent commit. In addition to unstaging changes, the --hard flag tells Git to overwrite all changes in the working directory, too. Put another way: this obliterates all uncommitted changes, so make sure you really want to throw away your local developments before using it.\n\nMove the current branch tip backward to commit, reset the staging area to match, but leave the working directory alone. All changes made since ＜commit＞ will reside in the working directory, which lets you re-commit the project history using cleaner, more atomic snapshots.\n\nMove the current branch tip backward to ＜commit＞ and reset both the staging area and the working directory to match. This obliterates not only the uncommitted changes, but all commits after, as well.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit reset ＜file＞\n```",
          "```bash\ngit reset\n```",
          "```bash\ngit reset --hard\n```",
          "```bash\ngit reset\n```",
          "```bash\ngit reset --hard\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1192
        }
      },
      {
        "header": "Unstaging a file",
        "content": "The git reset command is frequently encountered while preparing the staged snapshot. The next example assumes you have two files called hello.py and main.py that you’ve already added to the repository.\n\nAs you can see, git reset helps you keep your commits highly-focused by letting you unstage changes that aren’t related to the next commit.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# Edit both hello.py and main.py# Stage everything in the current directorygit add .# Realize that the changes in hello.py and main.py# should be committed in different snapshots# Unstage main.pygit reset main.py# Commit only hello.pygit commit -m \"Make some changes to hello.py\"# Commit main.py in a separate snapshotgit add main.pygit commit -m \"Edit main.py\"\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 342
        }
      },
      {
        "header": "Removing local commits",
        "content": "The next example shows a more advanced use case. It demonstrates what happens when you’ve been working on a new experiment for a while, but decide to completely throw it away after committing a few snapshots.\n\nThe git reset HEAD~2 command moves the current branch backward by two commits, effectively removing the two snapshots we just created from the project history. Remember that this kind of reset should only be used on unpublished commits. Never perform the above operation if you’ve already pushed your commits to a shared repository.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# Create a new file called `foo.py` and add some code to it# Commit it to the project historygit add foo.pygit commit -m \"Start developing a crazy feature\"# Edit `foo.py` again and change some other tracked files, too# Commit another snapshotgit commit -a -m \"Continue my crazy feature\"# Decide to scrap the feature and remove the associated commitsgit reset --hard HEAD~2\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 542
        }
      },
      {
        "header": "Summary",
        "content": "To review, git reset is a powerful command that is used to undo local changes to the state of a Git repo. Git reset operates on \"The Three Trees of Git\". These trees are the Commit History (HEAD), the Staging Index, and the Working Directory. There are three command line options that correspond to the three trees. The options --soft, --mixed, and --hard can be passed to git reset.\\\n\nIn this article we leveraged several other Git commands to help demonstrate the reset processes. Learn more about those commands on their individual pages at: git status, git log, git add, git checkout, git reflog, and git revert.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 616
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/undoing-changes/git-reset",
    "doc_type": "git",
    "total_sections": 20
  },
  {
    "title": "Git RM",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "A common question when getting started with Git is \"How do I tell Git not to track a file (or files) any more?\" The git rm command is used to remove files from a Git repository. It can be thought of as the inverse of the git add command.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 237
        }
      },
      {
        "header": "Git rm overview",
        "content": "The git rm command can be used to remove individual files or a collection of files. The primary function of git rm is to remove tracked files from the Git index. Additionally, git rm can be used to remove files from both the staging index and the working directory. There is no option to remove a file from only the working directory. The files being operated on must be identical to the files in the current HEAD. If there is a discrepancy between the HEAD version of a file and the staging index or working tree version, Git will block the removal. This block is a safety mechanism to prevent removal of in-progress changes.\n\nNote that git rm does not remove branches. Learn more about using git branches",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 706
        }
      },
      {
        "header": "Usage",
        "content": "Specifies the target files to remove. The option value can be an individual file, a space delimited list of files file1 file2 file3, or a wildcard file glob (~./directory/*).\n\nThe -f option is used to override the safety check that Git makes to ensure that the files in HEAD match the current content in the staging index and working directory.\n\nThe \"dry run\" option is a safeguard that will execute the git rm command but not actually delete the files. Instead it will output which files it would have removed.\n\nThe -r option is shorthand for 'recursive'. When operating in recursive mode git rm will remove a target directory and all the contents of that directory.\n\nThe separator option is used to explicitly distinguish between a list of file names and the arguments being passed to git rm. This is useful if some of the file names have syntax that might be mistaken for other options.\n\nThe cached option specifies that the removal should happen only on the staging index. Working directory files will be left alone.\n\nThis causes the command to exit with a 0 sigterm status even if no files matched. This is a Unix level status code. The code 0 indicates a successful invocation of the command. The --ignore-unmatch option can be helpful when using git rm as part of a greater shell script that needs to fail gracefully.\n\nThe quiet option hides the output of the git rm command. The command normally outputs one line for each file removed.",
        "code_examples": [
          "```bash\n<file>…​\n```",
          "```bash\n-f--force\n```",
          "```bash\n-n--dry-run\n```",
          "```bash\n--cached\n```",
          "```bash\n--ignore-unmatch\n```",
          "```bash\n-q--quiet\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1443
        }
      },
      {
        "header": "How to undo git rm",
        "content": "Executing git rm is not a permanent update. The command will update the staging index and the working directory. These changes will not be persisted until a new commit is created and the changes are added to the commit history. This means that the changes here can be \"undone\" using common Git commands.\n\nA reset will revert the current staging index and working directory back to the HEAD commit. This will undo a git rm.\n\nA checkout will have the same effect and restore the latest version of a file from HEAD.\n\nIn the event that git rm was executed and a new commit was created which persist the removal, git reflog can be used to find a ref that is before the git rm execution. Learn more about using git reflog.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit reset HEAD\n```",
          "```bash\ngit checkout .\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 716
        }
      },
      {
        "header": "Discussion",
        "content": "The <file> argument given to the command can be exact paths, wildcard file glob patterns, or exact directory names. The command removes only paths currently commited to the Git repository.\n\nWildcard file globbing matches across directories. It is important to be cautious when using wildcard globs. Consider the examples: directory/* and directory*. The first example will remove all sub files of directory/ whereas the second example will remove all sibling directories like directory1 directory2 directory_whatever which may be an unexpected result.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 551
        }
      },
      {
        "header": "The scope of git rm",
        "content": "The git rm command operates on the current branch only. The removal event is only applied to the working directory and staging index trees. The file removal is not persisted to the repository history until a new commit is created.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 230
        }
      },
      {
        "header": "Why use git rm instead of rm",
        "content": "A Git repository will recognize when a regular shell rm command has been executed on a file it is tracking. It will update the working directory to reflect the removal. It will not update the staging index with the removal. An additional git add command will have to be executed on the removed file paths to add the changes to the staging index. The git rm command acts a shortcut in that it will update the working directory and the staging index with the removal.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 465
        }
      },
      {
        "header": "Examples",
        "content": "This example uses a wildcard file glob to remove all *.txt files that are children of the Documentation directory and any of its subdirectories.\n\nNote that the asterisk * is escaped with slashes in this example; this is a guard that prevents the shell from expanding the wildcard. The wildcard then expands the pathnames of files and subdirectories under the Documentation/ directory.\n\nThis example uses the force option and targets all wildcard git-*.sh files. The force option explicitly removes the target files from both the working directory and staging index.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit rm Documentation/\\*.txt\n```",
          "```bash\ngit rm -f git-*.sh\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 565
        }
      },
      {
        "header": "How to remove files no longer in the filesystem",
        "content": "As stated above in \"Why use git rm instead of rm\" , git rm is actually a convenience command that combines the standard shell rm and git add to remove a file from the working directory and promote that removal to the staging index. A repository can get into a cumbersome state in the event that several files have been removed using only the standard shell rm command.\n\nIf intentions are to record all the explicitly removed files as part of the next commit, git commit -a will add all the removal events to the staging index in preparation of the next commit.\n\nIf however, intentions are to persistently remove the files that were removed with the shell rm, use the following command:\n\nThis command will generate a list of the removed files from the working directory and pipe that list to git rm --cached which will update the staging index.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit diff --name-only --diff-filter=D -z | xargs -0 git rm --cached\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 843
        }
      },
      {
        "header": "Git rm summary",
        "content": "git rm is a command that operates on two of the primary Git internal state management trees: the working directory, and staging index. git rm is used to remove a file from a Git repository. It is a convenience method that combines the effect of the default shell rm command with git add. This means that it will first remove a target from the filesystem and then add that removal event to the staging index. The command is one of many that can be used for undoing changes in Git.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 479
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/undoing-changes/git-rm",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Rewriting history",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "Git commit --amend and other methods of rewriting history",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 57
        }
      },
      {
        "header": "Intro",
        "content": "This tutorial will cover various methods of rewriting and altering Git history. Git uses a few different methods to record changes. We will discuss the strengths and weaknesses of the different methods and give examples of how to work with them. This tutorial discusses some of the most common reasons for overwriting committed snapshots and shows you how to avoid the pitfalls of doing so.\n\nGit's main job is to make sure you never lose a committed change. But it's also designed to give you total control over your development workflow. This includes letting you define exactly what your project history looks like; however, it also creates the potential of losing commits. Git provides its history-rewriting commands under the disclaimer that using them may result in lost content.\n\nGit has several mechanisms for storing history and saving changes. These mechanisms include: Commit --amend, git rebase and git reflog. These options give you powerful work flow customization options. By the end of this tutorial, you'll be familiar with commands that will let you restructure your Git commits, and be able to avoid pitfalls that are commonly encountered when rewriting history.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1180
        }
      },
      {
        "header": "Changing the Last Commit: git commit --amend",
        "content": "The git commit --amend command is a convenient way to modify the most recent commit. It lets you combine staged changes with the previous commit instead of creating an entirely new commit. It can also be used to simply edit the previous commit message without changing its snapshot. But, amending does not just alter the most recent commit, it replaces it entirely, meaning the amended commit will be a new entity with its own ref. To Git, it will look like a brand new commit, which is visualized with an asterisk (*) in the diagram below. There are a few common scenarios for using git commit --amend. We'll cover usage examples in the following sections.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 657
        }
      },
      {
        "header": "Change most recent Git commit message",
        "content": "Let's say you just committed and you made a mistake in your commit log message. Running this command when there is nothing staged lets you edit the previous commit’s message without altering its snapshot.\n\nPremature commits happen all the time in the course of your everyday development. It’s easy to forget to stage a file or to format your commit message the wrong way. The --amend flag is a convenient way to fix these minor mistakes.\n\nAdding the -m option allows you to pass in a new message from the command line without being prompted to open an editor.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit commit --amend\n```",
          "```bash\ngit commit --amend -m \"an updated commit message\"\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 559
        }
      },
      {
        "header": "Changing committed files",
        "content": "The following example demonstrates a common scenario in Git-based development. Let's say we've edited a few files that we would like to commit in a single snapshot, but then we forget to add one of the files the first time around. Fixing the error is simply a matter of staging the other file and committing with the --amend flag:\n\nThe --no-edit flag will allow you to make the amendment to your commit without changing its commit message. The resulting commit will replace the incomplete one, and it will look like we committed the changes to hello.py and main.py in a single snapshot.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# Edit hello.py and main.pygit add hello.pygit commit# Realize you forgot to add the changes from main.pygit add main.pygit commit --amend --no-edit\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 586
        }
      },
      {
        "header": "Don’t amend public commits",
        "content": "Amended commits are actually entirely new commits and the previous commit will no longer be on your current branch. This has the same consequences as resetting a public snapshot. Avoid amending a commit that other developers have based their work on. This is a confusing situation for developers to be in and it’s complicated to recover from.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 342
        }
      },
      {
        "header": "Recap",
        "content": "To review, git commit --amend lets you take the most recent commit and add new staged changes to it. You can add or remove changes from the Git staging area to apply with a --amend commit. If there are no changes staged, a --amend will still prompt you to modify the last commit message log. Be cautious when using --amend on commits shared with other team members. Amending a commit that is shared with another user will potentially require confusing and lengthy merge conflict resolutions.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 491
        }
      },
      {
        "header": "Changing older or multiple commits",
        "content": "To modify older or multiple commits, you can use git rebase to combine a sequence of commits into a new base commit. In standard mode, git rebase allows you to literally rewrite history — automatically applying commits in your current working branch to the passed branch head. Since your new commits will be replacing the old, it's important to not use git rebase on commits that have been pushed public, or it will appear that your project history disappeared.\n\nIn these or similar instances where it's important to preserve a clean project history, adding the -i option to git rebase allows you to run rebase interactive. This gives you the opportunity to alter individual commits in the process, rather than moving all commits. You can learn more about interactive rebasing and additional rebase commands on the git rebase page.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 831
        }
      },
      {
        "header": "Changing committed files",
        "content": "During a rebase, the edit or e command will pause the rebase playback on that commit and allow you to make additional changes with git commit --amend Git will interrupt the playback and present a message:",
        "code_examples": [],
        "usage_examples": [
          "```bash\nStopped at 5d025d1... formattingYou can amend the commit now, withgit commit --amendOnce you are satisfied with your changes, rungit rebase --continue\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 204
        }
      },
      {
        "header": "Multiple messages",
        "content": "Each regular Git commit will have a log message explaining what happened in the commit. These messages provide valuable insight into the project history. During a rebase, you can run a few commands on commits to modify commit messages.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 235
        }
      },
      {
        "header": "Squash commits for a clean history",
        "content": "The s \"squash\" command is where we see the true utility of rebase. Squash allows you to specify which commits you want to merge into the previous commits. This is what enables a \"clean history.\" During rebase playback, Git will execute the specified rebase command for each commit. In the case of squash commits, Git will open your configured text editor and prompt to combine the specified commit messages. This entire process can be visualized as follows:\n\nNote that the commits modified with a rebase command have a different ID than either of the original commits. Commits marked with pick will have a new ID if the previous commits have been rewritten.\n\nModern Git hosting solutions like Bitbucket now offer \"auto squashing\" features upon merge. These features will automatically rebase and squash a branch's commits for you when utilizing the hosted solutions UI. For more info see \"Squash commits when merging a Git branch with Bitbucket.\"",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 946
        }
      },
      {
        "header": "Recap",
        "content": "Git rebase gives you the power to modify your history, and interactive rebasing allows you to do so without leaving a “messy” trail. This creates the freedom to make and correct errors and refine your work, while still maintaining a clean, linear project history.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 263
        }
      },
      {
        "header": "The safety net: git reflog",
        "content": "Reference logs, or \"reflogs\" are a mechanism Git uses to record updates applied to tips of branches and other commit references. Reflog allows you to go back to commits even though they are not referenced by any branch or tag. After rewriting history, the reflog contains information about the old state of branches and allows you to go back to that state if necessary. Every time your branch tip is updated for any reason (by switching branches, pulling in new changes, rewriting history or simply by adding new commits), a new entry will be added to the reflog. In this section we will take a high level look at the git reflog command and explore some common uses.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 666
        }
      },
      {
        "header": "Usage",
        "content": "This displays the reflog for the local repository.\n\nThis shows the reflog with relative date information (e.g. 2 weeks ago).",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit reflog\n```",
          "```bash\ngit reflog --relative-date\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 124
        }
      },
      {
        "header": "Example",
        "content": "To understand git reflog, let's run through an example.\n\nThe reflog above shows a checkout from main to the 2.2 branch and back. From there, there's a hard reset to an older commit. The latest activity is represented at the top labeled HEAD@{0}.\n\nIf it turns out that you accidentally moved back, the reflog will contain the commit main pointed to (0254ea7) before you accidentally dropped 2 commits.\n\ngit reset --hard 0254ea7\n\nUsing Git reset, it is now possible to change main back to the commit it was before. This provides a safety net in case the history was accidentally changed.\n\nIt's important to note that the reflog only provides a safety net if changes have been committed to your local repository and that it only tracks movements of the repositories branch tip. Additionally reflog entries have an expiration date. The default expiration time for reflog entries is 90 days.\n\nFor additional information, see our git reflog page.",
        "code_examples": [
          "```bash\n0a2e358 HEAD@{0}: reset: moving to HEAD~20254ea7 HEAD@{1}: checkout: moving from 2.2 to mainc10f740 HEAD@{2}: checkout: moving from main to 2.2\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 940
        }
      },
      {
        "header": "Summary",
        "content": "In this article we discussed several methods of changing git history, and undoing git changes. We took a high level look at the git rebase process. Some Key takeaways are:\n\nLearn more about the commands we covered at their individual pages:\n\n• There are many ways to rewrite history with git.\n• Use git commit --amend to change your latest log message.\n• Use git commit --amend to make modifications to the most recent commit.\n• Use git rebase to combine commits and modify history of a branch.\n• git rebase -i gives much more fine grained control over history modifications than a standard git rebase.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 602
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/rewriting-history",
    "doc_type": "git",
    "total_sections": 18
  },
  {
    "title": "Rewriting history",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "Git commit --amend and other methods of rewriting history",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 57
        }
      },
      {
        "header": "Intro",
        "content": "This tutorial will cover various methods of rewriting and altering Git history. Git uses a few different methods to record changes. We will discuss the strengths and weaknesses of the different methods and give examples of how to work with them. This tutorial discusses some of the most common reasons for overwriting committed snapshots and shows you how to avoid the pitfalls of doing so.\n\nGit's main job is to make sure you never lose a committed change. But it's also designed to give you total control over your development workflow. This includes letting you define exactly what your project history looks like; however, it also creates the potential of losing commits. Git provides its history-rewriting commands under the disclaimer that using them may result in lost content.\n\nGit has several mechanisms for storing history and saving changes. These mechanisms include: Commit --amend, git rebase and git reflog. These options give you powerful work flow customization options. By the end of this tutorial, you'll be familiar with commands that will let you restructure your Git commits, and be able to avoid pitfalls that are commonly encountered when rewriting history.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1180
        }
      },
      {
        "header": "Changing the Last Commit: git commit --amend",
        "content": "The git commit --amend command is a convenient way to modify the most recent commit. It lets you combine staged changes with the previous commit instead of creating an entirely new commit. It can also be used to simply edit the previous commit message without changing its snapshot. But, amending does not just alter the most recent commit, it replaces it entirely, meaning the amended commit will be a new entity with its own ref. To Git, it will look like a brand new commit, which is visualized with an asterisk (*) in the diagram below. There are a few common scenarios for using git commit --amend. We'll cover usage examples in the following sections.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 657
        }
      },
      {
        "header": "Change most recent Git commit message",
        "content": "Let's say you just committed and you made a mistake in your commit log message. Running this command when there is nothing staged lets you edit the previous commit’s message without altering its snapshot.\n\nPremature commits happen all the time in the course of your everyday development. It’s easy to forget to stage a file or to format your commit message the wrong way. The --amend flag is a convenient way to fix these minor mistakes.\n\nAdding the -m option allows you to pass in a new message from the command line without being prompted to open an editor.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit commit --amend\n```",
          "```bash\ngit commit --amend -m \"an updated commit message\"\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 559
        }
      },
      {
        "header": "Changing committed files",
        "content": "The following example demonstrates a common scenario in Git-based development. Let's say we've edited a few files that we would like to commit in a single snapshot, but then we forget to add one of the files the first time around. Fixing the error is simply a matter of staging the other file and committing with the --amend flag:\n\nThe --no-edit flag will allow you to make the amendment to your commit without changing its commit message. The resulting commit will replace the incomplete one, and it will look like we committed the changes to hello.py and main.py in a single snapshot.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# Edit hello.py and main.pygit add hello.pygit commit# Realize you forgot to add the changes from main.pygit add main.pygit commit --amend --no-edit\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 586
        }
      },
      {
        "header": "Don’t amend public commits",
        "content": "Amended commits are actually entirely new commits and the previous commit will no longer be on your current branch. This has the same consequences as resetting a public snapshot. Avoid amending a commit that other developers have based their work on. This is a confusing situation for developers to be in and it’s complicated to recover from.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 342
        }
      },
      {
        "header": "Recap",
        "content": "To review, git commit --amend lets you take the most recent commit and add new staged changes to it. You can add or remove changes from the Git staging area to apply with a --amend commit. If there are no changes staged, a --amend will still prompt you to modify the last commit message log. Be cautious when using --amend on commits shared with other team members. Amending a commit that is shared with another user will potentially require confusing and lengthy merge conflict resolutions.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 491
        }
      },
      {
        "header": "Changing older or multiple commits",
        "content": "To modify older or multiple commits, you can use git rebase to combine a sequence of commits into a new base commit. In standard mode, git rebase allows you to literally rewrite history — automatically applying commits in your current working branch to the passed branch head. Since your new commits will be replacing the old, it's important to not use git rebase on commits that have been pushed public, or it will appear that your project history disappeared.\n\nIn these or similar instances where it's important to preserve a clean project history, adding the -i option to git rebase allows you to run rebase interactive. This gives you the opportunity to alter individual commits in the process, rather than moving all commits. You can learn more about interactive rebasing and additional rebase commands on the git rebase page.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 831
        }
      },
      {
        "header": "Changing committed files",
        "content": "During a rebase, the edit or e command will pause the rebase playback on that commit and allow you to make additional changes with git commit --amend Git will interrupt the playback and present a message:",
        "code_examples": [],
        "usage_examples": [
          "```bash\nStopped at 5d025d1... formattingYou can amend the commit now, withgit commit --amendOnce you are satisfied with your changes, rungit rebase --continue\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 204
        }
      },
      {
        "header": "Multiple messages",
        "content": "Each regular Git commit will have a log message explaining what happened in the commit. These messages provide valuable insight into the project history. During a rebase, you can run a few commands on commits to modify commit messages.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 235
        }
      },
      {
        "header": "Squash commits for a clean history",
        "content": "The s \"squash\" command is where we see the true utility of rebase. Squash allows you to specify which commits you want to merge into the previous commits. This is what enables a \"clean history.\" During rebase playback, Git will execute the specified rebase command for each commit. In the case of squash commits, Git will open your configured text editor and prompt to combine the specified commit messages. This entire process can be visualized as follows:\n\nNote that the commits modified with a rebase command have a different ID than either of the original commits. Commits marked with pick will have a new ID if the previous commits have been rewritten.\n\nModern Git hosting solutions like Bitbucket now offer \"auto squashing\" features upon merge. These features will automatically rebase and squash a branch's commits for you when utilizing the hosted solutions UI. For more info see \"Squash commits when merging a Git branch with Bitbucket.\"",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 946
        }
      },
      {
        "header": "Recap",
        "content": "Git rebase gives you the power to modify your history, and interactive rebasing allows you to do so without leaving a “messy” trail. This creates the freedom to make and correct errors and refine your work, while still maintaining a clean, linear project history.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 263
        }
      },
      {
        "header": "The safety net: git reflog",
        "content": "Reference logs, or \"reflogs\" are a mechanism Git uses to record updates applied to tips of branches and other commit references. Reflog allows you to go back to commits even though they are not referenced by any branch or tag. After rewriting history, the reflog contains information about the old state of branches and allows you to go back to that state if necessary. Every time your branch tip is updated for any reason (by switching branches, pulling in new changes, rewriting history or simply by adding new commits), a new entry will be added to the reflog. In this section we will take a high level look at the git reflog command and explore some common uses.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 666
        }
      },
      {
        "header": "Usage",
        "content": "This displays the reflog for the local repository.\n\nThis shows the reflog with relative date information (e.g. 2 weeks ago).",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit reflog\n```",
          "```bash\ngit reflog --relative-date\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 124
        }
      },
      {
        "header": "Example",
        "content": "To understand git reflog, let's run through an example.\n\nThe reflog above shows a checkout from main to the 2.2 branch and back. From there, there's a hard reset to an older commit. The latest activity is represented at the top labeled HEAD@{0}.\n\nIf it turns out that you accidentally moved back, the reflog will contain the commit main pointed to (0254ea7) before you accidentally dropped 2 commits.\n\ngit reset --hard 0254ea7\n\nUsing Git reset, it is now possible to change main back to the commit it was before. This provides a safety net in case the history was accidentally changed.\n\nIt's important to note that the reflog only provides a safety net if changes have been committed to your local repository and that it only tracks movements of the repositories branch tip. Additionally reflog entries have an expiration date. The default expiration time for reflog entries is 90 days.\n\nFor additional information, see our git reflog page.",
        "code_examples": [
          "```bash\n0a2e358 HEAD@{0}: reset: moving to HEAD~20254ea7 HEAD@{1}: checkout: moving from 2.2 to mainc10f740 HEAD@{2}: checkout: moving from main to 2.2\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 940
        }
      },
      {
        "header": "Summary",
        "content": "In this article we discussed several methods of changing git history, and undoing git changes. We took a high level look at the git rebase process. Some Key takeaways are:\n\nLearn more about the commands we covered at their individual pages:\n\n• There are many ways to rewrite history with git.\n• Use git commit --amend to change your latest log message.\n• Use git commit --amend to make modifications to the most recent commit.\n• Use git rebase to combine commits and modify history of a branch.\n• git rebase -i gives much more fine grained control over history modifications than a standard git rebase.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 602
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/rewriting-history/git-commit--amend",
    "doc_type": "git",
    "total_sections": 18
  },
  {
    "title": "Git rebase",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "This document will serve as an in-depth discussion of the git rebase command. The Rebase command has also been looked at on the setting up a repository and rewriting history pages. This page will take a more detailed look at git rebase configuration and execution. Common Rebase use cases and pitfalls will be covered here.\n\nRebase is one of two Git utilities that specializes in integrating changes from one branch onto another. The other change integration utility is git merge. Merge is always a forward moving change record. Alternatively, rebase has powerful history rewriting features. For a detailed look at Merge vs. Rebase, visit our Merging vs Rebasing guide. Rebase itself has 2 main modes: \"manual\" and \"interactive\" mode. We will cover the different Rebase modes in more detail below.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 797
        }
      },
      {
        "header": "What is git rebase?",
        "content": "Rebasing is the process of moving or combining a sequence of commits to a new base commit. Rebasing is most useful and easily visualized in the context of a feature branching workflow. The general process can be visualized as the following:\n\nFrom a content perspective, rebasing is changing the base of your branch from one commit to another making it appear as if you'd created your branch from a different commit. Internally, Git accomplishes this by creating new commits and applying them to the specified base. It's very important to understand that even though the branch looks the same, it's composed of entirely new commits.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 631
        }
      },
      {
        "header": "Usage",
        "content": "The primary reason for rebasing is to maintain a linear project history. For example, consider a situation where the main branch has progressed since you started working on a feature branch. You want to get the latest updates to the main branch in your feature branch, but you want to keep your branch's history clean so it appears as if you've been working off the latest main branch. This gives the later benefit of a clean merge of your feature branch back into the main branch. Why do we want to maintain a \"clean history\"? The benefits of having a clean history become tangible when performing Git operations to investigate the introduction of a regression. A more real-world scenario would be:\n\n1. A bug is identified in the main branch. A feature that was working successfully is now broken.\n\n2. A developer examines the history of the main branch using git log because of the \"clean history\" the developer is quickly able to reason about the history of the project.\n\n3. The developer can not identify when the bug was introduced using git log so the developer executes a git bisect.\n\n4. Because the git history is clean, git bisect has a refined set of commits to compare when looking for the regression. The developer quickly finds the commit that introduced the bug and is able to act accordingly.\n\nLearn more about git log and git bisect on their individual usage pages.\n\nYou have two options for integrating your feature into the main branch: merging directly or rebasing and then merging. The former option results in a 3-way merge and a merge commit, while the latter results in a fast-forward merge and a perfectly linear history. The following diagram demonstrates how rebasing onto the main branch facilitates a fast-forward merge.\n\nRebasing is a common way to integrate upstream changes into your local repository. Pulling in upstream changes with Git merge results in a superfluous merge commit every time you want to see how the project has progressed. On the other hand, rebasing is like saying, “I want to base my changes on what everybody has already done.”",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 2080
        }
      },
      {
        "header": "Don't rebase public history",
        "content": "As we've discussed previously in rewriting history, you should never rebase commits once they've been pushed to a public repository. The rebase would replace the old commits with new ones and it would look like that part of your project history abruptly vanished.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 263
        }
      },
      {
        "header": "Git rebase standard vs git rebase interactive",
        "content": "Git rebase interactive is when git rebase accepts an -- i argument. This stands for \"Interactive.\" Without any arguments, the command runs in standard mode. In both cases, let's assume we have created a separate feature branch.\n\nGit rebase in standard mode will automatically take the commits in your current working branch and apply them to the head of the passed branch.\n\nThis automatically rebases the current branch onto ＜base＞, which can be any kind of commit reference (for example an ID, a branch name, a tag, or a relative reference to HEAD).\n\nRunning git rebase with the -i flag begins an interactive rebasing session. Instead of blindly moving all of the commits to the new base, interactive rebasing gives you the opportunity to alter individual commits in the process. This lets you clean up history by removing, splitting, and altering an existing series of commits. It's like Git commit --amend on steroids.\n\nThis rebases the current branch onto ＜base＞ but uses an interactive rebasing session. This opens an editor where you can enter commands (described below) for each commit to be rebased. These commands determine how individual commits will be transferred to the new base. You can also reorder the commit listing to change the order of the commits themselves. Once you've specified commands for each commit in the rebase, Git will begin playing back commits applying the rebase commands. The rebasing edit commands are as follows:\n\nAs detailed in the rewriting history page, rebasing can be used to change older and multiple commits, committed files, and multiple messages. While these are the most common applications, git rebase also has additional command options that can be useful in more complex applications.\n\n• git rebase -- d means during playback the commit will be discarded from the final combined commit block.\n• git rebase -- p leaves the commit as is. It will not modify the commit's message or content and will still be an individual commit in the branches history.\n• git rebase -- x during playback executes a command line shell script on each marked commit. A useful example would be to run your codebase's test suite on specific commits, which may help identify regressions during a rebase.",
        "code_examples": [
          "```bash\npick 2231360 some old commitpick ee2adc2 Adds new feature# Rebase 2cf755d..ee2adc2 onto 2cf755d (9 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like \"squash\", but discard this commit's log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit\n```"
        ],
        "usage_examples": [
          "```bash\n# Create a feature branch based off of maingit checkout -b feature_branch main# Edit filesgit commit -a -m \"Adds new feature\"\n```",
          "```bash\ngit rebase <base>\n```",
          "```bash\ngit rebase --interactive <base>\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 2229
        }
      },
      {
        "header": "Recap",
        "content": "Interactive rebasing gives you complete control over what your project history looks like. This affords a lot of freedom to developers, as it lets them commit a \"messy\" history while they're focused on writing code, then go back and clean it up after the fact.\n\nMost developers like to use an interactive rebase to polish a feature branch before merging it into the main code base. This gives them the opportunity to squash insignificant commits, delete obsolete ones, and make sure everything else is in order before committing to the “official” project history. To everybody else, it will look like the entire feature was developed in a single series of well-planned commits.\n\nThe real power of interactive rebasing can be seen in the history of the resulting main branch. To everybody else, it looks like you're a brilliant developer who implemented the new feature with the perfect amount of commits the first time around. This is how interactive rebasing can keep a project's history clean and meaningful.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1010
        }
      },
      {
        "header": "Configuration options",
        "content": "There are a few rebase properties that can be set using git config. These options will alter the git rebase output look and feel.\n\nPrints warning output in interactive mode which warns of removed commits\n\nStops the rebase and prints removed commit warning messages\n\nSet by default this ignores any missing commit warnings\n\n• rebase.stat: A boolean that is set to false by default. The option toggles display of visual diffstat content that shows what changed since the last rebase.\n• rebase.autoSquash: A boolean value that toggles the --autosquash behavior.\n• rebase.missingCommitsCheck: Can be set to multiple values which change rebase behavior around missing commits.\n\n• rebase.instructionFormat: A git log format string that will be used for formatting interactive rebase display\n\nerror | Stops the rebase and prints removed commit warning messages\nignore | Set by default this ignores any missing commit warnings",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 4,
          "content_length": 918
        }
      },
      {
        "header": "Advanced rebase application",
        "content": "The command line argument --onto can be passed to git rebase. When in git rebase --onto mode the command expands to:\n\nThe --onto command enables a more powerful form or rebase that allows passing specific refs to be the tips of a rebase. Let’s say we have an example repo with branches like:\n\nfeatureB is based on featureA, however, we realize featureB is not dependent on any of the changes in featureA and could just be branched off main.\n\nfeatureA is the ＜oldbase＞. main becomes the ＜newbase＞ and featureB is reference for what HEAD of the ＜newbase＞ will point to. The results are then:",
        "code_examples": [
          "```bash\no---o---o---o---o  main\\o---o---o---o---o  featureA\\o---o---o  featureB\n```",
          "```bash\no---o---o  featureB/o---o---o---o---o  main\\o---o---o---o---o  featureA\n```"
        ],
        "usage_examples": [
          "```bash\ngit rebase --onto <newbase> <oldbase>\n```",
          "```bash\ngit rebase --onto main featureA featureB\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 589
        }
      },
      {
        "header": "Understanding the dangers of rebase",
        "content": "One caveat to consider when working with Git Rebase is merge conflicts may become more frequent during a rebase workflow. This occurs if you have a long-lived branch that has strayed from main. Eventually you will want to rebase against main and at that time it may contain many new commits that your branch changes may conflict with. This is easily remedied by rebasing your branch frequently against main, and making more frequent commits. The --continue and --abort command line arguments can be passed to git rebase to advance or reset the the rebase when dealing with conflicts.\n\nA more serious rebase caveat is lost commits from interactive history rewriting. Running rebase in interactive mode and executing subcommands like squash or drop will remove commits from your branche's immediate log. At first glance this can appear as though the commits are permanently gone. Using git reflog these commits can be restored and the entire rebase can be undone. For more info on using git reflog to find lost commits, visit our Git reflog documentation page.\n\nGit Rebase itself is not seriously dangerous. The real danger cases arise when executing history rewriting interactive rebases and force pushing the results to a remote branch that's shared by other users. This is a pattern that should be avoided as it has the capability to overwrite other remote users' work when they pull.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1385
        }
      },
      {
        "header": "Recovering from upstream rebase",
        "content": "If another user has rebased and force pushed to the branch that you’re committing to, a git pull will then overwrite any commits you have based off that previous branch with the tip that was force pushed. Luckily, using git reflog you can get the reflog of the remote branch. On the remote branch's reflog you can find a ref before it was rebased. You can then rebase your branch against that remote ref using the --onto option as discussed above in the Advanced Rebase Application section.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 490
        }
      },
      {
        "header": "Summary",
        "content": "In this article we covered git rebase usage. We discussed basic and advanced use cases and more advanced examples. Some key discussion points are:\n\nWe looked at git rebase usage with other tools like git reflog, git fetch, and git push. Visit their corresponding pages for further information.\n\n• git rebase standard vs interactive modes\n• git rebase configuration options\n• git rebase --onto\n• git rebase lost commits",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 418
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase",
    "doc_type": "git",
    "total_sections": 13
  },
  {
    "title": "Git Reflog",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "This page provides a detailed discussion of the git reflog command. Git keeps track of updates to the tip of branches using a mechanism called reference logs, or \"reflogs.\" Many Git commands accept a parameter for specifying a reference or \"ref\", which is a pointer to a commit. Common examples include:\n\nReflogs track when Git refs were updated in the local repository. In addition to branch tip reflogs, a special reflog is maintained for the Git stash. Reflogs are stored in directories under the local repository's .git directory. git reflog directories can be found at .git/logs/refs/heads/., .git/logs/HEAD, and also .git/logs/refs/stash if the git stash has been used on the repo.\n\nWe discussed git reflog at a high level on the Rewriting History Page. This document will cover: extended configuration options of git reflog, common use-cases and pitfalls of git reflog, how to undo changes with git reflog, and more.\n\n• git checkout",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 939
        }
      },
      {
        "header": "Basic usage",
        "content": "The most basic Reflog use case is invoking:\n\nThis is essentially a short cut that's equivalent to:\n\nThis will output the HEAD reflog. You should see output similar to:\n\nVisit the Rewriting History page for another example of common reflog access.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit reflog\n```",
          "```bash\ngit reflog show HEAD\n```",
          "```bash\neff544f HEAD@{0}: commit: migrate existing contentbf871fd HEAD@{1}: commit: Add Git Reflog outline9a4491f HEAD@{2}: checkout: moving from main to git_reflog9a4491f HEAD@{3}: checkout: moving from Git_Config to main39b159a HEAD@{4}: commit: expand on git context9b3aa71 HEAD@{5}: commit: more color clarificationf34388b HEAD@{6}: commit: expand on color support9962aed HEAD@{7}: commit: a git editor -> the Git editor\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 246
        }
      },
      {
        "header": "Reflog references",
        "content": "By default, git reflog will output the reflog of the HEAD ref. HEAD is a symbolic reference to the currently active branch. Reflogs are available for other refs as well. The syntax to access a git ref is name@{qualifier}. In addition to HEAD refs, other branches, tags, remotes, and the Git stash can be referenced as well.\n\nYou can get a complete reflog of all refs by executing:\n\nTo see the reflog for a specific branch pass that branch name to git reflog show\n\nBitbucket displays the Create a new repository page. Take some time to review the dialog's contents. With the exception of the Repository type, everything you enter on this page you can later change.\n\nExecuting this example will show a reflog for the otherbranch branch. The following example assumes you have previously stashed some changes using the git stash command.\n\nThis will output a reflog for the Git stash. The returned ref pointers can be passed to other Git commands:\n\nWhen executed, this example code will display Git diff output comparing the stash@{0} changes against the otherbranch@{0} ref.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit reflog show --all\n```",
          "```bash\ngit reflog show otherbranch9a4491f otherbranch@{0}: commit: seperate articles into branch PRs35aee4a otherbranch{1}: commit (initial): initial commit add git-init and setting-up-a-repo docs\n```",
          "```bash\ngit reflog stash0d44de3 stash@{0}: WIP on git_reflog: c492574 flesh out intro\n```",
          "```bash\ngit diff stash@{0} otherbranch@{0}\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1071
        }
      },
      {
        "header": "Timed reflogs",
        "content": "Every reflog entry has a timestamp attached to it. These timestamps can be leveraged as the qualifier token of Git ref pointer syntax. This enables filtering Git reflogs by time. The following are some examples of available time qualifiers:\n\nTime qualifiers can be combined (e.g. 1.day.2.hours.ago), Additionally plural forms are accepted (e.g. 5.minutes.ago).\n\nTime qualifier refs can be passed to other git commands.\n\nThis example will diff the current main branch against main 1 day ago. This example is very useful if you want to know changes that have occurred within a time frame.\n\n• 1.minute.ago\n• 1.month.ago\n• 2011-05-17.09:00:00",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit diff main@{0} main@{1.day.ago}\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 638
        }
      },
      {
        "header": "Subcommands & configuration options",
        "content": "git reflog accepts few addition arguments which are considered subcommands.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 75
        }
      },
      {
        "header": "Show - git reflog show",
        "content": "show is implicitly passed by default. For example, the command:\n\nis equivalent to the command:\n\nIn addition, git reflog show is an alias for git log -g --abbrev-commit --pretty=oneline. Executing git reflog show will display the log for the passed .",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit reflog main@{0}\n```",
          "```bash\ngit reflog show main@{0}\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 249
        }
      },
      {
        "header": "Expire - git reflog expire",
        "content": "The expire subcommand cleans up old or unreachable reflog entries. The expire subcommand has potential for data loss. This subcommand is not typically used by end users, but used by git internally. Passing a -n or --dry-run option to git reflog expire Will perform a \"dry run\" which will output which reflog entries are marked to be pruned, but will not actually prune them.\n\nBy default, the reflog expiration date is set to 90 days. An expire time can be specified by passing a command line argument --expire=time to git reflog expire or by setting a git configuration name of gc.reflogExpire.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 594
        }
      },
      {
        "header": "Delete - git reflog delete",
        "content": "The delete subcommand is self explanatory and will delete a passed in reflog entry. As with expire, delete has potential to lose data and is not commonly invoked by end users.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 175
        }
      },
      {
        "header": "Recovering lost commits",
        "content": "Git never really loses anything, even when performing history rewriting operations like rebasing or commit amending. For the next example let's assume that we have made some new changes to our repo. Our git log --pretty=oneline looks like the following:\n\nWe then commit those changes and execute the following:\n\nWith the addition of the new commit. The log now looks like:\n\nIf you get this error, enter the following at the command line:\n\nAt this point we perform an interactive rebase against the main branch by executing...\n\nDuring the rebase we mark commits for squash with the s rebase subcommand. During the rebase, we squash a few commits into the most recent \"some WIP changes\" commit.\n\nBecause we squashed commits the git log output now looks like:\n\nIf we examine git log at this point it appears that we no longer have the commits that were marked for squashing. What if we want to operate on one of the squashed commits? Maybe to remove its changes from history? This is an opportunity to leverage the reflog.\n\nWe can see there are reflog entries for the start and finish of the rebase and prior to those is our \"some WIP changes\" commit. We can pass the reflog ref to git reset and reset to a commit that was before the rebase.\n\nExecuting this reset command will move HEAD to the commit where \"some WIP changes\" was added, essentially restoring the other squashed commits.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n338fbcb41de10f7f2e54095f5649426cb4bf2458 extended content1e63ceab309da94256db8fb1f35b1678fb74abd4 bunch of contentc49257493a95185997c87e0bc3a9481715270086 flesh out introeff544f986d270d7f97c77618314a06f024c7916 migrate existing contentbf871fd762d8ef2e146d7f0226e81a92f91975ad Add Git Reflog outline35aee4a4404c42128bee8468a9517418ed0eb3dc initial commit add git-init and setting-up-a-repo docs\n```",
          "```bash\n#make changes to HEADgit commit -am \"some WIP changes\"\n```",
          "```bash\n$ git clonehttps://emmap1@bitbucket.org/emmap1/bitbucketstationlocations.gitCloning into 'bitbucketspacestation'...fatal: could not readPassword for 'https://emmap1@bitbucket.org': No such file or directory\n```",
          "```bash\n37656e19d4e4f1a9b419f57850c8f1974f871b07 some WIP changes338fbcb41de10f7f2e54095f5649426cb4bf2458 extended content1e63ceab309da94256db8fb1f35b1678fb74abd4 bunch of contentc49257493a95185997c87e0bc3a9481715270086 flesh out introeff544f986d270d7f97c77618314a06f024c7916 migrate existing contentbf871fd762d8ef2e146d7f0226e81a92f91975ad Add Git Reflog outline35aee4a4404c42128bee8468a9517418ed0eb3dc initial commit add git-init and setting-up-a-repo docs\n```",
          "```bash\ngit rebase -i origin/main\n```",
          "```bash\n40dhsoi37656e19d4e4f1a9b419f57850ch87dah987698hs some WIP changes35aee4a4404c42128bee8468a9517418ed0eb3dc initial commit add git-init and setting-up-a-repo docs\n```",
          "```bash\ngit reflog37656e1 HEAD@{0}: rebase -i (finish): returning to refs/heads/git_reflog37656e1 HEAD@{1}: rebase -i (start): checkout origin/main37656e1 HEAD@{2}: commit: some WIP changes\n```",
          "```bash\ngit reset HEAD@{2}\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 1383
        }
      },
      {
        "header": "Summary",
        "content": "In this tutorial we discussed the git reflog command. Some key points covered were:\n\nWe briefly mentioned that git reflog can be used with other git commands like git checkout, git reset, and git merge. Learn more at their respective pages. For additional discussion on refs and the reflog, learn more here.\n\n• How to view reflog for specific branches\n• How to undo a git rebase using the reflog\n• How specify and view time based reflog entries",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 444
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/rewriting-history/git-reflog",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Git Branch",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "This document is an in-depth review of the git branch command and a discussion of the overall Git branching model. Branching is a feature available in most modern version control systems. Branching in other VCS's can be an expensive operation in both time and disk space. In Git, branches are a part of your everyday development process.\n\nGit branches are effectively a pointer to a snapshot of your changes. When you want to add a new feature or fix a bug—no matter how big or how small—you spawn a new branch to encapsulate your changes. This makes it harder for unstable code to get merged into the main code base, and it gives you the chance to clean up your future's history before merging it into the main branch.\n\nThe diagram above visualizes a repository with two isolated lines of development, one for a little feature, and one for a longer-running feature. By developing them in branches, it’s not only possible to work on both of them in parallel, but it also keeps the main branch free from questionable code.\n\nThe implementation behind Git branches is much more lightweight than other version control system models. Instead of copying files from directory to directory, Git stores a branch as a reference to a commit. In this sense, a branch represents the tip of a series of commits—it's not a container for commits. The history for a branch is extrapolated through the commit relationships.\n\nAs you read, remember that Git branches aren't like SVN branches. Whereas SVN branches are only used to capture the occasional large-scale development effort, Git branches are an integral part of your everyday workflow. The following content will expand on the internal Git branching architecture.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1704
        }
      },
      {
        "header": "How it works",
        "content": "A branch represents an independent line of development. Branches serve as an abstraction for the edit/stage/commit process. You can think of them as a way to request a brand new working directory, staging area, and project history. New commits are recorded in the history for the current branch, which results in a fork in the history of the project.\n\nThe git branch command lets you create, list, rename, and delete branches. It doesn’t let you switch between branches or put a forked history back together again. For this reason, git branch is tightly integrated with the git checkout and git merge commands.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 610
        }
      },
      {
        "header": "Common options",
        "content": "List all of the branches in your repository. This is synonymous with git branch --list.\n\nCreate a new branch called ＜branch＞. This does not check out the new branch.\n\nDelete the specified branch. This is a “safe” operation in that Git prevents you from deleting the branch if it has unmerged changes.\n\nForce delete the specified branch, even if it has unmerged changes. This is the command to use if you want to permanently throw away all of the commits associated with a particular line of development.\n\nRename the current branch to ＜branch＞.\n\nList all remote branches.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit branch\n```",
          "```bash\ngit branch <branch>\n```",
          "```bash\ngit branch -d <branch>\n```",
          "```bash\ngit branch -D <branch>\n```",
          "```bash\ngit branch -m <branch>\n```",
          "```bash\ngit branch -a\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 570
        }
      },
      {
        "header": "Creating branches",
        "content": "It's important to understand that branches are just pointers to commits. When you create a branch, all Git needs to do is create a new pointer, it doesn’t change the repository in any other way. If you start with a repository that looks like this:\n\nThen, you create a branch using the following command:\n\nThe repository history remains unchanged. All you get is a new pointer to the current commit:\n\nNote that this only creates the new branch. To start adding commits to it, you need to select it with git checkout, and then use the standard git add and git commit commands.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit branch crazy-experiment\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 574
        }
      },
      {
        "header": "Creating remote branches",
        "content": "So far these examples have all demonstrated local branch operations. The git branch command also works on remote branches. In order to operate on remote branches, a remote repo must first be configured and added to the local repo config.\n\nThis command will push a copy of the local branch crazy-experiment to the remote repo ＜remote＞.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git remote add new-remote-repo https://bitbucket.com/user/repo.git# Add remote repo to local repo config$ git push <new-remote-repo> crazy-experiment~# pushes the crazy-experiment branch to new-remote-repo\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 334
        }
      },
      {
        "header": "Deleting branches",
        "content": "Once you’ve finished working on a branch and have merged it into the main code base, you’re free to delete the branch without losing any history:\n\nHowever, if the branch hasn’t been merged, the above command will output an error message:\n\nThis protects you from losing access to that entire line of development. If you really want to delete the branch (e.g., it’s a failed experiment), you can use the capital -D flag:\n\nThis deletes the branch regardless of its status and without warnings, so use it judiciously.\n\nThe previous commands will delete a local copy of a branch. The branch may still exist in remote repos. To delete a remote branch execute the following.\n\nThis will push a delete signal to the remote origin repository that triggers a delete of the remote crazy-experiment branch.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit branch -d crazy-experiment\n```",
          "```bash\nerror: The branch 'crazy-experiment' is not fully merged. If you are sure you want to delete it, run 'git branch -D crazy-experiment'.\n```",
          "```bash\ngit branch -D crazy-experiment\n```",
          "```bash\ngit push origin --delete crazy-experiment\n```",
          "```bash\ngit push origin :crazy-experiment\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 793
        }
      },
      {
        "header": "Summary",
        "content": "In this document we discussed Git's branching behavior and the git branch command. The git branch commands primary functions are to create, list, rename and delete branches. To operate further on the resulting branches the command is commonly used with other commands like git checkout. Learn more about git checkout branch operations; such as switching branches and merging branches, on the git checkout page.\n\nCompared to other VCSs, Git's branch operations are inexpensive and frequently used. This flexibility enables powerful Git workflow customization. For more info on Git workflows visit our extended workflow discussion pages: The Feature Branch Workflow, GitFlow Workflow, and Forking Workflow.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 704
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/using-branches",
    "doc_type": "git",
    "total_sections": 9
  },
  {
    "title": "Git Branch",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "This document is an in-depth review of the git branch command and a discussion of the overall Git branching model. Branching is a feature available in most modern version control systems. Branching in other VCS's can be an expensive operation in both time and disk space. In Git, branches are a part of your everyday development process.\n\nGit branches are effectively a pointer to a snapshot of your changes. When you want to add a new feature or fix a bug—no matter how big or how small—you spawn a new branch to encapsulate your changes. This makes it harder for unstable code to get merged into the main code base, and it gives you the chance to clean up your future's history before merging it into the main branch.\n\nThe diagram above visualizes a repository with two isolated lines of development, one for a little feature, and one for a longer-running feature. By developing them in branches, it’s not only possible to work on both of them in parallel, but it also keeps the main branch free from questionable code.\n\nThe implementation behind Git branches is much more lightweight than other version control system models. Instead of copying files from directory to directory, Git stores a branch as a reference to a commit. In this sense, a branch represents the tip of a series of commits—it's not a container for commits. The history for a branch is extrapolated through the commit relationships.\n\nAs you read, remember that Git branches aren't like SVN branches. Whereas SVN branches are only used to capture the occasional large-scale development effort, Git branches are an integral part of your everyday workflow. The following content will expand on the internal Git branching architecture.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1704
        }
      },
      {
        "header": "How it works",
        "content": "A branch represents an independent line of development. Branches serve as an abstraction for the edit/stage/commit process. You can think of them as a way to request a brand new working directory, staging area, and project history. New commits are recorded in the history for the current branch, which results in a fork in the history of the project.\n\nThe git branch command lets you create, list, rename, and delete branches. It doesn’t let you switch between branches or put a forked history back together again. For this reason, git branch is tightly integrated with the git checkout and git merge commands.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 610
        }
      },
      {
        "header": "Common options",
        "content": "List all of the branches in your repository. This is synonymous with git branch --list.\n\nCreate a new branch called ＜branch＞. This does not check out the new branch.\n\nDelete the specified branch. This is a “safe” operation in that Git prevents you from deleting the branch if it has unmerged changes.\n\nForce delete the specified branch, even if it has unmerged changes. This is the command to use if you want to permanently throw away all of the commits associated with a particular line of development.\n\nRename the current branch to ＜branch＞.\n\nList all remote branches.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit branch\n```",
          "```bash\ngit branch <branch>\n```",
          "```bash\ngit branch -d <branch>\n```",
          "```bash\ngit branch -D <branch>\n```",
          "```bash\ngit branch -m <branch>\n```",
          "```bash\ngit branch -a\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 570
        }
      },
      {
        "header": "Creating branches",
        "content": "It's important to understand that branches are just pointers to commits. When you create a branch, all Git needs to do is create a new pointer, it doesn’t change the repository in any other way. If you start with a repository that looks like this:\n\nThen, you create a branch using the following command:\n\nThe repository history remains unchanged. All you get is a new pointer to the current commit:\n\nNote that this only creates the new branch. To start adding commits to it, you need to select it with git checkout, and then use the standard git add and git commit commands.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit branch crazy-experiment\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 574
        }
      },
      {
        "header": "Creating remote branches",
        "content": "So far these examples have all demonstrated local branch operations. The git branch command also works on remote branches. In order to operate on remote branches, a remote repo must first be configured and added to the local repo config.\n\nThis command will push a copy of the local branch crazy-experiment to the remote repo ＜remote＞.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git remote add new-remote-repo https://bitbucket.com/user/repo.git# Add remote repo to local repo config$ git push <new-remote-repo> crazy-experiment~# pushes the crazy-experiment branch to new-remote-repo\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 334
        }
      },
      {
        "header": "Deleting branches",
        "content": "Once you’ve finished working on a branch and have merged it into the main code base, you’re free to delete the branch without losing any history:\n\nHowever, if the branch hasn’t been merged, the above command will output an error message:\n\nThis protects you from losing access to that entire line of development. If you really want to delete the branch (e.g., it’s a failed experiment), you can use the capital -D flag:\n\nThis deletes the branch regardless of its status and without warnings, so use it judiciously.\n\nThe previous commands will delete a local copy of a branch. The branch may still exist in remote repos. To delete a remote branch execute the following.\n\nThis will push a delete signal to the remote origin repository that triggers a delete of the remote crazy-experiment branch.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit branch -d crazy-experiment\n```",
          "```bash\nerror: The branch 'crazy-experiment' is not fully merged. If you are sure you want to delete it, run 'git branch -D crazy-experiment'.\n```",
          "```bash\ngit branch -D crazy-experiment\n```",
          "```bash\ngit push origin --delete crazy-experiment\n```",
          "```bash\ngit push origin :crazy-experiment\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 793
        }
      },
      {
        "header": "Summary",
        "content": "In this document we discussed Git's branching behavior and the git branch command. The git branch commands primary functions are to create, list, rename and delete branches. To operate further on the resulting branches the command is commonly used with other commands like git checkout. Learn more about git checkout branch operations; such as switching branches and merging branches, on the git checkout page.\n\nCompared to other VCSs, Git's branch operations are inexpensive and frequently used. This flexibility enables powerful Git workflow customization. For more info on Git workflows visit our extended workflow discussion pages: The Feature Branch Workflow, GitFlow Workflow, and Forking Workflow.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 704
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/using-branches/git-branch",
    "doc_type": "git",
    "total_sections": 9
  },
  {
    "title": "Git checkout",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "This page is an examination of the git checkout command. It will cover usage examples and edge cases. In Git terms, a \"checkout\" is the act of switching between different versions of a target entity. The git checkout command operates upon three distinct entities: files, commits, and branches. In addition to the definition of \"checkout\" the phrase \"checking out\" is commonly used to imply the act of executing the git checkout command. In the Undoing Changes topic, we saw how git checkout can be used to view old commits. The focus for the majority of this document will be checkout operations on branches.\n\nChecking out branches is similar to checking out old commits and files in that the working directory is updated to match the selected branch/revision; however, new changes are saved in the project history—that is, it’s not a read-only operation.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 855
        }
      },
      {
        "header": "Checking out branches",
        "content": "The git checkout command lets you navigate between the branches created by git branch. Checking out a branch updates the files in the working directory to match the version stored in that branch, and it tells Git to record all new commits on that branch. Think of it as a way to select which line of development you’re working on.\n\nHaving a dedicated branch for each new feature is a dramatic shift from a traditional SVN workflow. It makes it ridiculously easy to try new experiments without the fear of destroying existing functionality, and it makes it possible to work on many unrelated features at the same time. In addition, branches also facilitate several collaborative workflows.\n\nThe git checkout command may occasionally be confused with git clone. The difference between the two commands is that clone works to fetch code from a remote repository, alternatively checkout works to switch between versions of code already on the local system.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 952
        }
      },
      {
        "header": "Usage: Existing branches",
        "content": "Assuming the repo you're working in contains pre-existing branches, you can switch between these branches using git checkout. To find out what branches are available and what the current branch name is, execute git branch.\n\nThe above example demonstrates how to view a list of available branches by executing the git branch command, and switch to a specified branch, in this case, the feature_inprogress_branch.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$＞ git branchmainanother_branchfeature_inprogress_branch$＞ git checkout feature_inprogress_branch\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 411
        }
      },
      {
        "header": "New branches",
        "content": "Git checkout works hand-in-hand with git branch. The git branch command can be used to create a new branch. When you want to start a new feature, you create a new branch off main using git branch new_branch. Once created you can then use git checkout new_branch to switch to that branch. Additionally, The git checkout command accepts a -b argument that acts as a convenience method which will create the new branch and immediately switch to it. You can work on multiple features in a single repository by switching between them with git checkout.\n\nThe above example simultaneously creates and checks out ＜new-branch＞. The -b option is a convenience flag that tells Git to run git branch before running git checkout ＜new-branch＞.\n\nBy default git checkout -b will base the new-branch off the current HEAD. An optional additional branch parameter can be passed to git checkout. In the above example, ＜existing-branch＞ is passed which then bases new-branch off of existing-branch instead of the current HEAD.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout -b ＜new-branch＞\n```",
          "```bash\ngit checkout -b ＜new-branch＞ ＜existing-branch＞\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1005
        }
      },
      {
        "header": "Switching branches",
        "content": "Switching branches is a straightforward operation. Executing the following will point HEAD to the tip of ＜branchname＞.\n\nGit tracks a history of checkout operations in the reflog. You can execute git reflog to view the history.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout ＜branchname＞\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 226
        }
      },
      {
        "header": "Git checkout a remote branch",
        "content": "When collaborating with a team it is common to utilize remote repositories. These repositories may be hosted and shared or they may be another colleague's local copy. Each remote repository will contain its own set of branches. In order to checkout a remote branch you have to first fetch the contents of the branch.\n\nIn modern versions of Git, you can then checkout the remote branch like a local branch.\n\nOlder versions of Git require the creation of a new branch based on the remote.\n\nAdditionally you can checkout a new local branch and reset it to the remote branches last commit.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit fetch --all\n```",
          "```bash\ngit checkout ＜remotebranch＞\n```",
          "```bash\ngit checkout -b ＜remotebranch＞ origin/＜remotebranch＞\n```",
          "```bash\ngit checkout -b ＜branchname＞git reset --hard origin/＜branchname＞\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 585
        }
      },
      {
        "header": "Detached HEADS",
        "content": "Now that we’ve seen the three main uses of git checkout on branches, it's important to discuss the “detached HEAD” state. Remember that the HEAD is Git’s way of referring to the current snapshot. Internally, the git checkout command simply updates the HEAD to point to either the specified branch or commit. When it points to a branch, Git doesn't complain, but when you check out a commit, it switches into a “detached HEAD” state.\n\nThis is a warning telling you that everything you’re doing is “detached” from the rest of your project’s development. If you were to start developing a feature while in a detached HEAD state, there would be no branch allowing you to get back to it. When you inevitably check out another branch (e.g., to merge your feature in), there would be no way to reference your feature:\n\nThe point is, your development should always take place on a branch—never on a detached HEAD. This makes sure you always have a reference to your new commits. However, if you’re just looking at an old commit, it doesn’t really matter if you’re in a detached HEAD state or not.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1088
        }
      },
      {
        "header": "Summary",
        "content": "This page focused on usage of the git checkout command when changing branches. In summation, git checkout, when used on branches, alters the target of the HEAD ref. It can be used to create branches, switch branches, and checkout remote branches. The git checkout command is an essential tool for standard Git operation. It is a counterpart to git merge. The git checkout and git merge commands are critical tools to enabling git workflows.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 440
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/using-branches/git-checkout",
    "doc_type": "git",
    "total_sections": 10
  },
  {
    "title": "Git merge",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "Merging is Git's way of putting a forked history back together again. The git merge command lets you take the independent lines of development created by git branch and integrate them into a single branch.\n\nNote that all of the commands presented below merge into the current branch. The current branch will be updated to reflect the merge, but the target branch will be completely unaffected. Again, this means that git merge is often used in conjunction with git checkout for selecting the current branch and git branch -d for deleting the obsolete target branch.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 565
        }
      },
      {
        "header": "How it works",
        "content": "Git merge will combine multiple sequences of commits into one unified history. In the most frequent use cases, git merge is used to combine two branches. The following examples in this document will focus on this branch merging pattern. In these scenarios, git merge takes two commit pointers, usually the branch tips, and will find a common base commit between them. Once Git finds a common base commit it will create a new \"merge commit\" that combines the changes of each queued merge commit sequence.\n\nSay we have a new branch feature that is based off the main branch. We now want to merge this feature branch into main.\n\nInvoking this command will merge the specified branch feature into the current branch, we'll assume main. Git will determine the merge algorithm automatically (discussed below).\n\nMerge commits are unique against other commits in the fact that they have two parent commits. When creating a merge commit Git will attempt to auto magically merge the separate histories for you. If Git encounters a piece of data that is changed in both histories it will be unable to automatically combine them. This scenario is a version control conflict and Git will need user intervention to continue.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1210
        }
      },
      {
        "header": "Preparing to merge",
        "content": "Before performing a merge there are a couple of preparation steps to take to ensure the merge goes smoothly.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 108
        }
      },
      {
        "header": "Confirm the receiving branch",
        "content": "Execute git status to ensure that HEAD is pointing to the correct merge-receiving branch. If needed, execute git checkout to switch to the receiving branch. In our case we will execute git checkout main.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 203
        }
      },
      {
        "header": "Fetch latest remote commits",
        "content": "Make sure the receiving branch and the merging branch are up-to-date with the latest remote changes. Execute git fetch to pull the latest remote commits. Once the fetch is completed ensure the main branch has the latest updates by executing git pull.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 250
        }
      },
      {
        "header": "Merging",
        "content": "Once the previously discussed \"preparing to merge\" steps have been taken a merge can be initiated by executing git merge where is the name of the branch that will be merged into the receiving branch.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 199
        }
      },
      {
        "header": "Fast forward merge",
        "content": "A fast-forward merge can occur when there is a linear path from the current branch tip to the target branch. Instead of “actually” merging the branches, all Git has to do to integrate the histories is move (i.e., “fast forward”) the current branch tip up to the target branch tip. This effectively combines the histories, since all of the commits reachable from the target branch are now available through the current one. For example, a fast forward merge of some-feature into main would look something like the following:\n\nHowever, a fast-forward merge is not possible if the branches have diverged. When there is not a linear path to the target branch, Git has no choice but to combine them via a 3-way merge. 3-way merges use a dedicated commit to tie together the two histories. The nomenclature comes from the fact that Git uses three commits to generate the merge commit: the two branch tips and their common ancestor.\n\nWhile you can use either of these merge strategies, many developers like to use fast-forward merges (facilitated through rebasing) for small features or bug fixes, while reserving 3-way merges for the integration of longer-running features. In the latter case, the resulting merge commit serves as a symbolic joining of the two branches.\n\nOur first example demonstrates a fast-forward merge. The code below creates a new branch, adds two commits to it, then integrates it into the main line with a fast-forward merge.\n\nThis is a common workflow for short-lived topic branches that are used more as an isolated development than an organizational tool for longer-running features.\n\nAlso note that Git should not complain about the git branch -d, since new-feature is now accessible from the main branch.\n\nIn the event that you require a merge commit during a fast forward merge for record keeping purposes you can execute git merge with the --no-ff option.\n\nThis command merges the specified branch into the current branch, but always generates a merge commit (even if it was a fast-forward merge). This is useful for documenting all merges that occur in your repository.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# Start a new featuregit checkout -b new-feature main# Edit some filesgit add <file>git commit -m \"Start a feature\"# Edit some filesgit add <file>git commit -m \"Finish a feature\"# Merge in the new-feature branchgit checkout maingit merge new-featuregit branch -d new-feature\n```",
          "```bash\ngit merge --no-ff <branch>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 2096
        }
      },
      {
        "header": "3-way merge",
        "content": "The next example is very similar, but requires a 3-way merge because main progresses while the feature is in-progress. This is a common scenario for large features or when several developers are working on a project simultaneously.\n\nNote that it’s impossible for Git to perform a fast-forward merge, as there is no way to move main up to new-feature without backtracking.\n\nFor most workflows, new-feature would be a much larger feature that took a long time to develop, which would be why new commits would appear on main in the meantime. If your feature branch was actually as small as the one in the above example, you would probably be better off rebasing it onto main and doing a fast-forward merge. This prevents superfluous merge commits from cluttering up the project history.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nStart a new featuregit checkout -b new-feature main# Edit some filesgit add <file>git commit -m \"Start a feature\"# Edit some filesgit add <file>git commit -m \"Finish a feature\"# Develop the main branchgit checkout main# Edit some filesgit add <file>git commit -m \"Make some super-stable changes to main\"# Merge in the new-feature branchgit merge new-featuregit branch -d new-feature\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 783
        }
      },
      {
        "header": "Resolving conflict",
        "content": "If the two branches you're trying to merge both changed the same part of the same file, Git won't be able to figure out which version to use. When such a situation occurs, it stops right before the merge commit so that you can resolve the conflicts manually.\n\nThe great part of Git's merging process is that it uses the familiar edit/stage/commit workflow to resolve merge conflicts. When you encounter a merge conflict, running the git status command shows you which files need to be resolved. For example, if both branches modified the same section of hello.py, you would see something like the following:",
        "code_examples": [],
        "usage_examples": [
          "```bash\nOn branch mainUnmerged paths:(use \"git add/rm ...\" as appropriate to mark resolution)both modified: hello.py\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 607
        }
      },
      {
        "header": "How conflicts are presented",
        "content": "When Git encounters a conflict during a merge, It will edit the content of the affected files with visual indicators that mark both sides of the conflicted content. These visual markers are: <<<<<<<, =======, and >>>>>>>. It's helpful to search a project for these indicators during a merge to find where conflicts need to be resolved.\n\nGenerally the content before the ======= marker is the receiving branch and the part after is the merging branch.\n\nOnce you've identified conflicting sections, you can go in and fix up the merge to your liking. When you're ready to finish the merge, all you have to do is run git add on the conflicted file(s) to tell Git they're resolved. Then, you run a normal git commit to generate the merge commit. It’s the exact same process as committing an ordinary snapshot, which means it’s easy for normal developers to manage their own merges.\n\nNote that merge conflicts will only occur in the event of a 3-way merge. It’s not possible to have conflicting changes in a fast-forward merge.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nhere is some content not affected by the conflict<<<<<<< mainthis is conflicted text from main=======this is conflicted text from feature branch>>>>>>> feature branch;\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1021
        }
      },
      {
        "header": "Summary",
        "content": "This document is an overview of the git merge command. Merging is an essential process when working with Git. We discussed the internal mechanics behind a merge and the differences between a fast forward merge and a three way, true merge. Some key take-aways are:\n\n1. Git merging combines sequences of commits into one unified history of commits.\n\n2. There are two main ways Git will merge: Fast Forward and Three way\n\n3. Git can automatically merge commits unless there are changes that conflict in both commit sequences.\n\nThis document integrated and referenced other Git commands like: git branch, git pull, and git fetch. Visit their corresponding stand-alone pages for more information.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 691
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/using-branches/git-merge",
    "doc_type": "git",
    "total_sections": 13
  },
  {
    "title": "Git merge conflicts",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "Version control systems are all about managing contributions between multiple distributed authors ( usually developers ). Sometimes multiple developers may try to edit the same content. If Developer A tries to edit code that Developer B is editing a conflict may occur. To alleviate the occurrence of conflicts developers will work in separate isolated branches. The git merge command's primary responsibility is to combine separate branches and resolve any conflicting edits.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 476
        }
      },
      {
        "header": "Understanding merge conflicts",
        "content": "Conflicts generally arise when two people have changed the same lines in a file, or if one developer deleted a file while another developer was modifying it. In these cases, Git cannot automatically determine what is correct. Conflicts only affect the developer conducting the merge, the rest of the team is unaware of the conflict. Git will mark the file as being conflicted and halt the merging process. It is then the developers' responsibility to resolve the conflict.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 472
        }
      },
      {
        "header": "Types of merge conflicts",
        "content": "A merge can enter a conflicted state at two separate points. When starting and during a merge process. The following is a discussion of how to address each of these conflict scenarios.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 184
        }
      },
      {
        "header": "Git fails to start the merge",
        "content": "A merge will fail to start when Git sees there are changes in either the working directory or staging area of the current project. Git fails to start the merge because these pending changes could be written over by the commits that are being merged in. When this happens, it is not because of conflicts with other developer's, but conflicts with pending local changes. The local state will need to be stabilized using git stash, git checkout, git commit or git reset. A merge failure on start will output the following error message:",
        "code_examples": [
          "```bash\nerror: Entry '<fileName>' not uptodate. Cannot merge. (Changes in working directory)\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 533
        }
      },
      {
        "header": "Git fails during the merge",
        "content": "A failure DURING a merge indicates a conflict between the current local branch and the branch being merged. This indicates a conflict with another developers code. Git will do its best to merge the files but will leave things for you to resolve manually in the conflicted files. A mid-merge failure will output the following error message:",
        "code_examples": [
          "```bash\nerror: Entry '<fileName>' would be overwritten by merge. Cannot merge. (Changes in staging area)\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 339
        }
      },
      {
        "header": "Creating a merge conflict",
        "content": "In order to get real familiar with merge conflicts, the next section will simulate a conflict to later examine and resolve. The example will be using a Unix-like command-line Git interface to execute the example simulation.\n\nThis code example executes a sequence of commands that accomplish the following.\n\nNow we have a new repo with one branch main and a file merge.txt with content in it. Next, we will create a new branch to use as the conflicting merge.\n\nThe proceeding command sequence achieves the following:\n\nWith this new branch: new_branch_to_merge_later we have created a commit that overrides the content of merge.txt\n\nThis chain of commands checks out the main branch, appends content to merge.txt, and commits it. This now puts our example repo in a state where we have 2 new commits. One in the main branch and one in the new_branch_to_merge_later branch. At this time lets git merge new_branch_to_merge_later and see what happen!\n\nBOOM 💥. A conflict appears. Thanks, Git for letting us know about this!\n\n• Create a new directory named git-merge-test, change to that directory, and initialize it as a new Git repo.\n• Create a new text file merge.txt with some content in it.\n• Add merge.txt to the repo and commit it.\n\n• create and check out a new branch named new_branch_to_merge_later\n• overwrite the content in merge.txt\n• commit the new content",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ mkdir git-merge-test$ cd git-merge-test$ git init .$ echo \"this is some content to mess with\" > merge.txt$ git add merge.txt$ git commit -am\"we are commiting the inital content\"[main (root-commit) d48e74c] we are commiting the inital content1 file changed, 1 insertion(+)create mode 100644 merge.txt\n```",
          "```bash\n$ git checkout -b new_branch_to_merge_later$ echo \"totally different content to merge later\" > merge.txt$ git commit -am\"edited the content of merge.txt to cause a conflict\"[new_branch_to_merge_later 6282319] edited the content of merge.txt to cause a conflict1 file changed, 1 insertion(+), 1 deletion(-)\n```",
          "```bash\ngit checkout mainSwitched to branch 'main'echo \"content to append\" >> merge.txtgit commit -am\"appended content to merge.txt\"[main 24fbe3c] appended content to merge.tx1 file changed, 1 insertion(+)\n```",
          "```bash\n$ git merge new_branch_to_merge_laterAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1363
        }
      },
      {
        "header": "How to identify merge conflicts",
        "content": "As we have experienced from the proceeding example, Git will produce some descriptive output letting us know that a CONFLICT has occcured. We can gain further insight by running the git status command\n\nThe output from git status indicates that there are unmerged paths due to a conflict. The merge.text file now appears in a modified state. Let's examine the file and see whats modified.\n\nHere we have used the cat command to put out the contents of the merge.txt file. We can see some strange new additions\n\nThink of these new lines as \"conflict dividers\". The ======= line is the \"center\" of the conflict. All the content between the center and the <<<<<<< HEAD line is content that exists in the current branch main which the HEAD ref is pointing to. Alternatively all content between the center and >>>>>>> new_branch_to_merge_later is content that is present in our merging branch.\n\n• <<<<<<< HEAD\n• >>>>>>> new_branch_to_merge_later",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git statusOn branch mainYou have unmerged paths.(fix conflicts and run \"git commit\")(use \"git merge --abort\" to abort the merge)Unmerged paths:(use \"git add <file>...\" to mark resolution)both modified:   merge.txt\n```",
          "```bash\n$ cat merge.txt<<<<<<< HEADthis is some content to mess withcontent to append=======totally different content to merge later>>>>>>> new_branch_to_merge_later\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 938
        }
      },
      {
        "header": "How to resolve merge conflicts using the command line",
        "content": "The most direct way to resolve a merge conflict is to edit the conflicted file. Open the merge.txt file in your favorite editor. For our example lets simply remove all the conflict dividers. The modified merge.txt content should then look like:\n\nOnce the file has been edited use git add merge.txt to stage the new merged content. To finalize the merge create a new commit by executing:\n\nGit will see that the conflict has been resolved and creates a new merge commit to finalize the merge.",
        "code_examples": [
          "```bash\nthis is some content to mess withcontent to appendtotally different content to merge later\n```"
        ],
        "usage_examples": [
          "```bash\ngit commit -m \"merged and resolved the conflict in merge.txt\"\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 490
        }
      },
      {
        "header": "General tools",
        "content": "The status command is in frequent use when a working with Git and during a merge it will help identify conflicted files.\n\nPassing the --merge argument to the git log command will produce a log with a list of commits that conflict between the merging branches.\n\ndiff helps find differences between states of a repository/files. This is useful in predicting and preventing merge conflicts.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit status\n```",
          "```bash\ngit log --merge\n```",
          "```bash\ngit diff\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 387
        }
      },
      {
        "header": "Tools for when git fails to start a merge",
        "content": "checkout can be used for undoing changes to files, or for changing branches\n\nreset can be used to undo changes to the working directory and staging area.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout\n```",
          "```bash\ngit reset --mixed\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 153
        }
      },
      {
        "header": "Tools for when git conflicts arise during a merge",
        "content": "Executing git merge with the --abort option will exit from the merge process and return the branch to the state before the merge began.\n\nGit reset can be used during a merge conflict to reset conflicted files to a know good state",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit merge --abort\n```",
          "```bash\ngit reset\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 229
        }
      },
      {
        "header": "Summary",
        "content": "Merge conflicts can be an intimidating experience. Luckily, Git offers powerful tools to help navigate and resolve conflicts. Git can handle most merges on its own with automatic merging features. A conflict arises when two separate branches have made edits to the same line in a file, or when a file has been deleted in one branch but edited in the other. Conflicts will most likely happen when working in a team environment.\n\nThere are many tools to help resolve merge conflicts. Git has plenty of command line tools we discussed here. For more detailed information on these tools visit stand-alone pages for git log, git reset, git status, git checkout, and git reset. In addition to the Git, many third-party tools offer streamlined merge conflict support features.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 769
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/using-branches/merge-conflicts",
    "doc_type": "git",
    "total_sections": 14
  },
  {
    "title": "Git merge strategy options and examples",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "When a piece of work is complete, tested and ready to be merged back into the main line of development, your team has some policy choices to make. What are your merge strategy options? In this article we'll examine the possibilities and then provide some notes on how Atlassian operates. Hopefully at the end you'll have the tools to decide what works best for your team.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 371
        }
      },
      {
        "header": "Git merge strategies",
        "content": "A merge happens when combining two branches. Git will take two (or more) commit pointers and attempt to find a common base commit between them. Git has several different methods to find a base commit, these methods are called \"merge strategies\". Once Git finds a common base commit it will create a new \"merge commit\" that combines the changes of the specified merge commits. Technically, a merge commit is a regular commit which just happens to have two parent commits.\n\ngit merge will automatically select a merge strategy unless explicitly specified. The git merge and git pull commands can be passed an -s (strategy) option. The -s option can be appended with the name of the desired merge strategy. If not explicitly specified, Git will select the most appropriate merge strategy based on the provided branches. The following is a list of the available merge strategies.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 875
        }
      },
      {
        "header": "Recursive",
        "content": "This operates on two heads. Recursive is the default merge strategy when pulling or merging one branch. Additionally this can detect and handle merges involving renames, but currently cannot make use of detected copies. This is the default merge strategy when pulling or merging one branch.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit merge -s recursive branch1 branch2\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 290
        }
      },
      {
        "header": "Resolve",
        "content": "This can only resolve two heads using a 3-way merge algorithm. It tries to carefully detect cris-cross merge ambiguities and is considered generally safe and fast.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit merge -s resolve branch1 branch2\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 163
        }
      },
      {
        "header": "Octopus",
        "content": "The default merge strategy for more than two heads. When more than one branch is passed octopus is automatically engaged. If a merge has conflicts that need manual resolution octopus will refuse the merge attempt. It is primarily used for bundling similar feature branch heads together.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit merge -s octopus branch1 branch2 branch3 branchN\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 286
        }
      },
      {
        "header": "Ours",
        "content": "The Ours strategy operates on multiple N number of branches. The output merge result is always that of the current branch HEAD. The \"ours\" term implies the preference effectively ignoring all changes from all other branches. It is intended to be used to combine history of similar feature branches.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit merge -s ours branch1 branch2 branchN\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 298
        }
      },
      {
        "header": "Subtree",
        "content": "This is an extension of the recursive strategy. When merging A and B, if B is a child subtree of A, B is first updated to reflect the tree structure of A, This update is also done to the common ancestor tree that is shared between A and B.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit merge -s subtree branchA branchB\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 239
        }
      },
      {
        "header": "Explicit merges",
        "content": "Explicit merges are the default merge type. The 'explicit' part is that they create a new merge commit. This alters the commit history and explicitly shows where a merge was executed. The merge commit content is also explicit in the fact that it shows which commits were the parents of the merge commit. Some teams avoid explicit merges because arguably the merge commits add \"noise\" to the history of the project.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 414
        }
      },
      {
        "header": "Recursive git merge strategy options",
        "content": "The 'recursive' strategy introduced above, has its own subset of additional operation options.\n\nNot to be confused with the Ours merge strategy. This option conflicts to be auto-resolved cleanly by favoring the 'our' version. Changes from the 'theirs' side are automatically incorporated if they do not conflict.\n\nThe opposite of the 'ours' strategy. the \"theirs\" option favors the foreign merging tree in conflict resolution.\n\nThis option spends extra time to avoid mis-merges on unimportant matching lines. This options is best used when branches to be merged have extremely diverged.\n\nA set of options that target whitespace characters. Any line that matches the subset of the passed option will be ignored.\n\nThis option runs a check-out and check-in on all of the tree git trees while resolving a three-way merge. This option is intended to be used with merging branches with differing checkin/checkout states.\n\nDisables the renormalize option. This overrides the merge.renormalize configuration variable.\n\nThis option will ignore renamed files during the merge.\n\nThis is the default behavior. The recursive merge will honor file renames. The n parameter can be used to pass a threshold for rename similarity. The default n value is 100%.\n\nThis option borrows from the `subtree` strategy. Where the strategy operates on two trees and modifies how to make them match on a shared ancestor, this option instead operates on the path metadata of the tree to make them match.",
        "code_examples": [
          "```bash\ntheirs\n```",
          "```bash\npatience\n```",
          "```bash\ndiff-algorithim\n```",
          "```bash\nignore-*ignore-space-changeignore-all-spaceignore-space-at-eolignore-cr-at-eol\n```",
          "```bash\nrenormalize\n```",
          "```bash\nno-normalize\n```",
          "```bash\nno-renames\n```",
          "```bash\nfind-renames=n\n```",
          "```bash\nsubtree\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 1473
        }
      },
      {
        "header": "Our git merge policy",
        "content": "Atlassian strongly prefers using explicit merges. The reason is very simple: explicit merges provide great traceability and context on the features being merged. A local history clean-up rebase before sharing a feature branch for review is absolutely encouraged, but this does not change the policy at all. It augments it.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 322
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/using-branches/merge-strategy",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Git remote",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "SVN uses a single centralized repository to serve as the communication hub for developers, and collaboration takes place by passing changesets between the developers’ working copies and the central repository. This is different from Git's distributed collaboration model, which gives every developer their own copy of the repository, complete with its own local history and branch structure. Users typically need to share a series of commits rather than a single changeset. Instead of committing a changeset from a working copy to the central repository, Git lets you share entire branches between repositories.\n\nThe git remote command is one piece of the broader system which is responsible for syncing changes. Records registered through the git remote command are used in conjunction with the git fetch, git push, and git pull commands. These commands all have their own syncing responsibilities which can be explored on the corresponding links.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 948
        }
      },
      {
        "header": "Git remote",
        "content": "The git remote command lets you create, view, and delete connections to other repositories. Remote connections are more like bookmarks rather than direct links into other repositories. Instead of providing real-time access to another repository, they serve as convenient names that can be used to reference a not-so-convenient URL.\n\nFor example, the following diagram shows two remote connections from your repo into the central repo and another developer’s repo. Instead of referencing them by their full URLs, you can pass the origin and john shortcuts to other Git commands.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 577
        }
      },
      {
        "header": "Git remote usage overview",
        "content": "The git remote command is essentially an interface for managing a list of remote entries that are stored in the repository's ./.git/config file. The following commands are used to view the current state of the remote list.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 222
        }
      },
      {
        "header": "Viewing git remote configurations",
        "content": "List the remote connections you have to other repositories.\n\nSame as the above command, but include the URL of each connection.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit remote\n```",
          "```bash\ngit remote -v\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 127
        }
      },
      {
        "header": "Creating and modifying git remote configurations",
        "content": "The git remote command is also a convenience or 'helper' method for modifying a repo's ./.git/config file. The commands presented below let you manage connections with other repositories. The following commands will modify the repo's /.git/config file. The result of the following commands can also be achieved by directly editing the ./.git/config file with a text editor.\n\nCreate a new connection to a remote repository. After adding a remote, you’ll be able to use ＜name＞ as a convenient shortcut for ＜url＞ in other Git commands.\n\nRemove the connection to the remote repository called ＜name＞.\n\nRename a remote connection from ＜old-name＞ to ＜new-name＞.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit remote add <name> <url>\n```",
          "```bash\ngit remote rm <name>\n```",
          "```bash\ngit remote rename <old-name> <new-name>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 654
        }
      },
      {
        "header": "Git remote discussion",
        "content": "Git is designed to give each developer an entirely isolated development environment. This means that information is not automatically passed back and forth between repositories. Instead, developers need to manually pull upstream commits into their local repository or manually push their local commits back up to the central repository. The git remote command is really just an easier way to pass URLs to these \"sharing\" commands.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 430
        }
      },
      {
        "header": "The origin Remote",
        "content": "When you clone a repository with git clone, it automatically creates a remote connection called origin pointing back to the cloned repository. This is useful for developers creating a local copy of a central repository, since it provides an easy way to pull upstream changes or publish local commits. This behavior is also why most Git-based projects call their central repository origin.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 388
        }
      },
      {
        "header": "Repository URLs",
        "content": "Git supports many ways to reference a remote repository. Two of the easiest ways to access a remote repo are via the HTTP and the SSH protocols. HTTP is an easy way to allow anonymous, read-only access to a repository. For example:\n\nBut, it’s generally not possible to push commits to an HTTP address (you wouldn’t want to allow anonymous pushes anyways). For read-write access, you should use SSH instead:\n\nYou’ll need a valid SSH account on the host machine, but other than that, Git supports authenticated access via SSH out of the box. Modern secure 3rd party hosting solutions like Bitbucket.com will provide these URLs for you.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nhttp://host/path/to/repo.git\n```",
          "```bash\nssh://user@host/path/to/repo.git\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 633
        }
      },
      {
        "header": "Git remote commands",
        "content": "The git remote command is one of many Git commands that takes additional appended 'subcommands'. Below is an examination of the commonly used git remote subcommands.\n\nAdds a record to ./.git/config for remote named ＜name＞ at the repository url ＜url＞.\n\nAccepts a -f option, that will git fetch immediately after the remote record is created.\n\nAccepts a --tags option, that will git fetch immediately and import every tag from the remote repository.\n\nUpdates ./.git/config to rename the record ＜OLD＞ to ＜NEW＞. All remote-tracking branches and configuration settings for the remote are updated.\n\nModifies ./.git/config and removes the remote named ＜NAME＞. All remote-tracking branches and configuration settings for the remote are removed.\n\nOutputs the URLs for a remote record.\n\nAccepts --push, push URLs are queried rather than fetch URLs.\n\nWith --all, all URLs for the remote will be listed.\n\nOutputs high-level information about the remote ＜NAME＞.\n\nDeletes any local branches for ＜NAME＞ that are not present on the remote repository.\n\nAccepts a --dry-run option which will list what branches are set to be pruned, but will not actually prune them.",
        "code_examples": [
          "```bash\nADD <NAME> <URL>\n```",
          "```bash\nRENAME <OLD> <NEW>\n```",
          "```bash\nREMOVE or RM <NAME>\n```",
          "```bash\nGET-URL <NAME>\n```",
          "```bash\nSHOW <NAME>\n```",
          "```bash\nPRUNE <NAME>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 12,
          "content_length": 1148
        }
      },
      {
        "header": "Git remote examples",
        "content": "In addition to origin, it’s often convenient to have a connection to your teammates’ repositories. For example, if your co-worker, John, maintained a publicly accessible repository on dev.example.com/john.git, you could add a connection as follows:\n\nHaving this kind of access to individual developers’ repositories makes it possible to collaborate outside of the central repository. This can be very useful for small teams working on a large project.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit remote add john http://dev.example.com/john.git\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 451
        }
      },
      {
        "header": "Showing your remotes",
        "content": "By default, the git remote command will list previously stored remote connections to other repositories. This will produce single line output that lists the names of \"bookmark\" name of remote repos.\n\nInvoking git remote with the -v option will print the list of bookmarked repository names and additionally, the corresponding repository URL. The -v option stands for \"verbose\". Below is example output of verbose git remote output.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git remoteoriginupstreamother_users_repo\n```",
          "```bash\ngit remote -vorigin  git@bitbucket.com:origin_user/reponame.git (fetch)origin  git@bitbucket.com:origin_user/reponame.git (push)upstream    https://bitbucket.com/upstream_user/reponame.git (fetch)upstream    https://bitbucket.com/upstream_user/reponame.git (push)other_users_repo    https://bitbucket.com/other_users_repo/reponame (fetch)other_users_repo    https://bitbucket.com/other_users_repo/reponame (push)\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 431
        }
      },
      {
        "header": "Adding remote repositories",
        "content": "The git remote add command will create a new connection record to a remote repository. After adding a remote, you’ll be able to use as a convenient shortcut for in other Git commands. For more information on the accepted URL syntax, view the \"Repository URLs\" section below. This command will create a new record within the repository's ./.git/config. An example of this config file update follows:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git remote add fake_test https://bitbucket.com/upstream_user/reponame.git; [remote \"remote_test\"]url = https://bitbucket.com/upstream_user/reponame.gitfetch = +refs/heads/*:refs/remotes/remote_test/*\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 398
        }
      },
      {
        "header": "Inspecting a Remote",
        "content": "The show subcommand can be appended to git remote to give detailed output on the configuration of a remote. This output will contain a list of branches associated with the remote and also the endpoints attached for fetching and pushing.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit remote show upstream* remote upstreamFetch URL: https://bitbucket.com/upstream_user/reponame.gitPush URL: https://bitbucket.com/upstream_user/reponame.gitHEAD branch: mainRemote branches:main trackedsimd-deprecated trackedtutorial trackedLocal ref configured for 'git push':main pushes to main (fast-forwardable)\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 236
        }
      },
      {
        "header": "Fetching and pulling from Git remotes",
        "content": "Once a remote record has been configured through the use of the git remote command, the remote name can be passed as an argument to other Git commands to communicate with the remote repo. Both git fetch, and git pull can be used to read from a remote repository. Both commands have different operations that are explained in further depth on their respective links.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 365
        }
      },
      {
        "header": "Pushing to Git remotes",
        "content": "The git push command is used to write to a remote repository.\n\nThis example will upload the local state of ＜branch-name＞ to the remote repository specified by ＜remote-name＞.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push <remote-name> <branch-name>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 173
        }
      },
      {
        "header": "Renaming and removing remotes",
        "content": "The command git remote rename is self-explanatory. When executed, this command will rename a remote connection from ＜old-name＞ to ＜new-name＞. Additionally, this will modify the contents of ./.git/config to rename the record for the remote there as well.\n\nThe command git remote rm will remove the connection to the remote repository specified by the ＜name＞ parameter. To demonstrate let us 'undo' the remote addition from our last example. If we execute git remote rm remote_test, and then examine the contents of ./.git/config we can see that the [remote \"remote_test\"] record is no longer there.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit remote rename <old-name> <new-name>\n```",
          "```bash\ngit remote rm <name>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 597
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/syncing",
    "doc_type": "git",
    "total_sections": 18
  },
  {
    "title": "Git remote",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "SVN uses a single centralized repository to serve as the communication hub for developers, and collaboration takes place by passing changesets between the developers’ working copies and the central repository. This is different from Git's distributed collaboration model, which gives every developer their own copy of the repository, complete with its own local history and branch structure. Users typically need to share a series of commits rather than a single changeset. Instead of committing a changeset from a working copy to the central repository, Git lets you share entire branches between repositories.\n\nThe git remote command is one piece of the broader system which is responsible for syncing changes. Records registered through the git remote command are used in conjunction with the git fetch, git push, and git pull commands. These commands all have their own syncing responsibilities which can be explored on the corresponding links.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 948
        }
      },
      {
        "header": "Git remote",
        "content": "The git remote command lets you create, view, and delete connections to other repositories. Remote connections are more like bookmarks rather than direct links into other repositories. Instead of providing real-time access to another repository, they serve as convenient names that can be used to reference a not-so-convenient URL.\n\nFor example, the following diagram shows two remote connections from your repo into the central repo and another developer’s repo. Instead of referencing them by their full URLs, you can pass the origin and john shortcuts to other Git commands.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 577
        }
      },
      {
        "header": "Git remote usage overview",
        "content": "The git remote command is essentially an interface for managing a list of remote entries that are stored in the repository's ./.git/config file. The following commands are used to view the current state of the remote list.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 222
        }
      },
      {
        "header": "Viewing git remote configurations",
        "content": "List the remote connections you have to other repositories.\n\nSame as the above command, but include the URL of each connection.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit remote\n```",
          "```bash\ngit remote -v\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 127
        }
      },
      {
        "header": "Creating and modifying git remote configurations",
        "content": "The git remote command is also a convenience or 'helper' method for modifying a repo's ./.git/config file. The commands presented below let you manage connections with other repositories. The following commands will modify the repo's /.git/config file. The result of the following commands can also be achieved by directly editing the ./.git/config file with a text editor.\n\nCreate a new connection to a remote repository. After adding a remote, you’ll be able to use ＜name＞ as a convenient shortcut for ＜url＞ in other Git commands.\n\nRemove the connection to the remote repository called ＜name＞.\n\nRename a remote connection from ＜old-name＞ to ＜new-name＞.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit remote add <name> <url>\n```",
          "```bash\ngit remote rm <name>\n```",
          "```bash\ngit remote rename <old-name> <new-name>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 654
        }
      },
      {
        "header": "Git remote discussion",
        "content": "Git is designed to give each developer an entirely isolated development environment. This means that information is not automatically passed back and forth between repositories. Instead, developers need to manually pull upstream commits into their local repository or manually push their local commits back up to the central repository. The git remote command is really just an easier way to pass URLs to these \"sharing\" commands.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 430
        }
      },
      {
        "header": "The origin Remote",
        "content": "When you clone a repository with git clone, it automatically creates a remote connection called origin pointing back to the cloned repository. This is useful for developers creating a local copy of a central repository, since it provides an easy way to pull upstream changes or publish local commits. This behavior is also why most Git-based projects call their central repository origin.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 388
        }
      },
      {
        "header": "Repository URLs",
        "content": "Git supports many ways to reference a remote repository. Two of the easiest ways to access a remote repo are via the HTTP and the SSH protocols. HTTP is an easy way to allow anonymous, read-only access to a repository. For example:\n\nBut, it’s generally not possible to push commits to an HTTP address (you wouldn’t want to allow anonymous pushes anyways). For read-write access, you should use SSH instead:\n\nYou’ll need a valid SSH account on the host machine, but other than that, Git supports authenticated access via SSH out of the box. Modern secure 3rd party hosting solutions like Bitbucket.com will provide these URLs for you.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nhttp://host/path/to/repo.git\n```",
          "```bash\nssh://user@host/path/to/repo.git\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 633
        }
      },
      {
        "header": "Git remote commands",
        "content": "The git remote command is one of many Git commands that takes additional appended 'subcommands'. Below is an examination of the commonly used git remote subcommands.\n\nAdds a record to ./.git/config for remote named ＜name＞ at the repository url ＜url＞.\n\nAccepts a -f option, that will git fetch immediately after the remote record is created.\n\nAccepts a --tags option, that will git fetch immediately and import every tag from the remote repository.\n\nUpdates ./.git/config to rename the record ＜OLD＞ to ＜NEW＞. All remote-tracking branches and configuration settings for the remote are updated.\n\nModifies ./.git/config and removes the remote named ＜NAME＞. All remote-tracking branches and configuration settings for the remote are removed.\n\nOutputs the URLs for a remote record.\n\nAccepts --push, push URLs are queried rather than fetch URLs.\n\nWith --all, all URLs for the remote will be listed.\n\nOutputs high-level information about the remote ＜NAME＞.\n\nDeletes any local branches for ＜NAME＞ that are not present on the remote repository.\n\nAccepts a --dry-run option which will list what branches are set to be pruned, but will not actually prune them.",
        "code_examples": [
          "```bash\nADD <NAME> <URL>\n```",
          "```bash\nRENAME <OLD> <NEW>\n```",
          "```bash\nREMOVE or RM <NAME>\n```",
          "```bash\nGET-URL <NAME>\n```",
          "```bash\nSHOW <NAME>\n```",
          "```bash\nPRUNE <NAME>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 12,
          "content_length": 1148
        }
      },
      {
        "header": "Git remote examples",
        "content": "In addition to origin, it’s often convenient to have a connection to your teammates’ repositories. For example, if your co-worker, John, maintained a publicly accessible repository on dev.example.com/john.git, you could add a connection as follows:\n\nHaving this kind of access to individual developers’ repositories makes it possible to collaborate outside of the central repository. This can be very useful for small teams working on a large project.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit remote add john http://dev.example.com/john.git\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 451
        }
      },
      {
        "header": "Showing your remotes",
        "content": "By default, the git remote command will list previously stored remote connections to other repositories. This will produce single line output that lists the names of \"bookmark\" name of remote repos.\n\nInvoking git remote with the -v option will print the list of bookmarked repository names and additionally, the corresponding repository URL. The -v option stands for \"verbose\". Below is example output of verbose git remote output.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git remoteoriginupstreamother_users_repo\n```",
          "```bash\ngit remote -vorigin  git@bitbucket.com:origin_user/reponame.git (fetch)origin  git@bitbucket.com:origin_user/reponame.git (push)upstream    https://bitbucket.com/upstream_user/reponame.git (fetch)upstream    https://bitbucket.com/upstream_user/reponame.git (push)other_users_repo    https://bitbucket.com/other_users_repo/reponame (fetch)other_users_repo    https://bitbucket.com/other_users_repo/reponame (push)\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 431
        }
      },
      {
        "header": "Adding remote repositories",
        "content": "The git remote add command will create a new connection record to a remote repository. After adding a remote, you’ll be able to use as a convenient shortcut for in other Git commands. For more information on the accepted URL syntax, view the \"Repository URLs\" section below. This command will create a new record within the repository's ./.git/config. An example of this config file update follows:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git remote add fake_test https://bitbucket.com/upstream_user/reponame.git; [remote \"remote_test\"]url = https://bitbucket.com/upstream_user/reponame.gitfetch = +refs/heads/*:refs/remotes/remote_test/*\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 398
        }
      },
      {
        "header": "Inspecting a Remote",
        "content": "The show subcommand can be appended to git remote to give detailed output on the configuration of a remote. This output will contain a list of branches associated with the remote and also the endpoints attached for fetching and pushing.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit remote show upstream* remote upstreamFetch URL: https://bitbucket.com/upstream_user/reponame.gitPush URL: https://bitbucket.com/upstream_user/reponame.gitHEAD branch: mainRemote branches:main trackedsimd-deprecated trackedtutorial trackedLocal ref configured for 'git push':main pushes to main (fast-forwardable)\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 236
        }
      },
      {
        "header": "Fetching and pulling from Git remotes",
        "content": "Once a remote record has been configured through the use of the git remote command, the remote name can be passed as an argument to other Git commands to communicate with the remote repo. Both git fetch, and git pull can be used to read from a remote repository. Both commands have different operations that are explained in further depth on their respective links.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 365
        }
      },
      {
        "header": "Pushing to Git remotes",
        "content": "The git push command is used to write to a remote repository.\n\nThis example will upload the local state of ＜branch-name＞ to the remote repository specified by ＜remote-name＞.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push <remote-name> <branch-name>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 173
        }
      },
      {
        "header": "Renaming and removing remotes",
        "content": "The command git remote rename is self-explanatory. When executed, this command will rename a remote connection from ＜old-name＞ to ＜new-name＞. Additionally, this will modify the contents of ./.git/config to rename the record for the remote there as well.\n\nThe command git remote rm will remove the connection to the remote repository specified by the ＜name＞ parameter. To demonstrate let us 'undo' the remote addition from our last example. If we execute git remote rm remote_test, and then examine the contents of ./.git/config we can see that the [remote \"remote_test\"] record is no longer there.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit remote rename <old-name> <new-name>\n```",
          "```bash\ngit remote rm <name>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 597
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/syncing/git-remote",
    "doc_type": "git",
    "total_sections": 18
  },
  {
    "title": "Git fetch",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "The git fetch command downloads commits, files, and refs from a remote repository into your local repo. Fetching is what you do when you want to see what everybody else has been working on. It’s similar to svn update in that it lets you see how the central history has progressed, but it doesn’t force you to actually merge the changes into your repository. Git isolates fetched content from existing local content; it has absolutely no effect on your local development work. Fetched content has to be explicitly checked out using the git checkout command. This makes fetching a safe way to review commits before integrating them with your local repository.\n\nWhen downloading content from a remote repo, git pull and git fetch commands are available to accomplish the task. You can consider git fetch the 'safe' version of the two commands. It will download the remote content but not update your local repo's working state, leaving your current work intact. git pull is the more aggressive alternative; it will download the remote content for the active local branch and immediately execute git merge to create a merge commit for the new remote content. If you have pending changes in progress this will cause conflicts and kick-off the merge conflict resolution flow.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 1269
        }
      },
      {
        "header": "How git fetch works with remote branches",
        "content": "To better understand how git fetch works let us discuss how Git organizes and stores commits. Behind the scenes, in the repository's ./.git/objects directory, Git stores all commits, local and remote. Git keeps remote and local branch commits distinctly separate through the use of branch refs. The refs for local branches are stored in the ./.git/refs/heads/. Executing the git branch command will output a list of the local branch refs. The following is an example of git branch output with some demo branch names.\n\nExamining the contents of the /.git/refs/heads/ directory would reveal similar output.\n\nRemote branches are just like local branches, except they map to commits from somebody else’s repository. Remote branches are prefixed by the remote they belong to so that you don’t mix them up with local branches. Like local branches, Git also has refs for remote branches. Remote branch refs live in the ./.git/refs/remotes/ directory. The next example code snippet shows the branches you might see after fetching a remote repo conveniently named remote-repo:\n\nThis output displays the local branches we had previously examined but now displays them prefixed with origin/. Additionally, we now see the remote branches prefixed with remote-repo. You can check out a remote branch just like a local one, but this puts you in a detached HEAD state (just like checking out an old commit). You can think of them as read-only branches. To view your remote branches, simply pass the -r flag to the git branch command.\n\nYou can inspect remote branches with the usual git checkout and git log commands. If you approve the changes a remote branch contains, you can merge it into a local branch with a normal git merge. So, unlike SVN, synchronizing your local repository with a remote repository is actually a two-step process: fetch, then merge. The git pull command is a convenient shortcut for this process.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit branchmainfeature1debug2\n```",
          "```bash\nls ./.git/refs/heads/mainfeature1debug2\n```",
          "```bash\ngit branch -r# origin/main# origin/feature1# origin/debug2# remote-repo/main# remote-repo/other-feature\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1908
        }
      },
      {
        "header": "Git fetch commands and options",
        "content": "Fetch all of the branches from the repository. This also downloads all of the required commits and files from the other repository.\n\nSame as the above command, but only fetch the specified branch.\n\nA power move which fetches all registered remotes and their branches:\n\nThe --dry-run option will perform a demo run of the command. It will output examples of actions it will take during the fetch but not apply them.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit fetch <remote>\n```",
          "```bash\ngit fetch <remote> <branch>\n```",
          "```bash\ngit fetch --all\n```",
          "```bash\ngit fetch --dry-run\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 414
        }
      },
      {
        "header": "git fetch a remote branch",
        "content": "The following example will demonstrate how to fetch a remote branch and update your local working state to the remote contents. In this example, let us assume there is a central repo origin from which the local repository has been cloned from using the git clone command. Let us also assume an additional remote repository named coworkers_repo that contains a feature_branch which we will configure and fetch. With these assumptions set let us continue the example.\n\nFirstly we will need to configure the remote repo using the git remote command.\n\nHere we have created a reference to the coworker's repo using the repo URL. We will now pass that remote name to git fetch to download the contents.\n\nWe now locally have the contents of coworkers/feature_branch we will need the integrate this into our local working copy. We begin this process by using the git checkout command to checkout the newly downloaded remote branch.\n\nThe output from this checkout operation indicates that we are in a detached HEAD state. This is expected and means that our HEAD ref is pointing to a ref that is not in sequence with our local history. Being that HEAD is pointed at the coworkers/feature_branch ref, we can create a new local branch from that ref. The 'detached HEAD' output shows us how to do this using the git checkout command:\n\nHere we have created a new local branch named local_feature_branch. This puts updates HEAD to point at the latest remote content and we can continue development on it from this point.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit remote add coworkers_repo git@bitbucket.org:coworker/coworkers_repo.git\n```",
          "```bash\ngit fetch coworkers_repo coworkers/feature_branchfetching coworkers/feature_branch\n```",
          "```bash\ngit checkout coworkers/feature_branchNote: checking out coworkers/feature_branch'.You are in 'detached HEAD' state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example:git checkout -b <new-branch-name>\n```",
          "```bash\ngit checkout -b local_feature_branch\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1506
        }
      },
      {
        "header": "Synchronize origin with git fetch",
        "content": "The following example walks through the typical workflow for synchronizing your local repository with the central repository's main branch.\n\nThis will display the branches that were downloaded:\n\nThe commits from these new remote branches are shown as squares instead of circles in the diagram below. As you can see, git fetch gives you access to the entire branch structure of another repository.\n\nTo see what commits have been added to the upstream main, you can run a git log using origin/main as a filter:\n\nTo approve the changes and merge them into your local main branch use the following commands:\n\nThen we can use git merge origin/main:\n\nThe origin/main and main branches now point to the same commit, and you are synchronized with the upstream developments.",
        "code_examples": [
          "```bash\na1e8fb5..45e66a4 main -> origin/maina1e8fb5..9e8ab1c develop -> origin/develop* [new branch] some-feature -> origin/some-feature\n```"
        ],
        "usage_examples": [
          "```bash\ngit fetch origin\n```",
          "```bash\ngit log --oneline main..origin/main\n```",
          "```bash\ngit checkout maingit log origin/main\n```",
          "```bash\ngit merge origin/main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 765
        }
      },
      {
        "header": "Git fetch summary",
        "content": "In review, git fetch is a primary command used to download contents from a remote repository. git fetch is used in conjunction with git remote, git branch, git checkout, and git reset to update a local repository to the state of a remote. The git fetch command is a critical piece of collaborative git work flows. git fetch has similar behavior to git pull, however, git fetch can be considered a safer, nondestructive version.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 427
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/syncing/git-fetch",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "Git push",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "The git push command is used to upload local repository content to a remote repository. Pushing is how you transfer commits from your local repository to a remote repo. It's the counterpart to git fetch, but whereas fetching imports commits to local branches, pushing exports commits to remote branches. Remote branches are configured using the git remote command. Pushing has the potential to overwrite changes, caution should be taken when pushing. These issues are discussed below.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 484
        }
      },
      {
        "header": "Git push usage",
        "content": "Push the specified branch to , along with all of the necessary commits and internal objects. This creates a local branch in the destination repository. To prevent you from overwriting commits, Git won’t let you push when it results in a non-fast-forward merge in the destination repository.\n\nSame as the above command, but force the push even if it results in a non-fast-forward merge. Do not use the --force flag unless you’re absolutely sure you know what you’re doing.\n\nPush all of your local branches to the specified remote.\n\nTags are not automatically pushed when you push a branch or use the --all option. The --tags flag sends all of your local tags to the remote repository.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push <remote> <branch>\n```",
          "```bash\ngit push <remote> --force\n```",
          "```bash\ngit push <remote> --tags\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 683
        }
      },
      {
        "header": "Git push discussion",
        "content": "git push is most commonly used to publish an upload local changes to a central repository. After a local repository has been modified a push is executed to share the modifications with remote team members.\n\nThe above diagram shows what happens when your local main has progressed past the central repository’s main and you publish changes by running git push origin main. Notice how git push is essentially the same as running git merge main from inside the remote repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 476
        }
      },
      {
        "header": "Git push and syncing",
        "content": "git push is one component of many used in the overall Git \"syncing\" process. The syncing commands operate on remote branches which are configured using the git remote command. git push can be considered and 'upload' command whereas, git fetch and git pull can be thought of as 'download' commands. Once changesets have been moved via a download or upload a git merge may be performed at the destination to integrate the changes.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 428
        }
      },
      {
        "header": "Pushing to bare repositories",
        "content": "A frequently used, modern Git practice is to have a remotely hosted --bare repository act as a central origin repository. This origin repository is often hosted off-site with a trusted 3rd party like Bitbucket. Since pushing messes with the remote branch structure, It is safest and most common to push to repositories that have been created with the --bare flag. Bare repos don’t have a working directory so a push will not alter any in progress working directory content. For more information on bare repository creation, read about git init.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 544
        }
      },
      {
        "header": "Force pushing",
        "content": "Git prevents you from overwriting the central repository’s history by refusing push requests when they result in a non-fast-forward merge. So, if the remote history has diverged from your history, you need to pull the remote branch and merge it into your local one, then try pushing again. This is similar to how SVN makes you synchronize with the central repository via svn update before committing a changeset.\n\nThe --force flag overrides this behavior and makes the remote repository’s branch match your local one, deleting any upstream changes that may have occurred since you last pulled. The only time you should ever need to force push is when you realize that the commits you just shared were not quite right and you fixed them with a git commit --amend or an interactive rebase. However, you must be absolutely certain that none of your teammates have pulled those commits before using the --force option.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 914
        }
      },
      {
        "header": "Default git push",
        "content": "The following example describes one of the standard methods for publishing local contributions to the central repository. First, it makes sure your local main is up-to-date by fetching the central repository’s copy and rebasing your changes on top of them. The interactive rebase is also a good opportunity to clean up your commits before sharing them. Then, the git push command sends all of the commits on your local main to the central repository.\n\nSince we already made sure the local main was up-to-date, this should result in a fast-forward merge, and git push should not complain about any of the non-fast-forward issues discussed above.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout maingit fetch origin maingit rebase -i origin/main# Squash commits, fix up commit messages etc.git push origin main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 644
        }
      },
      {
        "header": "Amended force push",
        "content": "The git commit command accepts a --amend option which will update the previous commit. A commit is often amended to update the commit message or add new changes. Once a commit is amended a git push will fail because Git will see the amended commit and the remote commit as diverged content. The --force option must be used to push an amended commit.\n\nThe above example assumes it is being executed on an existing repository with a commit history. git commit --amend is used to update the previous commit. The amended commit is then force pushed using the --force option.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# make changes to a repo and git addgit commit --amend# update the existing commit messagegit push --force origin main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 570
        }
      },
      {
        "header": "Deleting a remote branch or tag",
        "content": "Sometimes branches need to be cleaned up for book keeping or organizational purposes. The fully delete a branch, it must be deleted locally and also remotely.\n\nThe above will delete the remote branch named branch_name passing a branch name prefixed with a colon to git push will delete the remote branch.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit branch -D branch_namegit push origin :branch_name\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 304
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/syncing/git-push",
    "doc_type": "git",
    "total_sections": 11
  },
  {
    "title": "Git pull",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "The git pull command is used to fetch and download content from a remote repository and immediately update the local repository to match that content. Merging remote upstream changes into your local repository is a common task in Git-based collaboration work flows. The git pull command is actually a combination of two other commands, git fetch followed by git merge. In the first stage of operation git pull will execute a git fetch scoped to the local branch that HEAD is pointed at. Once the content is downloaded, git pull will enter a merge workflow. A new merge commit will be-created and HEAD updated to point at the new commit.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 636
        }
      },
      {
        "header": "How it works",
        "content": "The git pull command first runs git fetch which downloads content from the specified remote repository. Then a git merge is executed to merge the remote content refs and heads into a new local merge commit. To better demonstrate the pull and merging process let us consider the following example. Assume we have a repository with a main branch and a remote origin.\n\nIn this scenario, git pull will download all the changes from the point where the local and main diverged. In this example, that point is E. git pull will fetch the diverged remote commits which are A-B-C. The pull process will then create a new local merge commit containing the content of the new diverged remote commits.\n\nIn the above diagram, we can see the new commit H. This commit is a new merge commit that contains the contents of remote A-B-C commits and has a combined log message. This example is one of a few git pull merging strategies. A --rebase option can be passed to git pull to use a rebase merging strategy instead of a merge commit. The next example will demonstrate how a rebase pull works. Assume that we are at a starting point of our first diagram, and we have executed git pull --rebase.\n\nIn this diagram, we can now see that a rebase pull does not create the new H commit. Instead, the rebase has copied the remote commits A--B--C and rewritten the local commits E--F--G to appear after them them in the local origin/main commit history.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1431
        }
      },
      {
        "header": "Common Options",
        "content": "Fetch the specified remote’s copy of the current branch and immediately merge it into the local copy. This is the same as git fetch ＜remote＞ followed by git merge origin/＜current-branch＞.\n\nSimilar to the default invocation, fetches the remote content but does not create a new merge commit.\n\nSame as the previous pull Instead of using git merge to integrate the remote branch with the local one, use git rebase.\n\nGives verbose output during a pull which displays the content being downloaded and the merge details.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit pull <remote>\n```",
          "```bash\ngit pull --no-commit <remote>\n```",
          "```bash\ngit pull --rebase <remote>\n```",
          "```bash\ngit pull --verbose\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 514
        }
      },
      {
        "header": "Git pull discussion",
        "content": "You can think of git pull as Git's version of svn update. It’s an easy way to synchronize your local repository with upstream changes. The following diagram explains each step of the pulling process.\n\nYou start out thinking your repository is synchronized, but then git fetch reveals that origin's version of main has progressed since you last checked it. Then git merge immediately integrates the remote main into the local one.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 429
        }
      },
      {
        "header": "Git pull and syncing",
        "content": "git pull is one of many commands that claim the responsibility of 'syncing' remote content. The git remote command is used to specify what remote endpoints the syncing commands will operate on. The git push command is used to upload content to a remote repository.\n\nThe git fetch command can be confused with git pull. They are both used to download remote content. An important safety distinction can be made between git pull and get fetch. git fetch can be considered the \"safe\" option whereas, git pull can be considered unsafe. git fetch will download the remote content and not alter the state of the local repository. Alternatively, git pull will download remote content and immediately attempt to change the local state to match that content. This may unintentionally cause the local repository to get in a conflicted state.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 831
        }
      },
      {
        "header": "Pulling via Rebase",
        "content": "The --rebase option can be used to ensure a linear history by preventing unnecessary merge commits. Many developers prefer rebasing over merging, since it’s like saying, \"I want to put my changes on top of what everybody else has done.\" In this sense, using git pull with the --rebase flag is even more like svn update than a plain git pull.\n\nIn fact, pulling with --rebase is such a common workflow that there is a dedicated configuration option for it:\n\nAfter running that command, all git pull commands will integrate via git rebase instead of git merge.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit config --global branch.autosetuprebase always\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 557
        }
      },
      {
        "header": "Git Pull Examples",
        "content": "The following examples demonstrate how to use git pull in common scenarios:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 75
        }
      },
      {
        "header": "Default Behavior",
        "content": "Executing the default invocation of git pull will is equivalent to git fetch origin HEAD and git merge HEAD where HEAD is ref pointing to the current branch.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit pull\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 157
        }
      },
      {
        "header": "Git pull on remotes",
        "content": "This example first performs a checkout and switches to the branch. Following that, the git pull is executed with being passed. This will implicitly pull down the newfeature branch from . Once the download is complete it will initiate a git merge.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout new_featuregit pull <remote repo>\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 246
        }
      },
      {
        "header": "Git pull rebase instead of merge",
        "content": "The following example demonstrates how to synchronize with the central repository's main branch using a rebase:\n\nThis simply moves your local changes onto the top of what everybody else has already contributed.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout maingit pull --rebase origin\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 210
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/syncing/git-pull",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Comparing Git workflows: What you should know",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "Git is the most commonly used version control system today. A Git workflow is a recipe or recommendation for how to use Git to accomplish work in a consistent and productive manner. Git workflows encourage developers and DevOps teams to leverage Git effectively and consistently. Git offers a lot of flexibility in how users manage changes. Given Git's focus on flexibility, there is no standardized process on how to interact with Git. When working with a team on a Git-managed project, it’s important to make sure the team is all in agreement on how the flow of changes will be applied. To ensure the team is on the same page, an agreed-upon Git workflow should be developed or selected. There are several publicized Git workflows that may be a good fit for your team. Here, we will discuss some of these Git workflow options.\n\nThe array of possible workflows can make it hard to know where to begin when implementing Git in the workplace. This page provides a starting point by surveying the most common Git workflows for software teams.\n\nAs you read through, remember that these workflows are designed to be guidelines rather than concrete rules. We want to show you what’s possible, so you can mix and match aspects from different workflows to suit your individual needs.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1276
        }
      },
      {
        "header": "What is a successful Git workflow?",
        "content": "When evaluating a workflow for your team, it's most important that you consider your team’s culture. You want the workflow to enhance the effectiveness of your team and not be a burden that limits productivity. Some things to consider when evaluating a Git workflow are:\n\n• Does this workflow scale with team size?\n• Is it easy to undo mistakes and errors with this workflow?\n• Does this workflow impose any new unnecessary cognitive overhead to the team?",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 455
        }
      },
      {
        "header": "Centralized workflow",
        "content": "The Centralized Workflow is a great Git workflow for teams transitioning from SVN. Like Subversion, the Centralized Workflow uses a central repository to serve as the single point-of-entry for all changes to the project. Instead of trunk, the default development branch is called main and all changes are committed into this branch. This workflow doesn’t require any other branches besides main.\n\nTransitioning to a distributed version control system may seem like a daunting task, but you don’t have to change your existing workflow to take advantage of Git. Your team can develop projects in the exact same way as they do with Subversion.\n\nHowever, using Git to power your development workflow presents a few advantages over SVN. First, it gives every developer their own local copy of the entire project. This isolated environment lets each developer work independently of all other changes to a project - they can add commits to their local repository and completely forget about upstream developments until it's convenient for them.\n\nSecond, it gives you access to Git’s robust branching and merging model. Unlike SVN, Git branches are designed to be a fail-safe mechanism for integrating code and sharing changes between repositories. The Centralized Workflow is similar to other workflows in its utilization of a remote server-side hosted repository that developers push and pull from. Compared to other workflows, the Centralized Workflow has no defined pull request or forking patterns. A Centralized Workflow is generally better suited for teams migrating from SVN to Git and smaller size teams.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1605
        }
      },
      {
        "header": "How it works",
        "content": "Developers start by cloning the central repository. In their own local copies of the project, they edit files and commit changes as they would with SVN; however, these new commits are stored locally - they’re completely isolated from the central repository. This lets developers defer synchronizing upstream until they’re at a convenient break point.\n\nTo publish changes to the official project, developers \"push\" their local main branch to the central repository. This is the equivalent of svn commit, except that it adds all of the local commits that aren’t already in the central main branch.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 595
        }
      },
      {
        "header": "Initialize the central repository",
        "content": "First, someone needs to create the central repository on a server. If it’s a new project, you can initialize an empty repository. Otherwise, you’ll need to import an existing Git or SVN repository.\n\nCentral repositories should always be bare repositories (they shouldn’t have a working directory), which can be created as follows:\n\nBe sure to use a valid SSH username for user, the domain or IP address of your server for host, and the location where you'd like to store your repo for /path/to/repo.git. Note that the .git extension is conventionally appended to the repository name to indicate that it’s a bare repository.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nssh user@host git init --bare /path/to/repo.git\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 623
        }
      },
      {
        "header": "Hosted central repositories",
        "content": "Central repositories are often created through 3rd party Git hosting services like Bitbucket Cloud. The process of initializing a bare repository discussed above is handled for you by the hosting service. The hosting service will then provide an address for the central repository to access from your local repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 318
        }
      },
      {
        "header": "Clone the central repository",
        "content": "Next, each developer creates a local copy of the entire project. This is accomplished via the git clone command:\n\nWhen you clone a repository, Git automatically adds a shortcut called origin that points back to the “parent” repository, under the assumption that you'll want to interact with it further on down the road.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit clone ssh://user@host/path/to/repo.git\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 319
        }
      },
      {
        "header": "Make changes and commit",
        "content": "Once the repository is cloned locally, a developer can make changes using the standard Git commit process: edit, stage, and commit. If you’re not familiar with the staging area, it’s a way to prepare a commit without having to include every change in the working directory. This lets you create highly focused commits, even if you’ve made a lot of local changes.\n\nRemember that since these commands create local commits, John can repeat this process as many times as he wants without worrying about what’s going on in the central repository. This can be very useful for large features that need to be broken down into simpler, more atomic chunks.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit status # View the state of the repogit add <some-file> # Stage a filegit commit # Commit a file</some-file>\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 646
        }
      },
      {
        "header": "Push new commits to central repository",
        "content": "Once the local repository has new changes committed. These change will need to be pushed to share with other developers on the project.\n\nThis command will push the new committed changes to the central repository. When pushing changes to the central repository, it is possible that updates from another developer have been previously pushed that contain code which conflict with the intended push updates. Git will output a message indicating this conflict. In this situation, git pull will first need to be executed. This conflict scenario will be expanded on in the following section.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push origin main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 585
        }
      },
      {
        "header": "Managing conflicts",
        "content": "The central repository represents the official project, so its commit history should be treated as sacred and immutable. If a developer’s local commits diverge from the central repository, Git will refuse to push their changes because this would overwrite official commits.\n\nBefore the developer can publish their feature, they need to fetch the updated central commits and rebase their changes on top of them. This is like saying, “I want to add my changes to what everyone else has already done.” The result is a perfectly linear history, just like in traditional SVN workflows.\n\nIf local changes directly conflict with upstream commits, Git will pause the rebasing process and give you a chance to manually resolve the conflicts. The nice thing about Git is that it uses the same git status and git add commands for both generating commits and resolving merge conflicts. This makes it easy for new developers to manage their own merges. Plus, if they get themselves into trouble, Git makes it very easy to abort the entire rebase and try again (or go find help).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1065
        }
      },
      {
        "header": "Example",
        "content": "Let’s take a general example at how a typical small team would collaborate using this workflow. We’ll see how two developers, John and Mary, can work on separate features and share their contributions via a centralized repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 230
        }
      },
      {
        "header": "John works on his feature",
        "content": "In his local repository, John can develop features using the standard Git commit process: edit, stage, and commit.\n\nRemember that since these commands create local commits, John can repeat this process as many times as he wants without worrying about what’s going on in the central repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 293
        }
      },
      {
        "header": "Mary works on her feature",
        "content": "Meanwhile, Mary is working on her own feature in her own local repository using the same edit/stage/commit process. Like John, she doesn’t care what’s going on in the central repository, and she really doesn’t care what John is doing in his local repository, since all local repositories are private.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 300
        }
      },
      {
        "header": "John publishes his feature",
        "content": "Once John finishes his feature, he should publish his local commits to the central repository so other team members can access it. He can do this with the git push command, like so:\n\nRemember that origin is the remote connection to the central repository that Git created when John cloned it. The main argument tells Git to try to make the origin’s main branch look like his local main branch. Since the central repository hasn’t been updated since John cloned it, this won’t result in any conflicts and the push will work as expected.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push origin main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 535
        }
      },
      {
        "header": "Mary tries to publish her feature",
        "content": "Let’s see what happens if Mary tries to push her feature after John has successfully published his changes to the central repository. She can use the exact same push command:\n\nBut, since her local history has diverged from the central repository, Git will refuse the request with a rather verbose error message:\n\nThis prevents Mary from overwriting official commits. She needs to pull John’s updates into her repository, integrate them with her local changes, and then try again.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push origin main\n```",
          "```bash\nerror: failed to push some refs to '/path/to/repo.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Merge the remote changes (e.g. 'git pull')hint: before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 479
        }
      },
      {
        "header": "Mary rebases on top of John’s commit(s)",
        "content": "Mary can use git pull to incorporate upstream changes into her repository. This command is sort of like svn update—it pulls the entire upstream commit history into Mary’s local repository and tries to integrate it with her local commits:\n\nThe --rebase option tells Git to move all of Mary’s commits to the tip of the main branch after synchronising it with the changes from the central repository, as shown below:\n\nThe pull would still work if you forgot this option, but you would wind up with a superfluous “merge commit” every time someone needed to synchronize with the central repository. For this workflow, it’s always better to rebase instead of generating a merge commit.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit pull --rebase origin main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 679
        }
      },
      {
        "header": "Mary resolves a merge conflict",
        "content": "Rebasing works by transferring each local commit to the updated main branch one at a time. This means that you catch merge conflicts on a commit-by-commit basis rather than resolving all of them in one massive merge commit. This keeps your commits as focused as possible and makes for a clean project history. In turn, this makes it much easier to figure out where bugs were introduced and, if necessary, to roll back changes with minimal impact on the project.\n\nIf Mary and John are working on unrelated features, it’s unlikely that the rebasing process will generate conflicts. But if it does, Git will pause the rebase at the current commit and output the following message, along with some relevant instructions:\n\nThe great thing about Git is that anyone can resolve their own merge conflicts. In our example, Mary would simply run a git status to see where the problem is. Conflicted files will appear in the Unmerged paths section:\n\nThen, she’ll edit the file(s) to her liking. Once she’s happy with the result, she can stage the file(s) in the usual fashion and let git rebase do the rest:\n\nAnd that’s all there is to it. Git will move on to the next commit and repeat the process for any other commits that generate conflicts.\n\nIf you get to this point and realize and you have no idea what’s going on, don’t panic. Just execute the following command and you’ll be right back to where you started:",
        "code_examples": [
          "```bash\nCONFLICT (content): Merge conflict in <some-file>\n```"
        ],
        "usage_examples": [
          "```bash\n# Unmerged paths:# (use \"git reset HEAD <some-file>...\" to unstage)# (use \"git add/rm <some-file>...\" as appropriate to mark resolution)## both modified: <some-file>\n```",
          "```bash\ngit add <some-file>git rebase --continue\n```",
          "```bash\ngit rebase --abort\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1405
        }
      },
      {
        "header": "Mary successfully publishes her feature",
        "content": "After she’s done synchronizing with the central repository, Mary will be able to publish her changes successfully:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push origin main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 114
        }
      },
      {
        "header": "Where to go from here",
        "content": "As you can see, it’s possible to replicate a traditional Subversion development environment using only a handful of Git commands. This is great for transitioning teams off of SVN, but it doesn’t leverage the distributed nature of Git.\n\nThe Centralized Workflow is great for small teams. The conflict resolution process detailed above can form a bottleneck as your team scales in size. If your team is comfortable with the Centralized Workflow but wants to streamline its collaboration efforts, it's definitely worth exploring the benefits of the Feature Branch Workflow. By dedicating an isolated branch to each feature, it’s possible to initiate in-depth discussions around new additions before integrating them into the official project.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 739
        }
      },
      {
        "header": "Other common workflows",
        "content": "The Centralized Workflow is essentially a building block for other Git workflows. Most popular Git workflows will have some sort of centralized repo that individual developers will push and pull from. Below we will briefly discuss some other popular Git workflows. These extended workflows offer more specialized patterns in regard to managing branches for feature development, hot fixes, and eventual release.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 410
        }
      },
      {
        "header": "Feature branching",
        "content": "Feature Branching is a logical extension of Centralized Workflow. The core idea behind the Feature Branch Workflow is that all feature development should take place in a dedicated branch instead of the main branch. This encapsulation makes it easy for multiple developers to work on a particular feature without disturbing the main codebase. It also means the main branch should never contain broken code, which is a huge advantage for continuous integration environments.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 472
        }
      },
      {
        "header": "Gitflow Workflow",
        "content": "The Gitflow Workflow was first published in a highly regarded 2010 blog post from Vincent Driessen at nvie. The Gitflow Workflow defines a strict branching model designed around the project release. This workflow doesn’t add any new concepts or commands beyond what’s required for the Feature Branch Workflow. Instead, it assigns very specific roles to different branches and defines how and when they should interact.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 418
        }
      },
      {
        "header": "Forking Workflow",
        "content": "The Forking Workflow is fundamentally different than the other workflows discussed in this tutorial. Instead of using a single server-side repository to act as the “central” codebase, it gives every developer a server-side repository. This means that each contributor has not one, but two Git repositories: a private local one and a public server-side one.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 356
        }
      },
      {
        "header": "Guidelines",
        "content": "There is no one size fits all Git workflow. As previously stated, it’s important to develop a Git workflow that is a productivity enhancement for your team. In addition to team culture, a workflow should also complement business culture. Git features like branches and tags should complement your business’s release schedule. If your team is using task tracking project management software you may want to use branches that correspond with tasks in progress. In addition, some guidelines to consider when deciding on a workflow are:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 532
        }
      },
      {
        "header": "Short-lived branches",
        "content": "The longer a branch lives separate from the production branch, the higher the risk for merge conflicts and deployment challenges. Short-lived branches promote cleaner merges and deploys.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 186
        }
      },
      {
        "header": "Minimize and simplify reverts",
        "content": "It’s important to have a workflow that helps proactively prevent merges that will have to be reverted. A workflow that tests a branch before allowing it to be merged into the main branch is an example. However, accidents do happen. That being said, it’s beneficial to have a workflow that allows for easy reverts that will not disrupt the flow for other team members.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 367
        }
      },
      {
        "header": "Match a release schedule",
        "content": "A workflow should complement your business’s software development release cycle. If you plan to release multiple times a day, you will want to keep your main branch stable. If your release schedule is less frequent, you may want to consider using Git tags to tag a branch to a version.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 285
        }
      },
      {
        "header": "Summary",
        "content": "In this document we discussed Git workflows. We took an in-depth look at a Centralized Workflow with practical examples. Expanding on the Centralized Workflow we discussed additional specialized workflows. Some key takeaways from this document are:\n\nTo read about the next Git workflow check out our comprehensive breakdown of the Feature Branch Workflow.\n\n• There is no one-size-fits-all Git workflow\n• A workflow should be simple and enhance the productivity of your team\n• Your business requirements should help shape your Git workflow",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 538
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/comparing-workflows",
    "doc_type": "git",
    "total_sections": 30
  },
  {
    "title": "Comparing Git workflows: What you should know",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "Git is the most commonly used version control system today. A Git workflow is a recipe or recommendation for how to use Git to accomplish work in a consistent and productive manner. Git workflows encourage developers and DevOps teams to leverage Git effectively and consistently. Git offers a lot of flexibility in how users manage changes. Given Git's focus on flexibility, there is no standardized process on how to interact with Git. When working with a team on a Git-managed project, it’s important to make sure the team is all in agreement on how the flow of changes will be applied. To ensure the team is on the same page, an agreed-upon Git workflow should be developed or selected. There are several publicized Git workflows that may be a good fit for your team. Here, we will discuss some of these Git workflow options.\n\nThe array of possible workflows can make it hard to know where to begin when implementing Git in the workplace. This page provides a starting point by surveying the most common Git workflows for software teams.\n\nAs you read through, remember that these workflows are designed to be guidelines rather than concrete rules. We want to show you what’s possible, so you can mix and match aspects from different workflows to suit your individual needs.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1276
        }
      },
      {
        "header": "What is a successful Git workflow?",
        "content": "When evaluating a workflow for your team, it's most important that you consider your team’s culture. You want the workflow to enhance the effectiveness of your team and not be a burden that limits productivity. Some things to consider when evaluating a Git workflow are:\n\n• Does this workflow scale with team size?\n• Is it easy to undo mistakes and errors with this workflow?\n• Does this workflow impose any new unnecessary cognitive overhead to the team?",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 455
        }
      },
      {
        "header": "Centralized workflow",
        "content": "The Centralized Workflow is a great Git workflow for teams transitioning from SVN. Like Subversion, the Centralized Workflow uses a central repository to serve as the single point-of-entry for all changes to the project. Instead of trunk, the default development branch is called main and all changes are committed into this branch. This workflow doesn’t require any other branches besides main.\n\nTransitioning to a distributed version control system may seem like a daunting task, but you don’t have to change your existing workflow to take advantage of Git. Your team can develop projects in the exact same way as they do with Subversion.\n\nHowever, using Git to power your development workflow presents a few advantages over SVN. First, it gives every developer their own local copy of the entire project. This isolated environment lets each developer work independently of all other changes to a project - they can add commits to their local repository and completely forget about upstream developments until it's convenient for them.\n\nSecond, it gives you access to Git’s robust branching and merging model. Unlike SVN, Git branches are designed to be a fail-safe mechanism for integrating code and sharing changes between repositories. The Centralized Workflow is similar to other workflows in its utilization of a remote server-side hosted repository that developers push and pull from. Compared to other workflows, the Centralized Workflow has no defined pull request or forking patterns. A Centralized Workflow is generally better suited for teams migrating from SVN to Git and smaller size teams.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1605
        }
      },
      {
        "header": "How it works",
        "content": "Developers start by cloning the central repository. In their own local copies of the project, they edit files and commit changes as they would with SVN; however, these new commits are stored locally - they’re completely isolated from the central repository. This lets developers defer synchronizing upstream until they’re at a convenient break point.\n\nTo publish changes to the official project, developers \"push\" their local main branch to the central repository. This is the equivalent of svn commit, except that it adds all of the local commits that aren’t already in the central main branch.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 595
        }
      },
      {
        "header": "Initialize the central repository",
        "content": "First, someone needs to create the central repository on a server. If it’s a new project, you can initialize an empty repository. Otherwise, you’ll need to import an existing Git or SVN repository.\n\nCentral repositories should always be bare repositories (they shouldn’t have a working directory), which can be created as follows:\n\nBe sure to use a valid SSH username for user, the domain or IP address of your server for host, and the location where you'd like to store your repo for /path/to/repo.git. Note that the .git extension is conventionally appended to the repository name to indicate that it’s a bare repository.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nssh user@host git init --bare /path/to/repo.git\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 623
        }
      },
      {
        "header": "Hosted central repositories",
        "content": "Central repositories are often created through 3rd party Git hosting services like Bitbucket Cloud. The process of initializing a bare repository discussed above is handled for you by the hosting service. The hosting service will then provide an address for the central repository to access from your local repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 318
        }
      },
      {
        "header": "Clone the central repository",
        "content": "Next, each developer creates a local copy of the entire project. This is accomplished via the git clone command:\n\nWhen you clone a repository, Git automatically adds a shortcut called origin that points back to the “parent” repository, under the assumption that you'll want to interact with it further on down the road.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit clone ssh://user@host/path/to/repo.git\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 319
        }
      },
      {
        "header": "Make changes and commit",
        "content": "Once the repository is cloned locally, a developer can make changes using the standard Git commit process: edit, stage, and commit. If you’re not familiar with the staging area, it’s a way to prepare a commit without having to include every change in the working directory. This lets you create highly focused commits, even if you’ve made a lot of local changes.\n\nRemember that since these commands create local commits, John can repeat this process as many times as he wants without worrying about what’s going on in the central repository. This can be very useful for large features that need to be broken down into simpler, more atomic chunks.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit status # View the state of the repogit add <some-file> # Stage a filegit commit # Commit a file</some-file>\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 646
        }
      },
      {
        "header": "Push new commits to central repository",
        "content": "Once the local repository has new changes committed. These change will need to be pushed to share with other developers on the project.\n\nThis command will push the new committed changes to the central repository. When pushing changes to the central repository, it is possible that updates from another developer have been previously pushed that contain code which conflict with the intended push updates. Git will output a message indicating this conflict. In this situation, git pull will first need to be executed. This conflict scenario will be expanded on in the following section.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push origin main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 585
        }
      },
      {
        "header": "Managing conflicts",
        "content": "The central repository represents the official project, so its commit history should be treated as sacred and immutable. If a developer’s local commits diverge from the central repository, Git will refuse to push their changes because this would overwrite official commits.\n\nBefore the developer can publish their feature, they need to fetch the updated central commits and rebase their changes on top of them. This is like saying, “I want to add my changes to what everyone else has already done.” The result is a perfectly linear history, just like in traditional SVN workflows.\n\nIf local changes directly conflict with upstream commits, Git will pause the rebasing process and give you a chance to manually resolve the conflicts. The nice thing about Git is that it uses the same git status and git add commands for both generating commits and resolving merge conflicts. This makes it easy for new developers to manage their own merges. Plus, if they get themselves into trouble, Git makes it very easy to abort the entire rebase and try again (or go find help).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1065
        }
      },
      {
        "header": "Example",
        "content": "Let’s take a general example at how a typical small team would collaborate using this workflow. We’ll see how two developers, John and Mary, can work on separate features and share their contributions via a centralized repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 230
        }
      },
      {
        "header": "John works on his feature",
        "content": "In his local repository, John can develop features using the standard Git commit process: edit, stage, and commit.\n\nRemember that since these commands create local commits, John can repeat this process as many times as he wants without worrying about what’s going on in the central repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 293
        }
      },
      {
        "header": "Mary works on her feature",
        "content": "Meanwhile, Mary is working on her own feature in her own local repository using the same edit/stage/commit process. Like John, she doesn’t care what’s going on in the central repository, and she really doesn’t care what John is doing in his local repository, since all local repositories are private.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 300
        }
      },
      {
        "header": "John publishes his feature",
        "content": "Once John finishes his feature, he should publish his local commits to the central repository so other team members can access it. He can do this with the git push command, like so:\n\nRemember that origin is the remote connection to the central repository that Git created when John cloned it. The main argument tells Git to try to make the origin’s main branch look like his local main branch. Since the central repository hasn’t been updated since John cloned it, this won’t result in any conflicts and the push will work as expected.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push origin main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 535
        }
      },
      {
        "header": "Mary tries to publish her feature",
        "content": "Let’s see what happens if Mary tries to push her feature after John has successfully published his changes to the central repository. She can use the exact same push command:\n\nBut, since her local history has diverged from the central repository, Git will refuse the request with a rather verbose error message:\n\nThis prevents Mary from overwriting official commits. She needs to pull John’s updates into her repository, integrate them with her local changes, and then try again.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push origin main\n```",
          "```bash\nerror: failed to push some refs to '/path/to/repo.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Merge the remote changes (e.g. 'git pull')hint: before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 479
        }
      },
      {
        "header": "Mary rebases on top of John’s commit(s)",
        "content": "Mary can use git pull to incorporate upstream changes into her repository. This command is sort of like svn update—it pulls the entire upstream commit history into Mary’s local repository and tries to integrate it with her local commits:\n\nThe --rebase option tells Git to move all of Mary’s commits to the tip of the main branch after synchronising it with the changes from the central repository, as shown below:\n\nThe pull would still work if you forgot this option, but you would wind up with a superfluous “merge commit” every time someone needed to synchronize with the central repository. For this workflow, it’s always better to rebase instead of generating a merge commit.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit pull --rebase origin main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 679
        }
      },
      {
        "header": "Mary resolves a merge conflict",
        "content": "Rebasing works by transferring each local commit to the updated main branch one at a time. This means that you catch merge conflicts on a commit-by-commit basis rather than resolving all of them in one massive merge commit. This keeps your commits as focused as possible and makes for a clean project history. In turn, this makes it much easier to figure out where bugs were introduced and, if necessary, to roll back changes with minimal impact on the project.\n\nIf Mary and John are working on unrelated features, it’s unlikely that the rebasing process will generate conflicts. But if it does, Git will pause the rebase at the current commit and output the following message, along with some relevant instructions:\n\nThe great thing about Git is that anyone can resolve their own merge conflicts. In our example, Mary would simply run a git status to see where the problem is. Conflicted files will appear in the Unmerged paths section:\n\nThen, she’ll edit the file(s) to her liking. Once she’s happy with the result, she can stage the file(s) in the usual fashion and let git rebase do the rest:\n\nAnd that’s all there is to it. Git will move on to the next commit and repeat the process for any other commits that generate conflicts.\n\nIf you get to this point and realize and you have no idea what’s going on, don’t panic. Just execute the following command and you’ll be right back to where you started:",
        "code_examples": [
          "```bash\nCONFLICT (content): Merge conflict in <some-file>\n```"
        ],
        "usage_examples": [
          "```bash\n# Unmerged paths:# (use \"git reset HEAD <some-file>...\" to unstage)# (use \"git add/rm <some-file>...\" as appropriate to mark resolution)## both modified: <some-file>\n```",
          "```bash\ngit add <some-file>git rebase --continue\n```",
          "```bash\ngit rebase --abort\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1405
        }
      },
      {
        "header": "Mary successfully publishes her feature",
        "content": "After she’s done synchronizing with the central repository, Mary will be able to publish her changes successfully:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push origin main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 114
        }
      },
      {
        "header": "Where to go from here",
        "content": "As you can see, it’s possible to replicate a traditional Subversion development environment using only a handful of Git commands. This is great for transitioning teams off of SVN, but it doesn’t leverage the distributed nature of Git.\n\nThe Centralized Workflow is great for small teams. The conflict resolution process detailed above can form a bottleneck as your team scales in size. If your team is comfortable with the Centralized Workflow but wants to streamline its collaboration efforts, it's definitely worth exploring the benefits of the Feature Branch Workflow. By dedicating an isolated branch to each feature, it’s possible to initiate in-depth discussions around new additions before integrating them into the official project.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 739
        }
      },
      {
        "header": "Other common workflows",
        "content": "The Centralized Workflow is essentially a building block for other Git workflows. Most popular Git workflows will have some sort of centralized repo that individual developers will push and pull from. Below we will briefly discuss some other popular Git workflows. These extended workflows offer more specialized patterns in regard to managing branches for feature development, hot fixes, and eventual release.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 410
        }
      },
      {
        "header": "Feature branching",
        "content": "Feature Branching is a logical extension of Centralized Workflow. The core idea behind the Feature Branch Workflow is that all feature development should take place in a dedicated branch instead of the main branch. This encapsulation makes it easy for multiple developers to work on a particular feature without disturbing the main codebase. It also means the main branch should never contain broken code, which is a huge advantage for continuous integration environments.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 472
        }
      },
      {
        "header": "Gitflow Workflow",
        "content": "The Gitflow Workflow was first published in a highly regarded 2010 blog post from Vincent Driessen at nvie. The Gitflow Workflow defines a strict branching model designed around the project release. This workflow doesn’t add any new concepts or commands beyond what’s required for the Feature Branch Workflow. Instead, it assigns very specific roles to different branches and defines how and when they should interact.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 418
        }
      },
      {
        "header": "Forking Workflow",
        "content": "The Forking Workflow is fundamentally different than the other workflows discussed in this tutorial. Instead of using a single server-side repository to act as the “central” codebase, it gives every developer a server-side repository. This means that each contributor has not one, but two Git repositories: a private local one and a public server-side one.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 356
        }
      },
      {
        "header": "Guidelines",
        "content": "There is no one size fits all Git workflow. As previously stated, it’s important to develop a Git workflow that is a productivity enhancement for your team. In addition to team culture, a workflow should also complement business culture. Git features like branches and tags should complement your business’s release schedule. If your team is using task tracking project management software you may want to use branches that correspond with tasks in progress. In addition, some guidelines to consider when deciding on a workflow are:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 532
        }
      },
      {
        "header": "Short-lived branches",
        "content": "The longer a branch lives separate from the production branch, the higher the risk for merge conflicts and deployment challenges. Short-lived branches promote cleaner merges and deploys.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 186
        }
      },
      {
        "header": "Minimize and simplify reverts",
        "content": "It’s important to have a workflow that helps proactively prevent merges that will have to be reverted. A workflow that tests a branch before allowing it to be merged into the main branch is an example. However, accidents do happen. That being said, it’s beneficial to have a workflow that allows for easy reverts that will not disrupt the flow for other team members.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 367
        }
      },
      {
        "header": "Match a release schedule",
        "content": "A workflow should complement your business’s software development release cycle. If you plan to release multiple times a day, you will want to keep your main branch stable. If your release schedule is less frequent, you may want to consider using Git tags to tag a branch to a version.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 285
        }
      },
      {
        "header": "Summary",
        "content": "In this document we discussed Git workflows. We took an in-depth look at a Centralized Workflow with practical examples. Expanding on the Centralized Workflow we discussed additional specialized workflows. Some key takeaways from this document are:\n\nTo read about the next Git workflow check out our comprehensive breakdown of the Feature Branch Workflow.\n\n• There is no one-size-fits-all Git workflow\n• A workflow should be simple and enhance the productivity of your team\n• Your business requirements should help shape your Git workflow",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 538
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/comparing-workflows/centralized-workflow",
    "doc_type": "git",
    "total_sections": 30
  },
  {
    "title": "Git feature branch workflow",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "The core idea behind the Feature Branch Workflow is that all feature development should take place in a dedicated branch instead of the main branch. This encapsulation makes it easy for multiple developers to work on a particular feature without disturbing the main codebase. It also means the main branch will never contain broken code, which is a huge advantage for continuous integration environments.\n\nEncapsulating feature development also makes it possible to leverage pull requests, which are a way to initiate discussions around a branch. They give other developers the opportunity to sign off on a feature before it gets integrated into the official project. Or, if you get stuck in the middle of a feature, you can open a pull request asking for suggestions from your colleagues. The point is, pull requests make it incredibly easy for your team to comment on each other’s work.\n\nThe Git Feature Branch Workflow is a composable workflow that can be leveraged by other high-level Git workflows. We discussed other Git workflows on the Git workflow overview page. Git Feature Branch Workflow is branching model focused, meaning that it is a guiding framework for managing and creating branches. Other workflows are more repo focused. The Git Feature Branch Workflow can be incorporated into other workflows. The Gitflow, and Git Forking Workflows traditionally use a Git Feature Branch Workflow in regards to their branching models.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1440
        }
      },
      {
        "header": "How it works",
        "content": "The Feature Branch Workflow assumes a central repository, and main represents the official project history. Instead of committing directly on their local main branch, developers create a new branch every time they start work on a new feature. Feature branches should have descriptive names, like animated-menu-items or issue-#1061. The idea is to give a clear, highly-focused purpose to each branch. Git makes no technical distinction between the main branch and feature branches, so developers can edit, stage, and commit changes to a feature branch.\n\nIn addition, feature branches can (and should) be pushed to the central repository. This makes it possible to share a feature with other developers without touching any official code. Since main is the only “special” branch, storing several feature branches on the central repository doesn’t pose any problems. Of course, this is also a convenient way to back up everybody’s local commits. The following is a walk-through of the life-cycle of a feature branch.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 1013
        }
      },
      {
        "header": "Start with the main branch",
        "content": "All feature branches are created off the latest code state of a project. This guide assumes this is maintained and updated in the main branch.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout maingit fetch origingit reset --hard origin/main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 142
        }
      },
      {
        "header": "Create the repository",
        "content": "This switches the repo to the main branch, pulls the latest commits and resets the repo's local copy of main to match the latest version.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 137
        }
      },
      {
        "header": "Create a new-branch",
        "content": "Use a separate branch for each feature or issue you work on. After creating a branch, check it out locally so that any changes you make will be on that branch.\n\nThis checks out a branch called new-feature based on main, and the -b flag tells Git to create the branch if it doesn’t already exist.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout -b new-feature\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 295
        }
      },
      {
        "header": "Update, add, commit, and push changes",
        "content": "On this branch, edit, stage, and commit changes in the usual fashion, building up the feature with as many commits as necessary. Work on the feature and make commits like you would any time you use Git. When ready, push your commits, updating the feature branch on Bitbucket.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit statusgit add <some-file>git commit\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 275
        }
      },
      {
        "header": "Push feature branch to remote",
        "content": "It’s a good idea to push the feature branch up to the central repository. This serves as a convenient backup, when collaborating with other developers, this would give them access to view commits to the new branch.\n\nThis command pushes new-feature to the central repository (origin), and the -u flag adds it as a remote tracking branch. After setting up the tracking branch, git push can be invoked without any parameters to automatically push the new-feature branch to the central repository. To get feedback on the new feature branch, create a pull request in a repository management solution like Bitbucket Cloud or Bitbucket Data Center. From there, you can add reviewers and make sure everything is good to go before merging.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push -u origin new-feature\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 730
        }
      },
      {
        "header": "Resolve feedback",
        "content": "Now teammates comment and approve the pushed commits. Resolve their comments locally, commit, and push the suggested changes to Bitbucket. Your updates appear in the pull request.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 179
        }
      },
      {
        "header": "Merge your pull request",
        "content": "Before you merge, you may have to resolve merge conflicts if others have made changes to the repo. When your pull request is approved and conflict-free, you can add your code to the main branch. Merge from the pull request in Bitbucket.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 236
        }
      },
      {
        "header": "Pull requests",
        "content": "Aside from isolating feature development, branches make it possible to discuss changes via pull requests. Once someone completes a feature, they don’t immediately merge it into main. Instead, they push the feature branch to the central server and file a pull request asking to merge their additions into main. This gives other developers an opportunity to review the changes before they become a part of the main codebase.\n\nCode review is a major benefit of pull requests, but they’re actually designed to be a generic way to talk about code. You can think of pull requests as a discussion dedicated to a particular branch. This means that they can also be used much earlier in the development process. For example, if a developer needs help with a particular feature, all they have to do is file a pull request. Interested parties will be notified automatically, and they’ll be able to see the question right next to the relevant commits.\n\nOnce a pull request is accepted, the actual act of publishing a feature is much the same as in the Centralized Workflow. First, you need to make sure your local main is synchronized with the upstream main. Then, you merge the feature branch into main and push the updated main back to the central repository.\n\nPull requests can be facilitated by source code management solutions like Bitbucket Cloud.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1341
        }
      },
      {
        "header": "Example",
        "content": "The following is an example of the type of scenario in which a feature branching workflow is used. The scenario is that of a team doing code review around on a new feature pull request. This is one example of the many purposes this model can be used for.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 254
        }
      },
      {
        "header": "Mary begins a new feature",
        "content": "Before she starts developing a feature, Mary needs an isolated branch to work on. She can request a new branch with the following command:\n\nThis checks out a branch called marys-feature based on main, and the -b flag tells Git to create the branch if it doesn’t already exist. On this branch, Mary edits, stages, and commits changes in the usual fashion, building up her feature with as many commits as necessary:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout -b marys-feature main\n```",
          "```bash\ngit statusgit add <some-file>git commit\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 413
        }
      },
      {
        "header": "Mary goes to lunch",
        "content": "Mary adds a few commits to her feature over the course of the morning. Before she leaves for lunch, it’s a good idea to push her feature branch up to the central repository. This serves as a convenient backup, but if Mary was collaborating with other developers, this would also give them access to her initial commits.\n\nThis command pushes marys-feature to the central repository (origin), and the -u flag adds it as a remote tracking branch. After setting up the tracking branch, Mary can call git push without any parameters to push her feature.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push -u origin marys-feature\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 548
        }
      },
      {
        "header": "Mary finishes her feature",
        "content": "When Mary gets back from lunch, she completes her feature. Before merging it into main, she needs to file a pull request letting the rest of the team know she's done. But first, she should make sure the central repository has her most recent commits:\n\nThen, she files the pull request in her Git GUI asking to merge marys-feature into main, and team members will be notified automatically. The great thing about pull requests is that they show comments right next to their related commits, so it's easy to ask questions about specific changesets.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 546
        }
      },
      {
        "header": "Bill receives the pull request",
        "content": "Bill gets the pull request and takes a look at marys-feature. He decides he wants to make a few changes before integrating it into the official project, and he and Mary have some back-and-forth via the pull request.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 215
        }
      },
      {
        "header": "Mary makes the changes",
        "content": "To make the changes, Mary uses the exact same process as she did to create the first iteration of her feature. She edits, stages, commits, and pushes updates to the central repository. All her activity shows up in the pull request, and Bill can still make comments along the way.\n\nIf he wanted, Bill could pull marys-feature into his local repository and work on it on his own. Any commits he added would also show up in the pull request.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 438
        }
      },
      {
        "header": "Mary publishes her feature",
        "content": "Once Bill is ready to accept the pull request, someone needs to merge the feature into the stable project (this can be done by either Bill or Mary):\n\nThis process often results in a merge commit. Some developers like this because it’s like a symbolic joining of the feature with the rest of the code base. But, if you’re partial to a linear history, it’s possible to rebase the feature onto the tip of main before executing the merge, resulting in a fast-forward merge.\n\nSome GUI’s will automate the pull request acceptance process by running all of these commands just by clicking an “Accept” button. If yours doesn’t, it should at least be able to automatically close the pull request when the feature branch gets merged into main.\n\nMeanwhile, John is doing the exact same thing.\n\nWhile Mary and Bill are working on marys-feature and discussing it in her pull request, John is doing the exact same thing with his own feature branch. By isolating features into separate branches, everybody can work independently, yet it’s still trivial to share changes with other developers when necessary.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout maingit pullgit pull origin marys-featuregit push\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1092
        }
      },
      {
        "header": "Summary",
        "content": "In this document, we discussed the Git Feature Branch Workflow. This workflow helps organize and track branches that are focused on business domain feature sets. Other Git workflows like the Git Forking Workflow and the Gitflow Workflow are repo focused and can leverage the Git Feature Branch Workflow to manage their branching models. This document demonstrated a high-level code example and fictional example for implementing the Git Feature Branch Workflow. Some key associations to make with the Feature Branch Workflow are:\n\nUtilizing git rebase during the review and merge stages of a feature branch will create enforce a cohesive Git history of feature merges. A feature branching model is a great tool to promote collaboration within a team environment.\n\nGo one click deeper into Git workflows by reading our comprehensive tutorial of the Gitflow Workflow.\n\n• focused on branching patterns\n• can be leveraged by other repo oriented workflows\n• promotes collaboration with team members through pull requests and merge reviews",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1033
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow",
    "doc_type": "git",
    "total_sections": 20
  },
  {
    "title": "Gitflow workflow",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "Gitflow is a legacy Git workflow that was originally a disruptive and novel strategy for managing Git branches. Gitflow has fallen in popularity in favor of trunk-based workflows, which are now considered best practices for modern continuous software development and DevOps practices. Gitflow also can be challenging to use with CI/CD. This post details Gitflow for historical purposes.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 386
        }
      },
      {
        "header": "What is Gitflow?",
        "content": "Gitflow is an alternative Git branching model that involves the use of feature branches and multiple primary branches. It was first published and made popular by Vincent Driessen at nvie. Compared to trunk-based development, Gitflow has numerous, longer-lived branches and larger commits. Under this model, developers create a feature branch and delay merging it to the main trunk branch until the feature is complete. These long-lived feature branches require more collaboration to merge and have a higher risk of deviating from the trunk branch. They can also introduce conflicting updates.\n\nGitflow can be used for projects that have a scheduled release cycle and for the DevOps best practice of continuous delivery. This workflow doesn’t add any new concepts or commands beyond what’s required for the Feature Branch Workflow. Instead, it assigns very specific roles to different branches and defines how and when they should interact. In addition to feature branches, it uses individual branches for preparing, maintaining, and recording releases. Of course, you also get to leverage all the benefits of the Feature Branch Workflow: pull requests, isolated experiments, and more efficient collaboration.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 1208
        }
      },
      {
        "header": "Develop and main branches",
        "content": "Instead of a single main branch, this workflow uses two branches to record the history of the project. The main branch stores the official release history, and the develop branch serves as an integration branch for features. It's also convenient to tag all commits in the main branch with a version number.\n\nThe first step is to complement the default main with a develop branch. A simple way to do this is for one developer to create an empty develop branch locally and push it to the server:\n\nThis branch will contain the complete history of the project, whereas main will contain an abridged version. Other developers should now clone the central repository and create a tracking branch for develop.\n\nWhen using the git-flow extension library, executing git flow init on an existing repo will create the develop branch:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit branch developgit push -u origin develop\n```",
          "```bash\n$ git flow initInitialized empty Git repository in ~/project/.git/No branches exist yet. Base branches must be created now.Branch name for production releases: [main]Branch name for \"next release\" development: [develop]How to name your supporting branch prefixes?Feature branches? [feature/]Release branches? [release/]Hotfix branches? [hotfix/]Support branches? [support/]Version tag prefix? []$ git branch* developmain\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 822
        }
      },
      {
        "header": "Step 1. Create the repository",
        "content": "Each new feature should reside in its own branch, which can be pushed to the central repository for backup/collaboration. But, instead of branching off of main, feature branches use develop as their parent branch. When a feature is complete, it gets merged back into develop. Features should never interact directly with main.\n\nNote that feature branches combined with the develop branch is, for all intents and purposes, the Feature Branch Workflow. But, the Gitflow workflow doesn’t stop there.\n\nFeature branches are generally created off to the latest develop branch.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 570
        }
      },
      {
        "header": "Creating a feature branch",
        "content": "Without the git-flow extensions:\n\nWhen using the git-flow extension:\n\nContinue your work and use Git like you normally would.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout developgit checkout -b feature_branch\n```",
          "```bash\ngit flow feature start feature_branch\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 125
        }
      },
      {
        "header": "Finishing a feature branch",
        "content": "When you’re done with the development work on the feature, the next step is to merge the feature_branch into develop.\n\nWithout the git-flow extensions:\n\nUsing the git-flow extensions:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout developgit merge feature_branch\n```",
          "```bash\ngit flow feature finish feature_branch\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 183
        }
      },
      {
        "header": "Release branches",
        "content": "Once develop has acquired enough features for a release (or a predetermined release date is approaching), you fork a release branch off of develop. Creating this branch starts the next release cycle, so no new features can be added after this point—only bug fixes, documentation generation, and other release-oriented tasks should go in this branch. Once it's ready to ship, the release branch gets merged into main and tagged with a version number. In addition, it should be merged back into develop, which may have progressed since the release was initiated.\n\nUsing a dedicated branch to prepare releases makes it possible for one team to polish the current release while another team continues working on features for the next release. It also creates well-defined phases of development (e.g., it's easy to say, “This week we're preparing for version 4.0,” and to actually see it in the structure of the repository).\n\nMaking release branches is another straightforward branching operation. Like feature branches, release branches are based on the develop branch. A new release branch can be created using the following methods.\n\nWithout the git-flow extensions:\n\nWhen using the git-flow extensions:\n\nOnce the release is ready to ship, it will get merged it into main and develop, then the release branch will be deleted. It’s important to merge back into develop because critical updates may have been added to the release branch and they need to be accessible to new features. If your organization stresses code review, this would be an ideal place for a pull request.\n\nTo finish a release branch, use the following methods:\n\nWithout the git-flow extensions:\n\nOr with the git-flow extension:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout developgit checkout -b release/0.1.0\n```",
          "```bash\n$ git flow release start 0.1.0Switched to a new branch 'release/0.1.0'\n```",
          "```bash\ngit checkout maingit merge release/0.1.0\n```",
          "```bash\ngit flow release finish '0.1.0'\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 1695
        }
      },
      {
        "header": "Hotfix branches",
        "content": "Maintenance or “hotfix” branches are used to quickly patch production releases. Hotfix branches are a lot like release branches and feature branches except they're based on main instead of develop. This is the only branch that should fork directly off of main. As soon as the fix is complete, it should be merged into both main and develop (or the current release branch), and main should be tagged with an updated version number.\n\nHaving a dedicated line of development for bug fixes lets your team address issues without interrupting the rest of the workflow or waiting for the next release cycle. You can think of maintenance branches as ad hoc release branches that work directly with main. A hotfix branch can be created using the following methods:\n\nWithout the git-flow extensions:\n\nWhen using the git-flow extensions:\n\nSimilar to finishing a release branch, a hotfix branch gets merged into both main and develop.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout maingit checkout -b hotfix_branch\n```",
          "```bash\n$ git flow hotfix start hotfix_branch\n```",
          "```bash\ngit checkout maingit merge hotfix_branchgit checkout developgit merge hotfix_branchgit branch -D hotfix_branch\n```",
          "```bash\n$ git flow hotfix finish hotfix_branch\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 921
        }
      },
      {
        "header": "Example",
        "content": "A complete example demonstrating a Feature Branch Flow is as follows. Assuming we have a repo setup with a main branch.\n\nIn addition to the feature and release flow, a hotfix example is as follows:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout maingit checkout -b developgit checkout -b feature_branch# work happens on feature branchgit checkout developgit merge feature_branchgit checkout maingit merge developgit branch -d feature_branch\n```",
          "```bash\ngit checkout maingit checkout -b hotfix_branch# work is done commits are added to the hotfix_branchgit checkout developgit merge hotfix_branchgit checkout maingit merge hotfix_branch\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 197
        }
      },
      {
        "header": "Summary",
        "content": "Here we discussed the Gitflow Workflow. Gitflow is one of many styles of Git workflows you and your team can utilize.\n\nSome key takeaways to know about Gitflow are:\n\nThe overall flow of Gitflow is:\n\n1. A develop branch is created from main\n\n2. A release branch is created from develop\n\n3. Feature branches are created from develop\n\n4. When a feature is complete it is merged into the develop branch\n\n5. When the release branch is done it is merged into develop and main\n\n6. If an issue in main is detected a hotfix branch is created from main\n\n7. Once the hotfix is complete it is merged to both develop and main\n\nNext, learn about the Forking Workflow or visit our workflow comparison page.\n\n• The workflow is great for a release-based software workflow.\n• Gitflow offers a dedicated channel for hotfixes to production.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 11,
          "content_length": 820
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Forking workflow",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "The Forking Workflow is fundamentally different than other popular Git workflows. Instead of using a single server-side repository to act as the “central” codebase, it gives every developer their own server-side repository. This means that each contributor has not one, but two Git repositories: a private local one and a public server-side one. The Forking Workflow is most often seen in public open source projects.\n\nThe main advantage of the Forking Workflow is that contributions can be integrated without the need for everybody to push to a single central repository. Developers push to their own server-side repositories, and only the project maintainer can push to the official repository. This allows the maintainer to accept commits from any developer without giving them write access to the official codebase.\n\nThe Forking Workflow typically follows a branching model based on the Gitflow Workflow. This means that complete feature branches will be purposed for merge into the original project maintainer's repository. The result is a distributed workflow that provides a flexible way for large, organic teams (including untrusted third-parties) to collaborate securely. This also makes it an ideal workflow for open source projects.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1243
        }
      },
      {
        "header": "How it works",
        "content": "As in the other Git workflows, the Forking Workflow begins with an official public repository stored on a server. But when a new developer wants to start working on the project, they do not directly clone the official repository.\n\nInstead, they fork the official repository to create a copy of it on the server. This new copy serves as their personal public repository—no other developers are allowed to push to it, but they can pull changes from it (we’ll see why this is important in a moment). After they have created their server-side copy, the developer performs a git clone to get a copy of it onto their local machine. This serves as their private development environment, just like in the other workflows.\n\nWhen they're ready to publish a local commit, they push the commit to their own public repository—not the official one. Then, they file a pull request with the main repository, which lets the project maintainer know that an update is ready to be integrated. The pull request also serves as a convenient discussion thread if there are issues with the contributed code. The following is a step-by-step example of this workflow.\n\n1. A developer 'forks' an 'official' server-side repository. This creates their own server-side copy.\n\n2. The new server-side copy is cloned to their local system.\n\n3. A Git remote path for the 'official' repository is added to the local clone.\n\n4. A new local feature branch is created.\n\n5. The developer makes changes on the new branch.\n\n6. New commits are created for the changes.\n\n7. The branch gets pushed to the developer's own server-side copy.\n\n8. The developer opens a pull request from the new branch to the 'official' repository.\n\n9. The pull request gets approved for merge and is merged into the original server-side repository\n\nTo integrate the feature into the official codebase, the maintainer pulls the contributor’s changes into their local repository, checks to make sure it doesn’t break the project, merges it into their local main branch, then pushes the main branch to the official repository on the server. The contribution is now part of the project, and other developers should pull from the official repository to synchronize their local repositories.\n\nIt’s important to understand that the notion of an “official” repository in the Forking Workflow is merely a convention. In fact, the only thing that makes the official repository so official is that it’s the public repository of the project maintainer.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 14,
          "content_length": 2475
        }
      },
      {
        "header": "Forking vs cloning",
        "content": "It's important to note that \"forked\" repositories and \"forking\" are not special operations. Forked repositories are created using the standard git clone command. Forked repositories are generally \"server-side clones\" and usually managed and hosted by a 3rd party Git service like Bitbucket. There is no unique Git command to create forked repositories. A clone operation is essentially a copy of a repository and its history.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 425
        }
      },
      {
        "header": "Branching in the forking workflow",
        "content": "All of these personal public repositories are really just a convenient way to share branches with other developers. Everybody should still be using branches to isolate individual features, just like in the Feature Branch Workflow and the Gitflow Workflow. The only difference is how those branches get shared. In the Forking Workflow, they are pulled into another developer’s local repository, while in the Feature Branch and Gitflow Workflows they are pushed to the official repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 487
        }
      },
      {
        "header": "Fork a repository",
        "content": "All new developers to a Forking Workflow project need to fork the official repository. As previously stated, forking is just a standard git clone operation. It’s possible to do this by SSH’ing into the server and running git clone to copy it to another location on the server. Popular Git hosting services like Bitbucket, offer repo forking features that automate this step.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 374
        }
      },
      {
        "header": "Clone your fork",
        "content": "All new developers to a Forking Workflow project need to fork the official repository. As previously stated, forking is just a standard git clone operation. It’s possible to do this by SSH’ing into the server and running git clone to copy it to another location on the server. Popular Git hosting services like Bitbucket, offer repo forking features that automate this step.\n\nAssuming the use of Bitbucket to host these repositories, developers on a project should have their own Bitbucket account and they should clone their forked copy of the repository with:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit clone https://user@bitbucket.org/user/repo.git\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 561
        }
      },
      {
        "header": "Adding a remote",
        "content": "Whereas other Git workflows use a single origin remote that points to the central repository, the Forking Workflow requires two remotes—one for the official repository, and one for the developer’s personal server-side repository. While you can call these remotes anything you want, a common convention is to use origin as the remote for your forked repository (this will be created automatically when you run git clone) and upstream for the official repository.\n\nYou’ll need to create the upstream remote yourself using the above command. This will let you easily keep your local repository up-to-date as the official project progresses. Note that if your upstream repository has authentication enabled (i.e., it's not open source), you'll need to supply a username, like so:\n\nThis requires users to supply a valid password before cloning or pulling from the official codebase.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit remote add upstream https://bitbucket.org/maintainer/repo\n```",
          "```bash\ngit remote add upstream https://user@bitbucket.org/maintainer/repo.git\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 877
        }
      },
      {
        "header": "Working in a branch: making & pushing changes",
        "content": "In the developer's local copy of the forked repository they can edit code, commit changes, and create branches just like in other Git workflows:\n\nAll of their changes will be entirely private until they push it to their public repository. And, if the official project has moved forward, they can access new commits with git pull:\n\nSince developers should be working in a dedicated feature branch, this should generally result in a fast-forward merge.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout -b some-feature # Edit some code git commit -a -m \"Add first draft of some feature\"\n```",
          "```bash\ngit pull upstream main\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 450
        }
      },
      {
        "header": "Making a pull request",
        "content": "Once a developer is ready to share their new feature, they need to do two things. First, they have to make their contribution accessible to other developers by pushing it to their public repository. Their origin remote should already be set up, so all they should have to do is the following:\n\nThis diverges from the other workflows in that the origin remote points to the developer’s personal server-side repository, not the main codebase.\n\nSecond, they need to notify the project maintainer that they want to merge their feature into the official codebase. Bitbucket provides a “pull request” button that leads to a form asking you to specify which branch you want to merge into the official repository. Typically, you’ll want to integrate your feature branch into the upstream remote’s main branch.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push origin feature-branch\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 801
        }
      },
      {
        "header": "Summary",
        "content": "To recap, the Forking Workflow is commonly used in public open-source projects. Forking is a git clone operation executed on a server copy of a projects repo. A Forking Workflow is often used in conjunction with a Git hosting service like Bitbucket. A high-level example of a Forking Workflow is:\n\n1. You want to contribute to an open source library hosted at bitbucket.org/userA/open-project\n\n2. Using Bitbucket you create a fork of the repo to bitbucket.org/YourName/open-project\n\n3. On your local system you execute git clone on https://bitbucket.org/YourName/open-project to get a local copy of the repo\n\n4. You create a new feature branch in your local repo\n\n5. Work is done to complete the new feature and git commit is executed to save the changes\n\n6. You then push the new feature branch to your remote forked repo\n\n7. Using Bitbucket you open up a pull request for the new branch against the original repo at bitbucket.org/userA/open-project\n\nThe Forking Workflow helps a maintainer of a project open up the repository to contributions from any developer without having to manually manage authorization settings for each individual contributor. This gives the maintainer more of a \"pull\" style workflow. Most commonly used in open-source projects, the Forking Workflow can also be applied to private business workflows to give more authoritative control over what is merged into a release. This can be useful in teams that have Deploy Managers or strict release cycles.\n\nUnsure what workflow is right for you? Check out our comprehensive Git workflow comparison page.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 1576
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Advanced Git tutorials",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "Atlassian’s Git tutorials introduce the most common Git commands, and our Git Workflows modules discuss how these commands are typically used to facilitate collaboration. Alone, these are enough to get a development team up and running with Git. But, if you really want to leverage the full power of Git, you’re ready to dive into our Advanced Git articles.\n\nEach of these articles provide an in-depth discussion of an advanced feature of Git. Instead of presenting new commands and concepts, they refine your existing Git skills by explaining what’s going on under the hood. Armed with this knowledge, you’ll be able to use familiar Git commands more effectively. More importantly, you’ll never be scared of breaking your Git repository because you’ll understand why it broke and how to fix it.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 795
        }
      },
      {
        "header": "Merging vs. rebasing",
        "content": "Git is all about working with divergent history. Its git merge and git rebase commands offer alternative ways to integrate commits from different branches, and both options come with their own advantages. In this article, we’ll discuss how and when a basic git merge operation can be replaced with a rebase.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 307
        }
      },
      {
        "header": "Resetting, checking out, and reverting",
        "content": "The git reset, git checkout, and git revert commands are all similar in that they undo some type of change in your repository. But, they all affect different combinations of the working directory, staged snapshot, and commit history. This article clearly defines how these commands differ and when each of them should be used in the standard Git workflows.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 356
        }
      },
      {
        "header": "Advanced Git log",
        "content": "The git log command is what makes your project history useful. Without it, you wouldn’t be able to access any of your commits. But, if you’re like most aspiring Git users, you’ve probably only scratched the surface of what’s possible with git log. This article walks you through its advanced formatting and filtering options, giving you the power to extract all sorts of interesting information from your Git repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 420
        }
      },
      {
        "header": "Git hooks",
        "content": "If you want to perform custom actions when a certain event takes place in a Git repository, hooks are your tool of choice. They let you normalize commit messages, automate testing suites, notify continuous integration systems, and much more. After this article, you’ll understand the many ways in which Git hooks can streamline your workflow.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 342
        }
      },
      {
        "header": "Refs and the reflog",
        "content": "A ref is Git’s internal way of referring to a commit. You’re already familiar with many categories of refs, including commit hashes and branch names. But, there are many other types of refs, and virtually every Git command utilizes them in some form or another. You’ll walk away from this article with an intimate knowledge of Git’s inner workings.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 348
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/advanced-overview",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "Merging vs. rebasing",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "The git rebase command has a reputation for being magical Git hocus pocus that beginners should stay away from, but it can actually make life much easier for a development team when used with care. In this article, we’ll compare git rebase with the related git merge command and identify all of the potential opportunities to incorporate rebasing into the typical Git workflow.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 377
        }
      },
      {
        "header": "Conceptual overview",
        "content": "The first thing to understand about git rebase is that it solves the same problem as git merge. Both of these commands are designed to integrate changes from one branch into another branch—they just do it in very different ways.\n\nConsider what happens when you start working on a new feature in a dedicated branch, then another team member updates the main branch with new commits. This results in a forked history, which should be familiar to anyone who has used Git as a collaboration tool.\n\nNow, let’s say that the new commits in main are relevant to the feature that you’re working on. To incorporate the new commits into your feature branch, you have two options: merging or rebasing.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 689
        }
      },
      {
        "header": "The merge option",
        "content": "The easiest option is to merge the main branch into the feature branch using something like the following:\n\nOr, you can condense this to a one-liner:\n\nThis creates a new “merge commit” in the feature branch that ties together the histories of both branches, giving you a branch structure that looks like this:\n\nMerging is nice because it’s a non-destructive operation. The existing branches are not changed in any way. This avoids all of the potential pitfalls of rebasing (discussed below).\n\nOn the other hand, this also means that the feature branch will have an extraneous merge commit every time you need to incorporate upstream changes. If main is very active, this can pollute your feature branch’s history quite a bit. While it’s possible to mitigate this issue with advanced git log options, it can make it hard for other developers to understand the history of the project.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout featuregit merge main\n```",
          "```bash\ngit merge feature main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 882
        }
      },
      {
        "header": "The rebase option",
        "content": "As an alternative to merging, you can rebase the feature branch onto main branch using the following commands:\n\nThis moves the entire feature branch to begin on the tip of the main branch, effectively incorporating all of the new commits in main. But, instead of using a merge commit, rebasing re-writes the project history by creating brand new commits for each commit in the original branch.\n\nThe major benefit of rebasing is that you get a much cleaner project history. First, it eliminates the unnecessary merge commits required by git merge. Second, as you can see in the above diagram, rebasing also results in a perfectly linear project history—you can follow the tip of feature all the way to the beginning of the project without any forks. This makes it easier to navigate your project with commands like git log, git bisect, and gitk.\n\nBut, there are two trade-offs for this pristine commit history: safety and traceability. If you don’t follow the Golden Rule of Rebasing, re-writing project history can be potentially catastrophic for your collaboration workflow. And, less importantly, rebasing loses the context provided by a merge commit—you can’t see when upstream changes were incorporated into the feature.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout featuregit rebase main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1224
        }
      },
      {
        "header": "Interactive rebasing",
        "content": "Interactive rebasing gives you the opportunity to alter commits as they are moved to the new branch. This is even more powerful than an automated rebase, since it offers complete control over the branch’s commit history. Typically, this is used to clean up a messy history before merging a feature branch into main.\n\nTo begin an interactive rebasing session, pass the i option to the git rebase command:\n\nThis will open a text editor listing all of the commits that are about to be moved:\n\nThis listing defines exactly what the branch will look like after the rebase is performed. By changing the pick command and/or re-ordering the entries, you can make the branch’s history look like whatever you want. For example, if the 2nd commit fixes a small problem in the 1st commit, you can condense them into a single commit with the fixup command:\n\nWhen you save and close the file, Git will perform the rebase according to your instructions, resulting in project history that looks like the following:\n\nEliminating insignificant commits like this makes your feature’s history much easier to understand. This is something that git merge simply cannot do.",
        "code_examples": [
          "```bash\npick 33d5b7a Message for commit #1pick 9480b3d Message for commit #2pick 5c67e61 Message for commit #3\n```",
          "```bash\npick 33d5b7a Message for commit #1fixup 9480b3d Message for commit #2pick 5c67e61 Message for commit #3\n```"
        ],
        "usage_examples": [
          "```bash\ngit checkout featuregit rebase -i main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1150
        }
      },
      {
        "header": "The golden rule of rebasing",
        "content": "Once you understand what rebasing is, the most important thing to learn is when not to do it. The golden rule of git rebase is to never use it on public branches.\n\nFor example, think about what would happen if you rebased main onto your feature branch:\n\nThe rebase moves all of the commits in main onto the tip of feature. The problem is that this only happened in your repository. All of the other developers are still working with the original main. Since rebasing results in brand new commits, Git will think that your main branch’s history has diverged from everybody else’s.\n\nThe only way to synchronize the two main branches is to merge them back together, resulting in an extra merge commit and two sets of commits that contain the same changes (the original ones, and the ones from your rebased branch). Needless to say, this is a very confusing situation.\n\nSo, before you run git rebase, always ask yourself, “Is anyone else looking at this branch?” If the answer is yes, take your hands off the keyboard and start thinking about a non-destructive way to make your changes (e.g., the git revert command). Otherwise, you’re safe to re-write history as much as you like.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1177
        }
      },
      {
        "header": "Force-pushing",
        "content": "If you try to push the rebased main branch back to a remote repository, Git will prevent you from doing so because it conflicts with the remote main branch. But, you can force the push to go through by passing the --force flag, like so:\n\nThis overwrites the remote main branch to match the rebased one from your repository and makes things very confusing for the rest of your team. So, be very careful to use this command only when you know exactly what you’re doing.\n\nOne of the only times you should be force-pushing is when you’ve performed a local cleanup after you’ve pushed a private feature branch to a remote repository (e.g., for backup purposes). This is like saying, “Oops, I didn’t really want to push that original version of the feature branch. Take the current one instead.” Again, it’s important that nobody is working off of the commits from the original version of the feature branch.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# Be very careful with this command! git push --force\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 902
        }
      },
      {
        "header": "Workflow walkthrough",
        "content": "Rebasing can be incorporated into your existing Git workflow as much or as little as your team is comfortable with. In this section, we’ll take a look at the benefits that rebasing can offer at the various stages of a feature’s development.\n\nThe first step in any workflow that leverages git rebase is to create a dedicated branch for each feature. This gives you the necessary branch structure to safely utilize rebasing:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 422
        }
      },
      {
        "header": "Local cleanup",
        "content": "One of the best ways to incorporate rebasing into your workflow is to clean up local, in-progress features. By periodically performing an interactive rebase, you can make sure each commit in your feature is focused and meaningful. This lets you write your code without worrying about breaking it up into isolated commits—you can fix it up after the fact.\n\nWhen calling git rebase, you have two options for the new base: The feature’s parent branch (e.g., main), or an earlier commit in your feature. We saw an example of the first option in the Interactive Rebasing section. The latter option is nice when you only need to fix up the last few commits. For example, the following command begins an interactive rebase of only the last 3 commits.\n\nBy specifying HEAD~3 as the new base, you’re not actually moving the branch—you’re just interactively re-writing the 3 commits that follow it. Note that this will not incorporate upstream changes into the feature branch.\n\nIf you want to re-write the entire feature using this method, the git merge-base command can be useful to find the original base of the feature branch. The following returns the commit ID of the original base, which you can then pass to git rebase:\n\nThis use of interactive rebasing is a great way to introduce git rebase into your workflow, as it only affects local branches. The only thing other developers will see is your finished product, which should be a clean, easy-to-follow feature branch history.\n\nBut again, this only works for private feature branches. If you’re collaborating with other developers via the same feature branch, that branch is public, and you’re not allowed to re-write its history.\n\nThere is no git merge alternative for cleaning up local commits with an interactive rebase.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout feature git rebase -i HEAD~3\n```",
          "```bash\ngit merge-base feature main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1771
        }
      },
      {
        "header": "Incorporating upstream changes into a feature",
        "content": "In the Conceptual Overview section, we saw how a feature branch can incorporate upstream changes from main using either git merge or git rebase. Merging is a safe option that preserves the entire history of your repository, while rebasing creates a linear history by moving your feature branch onto the tip of main.\n\nThis use of git rebase is similar to a local cleanup (and can be performed simultaneously), but in the process it incorporates those upstream commits from main.\n\nKeep in mind that it’s perfectly legal to rebase onto a remote branch instead of main. This can happen when collaborating on the same feature with another developer and you need to incorporate their changes into your repository.\n\nFor example, if you and another developer named John added commits to the feature branch, your repository might look like the following after fetching the remote feature branch from John’s repository:\n\nYou can resolve this fork the exact same way as you integrate upstream changes from main: either merge your local feature with john/feature, or rebase your local feature onto the tip of john/feature.\n\nNote that this rebase doesn’t violate the Golden Rule of Rebasing because only your local feature commits are being moved—everything before that is untouched. This is like saying, “add my changes to what John has already done.” In most circumstances, this is more intuitive than synchronizing with the remote branch via a merge commit.\n\nBy default, the git pull command performs a merge, but you can force it to integrate the remote branch with a rebase by passing it the --rebase option.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1600
        }
      },
      {
        "header": "Reviewing a feature with a pull request",
        "content": "If you use pull requests as part of your code review process, you need to avoid using git rebase after creating the pull request. As soon as you make the pull request, other developers will be looking at your commits, which means that it’s a public branch. Re-writing its history will make it impossible for Git and your teammates to track any follow-up commits added to the feature.\n\nAny changes from other developers need to be incorporated with git merge instead of git rebase.\n\nFor this reason, it’s usually a good idea to clean up your code with an interactive rebase before submitting your pull request.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 609
        }
      },
      {
        "header": "Integrating an approved feature",
        "content": "After a feature has been approved by your team, you have the option of rebasing the feature onto the tip of the main branch before using git merge to integrate the feature into the main code base.\n\nThis is a similar situation to incorporating upstream changes into a feature branch, but since you’re not allowed to re-write commits in the main branch, you have to eventually use git merge to integrate the feature. However, by performing a rebase before the merge, you’re assured that the merge will be fast-forwarded, resulting in a perfectly linear history. This also gives you the chance to squash any follow-up commits added during a pull request.\n\nIf you’re not entirely comfortable with git rebase, you can always perform the rebase in a temporary branch. That way, if you accidentally mess up your feature’s history, you can check out the original branch and try again. For example:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout featuregit checkout -b temporary-branchgit rebase -i main# [Clean up the history]git checkout maingit merge temporary-branch\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 889
        }
      },
      {
        "header": "Summary",
        "content": "And that’s all you really need to know to start rebasing your branches. If you would prefer a clean, linear history free of unnecessary merge commits, you should reach for git rebase instead of git merge when integrating changes from another branch.\n\nOn the other hand, if you want to preserve the complete history of your project and avoid the risk of re-writing public commits, you can stick with git merge. Either option is perfectly valid, but at least now you have the option of leveraging the benefits of git rebase.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 522
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/merging-vs-rebasing",
    "doc_type": "git",
    "total_sections": 15
  },
  {
    "title": "Resetting, checking out & reverting",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "The git reset, git checkout, and git revert commands are some of the most useful tools in your Git toolbox. They all let you undo some kind of change in your repository, and the first two commands can be used to manipulate either commits or individual files.\n\nBecause they’re so similar, it’s very easy to mix up which command should be used in any given development scenario. In this article, we’ll compare the most common configurations of git reset, git checkout, and git revert. Hopefully, you’ll walk away with the confidence to navigate your repository using any of these commands.\n\nIt helps to think about each command in terms of their effect on the three state management mechanisms of a Git repository: the working directory, the staged snapshot, and the commit history. These components are sometimes known as \"The three trees\" of Git. We explore the three trees in depth on the git reset page. Keep these mechanisms in mind as you read through this article.\n\nA checkout is an operation that moves the HEAD ref pointer to a specified commit. To demonstrate this consider the following example.\n\nThis example demonstrates a sequence of commits on the main branch. The HEAD ref and main branch ref currently point to commit d. Now let us execute git checkout b\n\nThis is an update to the \"Commit History\" tree. The git checkout command can be used in a commit, or file level scope. A file level checkout will change the file's contents to those of the specific commit.\n\nA revert is an operation that takes a specified commit and creates a new commit which inverses the specified commit. git revert can only be run at a commit level scope and has no file level functionality.\n\nA reset is an operation that takes a specified commit and resets the \"three trees\" to match the state of the repository at that specified commit. A reset can be invoked in three different modes which correspond to the three trees.\n\nCheckout and reset are generally used for making local or private 'undos'. They modify the history of a repository that can cause conflicts when pushing to remote shared repositories. Revert is considered a safe operation for 'public undos' as it creates new history which can be shared remotely and doesn't overwrite history remote team members may be dependent on.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 2282
        }
      },
      {
        "header": "Git reset vs revert vs checkout reference",
        "content": "The table below sums up the most common use cases for all of these commands. Be sure to keep this reference handy, as you’ll undoubtedly need to use at least some of them during your Git career.\n\nCommand | Scope | Common use cases\n--- | --- | ---\ngit reset | Scope Commit-level | Common use cases Discard commits in a private branch or throw away uncommitted changes\ngit reset | Scope File-level | Common use cases Unstage a file\ngit checkout | Scope Commit-level | Common use cases Switch between branches or inspect old snapshots\ngit checkout | Scope File-level | Common use cases Discard changes in the working directory\ngit revert | Scope Commit-level | Common use cases Undo commits in a public branch\ngit revert | Scope File-level | Common use cases (N/A)",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 1,
          "content_length": 761
        }
      },
      {
        "header": "Command",
        "content": "Discard commits in a private branch or throw away uncommitted changes\n\nSwitch between branches or inspect old snapshots\n\nDiscard changes in the working directory\n\nUndo commits in a public branch",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 194
        }
      },
      {
        "header": "Commit level operations",
        "content": "The parameters that you pass to git reset and git checkout determine their scope. When you don’t include a file path as a parameter, they operate on whole commits. That’s what we’ll be exploring in this section. Note that git revert has no file-level counterpart.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 263
        }
      },
      {
        "header": "Reset a specific commit",
        "content": "On the commit-level, resetting is a way to move the tip of a branch to a different commit. This can be used to remove commits from the current branch. For example, the following command moves the hotfix branch backwards by two commits.\n\nThe two commits that were on the end of hotfix are now dangling, or orphaned commits. This means they will be deleted the next time Git performs a garbage collection. In other words, you’re saying that you want to throw away these commits. This can be visualized as the following:\n\nThis usage of git reset is a simple way to undo changes that haven’t been shared with anyone else. It’s your go-to command when you’ve started working on a feature and find yourself thinking, “Oh crap, what am I doing? I should just start over.”\n\nIn addition to moving the current branch, you can also get git reset to alter the staged snapshot and/or the working directory by passing it one of the following flags:\n\nIt’s easier to think of these modes as defining the scope of a git reset operation. For further detailed information visit the git reset page.\n\n• --soft – The staged snapshot and working directory are not altered in any way.\n• --mixed – The staged snapshot is updated to match the specified commit, but the working directory is not affected. This is the default option.\n• --hard – The staged snapshot and the working directory are both updated to match the specified commit.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout hotfix git reset HEAD~2\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1410
        }
      },
      {
        "header": "Checkout old commits",
        "content": "The git checkout command is used to update the state of the repository to a specific point in the projects history. When passed with a branch name, it lets you switch between branches.\n\nInternally, all the above command does is move HEAD to a different branch and update the working directory to match. Since this has the potential to overwrite local changes, Git forces you to commit or stash any changes in the working directory that will be lost during the checkout operation. Unlike git reset, git checkout doesn’t move any branches around.\n\nYou can also check out arbitrary commits by passing the commit reference instead of a branch. This does the exact same thing as checking out a branch: it moves the HEAD reference to the specified commit. For example, the following command will check out the grandparent of the current commit:\n\nThis is useful for quickly inspecting an old version of your project. However, since there is no branch reference to the current HEAD, this puts you in a detached HEAD state. This can be dangerous if you start adding new commits because there will be no way to get back to them after you switch to another branch. For this reason, you should always create a new branch before adding commits to a detached HEAD.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout hotfix\n```",
          "```bash\ngit checkout HEAD~2\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1250
        }
      },
      {
        "header": "Undo public commits with revert",
        "content": "Reverting undoes a commit by creating a new commit. This is a safe way to undo changes, as it has no chance of re-writing the commit history. For example, the following command will figure out the changes contained in the 2nd to last commit, create a new commit undoing those changes, and tack the new commit onto the existing project.\n\nThis can be visualized as the following:\n\nContrast this with git reset, which does alter the existing commit history. For this reason, git revert should be used to undo changes on a public branch, and git reset should be reserved for undoing changes on a private branch.\n\nYou can also think of git revert as a tool for undoing committed changes, while git reset HEAD is for undoing uncommitted changes.\n\nLike git checkout, git revert has the potential to overwrite files in the working directory, so it will ask you to commit or stash changes that would be lost during the revert operation.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout hotfix git revert HEAD~2\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 927
        }
      },
      {
        "header": "File-level operations",
        "content": "The git reset and git checkout commands also accept an optional file path as a parameter. This dramatically alters their behavior. Instead of operating on entire snapshots, this forces them to limit their operations to a single file.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 233
        }
      },
      {
        "header": "Git reset a specific file",
        "content": "When invoked with a file path, git reset updates the staged snapshot to match the version from the specified commit. For example, this command will fetch the version of foo.py in the 2nd-to-last commit and stage it for the next commit:\n\nAs with the commit-level version of git reset, this is more commonly used with HEAD rather than an arbitrary commit. Running git reset HEAD foo.py will unstage foo.py. The changes it contains will still be present in the working directory.\n\nThe --soft, --mixed, and --hard flags do not have any effect on the file-level version of git reset, as the staged snapshot is always updated, and the working directory is never updated.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit reset HEAD~2 foo.py\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 664
        }
      },
      {
        "header": "Git checkout file",
        "content": "Checking out a file is similar to using git reset with a file path, except it updates the working directory instead of the stage. Unlike the commit-level version of this command, this does not move the HEAD reference, which means that you won’t switch branches.\n\nFor example, the following command makes foo.py in the working directory match the one from the 2nd-to-last commit:\n\nJust like the commit-level invocation of git checkout, this can be used to inspect old versions of a project—but the scope is limited to the specified file.\n\nIf you stage and commit the checked-out file, this has the effect of “reverting” to the old version of that file. Note that this removes all of the subsequent changes to the file, whereas the git revert command undoes only the changes introduced by the specified commit.\n\nLike git reset, this is commonly used with HEAD as the commit reference. For instance, git checkout HEAD foo.py has the effect of discarding unstaged changes to foo.py. This is similar behavior to git reset HEAD --hard, but it operates only on the specified file.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout HEAD~2 foo.py\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1073
        }
      },
      {
        "header": "Summary",
        "content": "You should now have all the tools you could ever need to undo changes in a Git repository. The git reset, git checkout, and git revert commands can be confusing, but when you think about their effects on the working directory, staged snapshot, and commit history, it should be easier to discern which command fits the development task at hand.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 343
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting",
    "doc_type": "git",
    "total_sections": 13
  },
  {
    "title": "Git hooks",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "Git hooks are scripts that run automatically every time a particular event occurs in a Git repository. They let you customize Git’s internal behavior and trigger customizable actions at key points in the development life cycle.\n\nCommon use cases for Git hooks include encouraging a commit policy, altering the project environment depending on the state of the repository, and implementing continuous integration workflows. But, since scripts are infinitely customizable, you can use Git hooks to automate or optimize virtually any aspect of your development workflow.\n\nIn this article, we’ll start with a conceptual overview of how Git hooks work. Then, we’ll survey some of the most popular hooks for use in both local and server-side repositories.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 749
        }
      },
      {
        "header": "Conceptual overview",
        "content": "All Git hooks are ordinary scripts that Git executes when certain events occur in the repository. This makes them very easy to install and configure.\n\nHooks can reside in either local or server-side repositories, and they are only executed in response to actions in that repository. We’ll take a concrete look at categories of hooks later in this article. The configuration discussed in the rest of this section applies to both local and server-side hooks.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 456
        }
      },
      {
        "header": "Installing hooks",
        "content": "Hooks reside in the .git/hooks directory of every Git repository. Git automatically populates this directory with example scripts when you initialize a repository. If you take a look inside .git/hooks, you’ll find the following files:\n\nThese represent most of the available hooks, but the .sample extension prevents them from executing by default. To “install” a hook, all you have to do is remove the .sample extension. Or, if you’re writing a new script from scratch, you can simply add a new file matching one of the above filenames, minus the .sample extension.\n\nAs an example, try installing a simple prepare-commit-msg hook. Remove the .sample extension from this script, and add the following to the file:\n\nHooks need to be executable, so you may need to change the file permissions of the script if you’re creating it from scratch. For example, to make sure that prepare-commit-msg is executable, you would run the following command:\n\nYou should now see this message in place of the default commit message every time you run git commit. We’ll take a closer look at how this actually works in the Prepare Commit Message section. For now, let’s just revel in the fact that we can customize some of Git’s internal functionality.\n\nThe built-in sample scripts are very useful references, as they document the parameters that are passed in to each hook (they vary from hook to hook).",
        "code_examples": [
          "```bash\napplypatch-msg.sample       pre-push.samplecommit-msg.sample           pre-rebase.samplepost-update.sample          prepare-commit-msg.samplepre-applypatch.sample       update.samplepre-commit.sample\n```",
          "```bash\nchmod +x prepare-commit-msg\n```"
        ],
        "usage_examples": [
          "```bash\n#!/bin/shecho \"# Please include a useful commit message!\" > $1\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1385
        }
      },
      {
        "header": "Scripting languages",
        "content": "The built-in scripts are mostly shell and PERL scripts, but you can use any scripting language you like as long as it can be run as an executable. The shebang line (#!/bin/sh) in each script defines how your file should be interpreted. So, to use a different language, all you have to do is change it to the path of your interpreter.\n\nFor instance, we can write an executable Python script in the prepare-commit-msg file instead of using shell commands. The following hook will do the same thing as the shell script in the previous section.\n\nNotice how the first line changed to point to the Python interpreter. And, instead of using $1 to access the first argument passed to the script, we used sys.argv[1] (again, more on this in a moment).\n\nThis is a very powerful feature for Git hooks because it lets you work in whatever language you’re most comfortable with.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n#!/usr/bin/env pythonimport sys, oscommit_msg_filepath = sys.argv[1]with open(commit_msg_filepath, 'w') as f:f.write(\"# Please include a useful commit message!\")\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 865
        }
      },
      {
        "header": "Scope of hooks",
        "content": "Hooks are local to any given Git repository, and they are not copied over to the new repository when you run git clone. And, since hooks are local, they can be altered by anybody with access to the repository.\n\nThis has an important impact when configuring hooks for a team of developers. First, you need to find a way to make sure hooks stay up-to-date amongst your team members. Second, you can’t force developers to create commits that look a certain way—you can only encourage them to do so.\n\nMaintaining hooks for a team of developers can be a little tricky because the .git/hooks directory isn’t cloned with the rest of your project, nor is it under version control. A simple solution to both of these problems is to store your hooks in the actual project directory (above the .git directory). This lets you edit them like any other version-controlled file. To install the hook, you can either create a symlink to it in .git/hooks, or you can simply copy and paste it into the .git/hooks directory whenever the hook is updated.\n\nAs an alternative, Git also provides a Template Directory mechanism that makes it easier to install hooks automatically. All of the files and directories contained in this template directory are copied into the .git directory every time you use git init or git clone.\n\nAll of the local hooks described below can be altered—or completely un-installed—by the owner of a repository. It’s entirely up to each team member whether or not they actually use a hook. With this in mind, it’s best to think of Git hooks as a convenient developer tool rather than a strictly enforced development policy.\n\nThat said, it is possible to reject commits that do not conform to some standard using server-side hooks. We’ll talk more about this later in the article.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1782
        }
      },
      {
        "header": "Local hooks",
        "content": "Local hooks affect only the repository in which they reside. As you read through this section, remember that each developer can alter their own local hooks, so you can’t use them as a way to enforce a commit policy. They can, however, make it much easier for developers to adhere to certain guidelines. In this section, we’ll be exploring 6 of the most useful local hooks:\n\nThe first 4 hooks let you plug into the entire commit life cycle, and the final 2 let you perform some extra actions or safety checks for the git checkout and git rebase commands, respectively.\n\nAll of the pre- hooks let you alter the action that’s about to take place, while the post- hooks are used only for notifications.\n\nWe’ll also see some useful techniques for parsing hook arguments and requesting information about the repository using lower-level Git commands.\n\n• prepare-commit-msg\n• post-commit\n• post-checkout",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 896
        }
      },
      {
        "header": "Pre-Commit",
        "content": "The pre-commit script is executed every time you run git commit before Git asks the developer for a commit message or generates a commit object. You can use this hook to inspect the snapshot that is about to be committed. For example, you may want to run some automated tests that make sure the commit doesn’t break any existing functionality.\n\nNo arguments are passed to the pre-commit script, and exiting with a non-zero status aborts the entire commit. Let’s take a look at a simplified (and more verbose) version of the built-in pre-commit hook. This script aborts the commit if it finds any whitespace errors, as defined by the git diff-index command (trailing whitespace, lines with only whitespace, and a space followed by a tab inside the initial indent of a line are considered errors by default).\n\nIn order to use git diff-index, we need to figure out which commit reference we’re comparing the index to. Normally, this is HEAD; however, HEAD doesn’t exist when creating the initial commit, so our first task is to account for this edge case. We do this with git rev-parse --verify, which simply checks whether or not the argument (HEAD) is a valid reference. The >/dev/null 2>&1 portion silences any output from git rev-parse. Either HEAD or an empty commit object is stored in the against variable for use with git diff-index. The 4b825d... hash is a magic commit ID that represents an empty commit.\n\nThe git diff-index --cached command compares a commit against the index. By passing the --check option, we’re asking it to warn us if the changes introduces whitespace errors. If it does, we abort the commit by returning an exit status of 1, otherwise we exit with 0 and the commit workflow continues as normal.\n\nThis is just one example of the pre-commit hook. It happens to use existing Git commands to run tests on the changes introduced by the proposed commit, but you can do anything you want in pre-commit including executing other scripts, running a 3rd-party test suite, or checking code style with Lint.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n#!/bin/sh# Check if this is the initial commitif git rev-parse --verify HEAD >/dev/null 2>&1thenecho \"pre-commit: About to create a new commit...\"against=HEADelseecho \"pre-commit: About to create the first commit...\"against=4b825dc642cb6eb9a060e54bf8d69288fbee4904fi# Use git diff-index to check for whitespace errorsecho \"pre-commit: Testing for whitespace errors...\"if ! git diff-index --check --cached $againstthenecho \"pre-commit: Aborting commit due to whitespace errors\"exit 1elseecho \"pre-commit: No whitespace errors :)\"exit 0fi\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 2025
        }
      },
      {
        "header": "Prepare commit message",
        "content": "The prepare-commit-msg hook is called after the pre-commit hook to populate the text editor with a commit message. This is a good place to alter the automatically generated commit messages for squashed or merged commits.\n\nOne to three arguments are passed to the prepare-commit-msg script:\n\n1. The name of a temporary file that contains the message. You change the commit message by altering this file in-place.\n\n2. The type of commit. This can be message (-m or -F option), template (-t option), merge (if the commit is a merge commit), or squash (if the commit is squashing other commits).\n\n3. The SHA1 hash of the relevant commit. Only given if -c, -C, or --amend option was given.\n\nAs with pre-commit, exiting with a non-zero status aborts the commit.\n\nWe already saw a simple example that edited the commit message, but let’s take a look at a more useful script. When using an issue tracker, a common convention is to address each issue in a separate branch. If you include the issue number in the branch name, you can write a prepare-commit-msg hook to automatically include it in each commit message on that branch.\n\nFirst, the above prepare-commit-msg hook shows you how to collect all of the parameters that are passed to the script. Then, it calls git symbolic-ref --short HEAD to get the branch name that corresponds to HEAD. If this branch name starts with issue-, it re-writes the commit message file contents to include the issue number in the first line. So, if your branch name is issue-224, this will generate the following commit message.\n\nOne thing to keep in mind when using prepare-commit-msg is that it runs even when the user passes in a message with the -m option of git commit. This means that the above script will automatically insert the ISSUE-[#] string without letting the user edit it. You can handle this case by seeing if the 2nd parameter (commit_type) is equal to message.\n\nHowever, without the -m option, the prepare-commit-msg hook does allow the user to edit the message after its generated, so this is really more of a convenience script than a way to enforce a commit message policy. For that, you need the commit-msg hook discussed in the next section.",
        "code_examples": [
          "```bash\nISSUE-224# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.# On branch issue-224# Changes to be committed:#   modified:   test.txt\n```"
        ],
        "usage_examples": [
          "```bash\n#!/usr/bin/env pythonimport sys, os, refrom subprocess import check_output# Collect the parameterscommit_msg_filepath = sys.argv[1]if len(sys.argv) > 2:commit_type = sys.argv[2]else:commit_type = ''if len(sys.argv) > 3:commit_hash = sys.argv[3]else:commit_hash = ''print \"prepare-commit-msg: File: %s\\nType: %s\\nHash: %s\" % (commit_msg_filepath, commit_type, commit_hash)# Figure out which branch we're onbranch = check_output(['git', 'symbolic-ref', '--short', 'HEAD']).strip()print \"prepare-commit-msg: On branch '%s'\" % branch# Populate the commit message with the issue #, if there is oneif branch.startswith('issue-'):print \"prepare-commit-msg: Oh hey, it's an issue branch.\"result = re.match('issue-(.*)', branch)issue_number = result.group(1)with open(commit_msg_filepath, 'r+') as f:content = f.read()f.seek(0, 0)f.write(\"ISSUE-%s %s\" % (issue_number, content))\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 2193
        }
      },
      {
        "header": "Commit message",
        "content": "The commit-msg hook is much like the prepare-commit-msg hook, but it’s called after the user enters a commit message. This is an appropriate place to warn developers that their message doesn’t adhere to your team’s standards.\n\nThe only argument passed to this hook is the name of the file that contains the message. If it doesn’t like the message that the user entered, it can alter this file in-place (just like with prepare-commit-msg) or it can abort the commit entirely by exiting with a non-zero status.\n\nFor example, the following script checks to make sure that the user didn’t delete the ISSUE-[#] string that was automatically generated by the prepare-commit-msg hook in the previous section.\n\nWhile this script is called every time the user creates a commit, you should avoid doing much outside of checking the commit message. If you need to notify other services that a snapshot was committed, you should use the post-commit hook instead.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n#!/usr/bin/env pythonimport sys, os, refrom subprocess import check_output# Collect the parameterscommit_msg_filepath = sys.argv[1]# Figure out which branch we're onbranch = check_output(['git', 'symbolic-ref', '--short', 'HEAD']).strip()print \"commit-msg: On branch '%s'\" % branch# Check the commit message if we're on an issue branchif branch.startswith('issue-'):print \"commit-msg: Oh hey, it's an issue branch.\"result = re.match('issue-(.*)', branch)issue_number = result.group(1)required_message = \"ISSUE-%s\" % issue_numberwith open(commit_msg_filepath, 'r') as f:content = f.read()if not content.startswith(required_message):print \"commit-msg: ERROR! The commit message must start with '%s'\" % required_messagesys.exit(1)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 949
        }
      },
      {
        "header": "Post-Commit",
        "content": "The post-commit hook is called immediately after the commit-msg hook. It can’t change the outcome of the git commit operation, so it’s used primarily for notification purposes.\n\nThe script takes no parameters and its exit status does not affect the commit in any way. For most post-commit scripts, you’ll want access to the commit that was just created. You can use git rev-parse HEAD to get the new commit’s SHA1 hash, or you can use git log -1 HEAD to get all of its information.\n\nFor example, if you want to email your boss every time you commit a snapshot (probably not the best idea for most workflows), you could add the following post-commit hook.\n\nIt’s possible to use post-commit to trigger a local continuous integration system, but most of the time you’ll want to be doing this in the post-receive hook. This runs on the server instead of the user’s local machine, and it also runs every time any developer pushes their code. This makes it a much more appropriate place to perform your continuous integration.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n#!/usr/bin/env pythonimport smtplibfrom email.mime.text import MIMETextfrom subprocess import check_output# Get the git log --stat entry of the new commitlog = check_output(['git', 'log', '-1', '--stat', 'HEAD'])# Create a plaintext email messagemsg = MIMEText(\"Look, I'm actually doing some work:\\n\\n%s\" % log)msg['Subject'] = 'Git post-commit hook notification'msg['From'] = 'mary@example.com'msg['To'] = 'boss@example.com'# Send the messageSMTP_SERVER = 'smtp.example.com'SMTP_PORT = 587session = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)session.ehlo()session.starttls()session.ehlo()session.login(msg['From'], 'secretPassword')session.sendmail(msg['From'], msg['To'], msg.as_string())session.quit()\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1020
        }
      },
      {
        "header": "Post-Checkout",
        "content": "The post-checkout hook works a lot like the post-commit hook, but it’s called whenever you successfully check out a reference with git checkout. This is nice for clearing out your working directory of generated files that would otherwise cause confusion.\n\nThis hook accepts three parameters, and its exit status has no affect on the git checkout command.\n\n1. The ref of the previous HEAD\n\n2. The ref of the new HEAD\n\n3. A flag telling you if it was a branch checkout or a file checkout. The flag will be 1 and 0, respectively.\n\nA common problem with Python developers occurs when generated .pyc files stick around after switching branches. The interpreter sometimes uses these .pyc instead of the .py source file. To avoid any confusion, you can delete all .pyc files every time you check out a new branch using the following post-checkout script:\n\nThe current working directory for hook scripts is always set to the root of the repository, so the os.walk('.') call iterates through every file in the repository. Then, we check its extension and delete it if it’s a .pyc file.\n\nYou can also use the post-checkout hook to alter your working directory based on which branch you have checked out. For example, you might use a plugins branch to store all of your plugins outside of the core codebase. If these plugins require a lot of binaries that other branches do not, you can selectively build them only when you’re on the plugins branch.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n#!/usr/bin/env pythonimport sys, os, refrom subprocess import check_output# Collect the parametersprevious_head = sys.argv[1]new_head = sys.argv[2]is_branch_checkout = sys.argv[3]if is_branch_checkout == \"0\":print \"post-checkout: This is a file checkout. Nothing to do.\"sys.exit(0)print \"post-checkout: Deleting all '.pyc' files in working directory\"for root, dirs, files in os.walk('.'):for filename in files:ext = os.path.splitext(filename)[1]if ext == '.pyc':os.unlink(os.path.join(root, filename))\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1438
        }
      },
      {
        "header": "Pre-Rebase",
        "content": "The pre-rebase hook is called before git rebase changes anything, making it a good place to make sure something terrible isn’t about to happen.\n\nThis hook takes 2 parameters: the upstream branch that the series was forked from, and the branch being rebased. The second parameter is empty when rebasing the current branch. To abort the rebase, exit with a non-zero status.\n\nFor example, if you want to completely disallow rebasing in your repository, you could use the following pre-rebase script:\n\nNow, every time you run git rebase, you’ll see this message:\n\nFor a more in-depth example, take a look at the included pre-rebase.sample script. This script is a little more intelligent about when to disallow rebasing. It checks to see if the topic branch that you’re trying to rebase has already been merged into the next branch (which is assumed to be the mainline branch). If it has, you’re probably going to get into trouble by rebasing it, so the script aborts the rebase.",
        "code_examples": [
          "```bash\n#!/bin/sh# Disallow all rebasingecho \"pre-rebase: Rebasing is dangerous. Don't do it.\"exit 1\n```",
          "```bash\npre-rebase: Rebasing is dangerous. Don't do it.The pre-rebase hook refused to rebase.\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 975
        }
      },
      {
        "header": "Server-side hooks",
        "content": "Server-side hooks work just like local ones, except they reside in server-side repositories (e.g., a central repository, or a developer’s public repository). When attached to the official repository, some of these can serve as a way to enforce policy by rejecting certain commits.\n\nThere are 3 server-side hooks that we’ll be discussing in the rest of this article:\n\nAll of these hooks let you react to different stages of the git push process.\n\nThe output from server-side hooks are piped to the client’s console, so it’s very easy to send messages back to the developer. But, you should also keep in mind that these scripts don’t return control of the terminal until they finish executing, so you should be careful about performing long-running operations.\n\n• pre-receive\n• post-receive",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 788
        }
      },
      {
        "header": "Pre-Receive",
        "content": "The pre-receive hook is executed every time somebody uses git push to push commits to the repository. It should always reside in the remote repository that is the destination of the push, not in the originating repository.\n\nThe hook runs before any references are updated, so it’s a good place to enforce any kind of development policy that you want. If you don’t like who is doing the pushing, how the commit message is formatted, or the changes contained in the commit, you can simply reject it. While you can’t stop developers from making malformed commits, you can prevent these commits from entering the official codebase by rejecting them with pre-receive.\n\nThe script takes no parameters, but each ref that is being pushed is passed to the script on a separate line on standard input in the following format:\n\nYou can see how this hook works using a very basic pre-receive script that simply reads in the pushed refs and prints them out.\n\nAgain, this is a little different than the other hooks because information is passed to the script via standard input instead of as command-line arguments. After placing the above script in the .git/hooks directory of a remote repository and pushing the main branch, you’ll see something like the following in your console:\n\nYou can use these SHA1 hashes, along with some lower-level Git commands, to inspect the changes that are going to be introduced. Some common use cases include:\n\nIf multiple refs are pushed, returning a non-zero status from pre-receive aborts all of them. If you want to accept or reject branches on a case-by-case basis, you need to use the update hook instead.\n\n• Rejecting changes that involve an upstream rebase\n• Preventing non-fast-forward merges\n• Checking that the user has the correct permissions to make the intended changes (mostly used for centralized Git workflows)",
        "code_examples": [
          "```bash\n<old-value> <new-value> <ref-name>\n```",
          "```bash\nb6b36c697eb2d24302f89aa22d9170dfe609855b 85baa88c22b52ddd24d71f05db31f4e46d579095 refs/heads/main\n```"
        ],
        "usage_examples": [
          "```bash\n#!/usr/bin/env pythonimport sysimport fileinput# Read in each ref that the user is trying to updatefor line in fileinput.input():print \"pre-receive: Trying to push ref: %s\" % line# Abort the push# sys.exit(1)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1848
        }
      },
      {
        "header": "Update",
        "content": "The update hook is called after pre-receive, and it works much the same way. It’s still called before anything is actually updated, but it’s called separately for each ref that was pushed. That means if the user tries to push 4 branches, update is executed 4 times. Unlike pre-receive, this hook doesn’t need to read from standard input. Instead, it accepts the following 3 arguments:\n\n1. The name of the ref being updated\n\n2. The old object name stored in the ref\n\n3. The new object name stored in the ref\n\nThis is the same information passed to pre-receive, but since update is invoked separately for each ref, you can reject some refs while allowing others.\n\nThe above update hook simply outputs the branch and the old/new commit hashes. When pushing more than one branch to the remote repository, you’ll see the print statement execute for each branch.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n#!/usr/bin/env pythonimport sysbranch = sys.argv[1]old_commit = sys.argv[2]new_commit = sys.argv[3]print \"Moving '%s' from %s to %s\" % (branch, old_commit, new_commit)# Abort pushing only this branch# sys.exit(1)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 856
        }
      },
      {
        "header": "Post-Receive",
        "content": "The post-receive hook gets called after a successful push operation, making it a good place to perform notifications. For many workflows, this is a better place to trigger notifications than post-commit because the changes are available on a public server instead of residing only on the user’s local machine. Emailing other developers and triggering a continuous integration system are common use cases for post-receive.\n\nThe script takes no parameters, but is sent the same information as pre-receive via standard input.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 522
        }
      },
      {
        "header": "Summary",
        "content": "In this article, we learned how Git hooks can be used to alter internal behavior and receive notifications when certain events occur in a repository. Hooks are ordinary scripts that reside in the .git/hooks repository, which makes them very easy to install and customize.\n\nWe also looked at some of the most common local and server-side hooks. These let us plug in to the entire development life cycle. We now know how to perform customizable actions at every stage in the commit creation process, as well as the git push process. With a little bit of scripting knowledge, this lets you do virtually anything you can imagine with a Git repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 647
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/git-hooks",
    "doc_type": "git",
    "total_sections": 19
  },
  {
    "title": "Git refs: An overview",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "Learn the basics of Git with this space themed tutorial.\n\nBy understanding the many ways to refer to a commit, you make all of these commands that much more powerful. In this chapter, we’ll shed some light on the internal workings of common commands like git checkout, git branch, and git push by exploring the many methods of referring to a commit.\n\nWe’ll also learn how to revive seemingly “lost” commits by accessing them through Git’s reflog mechanism.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 456
        }
      },
      {
        "header": "Hashes",
        "content": "The most direct way to reference a commit is via its SHA-1 hash. This acts as the unique ID for each commit. You can find the hash of all your commits in the git log output.\n\nWhen passing the commit to other Git commands, you only need to specify enough characters to uniquely identify the commit. For example, you can inspect the above commit with git show by running the following command:\n\nIt’s sometimes necessary to resolve a branch, tag, or another indirect reference into the corresponding commit hash. For this, you can use the git rev-parse command. The following returns the hash of the commit pointed to by the main branch:\n\nThis is particularly useful when writing custom scripts that accept a commit reference. Instead of parsing the commit reference manually, you can let git rev-parse normalize the input for you.",
        "code_examples": [
          "```bash\ncommit 0c708fdec272bc4446c6cabea4f0022c2b616eba Author: Mary Johnson  Date: Wed Jul 9 16:37:42 2014 -0500 Some commit message\n```"
        ],
        "usage_examples": [
          "```bash\ngit show 0c708f\n```",
          "```bash\ngit rev-parse main\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 828
        }
      },
      {
        "header": "Refs",
        "content": "A ref is an indirect way of referring to a commit. You can think of it as a user-friendly alias for a commit hash. This is Git’s internal mechanism of representing branches and tags.\n\nRefs are stored as normal text files in the .git/refs directory, where .git is usually called .git. To explore the refs in one of your repositories, navigate to .git/refs. You should see the following structure, but it will contain different files depending on what branches, tags, and remotes you have in your repo:\n\nThe heads directory defines all of the local branches in your repository. Each filename matches the name of the corresponding branch, and inside the file you’ll find a commit hash. This commit hash is the location of the tip of the branch. To verify this, try running the following two commands from the root of the Git repository:\n\nThe commit hash returned by the cat command should match the commit ID displayed by git log.\n\nTo change the location of the main branch, all Git has to do is change the contents of the refs/heads/main file. Similarly, creating a new branch is simply a matter of writing a commit hash to a new file. This is part of the reason why Git branches are so lightweight compared to SVN.\n\nThe tags directory works the exact same way, but it contains tags instead of branches. The remotes directory lists all remote repositories that you created with git remote as separate subdirectories. Inside each one, you’ll find all the remote branches that have been fetched into your repository.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n.git/refs/ heads/ main some-feature remotes/ origin/ main tags/ v0.9\n```",
          "```bash\n# Output the contents of `refs/heads/main` file: cat .git/refs/heads/main # Inspect the commit at the tip of the `main` branch: git log -1 main\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1512
        }
      },
      {
        "header": "Specifying refs",
        "content": "When passing a ref to a Git command, you can either define the full name of the ref, or use a short name and let Git search for a matching ref. You should already be familiar with short names for refs, as this is what you’re using each time you refer to a branch by name.\n\nThe some-feature argument in the above command is actually a short name for the branch. Git resolves this to refs/heads/some-feature before using it. You can also specify the full ref on the command line, like so:\n\nThis avoids any ambiguity regarding the location of the ref. This is necessary, for instance, if you had both a tag and a branch called some-feature. However, if you’re using proper naming conventions, ambiguity between tags and branches shouldn’t generally be a problem.\n\nWe’ll see more full ref names in the Refspecs section.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit show some-feature\n```",
          "```bash\ngit show refs/heads/some-feature\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 815
        }
      },
      {
        "header": "Packed refs",
        "content": "For large repositories, Git will periodically perform a garbage collection to remove unnecessary objects and compress refs into a single file for more efficient performance. You can force this compression with the garbage collection command:\n\nThis moves all of the individual branch and tag files in the refs folder into a single file called packed-refs located in the top of the .git directory. If you open up this file, you’ll find a mapping of commit hashes to refs:\n\nOn the outside, normal Git functionality won’t be affected in any way. But, if you’re wondering why your .git/refs folder is empty, this is where the refs went.",
        "code_examples": [
          "```bash\n00f54250cf4e549fdfcafe2cf9a2c90bc3800285 refs/heads/feature 0e25143693cfe9d5c2e83944bbaf6d3c4505eb17 refs/heads/main bb883e4c91c870b5fed88fd36696e752fb6cf8e6 refs/tags/v0.9\n```"
        ],
        "usage_examples": [
          "```bash\ngit gc\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 631
        }
      },
      {
        "header": "Special refs",
        "content": "In addition to the refs directory, there are a few special refs that reside in the top-level .git directory. They are listed below:\n\nThese refs are all created and updated by Git when necessary. For example, The git pull command first runs git fetch, which updates the FETCH_HEAD reference. Then, it runs git merge FETCH_HEAD to finish pulling the fetched branches into the repository. Of course, you can use all of these like any other ref, as I’m sure you’ve done with HEAD.\n\nThese files contain different content depending on their type and the state of your repository. The HEAD ref can contain either a symbolic ref, which is simply a reference to another ref instead of a commit hash, or a commit hash. For example, take a look at the contents of HEAD when you’re on the main branch:\n\nThis will output ref: refs/heads/main, which means that HEAD points to the refs/heads/main ref. This is how Git knows that the main branch is currently checked out. If you were to switch to another branch, the contents of HEAD would be updated to reflect the new branch. But, if you were to check out a commit instead of a branch, HEAD would contain a commit hash instead of a symbolic ref. This is how Git knows that it’s in a detached HEAD state.\n\nFor the most part, HEAD is the only reference that you’ll be using directly. The others are generally only useful when writing lower-level scripts that need to hook into Git’s internal workings.\n\n• HEAD – The currently checked-out commit/branch.\n• FETCH_HEAD – The most recently fetched branch from a remote repo.\n• ORIG_HEAD – A backup reference to HEAD before drastic changes to it.\n• MERGE_HEAD – The commit(s) that you’re merging into the current branch with git merge.\n• CHERRY_PICK_HEAD – The commit that you’re cherry-picking.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout main cat .git/HEAD\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1774
        }
      },
      {
        "header": "Refspecs",
        "content": "A refspec maps a branch in the local repository to a branch in a remote repository. This makes it possible to manage remote branches using local Git commands and to configure some advanced git push and git fetch behavior.\n\nA refspec is specified as [+]＜src＞:＜dst＞. The ＜src＞ parameter is the source branch in the local repository, and the ＜dst＞ parameter is the destination branch in the remote repository. The optional + sign is for forcing the remote repository to perform a non-fast-forward update.\n\nRefspecs can be used with the git push command to give a different name to the remote branch. For example, the following command pushes the main branch to the origin remote repo like an ordinary git push, but it uses qa-main as the name for the branch in the origin repo. This is useful for QA teams that need to push their own branches to a remote repo.\n\nYou can also use refspecs for deleting remote branches. This is a common situation for feature-branch workflows that push the feature branches to a remote repo (e.g., for backup purposes). The remote feature branches still reside in the remote repo after they are deleted from the local repo, so you get a build-up of dead feature branches as your project progresses. You can delete them by pushing a refspec that has an empty parameter, like so:\n\nThis is very convenient, since you don’t need to log in to your remote repository and manually delete the remote branch. Note that as of Git v1.7.0 you can use the --delete flag instead of the above method. The following will have the same effect as the above command:\n\nBy adding a few lines to the Git configuration file, you can use refspecs to alter the behavior of git fetch. By default, git fetch fetches all of the branches in the remote repository. The reason for this is the following section of the .git/config file:\n\nThe fetch line tells git fetch to download all of the branches from the origin repo. But, some workflows don’t need all of them. For example, many continuous integration workflows only care about the main branch. To fetch only the main branch, change the fetch line to match the following:\n\nYou can also configure git push in a similar manner. For instance, if you want to always push the main branch to qa-main in the origin remote (as we did above), you would change the config file to:\n\nRefspecs give you complete control over how various Git commands transfer branches between repositories. They let you rename and delete branches from your local repository, fetch/push to branches with different names, and configure git push and git fetch to work with only the branches that you want.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push origin main:refs/heads/qa-main\n```",
          "```bash\ngit push origin :some-feature\n```",
          "```bash\ngit push origin --delete some-feature\n```",
          "```bash\n[remote \"origin\"] url = https://git@github.com:mary/example-repo.git fetch = +refs/heads/*:refs/remotes/origin/*\n```",
          "```bash\n[remote \"origin\"] url = https://git@github.com:mary/example-repo.git fetch = +refs/heads/main:refs/remotes/origin/main\n```",
          "```bash\n[remote \"origin\"] url = https://git@github.com:mary/example-repo.git fetch = +refs/heads/main:refs/remotes/origin/main push = refs/heads/main:refs/heads/qa-main\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 2624
        }
      },
      {
        "header": "Relative refs",
        "content": "You can also refer to commits relative to another commit. The ~ character lets you reach parent commits. For example, the following displays the grandparent of HEAD:\n\nBut, when working with merge commits, things get a little more complicated. Since merge commits have more than one parent, there is more than one path that you can follow. For 3-way merges, the first parent is from the branch that you were on when you performed the merge, and the second parent is from the branch that you passed to the git merge command.\n\nThe ~ character will always follow the first parent of a merge commit. If you want to follow a different parent, you need to specify which one with the ^ character. For example, if HEAD is a merge commit, the following returns the second parent of HEAD.\n\nYou can use more than one ^ character to move more than one generation. For instance, this displays the grandparent of HEAD (assuming it’s a merge commit) that rests on the second parent.\n\nTo clarify how ~ and ^ work, the following figure shows you how to reach any commit from A using relative references. In some cases, there are multiple ways to reach a commit.\n\nRelative refs can be used with the same commands that a normal ref can be used. For example, all of the following commands use a relative reference:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit show HEAD~2\n```",
          "```bash\ngit show HEAD^2\n```",
          "```bash\ngit show HEAD^2^1\n```",
          "```bash\n# Only list commits that are parent of the second parent of a merge commit git log HEAD^2 # Remove the last 3 commits from the current branch git reset HEAD~3 # Interactively rebase the last 3 commits on the current branch git rebase -i HEAD~3\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1293
        }
      },
      {
        "header": "The reflog",
        "content": "The reflog is Git’s safety net. It records almost every change you make in your repository, regardless of whether you committed a snapshot or not. You can think of it as a chronological history of everything you’ve done in your local repo. To view the reflog, run the git reflog command. It should output something that looks like the following:\n\nThis can be translated as follows:\n\nThe HEAD{} syntax lets you reference commits stored in the reflog. It works a lot like the HEAD~ references from the previous section, but the refers to an entry in the reflog instead of the commit history.\n\nYou can use this to revert to a state that would otherwise be lost. For example, lets say you just scrapped a new feature with git reset. Your reflog might look something like this:\n\nThe three commits before the git reset are now dangling, which means that there is no way to reference them—except through the reflog. Now, let’s say you realize that you shouldn’t have thrown away all of your work. All you have to do is check out the HEAD@{1} commit to get back to the state of your repository before you ran git reset.\n\nThis puts you in a detached HEAD state. From here, you can create a new branch and continue working on your feature.\n\n• You just checked out HEAD~2\n• Before that you amended a commit message\n• Before that you merged the feature branch into main\n• Before that you committed a snapshot",
        "code_examples": [
          "```bash\n400e4b7 HEAD@{0}: checkout: moving from main to HEAD~2 0e25143 HEAD@{1}: commit (amend): Integrate some awesome feature into `main` 00f5425 HEAD@{2}: commit (merge): Merge branch ';feature'; ad8621a HEAD@{3}: commit: Finish the feature\n```",
          "```bash\nad8621a HEAD@{0}: reset: moving to HEAD~3 298eb9f HEAD@{1}: commit: Some other commit message bbe9012 HEAD@{2}: commit: Continue the feature 9cb79fa HEAD@{3}: commit: Start a new feature\n```"
        ],
        "usage_examples": [
          "```bash\ngit checkout HEAD@{1}\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1396
        }
      },
      {
        "header": "Summary",
        "content": "You should now be quite comfortable referring to commits in a Git repository. We learned how branches and tags were stored as refs in the .git subdirectory, how to read a packed-refs file, how HEAD is represented, how to use refspecs for advanced pushing and fetching, and how to use the relative ~ and ^ operators to traverse a branch hierarchy.\n\nWe also took a look at the reflog, which is a way to reference commits that are not available through any other means. This is a great way to recover from those little “Oops, I shouldn’t have done that” situations.\n\nThe point of all this was to be able to pick out exactly the commit that you need in any given development scenario. It’s very easy to leverage the skills you learned in this article against your existing Git knowledge, as some of the most common commands accept refs as arguments, including git log, git show, git checkout, git reset, git revert, git rebase, and many others.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 940
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/refs-and-the-reflog",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Git LFS",
    "summary": "Learn Git Overview Git commands Learn Git with Bitbucket Cloud Learn about code review in Bitbucket Cloud Learn Branching with Bitbucket Cloud Learn Undoing Changes with Bitbucket Cloud Beginner Overview What is version control Source Code Management What is Git Why Git for your organization Install Git Git SSH Git archive GitOps Git cheat sheet Getting started Overview Setting up a repository Overview git init git clone git config git alias Saving changes (Git add) Overview git commit git diff ",
    "sections": [
      {
        "header": "",
        "content": "• What is Git LFS\n• Installing Git LFS\n• Creating a new Git LFS repository\n• Cloning an existing Git LFS repository\n• Speeding up clones\n• Pulling and checking out\n• Speeding up pulls\n• Tracking files with Git LFS\n• Committing and pushing\n• Moving a Git LFS repository between hosts\n• Fetching extra Git LFS history\n• Deleting local Git LFS files\n• Deleting remote Git LFS files from the server\n• Finding paths or commits that reference a Git LFS object\n• Including/excluding Git LFS files\n• Locking Git LFS files\n• How Git LFS works",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 533
        }
      },
      {
        "header": "What is Git LFS?",
        "content": "Git is a distributed version control system, meaning the entire history of the repository is transferred to the client during the cloning process. For projects containing large files, particularly large files that are modified regularly, this initial clone can take a huge amount of time, as every version of every file has to be downloaded by the client. Git LFS (Large File Storage) is a Git extension developed by Atlassian, GitHub, and a few other open source contributors, that reduces the impact of large files in your repository by downloading the relevant versions of them lazily. Specifically, large files are downloaded during the checkout process rather than during cloning or fetching.\n\nGit LFS does this by replacing large files in your repository with tiny pointer files. During normal usage, you'll never see these pointer files as they are handled automatically by Git LFS:\n\n1. When you add a file to your repository, Git LFS replaces its contents with a pointer, and stores the file contents in a local Git LFS cache.\n\n2. When you push new commits to the server, any Git LFS files referenced by the newly pushed commits are transferred from your local Git LFS cache to the remote Git LFS store tied to your Git repository.\n\nWhen you checkout a commit that contains Git LFS pointers, they are replaced with files from your local Git LFS cache, or downloaded from the remote Git LFS store.\n\nGit LFS is seamless: in your working copy you'll only see your actual file content. This means you can use Git LFS without changing your existing Git workflow; you simply git checkout, edit, git add, and git commit as normal. git clone and git pull operations will be significantly faster as you only download the versions of large files referenced by commits that you actually check out, rather than every version of the file that ever existed.\n\nTo use Git LFS, you will need a Git LFS aware host such as Bitbucket Cloud or Bitbucket Data Center. Repository users will need to have the Git LFS command-line client installed, or a Git LFS aware GUI client such as Sourcetree. Fun fact: Steve Streeting, the Atlassian developer who invented Sourcetree, is also a major contributor to the Git LFS project, so Sourcetree and Git LFS work together rather well.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 2262
        }
      },
      {
        "header": "Installing Git LFS",
        "content": "1. There are three easy ways to install Git LFS:\n\na. Install it using your favorite package manager. git-lfs packages are available for Homebrew, MacPorts, dnf, and packagecloud; or\n\nb. Download and install Git LFS from the project website; or\n\nc. Install Sourcetree, a free Git GUI client that comes bundled with Git LFS.\n\n2. Once git-lfs is on your path, run git lfs install to initialize Git LFS (you can skip this step if you installed Sourcetree):\n\nYou'll only need to run git lfs install once. Once initialized for your system, Git LFS will bootstrap itself automatically when you clone a repository containing Git LFS content.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git lfs install Git LFS initialized.\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 633
        }
      },
      {
        "header": "Creating a new Git LFS repository",
        "content": "To create a new Git LFS aware repository, you'll need to run git lfs install after you create the repository:\n\nThis installs a special pre-push Git hook in your repository that will transfer Git LFS files to the server when you git push.\n\nGit LFS is automatically enabled for all Bitbucket Cloud repositories. For Bitbucket Data Center, you'll need to enable Git LFS in your repository settings:\n\nOnce Git LFS is initialized for your repository, you can specify which files to track using git lfs track.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# initialize Git$ mkdir Atlasteroids$ cd Atlasteroids$ git initInitialized empty Git repository in /Users/tpettersen/Atlasteroids/.git/# initialize Git LFS$ git lfs installUpdated pre-push hook.Git LFS initialized.\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 503
        }
      },
      {
        "header": "Cloning an existing Git LFS repository",
        "content": "Once Git LFS is installed, you can clone a Git LFS repository as normal using git clone. At the end of the cloning process Git will check out the default branch (usually main), and any Git LFS files needed to complete the checkout process will be automatically downloaded for you. For example:\n\nThere are four PNGs in this repository being tracked by Git LFS. When running git clone, Git LFS files are downloaded one at a time as pointer files are checked out of your repository.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git clone git@bitbucket.org:tpettersen/Atlasteroids.gitCloning into 'Atlasteroids'...remote: Counting objects: 156, done.remote: Compressing objects: 100% (154/154), done.remote: Total 156 (delta 87), reused 0 (delta 0)Receiving objects: 100% (156/156), 54.04 KiB | 31.00 KiB/s, done.Resolving deltas: 100% (87/87), done.Checking connectivity... done.Downloading Assets/Sprites/projectiles-spritesheet.png (21.14 KB)Downloading Assets/Sprites/productlogos_cmyk-spritesheet.png (301.96 KB)Downloading Assets/Sprites/shuttle2.png (1.62 KB)Downloading Assets/Sprites/space1.png (1.11 MB)Checking out files: 100% (81/81), done.\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 479
        }
      },
      {
        "header": "Speeding up clones",
        "content": "If you're cloning a repository with a large number of LFS files, the explicit git lfs clone command offers far better performance:\n\nRather than downloading Git LFS files one at a time, the git lfs clone command waits until the checkout is complete, and then downloads any required Git LFS files as a batch. This takes advantage of parallelized downloads, and dramatically reduces the number of HTTP requests and processes spawned (which is especially important for improving performance on Windows).",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git lfs clone git@bitbucket.org:tpettersen/Atlasteroids.gitCloning into 'Atlasteroids'...remote: Counting objects: 156, done.remote: Compressing objects: 100% (154/154), done.remote: Total 156 (delta 87), reused 0 (delta 0)Receiving objects: 100% (156/156), 54.04 KiB | 0 bytes/s, done.Resolving deltas: 100% (87/87), done.Checking connectivity... done.Git LFS: (4 of 4 files) 1.14 MB / 1.15 MB\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 499
        }
      },
      {
        "header": "Pulling and checking out",
        "content": "Just like cloning, you can pull from a Git LFS repository using a normal git pull. Any needed Git LFS files will be downloaded as part of the automatic checkout process once the pull completes:\n\nNo explicit commands are needed to retrieve Git LFS content. However, if the checkout fails for an unexpected reason, you can download any missing Git LFS content for the current commit with git lfs pull:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git pullUpdating 4784e9d..7039f0aDownloading Assets/Sprites/powerup.png (21.14 KB)Fast-forwardAssets/Sprites/powerup.png      |    3 +Assets/Sprites/powerup.png.meta | 4133 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++2 files changed, 4136 insertions(+)create mode 100644 Assets/Sprites/projectiles-spritesheet.pngcreate mode 100644 Assets/Sprites/projectiles-spritesheet.png.meta\n```",
          "```bash\n$ git lfs pullGit LFS: (4 of 4 files) 1.14 MB / 1.15 MB\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 399
        }
      },
      {
        "header": "Speeding up pulls",
        "content": "Like git lfs clone, git lfs pull downloads your Git LFS files as a batch. If you know a large number of files have changed since the last time you pulled, you may wish to disable the automatic Git LFS download during checkout, and then batch download your Git LFS content with an explicit git lfs pull. This can be done by overriding your Git config with the -c option when you invoke git pull:\n\nSince that's rather a lot of typing, you may wish to create a simple Git alias to perform a batched Git and Git LFS pull for you:\n\nThis will greatly improve performance when a large number of Git LFS files need to be downloaded (again, especially on Windows).",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git -c filter.lfs.smudge= -c filter.lfs.required=false pull && git lfs pull\n```",
          "```bash\n$ git config --global alias.plfs \"\\!git -c filter.lfs.smudge= -c filter.lfs.required=false pull && git lfs pull\"$ git plfs\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 655
        }
      },
      {
        "header": "Tracking files with Git LFS",
        "content": "When you add a new type of large file to your repository, you'll need to tell Git LFS to track it by specifying a pattern using the git lfs track command:\n\nNote that the quotes around \"*.ogg\" are important. Omitting them will cause the wildcard to be expanded by your shell, and individual entries will be created for each .ogg file in your current directory:\n\nThe patterns supported by Git LFS are the same as those supported by .gitignore, for example:\n\nThese patterns are relative to the directory in which you ran the git lfs track command. To keep things simple, it is best to run git lfs track from the root of your repository. Note that Git LFS does not support negative patterns like .gitignore does.\n\nAfter running git lfs track, you'll notice a new file named .gitattributes in the directory you ran the command from. .gitattributes is a Git mechanism for binding special behaviors to certain file patterns. Git LFS automatically creates or updates .gitattributes files to bind tracked file patterns to the Git LFS filter. However, you will need to commit any changes to the .gitattributes file to your repository yourself:\n\nFor ease of maintenance, it is simplest to keep all Git LFS patterns in a single .gitattributes file by always running git lfs track from the root of your repository. However, you can display a list of all patterns that are currently tracked by Git LFS (and the .gitattributes files they are defined in) by invoking git lfs track with no arguments:\n\nYou can stop tracking a particular pattern with Git LFS by simply removing the appropriate line from your .gitattributes file, or by running the git lfs untrack command:\n\nAfter running git lfs untrack you will again have to commit the changes to .gitattributes yourself.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git lfs track \"*.ogg\"Tracking *.ogg\n```",
          "```bash\n# probably not what you want$ git lfs track *.oggTracking explode.oggTracking music.oggTracking phaser.ogg\n```",
          "```bash\n# track all .ogg files in any directory$ git lfs track \"*.ogg\"# track files named music.ogg in any directory$ git lfs track \"music.ogg\"# track all files in the Assets directory and all subdirectories$ git lfs track \"Assets/**\"# track all files in the Assets directory but *not* subdirectories$ git lfs track \"Assets/*\"# track all ogg files in Assets/Audio$ git lfs track \"Assets/Audio/*.ogg\"# track all ogg files in any directory named Music$ git lfs track \"**/Music/*.ogg\"# track png files containing \"xxhdpi\" in their name, in any directory$ git lfs track \"*xxhdpi*.png\n```",
          "```bash\n$ git lfs track \"*.ogg\"Tracking *.ogg$ git add .gitattributes$ git diff --cacheddiff --git a/.gitattributes b/.gitattributesnew file mode 100644index 0000000..b6dd0bb--- /dev/null+++ b/.gitattributes@@ -0,0 +1 @@+*.ogg filter=lfs diff=lfs merge=lfs -text$ git commit -m \"Track ogg files with Git LFS\"\n```",
          "```bash\n$ git lfs trackListing tracked paths*.stl (.gitattributes)*.png (Assets/Sprites/.gitattributes)*.ogg (Assets/Audio/.gitattributes)\n```",
          "```bash\n$ git lfs untrack \"*.ogg\"Untracking *.ogg$ git diffdiff --git a/.gitattributes b/.gitattributesindex b6dd0bb..e69de29 100644--- a/.gitattributes+++ b/.gitattributes@@ -1 +0,0 @@-*.ogg filter=lfs diff=lfs merge=lfs -text\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1755
        }
      },
      {
        "header": "Committing and pushing",
        "content": "You can commit and push as normal to a repository that contains Git LFS content. If you have committed changes to files tracked by Git LFS, you will see some additional output from git push as the Git LFS content is transferred to the server:\n\nIf transferring the LFS files fails for some reason, the push will be aborted and you can safely try again. Like Git, Git LFS storage is content addressable: content is stored against a key which is a SHA-256 hash of the content itself. This means it is always safe to re-attempt transferring Git LFS files to the server; you can't accidentally overwrite a Git LFS file's contents with the wrong version.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git pushGit LFS: (3 of 3 files) 4.68 MB / 4.68 MBCounting objects: 8, done.Delta compression using up to 8 threads.Compressing objects: 100% (8/8), done.Writing objects: 100% (8/8), 1.16 KiB | 0 bytes/s, done.Total 8 (delta 1), reused 0 (delta 0)To git@bitbucket.org:tpettersen/atlasteroids.git7039f0a..b3684d3  main -> main\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 648
        }
      },
      {
        "header": "Moving a Git LFS repository between hosts",
        "content": "To migrate a Git LFS repository from one hosting provider to another, you can use a combination of git lfs fetch and git lfs push with the --all option specified.\n\nFor example, to move all Git and Git LFS repository from a remote named github to a remote named bitbucket 😉 :",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# create a bare clone of the GitHub repository$ git clone --bare git@github.com:kannonboy/atlasteroids.git$ cd atlasteroids# set up named remotes for Bitbucket and GitHub$ git remote add bitbucket git@bitbucket.org:tpettersen/atlasteroids.git$ git remote add github git@github.com:kannonboy/atlasteroids.git# fetch all Git LFS content from GitHub$ git lfs fetch --all github# push all Git and Git LFS content to Bitbucket$ git push --mirror bitbucket$ git lfs push --all bitbucket\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 274
        }
      },
      {
        "header": "Fetching extra Git LFS history",
        "content": "Git LFS typically only downloads the files needed for commits that you actually checkout locally. However, you can force Git LFS to download extra content for other recently modified branches using git lfs fetch --recent:\n\nThis is useful for batch downloading new Git LFS content while you're out at lunch, or if you're planning on reviewing work from your teammates and will not be able to download content later on due to limited internet connectivity. For example, you may wish to run git lfs fetch --recent before jumping on a plane!\n\nGit LFS considers any branch or tag containing a commit newer than seven days as recent. You can configure the number of days considered as recent by setting the lfs.fetchrecentrefsdays property:\n\nBy default, git lfs fetch --recent will only download Git LFS content for the commit at the tip of a recent branch or tag.\n\nHowever you can configure Git LFS to download content for earlier commits on recent branches and tags by configuring the lfs.fetchrecentcommitsdays property:\n\nUse this setting with care: if you have fast moving branches, this can result in a huge amount of data being downloaded. However it can be useful if you need to review interstitial changes on a branch, cherry picking commits across branches, or rewrite history.\n\nAs discussed in Moving a Git LFS repository between hosts, you can also elect to fetch all Git LFS content for your repository with git lfs fetch --all:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git lfs fetch --recentFetching mainGit LFS: (0 of 0 files, 14 skipped) 0 B / 0 B, 2.83 MB skipped                                                                           Fetching recent branches within 7 daysFetching origin/power-upsGit LFS: (8 of 8 files, 4 skipped) 408.42 KB / 408.42 KB, 2.81 MB skippedFetching origin/more-musicGit LFS: (1 of 1 files, 14 skipped) 1.68 MB / 1.68 MB, 2.83 MB skipped\n```",
          "```bash\n# download Git LFS content for branches or tags updated in the last 10 days$ git config lfs.fetchrecentrefsdays 10\n```",
          "```bash\n# download the latest 3 days of Git LFS content for each recent branch or tag$ git config lfs.fetchrecentcommitsdays 3\n```",
          "```bash\n$ git lfs fetch --allScanning for all objects ever referenced...✔ 23 objects foundFetching objects...Git LFS: (9 of 9 files, 14 skipped) 2.06 MB / 2.08 MB, 2.83 MB skipped\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1434
        }
      },
      {
        "header": "Deleting local Git LFS files",
        "content": "You can delete files from your local Git LFS cache with the git lfs prune command:\n\nThis will delete any local Git LFS files that are considered old. An old file is any file not referenced by:\n\nBy default, a recent commit is any commit created in the last ten days. This is calculated by adding:\n\nYou can configure the prune offset to retain Git LFS content for a longer period:\n\nUnlike Git's built-in garbage collection, Git LFS content is not pruned automatically, so running git lfs prune on a regular basis is a good idea to keep your local repository size down.\n\nYou can test out what effect a prune operation will have with git lfs prune --dry-run:\n\nAnd exactly which Git LFS objects will be pruned with git lfs prune --verbose --dry-run:\n\nThe long hexadecimal strings output by --verbose mode are SHA-256 hashes (also known as Object IDs, or OIDs) of the Git LFS objects to be pruned. You can use the techniques described in Finding paths or commits that reference a Git LFS object to find our more about the objects that will be pruned.\n\nAs an additional safety check, you can use the --verify-remote option to check whether the remote Git LFS store has a copy of your Git LFS objects before they are pruned:\n\nThis makes the pruning process significantly slower, but gives you peace of mind knowing that any pruned objects are recoverable from the server. You can enable the --verify-remote option permanently for your system by configuring the lfs.pruneverifyremotealways property globally:\n\nOr you can enable remote verification for just the context repository by omitting the --global option from the command above.\n\n• the currently checked out commit\n• a commit that has not yet been pushed (to origin, or whatever lfs.pruneremotetocheck is set to)\n• a recent commit\n\n• the value of the lfs.fetchrecentrefsdays property discussed in Fetching extra Git LFS history (which defaults to seven); to\n• the value of the lfs.pruneoffsetdays property (which defaults to three)",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git lfs prune✔ 4 local objects, 33 retainedPruning 4 files, (2.1 MB)✔ Deleted 4 files\n```",
          "```bash\n# don't prune commits younger than four weeks (7 + 21)$ git config lfs.pruneoffsetdays 21\n```",
          "```bash\n$ git lfs prune --dry-run✔ 4 local objects, 33 retained4 files would be pruned (2.1 MB)\n```",
          "```bash\n$ git lfs prune --dry-run --verbose✔ 4 local objects, 33 retained4 files would be pruned (2.1 MB)* 4a3a36141cdcbe2a17f7bcf1a161d3394cf435ac386d1bff70bd4dad6cd96c48 (2.0 MB)* 67ad640e562b99219111ed8941cb56a275ef8d43e67a3dac0027b4acd5de4a3e (6.3 KB)* 6f506528dbf04a97e84d90cc45840f4a8100389f570b67ac206ba802c5cb798f (1.7 MB)* a1d7f7cdd6dba7307b2bac2bcfa0973244688361a48d2cebe3f3bc30babcf1ab (615.7 KB)\n```",
          "```bash\n$ git lfs prune --verify-remote✔ 16 local objects, 2 retained, 12 verified with remotePruning 14 files, (1.7 MB)✔ Deleted 14 files\n```",
          "```bash\n$ git config --global lfs.pruneverifyremotealways true\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 11,
          "content_length": 1979
        }
      },
      {
        "header": "Deleting remote Git LFS files from the server",
        "content": "The Git LFS command-line client doesn't support pruning files from the server, so how you delete them depends on your hosting provider.\n\nIn Bitbucket Cloud, you can view and delete Git LFS files via Repository Settings > Git LFS:\n\nNote that each Git LFS file is indexed by its SHA-256 OID; the paths that reference each file are not visible via the UI. This is because there could be many different paths at many different commits that may refer to a given object, so looking them up would be a very slow process.\n\nTo determine what a given Git LFS file actually contains, you have three options:\n\n• look at the file preview image and file type in the left hand column of the Bitbucket Git LFS UI\n• download the file using the link in the right hand column of the Bitbucket Git LFS UI -search for commits referencing the Git LFS object's SHA-256 OID, as discussed in the next section",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 883
        }
      },
      {
        "header": "Finding paths or commits that reference a Git LFS object",
        "content": "If you have a Git LFS SHA-256 OID, you can determine which commits reference it with git log --all -p -S :\n\nThis git log incantation generates a patch (-p) from commits on any branch (--all) that add or remove a line (-S) containing the specified string (a Git LFS SHA-256 OID).\n\nThe patch shows you the commit and the path to the LFS object, as well as who added it, and when it was committed. You can simply checkout the commit, and Git LFS will download the file if needed and place it in your working copy.\n\nIf you suspect that a particular Git LFS object is in your current HEAD, or on a particular branch, you can use git grep to find the file path that references it:\n\nYou can replace HEAD or power-ups with any ref, commit, or tree that contains the Git LFS object.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git log --all -p -S 3b6124b8b01d601fa20b47f5be14e1be3ea7759838c1aac8f36df4859164e4cccommit 22a98faa153d08804a63a74a729d8846e6525cb0Author: Tim Pettersen <tpettersen@atlassian.com>Date:   Wed Jul 27 11:03:27 2016 +1000Projectiles and exploding asteroidsdiff --git a/Assets/Sprites/projectiles-spritesheet.pngnew file mode 100755index 0000000..49d7baf--- /dev/null+++ b/Assets/Sprites/projectiles-spritesheet.png@@ -0,0 +1,3 @@+version https://git-lfs.github.com/spec/v1+oid sha256:3b6124b8b01d601fa20b47f5be14e1be3ea7759838c1aac8f36df4859164e4cc+size 21647\n```",
          "```bash\n# find a particular object by OID in HEAD$ git grep 3b6124b8b01d601fa20b47f5be14e1be3ea7759838c1aac8f36df4859164e4cc HEADHEAD:Assets/Sprites/projectiles-spritesheet.png:oid sha256:3b6124b8b01d601fa20b47f5be14e1be3ea7759838c1aac8f36df4859164e4cc# find a particular object by OID on the \"power-ups\" branch$ git grep e88868213a5dc8533fc9031f558f2c0dc34d6936f380ff4ed12c2685040098d4 power-upspower-ups:Assets/Sprites/shield2.png:oid sha256:e88868213a5dc8533fc9031f558f2c0dc34d6936f380ff4ed12c2685040098d4\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 773
        }
      },
      {
        "header": "Including/excluding Git LFS files",
        "content": "In some situations you may want to only download a subset of the available Git LFS content for a particular commit. For example, when configuring a CI build to run unit tests, you may only need your source code, so may want to exclude heavyweight files that aren't necessary to build your code.\n\nYou can exclude a pattern or subdirectory using git lfs fetch -X (or --exclude):\n\nAlternatively, you may want to only include a particular pattern or subdirectory. For example, an audio engineer could fetch just ogg and wav files with git lfs fetch -I (or --include):\n\nIf you combine includes and excludes, only files that match an include pattern and do not match an exclude pattern will be fetched. For example, you can fetch everything in your Assets directory except gifs with:\n\nExcludes and includes support the same patterns as git lfs track and .gitignore. You can make these patterns permanent for a particular repository by setting the lfs.fetchinclude and lfs.fetchexclude config properties:\n\nThese settings can also be applied to every repository on your system by appending the --global option.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git lfs fetch -X \"Assets/**\"\n```",
          "```bash\n$ git lfs fetch -I \"*.ogg,*.wav\"\n```",
          "```bash\n$ git lfs fetch -I \"Assets/**\" -X \"*.gif\"\n```",
          "```bash\n$ git config lfs.fetchinclude \"Assets/**\"$ git config lfs.fetchexclude \"*.gif\"\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1102
        }
      },
      {
        "header": "Locking Git LFS files",
        "content": "Unfortunately, there is no easy way of resolving binary merge conflicts. With Git LFS file locking, you can lock files by extension or by file name and prevent binary files from being overwritten during a merge.\n\nIn order to take advantage of LFS' file locking feature, you first need to tell Git which type of files are lockable. In the example below, the `--lockable` flag is appended to the `git lfs track` command which both stores PSD files in LFS and marks them as lockable.\n\nThen add the following to your .gitattributes file:\n\nWhen preparing to make changes to an LFS file, you'll use the lock command in order to register the file as locked on your Git server.\n\nOnce you no longer need the file lock, you can remove it using Git LFS' unlock command.\n\nGit LFS file locks can be overridden, similar to git push, using a --force flag. Do not use the --force flag unless you’re absolutely sure you know what you’re doing.",
        "code_examples": [
          "```bash\n*.psd filter=lfs diff=lfs merge=lfs -text lockable\n```"
        ],
        "usage_examples": [
          "```bash\n$ git lfs track \"*.psd\" --lockable\n```",
          "```bash\n$ git lfs lock images/foo.psdLocked images/foo.psd\n```",
          "```bash\n$ git lfs unlock images/foo.psd\n```",
          "```bash\n$ git lfs unlock images/foo.psd --force\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 926
        }
      },
      {
        "header": "Recommended reading",
        "content": "Bookmark these resources to learn about types of DevOps teams, or for ongoing updates about DevOps at Atlassian.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 112
        }
      },
      {
        "header": "Sign up for our DevOps newsletter",
        "content": "Thank you for signing up",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://www.atlassian.com/git/tutorials/git-lfs",
    "doc_type": "git",
    "total_sections": 19
  },
  {
    "title": "Set up Git",
    "summary": "Set up GitAt the heart of GitHub is an open-source version control system (VCS) called Git. Git is responsible for everything GitHub-related that happens locally on your computer.In this articleUsing Git To use Git on the command line, you will need to download, install, and configure Git on your computer. You can also install GitHub CLI to use GitHub from the command line. For more information, see About GitHub CLI. If you want to work with Git locally, but do not want to use the command line, ",
    "sections": [
      {
        "header": "",
        "content": "At the heart of GitHub is an open-source version control system (VCS) called Git. Git is responsible for everything GitHub-related that happens locally on your computer.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 169
        }
      },
      {
        "header": "Using Git",
        "content": "To use Git on the command line, you will need to download, install, and configure Git on your computer. You can also install GitHub CLI to use GitHub from the command line. For more information, see About GitHub CLI.\n\nIf you want to work with Git locally, but do not want to use the command line, you can download and install the GitHub Desktop client. For more information, see About GitHub Desktop.\n\nIf you do not need to work with files locally, GitHub lets you complete many Git-related actions directly in the browser, including:\n\n• Quickstart for repositories\n• Fork a repository\n• Managing files",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 602
        }
      },
      {
        "header": "Setting up Git",
        "content": "Download and install the latest version of Git.\n\nMost Chrome OS devices from 2020 onwards now have a built-in Linux environment, which includes Git. To enable it, go to the Launcher, search for Linux, and click Turn on.\n\nIf you are using an older Chrome OS device, another method is required:\n\nSet your username in Git.\n\nSet your commit email address in Git.\n\n• Download and install the latest version of Git. Note Most Chrome OS devices from 2020 onwards now have a built-in Linux environment, which includes Git. To enable it, go to the Launcher, search for Linux, and click Turn on. If you are using an older Chrome OS device, another method is required: Install a terminal emulator such as Termux from the Google Play Store on your Chrome OS device. From the terminal emulator that you installed, install Git. For example, in Termux, enter pkg install git and then type y when prompted.\n• Set your username in Git.\n• Set your commit email address in Git.\n\n• Install a terminal emulator such as Termux from the Google Play Store on your Chrome OS device.\n• From the terminal emulator that you installed, install Git. For example, in Termux, enter pkg install git and then type y when prompted.\n\n[Alert] Note Most Chrome OS devices from 2020 onwards now have a built-in Linux environment, which includes Git. To enable it, go to the Launcher, search for Linux, and click Turn on. If you are using an older Chrome OS device, another method is required: Install a terminal emulator such as Termux from the Google Play Store on your Chrome OS device. From the terminal emulator that you installed, install Git. For example, in Termux, enter pkg install git and then type y when prompted.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1686
        }
      },
      {
        "header": "Authenticating with GitHub from Git",
        "content": "When you connect to a GitHub repository from Git, you will need to authenticate with GitHub using either HTTPS or SSH.\n\nYou can authenticate to GitHub using GitHub CLI, for either HTTP or SSH. For more information, see gh auth login.\n\n[Alert] Note You can authenticate to GitHub using GitHub CLI, for either HTTP or SSH. For more information, see gh auth login.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 361
        }
      },
      {
        "header": "Connecting over HTTPS (recommended)",
        "content": "If you clone with HTTPS, you can cache your GitHub credentials in Git using a credential helper. For more information, see About remote repositories and Caching your GitHub credentials in Git.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 192
        }
      },
      {
        "header": "Connecting over SSH",
        "content": "If you clone with SSH, you must generate SSH keys on each computer you use to push or pull from GitHub. For more information, see About remote repositories and Generating a new SSH key and adding it to the ssh-agent.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 216
        }
      },
      {
        "header": "Next steps",
        "content": "You now have Git and GitHub all set up. You may now choose to create a repository where you can put your projects. Saving your code in a repository allows you to back up your code and share it around the world.\n\nCreating a repository for your project allows you to store code in GitHub. This provides a backup of your work that you can choose to share with other developers. For more information, see Quickstart for repositories.\n\nForking a repository will allow you to make changes to another repository without affecting the original. For more information, see Fork a repository.\n\nEach repository on GitHub is owned by a person or an organization. You can interact with the people, repositories, and organizations by connecting and following them on GitHub. For more information, see Finding inspiration on GitHub.\n\nGitHub has a great support community where you can ask for help and talk to people from around the world. Join the conversation on GitHub Community.\n\n• Creating a repository for your project allows you to store code in GitHub. This provides a backup of your work that you can choose to share with other developers. For more information, see Quickstart for repositories.\n• Forking a repository will allow you to make changes to another repository without affecting the original. For more information, see Fork a repository.\n• Each repository on GitHub is owned by a person or an organization. You can interact with the people, repositories, and organizations by connecting and following them on GitHub. For more information, see Finding inspiration on GitHub.\n• GitHub has a great support community where you can ask for help and talk to people from around the world. Join the conversation on GitHub Community.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1727
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/getting-started-with-git/set-up-git",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "Configuring Git to handle line endings",
    "summary": "Configuring Git to handle line endingsTo avoid problems in your diffs, you can configure Git to properly handle line endings.Platform navigationIn this articleAbout line endings Every time you press return on your keyboard you insert an invisible character called a line ending. Different operating systems handle line endings differently. When you're collaborating on projects with Git and GitHub, Git might produce unexpected results if, for example, you're working on a Windows machine, and your c",
    "sections": [
      {
        "header": "",
        "content": "To avoid problems in your diffs, you can configure Git to properly handle line endings.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 87
        }
      },
      {
        "header": "About line endings",
        "content": "Every time you press return on your keyboard you insert an invisible character called a line ending. Different operating systems handle line endings differently.\n\nWhen you're collaborating on projects with Git and GitHub, Git might produce unexpected results if, for example, you're working on a Windows machine, and your collaborator has made a change in macOS.\n\nYou can configure Git to handle line endings automatically so you can collaborate effectively with people who use different operating systems.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 506
        }
      },
      {
        "header": "Global settings for line endings",
        "content": "The git config core.autocrlf command is used to change how Git handles line endings. It takes a single argument.\n\nOn macOS, you simply pass input to the configuration. For example:\n\nOn Windows, you simply pass true to the configuration. For example:\n\nOn Linux, you simply pass input to the configuration. For example:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$git config --global core.autocrlf input#Configure Git to ensure line endingsinfiles you checkout are correctformacOS\n```",
          "```bash\n$git config --global core.autocrlftrue#Configure Git to ensure line endingsinfiles you checkout are correctforWindows.#For compatibility, line endings are converted to Unix style when you commit files.\n```",
          "```bash\n$git config --global core.autocrlf input#Configure Git to ensure line endingsinfiles you checkout are correctforLinux\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 317
        }
      },
      {
        "header": "Per-repository settings",
        "content": "Optionally, you can configure a .gitattributes file to manage how Git reads line endings in a specific repository. When you commit this file to a repository, it overrides the core.autocrlf setting for all repository contributors. This ensures consistent behavior for all users, regardless of their Git settings and environment.\n\nThe .gitattributes file must be created in the root of the repository and committed like any other file.\n\nA .gitattributes file looks like a table with two columns:\n\n• On the left is the file name for Git to match.\n• On the right is the line ending configuration that Git should use for those files.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 628
        }
      },
      {
        "header": "Example",
        "content": "Here's an example .gitattributes file. You can use it as a template for your repositories:\n\nYou'll notice that files are matched—*.c, *.sln, *.png—, separated by a space, then given a setting—text, text eol=crlf, binary. We'll go over some possible settings below.\n\ntext=auto Git will handle the files in whatever way it thinks is best. This is a good default option.\n\ntext eol=crlf Git will always convert line endings to CRLF on checkout. You should use this for files that must keep CRLF endings, even on OSX or Linux.\n\ntext eol=lf Git will always convert line endings to LF on checkout. You should use this for files that must keep LF endings, even on Windows.\n\nbinary Git will understand that the files specified are not text, and it should not try to change them. The binary setting is also an alias for -text -diff.\n\n• text=auto Git will handle the files in whatever way it thinks is best. This is a good default option.\n• text eol=crlf Git will always convert line endings to CRLF on checkout. You should use this for files that must keep CRLF endings, even on OSX or Linux.\n• text eol=lf Git will always convert line endings to LF on checkout. You should use this for files that must keep LF endings, even on Windows.\n• binary Git will understand that the files specified are not text, and it should not try to change them. The binary setting is also an alias for -text -diff.",
        "code_examples": [
          "```bash\n# Set the default behavior, in case people don't have core.autocrlf set.\n* text=auto\n\n# Explicitly declare text files you want to always be normalized and converted\n# to native line endings on checkout.\n*.c text\n*.h text\n\n# Declare files that will always have CRLF line endings on checkout.\n*.sln text eol=crlf\n\n# Denote all files that are truly binary and should not be modified.\n*.png binary\n*.jpg binary\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1385
        }
      },
      {
        "header": "Refreshing a repository after changing line endings",
        "content": "After you set the core.autocrlf option or commit a .gitattributes file, Git automatically changes line endings to match your new configuration. You may find that Git reports changes to files that you have not modified.\n\nTo ensure that all the line endings in your repository match your new configuration, back up your files with Git, then remove and restore all of the files to normalize the line endings.\n\nBefore adding or committing any changes, verify that Git has applied the configuration correctly. For example, Git automatically determines whether files in a repository are text or binary files. To avoid corruption of binary files in your repository, we recommend that you explicitly mark files as binary in .gitattributes. For more information, see gitattributes - Defining attributes per path in the Git documentation.\n\nTo avoid losing any local changes to files in the repository, add and commit any outstanding changes by running the following commands.\n\nTo update all files on the current branch to reflect the new configuration, run the following command.\n\nTo display the rewritten, normalized files, run the following command.\n\nOptionally, to commit any outstanding changes in your repository, run the following command.\n\n• Before adding or committing any changes, verify that Git has applied the configuration correctly. For example, Git automatically determines whether files in a repository are text or binary files. To avoid corruption of binary files in your repository, we recommend that you explicitly mark files as binary in .gitattributes. For more information, see gitattributes - Defining attributes per path in the Git documentation.\n• To avoid losing any local changes to files in the repository, add and commit any outstanding changes by running the following commands. git add . -u git commit -m \"Saving files before refreshing line endings\"\n• To update all files on the current branch to reflect the new configuration, run the following command. git add --renormalize .\n• To display the rewritten, normalized files, run the following command. git status\n• Optionally, to commit any outstanding changes in your repository, run the following command. git commit -m \"Normalize all the line endings\"\n\n[Example] git add . -u git commit -m \"Saving files before refreshing line endings\"\n\n[Example] git commit -m \"Normalize all the line endings\"",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit add . -u\ngit commit -m \"Saving files before refreshing line endings\"\n```",
          "```bash\ngit add --renormalize .\n```",
          "```bash\ngit status\n```",
          "```bash\ngit commit -m \"Normalize all the line endings\"\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 2368
        }
      },
      {
        "header": "Further reading",
        "content": "• Customizing Git - Git Attributes in the Pro Git book\n• git-config in the man pages for Git\n• Getting Started - First-Time Git Setup in the Pro Git book\n• Mind the End of Your Line by Tim Clem",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 193
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/getting-started-with-git/configuring-git-to-handle-line-endings",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "About remote repositories",
    "summary": "About remote repositoriesGitHub's collaborative approach to development depends on publishing commits from your local repository to GitHub for other people to view, fetch, and update.In this articleAbout remote repositories A remote URL is Git's fancy way of saying \"the place where your code is stored.\" That URL could be your repository on GitHub, or another user's fork, or even on a completely different server. You can only push to two types of URL addresses: An HTTPS URL like https://github.co",
    "sections": [
      {
        "header": "",
        "content": "GitHub's collaborative approach to development depends on publishing commits from your local repository to GitHub for other people to view, fetch, and update.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 158
        }
      },
      {
        "header": "About remote repositories",
        "content": "A remote URL is Git's fancy way of saying \"the place where your code is stored.\" That URL could be your repository on GitHub, or another user's fork, or even on a completely different server.\n\nYou can only push to two types of URL addresses:\n\nGit associates a remote URL with a name, and your default remote is usually called origin.\n\n• An HTTPS URL like https://github.com/user/repo.git\n• An SSH URL, like git@github.com:user/repo.git",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 435
        }
      },
      {
        "header": "Creating remote repositories",
        "content": "You can use the git remote add command to match a remote URL with a name. For example, you'd type the following in the command line:\n\nThis associates the name origin with the REMOTE_URL.\n\nYou can use the command git remote set-url to change a remote's URL.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit remote add origin <REMOTE_URL>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 256
        }
      },
      {
        "header": "Choosing a URL for your remote repository",
        "content": "There are several ways to clone repositories available on GitHub.\n\nWhen you view a repository while signed in to your account, the URLs you can use to clone the project onto your computer are available below the repository details.\n\nFor information on setting or changing your remote URL, see Managing remote repositories.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 322
        }
      },
      {
        "header": "Cloning with HTTPS URLs",
        "content": "The https:// clone URLs are available on all repositories, regardless of visibility. https:// clone URLs work even if you are behind a firewall or proxy.\n\nWhen you git clone, git fetch, git pull, or git push to a private remote repository using HTTPS URLs on the command line, Git will ask for your GitHub username and password. When Git prompts you for your password, enter your personal access token. Alternatively, you can use a credential helper like Git Credential Manager. Password-based authentication for Git has been removed in favor of more secure authentication methods. For more information, see Managing your personal access tokens.\n\nIf you are accessing an organization that uses SAML SSO and you are using a personal access token (classic), you must also authorize your personal access token to access the organization before you authenticate. For more information, see About authentication with single sign-on and Authorizing a personal access token for use with single sign-on.\n\nIf you'd rather use SSH but cannot connect over port 22, you might be able to use SSH over the HTTPS port. For more information, see Using SSH over the HTTPS port.\n\n• You can use a credential helper so Git will remember your GitHub credentials every time it talks to GitHub. For more information, see Caching your GitHub credentials in Git.\n• To clone a repository without authenticating to GitHub on the command line, you can use GitHub Desktop to clone instead. For more information, see Cloning a repository from GitHub to GitHub Desktop.\n\n[Alert] Tip You can use a credential helper so Git will remember your GitHub credentials every time it talks to GitHub. For more information, see Caching your GitHub credentials in Git. To clone a repository without authenticating to GitHub on the command line, you can use GitHub Desktop to clone instead. For more information, see Cloning a repository from GitHub to GitHub Desktop.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1923
        }
      },
      {
        "header": "Cloning with SSH URLs",
        "content": "SSH URLs provide access to a Git repository via SSH, a secure protocol. To use these URLs, you must generate an SSH keypair on your computer and add the public key to your account on GitHub. For more information, see Connecting to GitHub with SSH.\n\nWhen you git clone, git fetch, git pull, or git push to a remote repository using SSH URLs, you'll be prompted for a password and must provide your SSH key passphrase. For more information, see Working with SSH key passphrases.\n\nIf you are accessing an organization that uses SAML single sign-on (SSO), you must authorize your SSH key to access the organization before you authenticate. For more information, see About authentication with single sign-on and Authorizing an SSH key for use with single sign-on\" in the GitHub Enterprise Cloud documentation.\n\nYou can use an SSH URL to clone a repository to your computer, or as a secure way of deploying your code to production servers. You can also use SSH agent forwarding with your deploy script to avoid managing keys on the server. For more information, see Using SSH agent forwarding.\n\n[Alert] Tip You can use an SSH URL to clone a repository to your computer, or as a secure way of deploying your code to production servers. You can also use SSH agent forwarding with your deploy script to avoid managing keys on the server. For more information, see Using SSH agent forwarding.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1382
        }
      },
      {
        "header": "Cloning with GitHub CLI",
        "content": "You can also install GitHub CLI to use GitHub workflows in your terminal. For more information, see About GitHub CLI.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 117
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "Managing remote repositories",
    "summary": "Managing remote repositoriesLearn to work with your local repositories on your computer and remote repositories hosted on GitHub.Platform navigationIn this articleAdding a remote repository To add a new remote, use the git remote add command on the terminal, in the directory your repository is stored at. The git remote add command takes two arguments: A remote name, for example, origin A remote URL, for example, https://github.com/OWNER/REPOSITORY.git For example: $ git remote add origin https:/",
    "sections": [
      {
        "header": "",
        "content": "Learn to work with your local repositories on your computer and remote repositories hosted on GitHub.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 101
        }
      },
      {
        "header": "Adding a remote repository",
        "content": "To add a new remote, use the git remote add command on the terminal, in the directory your repository is stored at.\n\nThe git remote add command takes two arguments:\n\nFor more information on which URL to use, see About remote repositories.\n\n• A remote name, for example, origin\n• A remote URL, for example, https://github.com/OWNER/REPOSITORY.git",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$git remote add origin https://github.com/OWNER/REPOSITORY.git#Set a new remote$git remote -v#Verify new remote>origin  https://github.com/OWNER/REPOSITORY.git (fetch)>origin  https://github.com/OWNER/REPOSITORY.git (push)\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 345
        }
      },
      {
        "header": "Troubleshooting: Remote origin already exists",
        "content": "This error means you've tried to add a remote with a name that already exists in your local repository.\n\nTo fix this, you can:\n\n• Use a different name for the new remote.\n• Rename the existing remote repository before you add the new remote. For more information, see Renaming a remote repository below.\n• Delete the existing remote repository before you add the new remote. For more information, see Removing a remote repository below.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$git remote add origin https://github.com/octocat/Spoon-Knife.git>fatal: remote origin already exists.\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 436
        }
      },
      {
        "header": "Changing a remote repository's URL",
        "content": "The git remote set-url command changes an existing remote repository URL.\n\nFor information on the difference between HTTPS and SSH URLs, see About remote repositories.\n\nThe git remote set-url command takes two arguments:\n\nAn existing remote name. For example, origin or upstream are two common choices.\n\nA new URL for the remote. For example:\n\n• An existing remote name. For example, origin or upstream are two common choices.\n• A new URL for the remote. For example: If you're updating to use HTTPS, your URL might look like: https://github.com/OWNER/REPOSITORY.git If you're updating to use SSH, your URL might look like: git@github.com:OWNER/REPOSITORY.git\n\n• If you're updating to use HTTPS, your URL might look like:\n\n• If you're updating to use SSH, your URL might look like:\n\n[Alert] Tip For information on the difference between HTTPS and SSH URLs, see About remote repositories.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nhttps://github.com/OWNER/REPOSITORY.git\n```",
          "```bash\ngit@github.com:OWNER/REPOSITORY.git\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 887
        }
      },
      {
        "header": "Switching remote URLs from SSH to HTTPS",
        "content": "Open TerminalTerminalGit Bash.\n\nChange the current working directory to your local project.\n\nList your existing remotes in order to get the name of the remote you want to change.\n\nChange your remote's URL from SSH to HTTPS with the git remote set-url command.\n\nVerify that the remote URL has changed.\n\nThe next time you git fetch, git pull, or git push to the remote repository, you'll be asked for your GitHub username and password. When Git prompts you for your password, enter your personal access token. Alternatively, you can use a credential helper like Git Credential Manager. Password-based authentication for Git has been removed in favor of more secure authentication methods. For more information, see Managing your personal access tokens.\n\nYou can use a credential helper so Git will remember your GitHub username and personal access token every time it talks to GitHub.\n\n• Open TerminalTerminalGit Bash.\n• Change the current working directory to your local project.\n• List your existing remotes in order to get the name of the remote you want to change. $ git remote -v > origin git@github.com:OWNER/REPOSITORY.git (fetch) > origin git@github.com:OWNER/REPOSITORY.git (push)\n• Change your remote's URL from SSH to HTTPS with the git remote set-url command. git remote set-url origin https://github.com/OWNER/REPOSITORY.git\n• Verify that the remote URL has changed. $ git remote -v # Verify new remote URL > origin https://github.com/OWNER/REPOSITORY.git (fetch) > origin https://github.com/OWNER/REPOSITORY.git (push)",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$git remote -v>origin  git@github.com:OWNER/REPOSITORY.git (fetch)>origin  git@github.com:OWNER/REPOSITORY.git (push)\n```",
          "```bash\ngit remote set-url origin https://github.com/OWNER/REPOSITORY.git\n```",
          "```bash\n$git remote -v#Verify new remote URL>origin  https://github.com/OWNER/REPOSITORY.git (fetch)>origin  https://github.com/OWNER/REPOSITORY.git (push)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1530
        }
      },
      {
        "header": "Switching remote URLs from HTTPS to SSH",
        "content": "Open TerminalTerminalGit Bash.\n\nChange the current working directory to your local project.\n\nList your existing remotes in order to get the name of the remote you want to change.\n\nChange your remote's URL from HTTPS to SSH with the git remote set-url command.\n\nVerify that the remote URL has changed.\n\n• Open TerminalTerminalGit Bash.\n• Change the current working directory to your local project.\n• List your existing remotes in order to get the name of the remote you want to change. $ git remote -v > origin https://github.com/OWNER/REPOSITORY.git (fetch) > origin https://github.com/OWNER/REPOSITORY.git (push)\n• Change your remote's URL from HTTPS to SSH with the git remote set-url command. git remote set-url origin git@github.com:OWNER/REPOSITORY.git\n• Verify that the remote URL has changed. $ git remote -v # Verify new remote URL > origin git@github.com:OWNER/REPOSITORY.git (fetch) > origin git@github.com:OWNER/REPOSITORY.git (push)",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$git remote -v>origin  https://github.com/OWNER/REPOSITORY.git (fetch)>origin  https://github.com/OWNER/REPOSITORY.git (push)\n```",
          "```bash\ngit remote set-url origin git@github.com:OWNER/REPOSITORY.git\n```",
          "```bash\n$git remote -v#Verify new remote URL>origin  git@github.com:OWNER/REPOSITORY.git (fetch)>origin  git@github.com:OWNER/REPOSITORY.git (push)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 944
        }
      },
      {
        "header": "Troubleshooting: No such remote '[name]'",
        "content": "This error means that the remote you tried to change doesn't exist:\n\nCheck that you've correctly typed the remote name.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$git remote set-url sofake https://github.com/octocat/Spoon-Knife>fatal: No such remote'sofake'\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 119
        }
      },
      {
        "header": "Renaming a remote repository",
        "content": "Use the git remote rename command to rename an existing remote.\n\nThe git remote rename command takes two arguments:\n\n• An existing remote name, for example, origin\n• A new name for the remote, for example, destination",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 217
        }
      },
      {
        "header": "Example of renaming a remote repository",
        "content": "These examples assume you're cloning using HTTPS, which is recommended.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$git remote -v#View existing remotes>origin  https://github.com/OWNER/REPOSITORY.git (fetch)>origin  https://github.com/OWNER/REPOSITORY.git (push)$git remote rename origin destination#Change remote name from'origin'to'destination'$git remote -v#Verify remote's new name>destination  https://github.com/OWNER/REPOSITORY.git (fetch)>destination  https://github.com/OWNER/REPOSITORY.git (push)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 71
        }
      },
      {
        "header": "Troubleshooting: Could not rename config section 'remote.[old name]' to 'remote.[new name]'",
        "content": "This error means that the old remote name you typed doesn't exist.\n\nYou can check which remotes currently exist with the git remote -v command:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$git remote -v#View existing remotes>origin  https://github.com/OWNER/REPOSITORY.git (fetch)>origin  https://github.com/OWNER/REPOSITORY.git (push)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 143
        }
      },
      {
        "header": "Troubleshooting: Remote [new name] already exists",
        "content": "This error means that the remote name you want to use already exists. To solve this, either use a different remote name, or rename the original remote.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 151
        }
      },
      {
        "header": "Removing a remote repository",
        "content": "Use the git remote rm command to remove a remote URL from your repository.\n\nThe git remote rm command takes one argument:\n\nRemoving the remote URL from your repository only unlinks the local and remote repositories. It does not delete the remote repository.\n\n• A remote name, for example, destination",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 300
        }
      },
      {
        "header": "Example of removing a remote repository",
        "content": "These examples assume you're cloning using HTTPS, which is recommended.\n\ngit remote rm does not delete the remote repository from the server. It simply removes the remote and its references from your local repository.\n\n[Alert] Note git remote rm does not delete the remote repository from the server. It simply removes the remote and its references from your local repository.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$git remote -v#View current remotes>origin  https://github.com/OWNER/REPOSITORY.git (fetch)>origin  https://github.com/OWNER/REPOSITORY.git (push)>destination  https://github.com/FORKER/REPOSITORY.git (fetch)>destination  https://github.com/FORKER/REPOSITORY.git (push)$git remotermdestination#Remove remote$git remote -v#Verify it's gone>origin  https://github.com/OWNER/REPOSITORY.git (fetch)>origin  https://github.com/OWNER/REPOSITORY.git (push)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 376
        }
      },
      {
        "header": "Troubleshooting: Could not remove config section 'remote.[name]'",
        "content": "This error means that the remote you tried to delete doesn't exist:\n\nCheck that you've correctly typed the remote name.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$git remotermsofake>error: Could not remove config section'remote.sofake'\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 119
        }
      },
      {
        "header": "Further reading",
        "content": "• \"Working with Remotes\" from the Pro Git book",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 46
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/getting-started-with-git/managing-remote-repositories",
    "doc_type": "git",
    "total_sections": 15
  },
  {
    "title": "Caching your GitHub credentials in Git",
    "summary": "Caching your GitHub credentials in GitIf you're cloning GitHub repositories using HTTPS, we recommend you use GitHub CLI or Git Credential Manager (GCM) to remember your credentials.Platform navigationIn this articleTip If you clone GitHub repositories using SSH, then you can authenticate using an SSH key instead of using other credentials. For information about setting up an SSH connection, see Connecting to GitHub with SSH. GitHub CLI GitHub CLI will automatically store your Git credentials fo",
    "sections": [
      {
        "header": "",
        "content": "If you're cloning GitHub repositories using HTTPS, we recommend you use GitHub CLI or Git Credential Manager (GCM) to remember your credentials.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 144
        }
      },
      {
        "header": "In this article",
        "content": "If you clone GitHub repositories using SSH, then you can authenticate using an SSH key instead of using other credentials. For information about setting up an SSH connection, see Connecting to GitHub with SSH.\n\n[Alert] Tip If you clone GitHub repositories using SSH, then you can authenticate using an SSH key instead of using other credentials. For information about setting up an SSH connection, see Connecting to GitHub with SSH.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 432
        }
      },
      {
        "header": "GitHub CLI",
        "content": "GitHub CLI will automatically store your Git credentials for you when you choose HTTPS as your preferred protocol for Git operations and answer \"yes\" to the prompt asking if you would like to authenticate to Git with your GitHub credentials.\n\nFor more information about authenticating with GitHub CLI, see gh auth login.\n\n• Install GitHub CLI on macOS, Windows, or Linux.\n• In the command line, enter gh auth login, then follow the prompts. When prompted for your preferred protocol for Git operations, select HTTPS. When asked if you would like to authenticate to Git with your GitHub credentials, enter Y.\n\n• When prompted for your preferred protocol for Git operations, select HTTPS.\n• When asked if you would like to authenticate to Git with your GitHub credentials, enter Y.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 779
        }
      },
      {
        "header": "Git Credential Manager",
        "content": "Git Credential Manager (GCM) is another way to store your credentials securely and connect to GitHub over HTTPS. With GCM, you don't have to manually create and store a personal access token, as GCM manages authentication on your behalf, including 2FA (two-factor authentication).\n\nInstall Git using Homebrew:\n\nInstall GCM using Homebrew:\n\nFor macOS, you don't need to run git config because GCM automatically configures Git for you.\n\nThe next time you clone an HTTPS URL that requires authentication, Git will prompt you to log in using a browser window. You may first be asked to authorize an OAuth app. If your account or organization requires two-factor auth, you'll also need to complete the 2FA challenge.\n\nIf you're a member of an enterprise that uses Enterprise Managed Users, your enterprise view has the \"Users managed by ACCOUNT NAME\" header bar at the top of the screen. In that case you will need to disable account filtering locally in GCM to prevent getting prompted for authentication each time a remote Git operation is performed. For more details, see the git-credential-manager repository.\n\nTo configure the Git Credential Manager run the following command:\n\nOnce you've authenticated successfully, your credentials are stored in the macOS keychain and will be used every time you clone an HTTPS URL. Git will not require you to type your credentials in the command line again unless you change your credentials.\n\nWe recommend always installing the latest version. At a minimum, install version 2.29 or higher, which is the first version offering OAuth support for GitHub.\n\nThe next time you clone an HTTPS URL that requires authentication, Git will prompt you to log in using a browser window. You may first be asked to authorize an OAuth app. If your account or organization requires two-factor auth, you'll also need to complete the 2FA challenge.\n\nIf you're a member of an enterprise that uses Enterprise Managed Users, your enterprise view has the \"Users managed by ACCOUNT NAME\" header bar at the top of the screen. In that case you will need to disable account filtering locally in GCM to prevent getting prompted for authentication each time a remote Git operation is performed. For more details, see the git-credential-manager repository.\n\nTo configure the Git Credential Manager run the following command:\n\nOnce you've authenticated successfully, your credentials are stored in the Windows credential manager and will be used every time you clone an HTTPS URL. Git will not require you to type your credentials in the command line again unless you change your credentials.\n\nOlder versions of Git for Windows came with Git Credential Manager for Windows. This older product is no longer supported and cannot connect to GitHub via OAuth. We recommend you upgrade to the latest version of Git for Windows.\n\nIf you cached incorrect or outdated credentials in Credential Manager for Windows, Git will fail to access GitHub. To reset your cached credentials so that Git prompts you to enter your credentials, access the Credential Manager in the Windows Control Panel under User Accounts > Credential Manager. Look for the GitHub entry and delete it.\n\nFor Linux, install Git and GCM, then configure Git to use GCM.\n\nInstall Git from your distro's packaging system. Instructions will vary depending on the flavor of Linux you run.\n\nInstall GCM. See the instructions in the GCM repo, as they'll vary depending on the flavor of Linux you run.\n\nConfigure Git to use GCM. There are several backing stores that you may choose from, so see the GCM docs to complete your setup. For more information, see GCM Linux.\n\nThe next time you clone an HTTPS URL that requires authentication, Git will prompt you to log in using a browser window. You may first be asked to authorize an OAuth app. If your account or organization requires two-factor auth, you'll also need to complete the 2FA challenge.\n\nIf you're a member of an enterprise that uses Enterprise Managed Users, your enterprise view has the \"Users managed by ACCOUNT NAME\" header bar at the top of the screen. In that case you will need to disable account filtering locally in GCM to prevent getting prompted for authentication each time a remote Git operation is performed. For more details, see the git-credential-manager repository.\n\nTo configure the Git Credential Manager run the following command:\n\nOnce you've authenticated successfully, your credentials are stored on your system and will be used every time you clone an HTTPS URL. Git will not require you to type your credentials in the command line again unless you change your credentials.\n\nFor more options for storing your credentials on Linux, see Credential Storage in Pro Git.\n\nFor more information or to report issues with GCM, see the official GCM docs at Git Credential Manager.\n\n• Install Git using Homebrew: brew install git\n• Install GCM using Homebrew: brew install --cask git-credential-manager\n\n• Install Git for Windows, which includes GCM. For more information, see Git for Windows releases from its releases page.\n\n• Install Git from your distro's packaging system. Instructions will vary depending on the flavor of Linux you run.\n• Install GCM. See the instructions in the GCM repo, as they'll vary depending on the flavor of Linux you run.\n• Configure Git to use GCM. There are several backing stores that you may choose from, so see the GCM docs to complete your setup. For more information, see GCM Linux.\n\n[Alert] Tip If you're a member of an enterprise that uses Enterprise Managed Users, your enterprise view has the \"Users managed by ACCOUNT NAME\" header bar at the top of the screen. In that case you will need to disable account filtering locally in GCM to prevent getting prompted for authentication each time a remote Git operation is performed. For more details, see the git-credential-manager repository. To configure the Git Credential Manager run the following command: git config --global credential.gitHubAccountFiltering \"false\"\n\n[Alert] Tip If you're a member of an enterprise that uses Enterprise Managed Users, your enterprise view has the \"Users managed by ACCOUNT NAME\" header bar at the top of the screen. In that case you will need to disable account filtering locally in GCM to prevent getting prompted for authentication each time a remote Git operation is performed. For more details, see the git-credential-manager repository. To configure the Git Credential Manager run the following command: git config --global credential.gitHubAccountFiltering \"false\"\n\n[Alert] Warning Older versions of Git for Windows came with Git Credential Manager for Windows. This older product is no longer supported and cannot connect to GitHub via OAuth. We recommend you upgrade to the latest version of Git for Windows.\n\n[Alert] Warning If you cached incorrect or outdated credentials in Credential Manager for Windows, Git will fail to access GitHub. To reset your cached credentials so that Git prompts you to enter your credentials, access the Credential Manager in the Windows Control Panel under User Accounts > Credential Manager. Look for the GitHub entry and delete it.\n\n[Alert] Tip If you're a member of an enterprise that uses Enterprise Managed Users, your enterprise view has the \"Users managed by ACCOUNT NAME\" header bar at the top of the screen. In that case you will need to disable account filtering locally in GCM to prevent getting prompted for authentication each time a remote Git operation is performed. For more details, see the git-credential-manager repository. To configure the Git Credential Manager run the following command: git config --global credential.gitHubAccountFiltering \"false\"",
        "code_examples": [],
        "usage_examples": [
          "```bash\nbrew install git\n```",
          "```bash\nbrew install --cask git-credential-manager\n```",
          "```bash\ngit config --global credential.gitHubAccountFiltering\"false\"\n```",
          "```bash\ngit config --global credential.gitHubAccountFiltering\"false\"\n```",
          "```bash\ngit config --global credential.gitHubAccountFiltering\"false\"\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 25,
          "content_length": 7675
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/getting-started-with-git/caching-your-github-credentials-in-git",
    "doc_type": "git",
    "total_sections": 4
  },
  {
    "title": "Associating text editors with Git",
    "summary": "Associating text editors with GitUse a text editor to open and edit your files with Git.Platform navigationIn this articleUsing Visual Studio Code as your editor Install Visual Studio Code (VS Code). For more information, see Setting up VS Code in the VS Code documentation. Open TerminalTerminalGit Bash. Type this command: git config --global core.editor \"code --wait\" Install Visual Studio Code (VS Code). For more information, see Setting up VS Code in the VS Code documentation. Open TerminalTer",
    "sections": [
      {
        "header": "",
        "content": "Use a text editor to open and edit your files with Git.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 55
        }
      },
      {
        "header": "Using Visual Studio Code as your editor",
        "content": "Install Visual Studio Code (VS Code). For more information, see Setting up VS Code in the VS Code documentation.\n\nOpen TerminalTerminalGit Bash.\n\nInstall Visual Studio Code (VS Code). For more information, see Setting up VS Code in the VS Code documentation.\n\nOpen TerminalTerminalGit Bash.\n\nInstall Visual Studio Code (VS Code). For more information, see Setting up VS Code in the VS Code documentation.\n\nOpen TerminalTerminalGit Bash.\n\n• Install Visual Studio Code (VS Code). For more information, see Setting up VS Code in the VS Code documentation.\n• Open TerminalTerminalGit Bash.\n• Type this command: git config --global core.editor \"code --wait\"\n\n• Install Visual Studio Code (VS Code). For more information, see Setting up VS Code in the VS Code documentation.\n• Open TerminalTerminalGit Bash.\n• Type this command: git config --global core.editor \"code --wait\"\n\n• Install Visual Studio Code (VS Code). For more information, see Setting up VS Code in the VS Code documentation.\n• Open TerminalTerminalGit Bash.\n• Type this command: git config --global core.editor \"code --wait\"",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit config --global core.editor \"code --wait\"\n```",
          "```bash\ngit config --global core.editor \"code --wait\"\n```",
          "```bash\ngit config --global core.editor \"code --wait\"\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1084
        }
      },
      {
        "header": "Using Sublime Text as your editor",
        "content": "Install Sublime Text. For more information, see Installation in the Sublime Text documentation.\n\nOpen TerminalTerminalGit Bash.\n\nInstall Sublime Text. For more information, see Installation in the Sublime Text documentation.\n\nOpen TerminalTerminalGit Bash.\n\nInstall Sublime Text. For more information, see Installation in the Sublime Text documentation.\n\nOpen TerminalTerminalGit Bash.\n\n• Install Sublime Text. For more information, see Installation in the Sublime Text documentation.\n• Open TerminalTerminalGit Bash.\n• Type this command: git config --global core.editor \"subl -n -w\"\n\n• Install Sublime Text. For more information, see Installation in the Sublime Text documentation.\n• Open TerminalTerminalGit Bash.\n• Type this command: git config --global core.editor \"'C:/Program Files (x86)/sublime text 3/subl.exe' -w\"\n\n• Install Sublime Text. For more information, see Installation in the Sublime Text documentation.\n• Open TerminalTerminalGit Bash.\n• Type this command: git config --global core.editor \"subl -n -w\"",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit config --global core.editor \"subl -n -w\"\n```",
          "```bash\ngit config --global core.editor \"'C:/Program Files (x86)/sublime text 3/subl.exe' -w\"\n```",
          "```bash\ngit config --global core.editor \"subl -n -w\"\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1020
        }
      },
      {
        "header": "Using Notepad++ as your editor",
        "content": "Install Notepad++ from https://notepad-plus-plus.org/. For more information, see Getting started in the Notepad++ documentation.\n\nOpen TerminalTerminalGit Bash.\n\n• Install Notepad++ from https://notepad-plus-plus.org/. For more information, see Getting started in the Notepad++ documentation.\n• Open TerminalTerminalGit Bash.\n• Type this command: git config --global core.editor \"'C:/Program Files (x86)/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin\"",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit config --global core.editor \"'C:/Program Files (x86)/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin\"\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 471
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/getting-started-with-git/associating-text-editors-with-git",
    "doc_type": "git",
    "total_sections": 4
  },
  {
    "title": "About Git",
    "summary": "About GitLearn about the version control system, Git, and how it works with GitHub.In this articleAbout version control and Git A version control system, or VCS, tracks the history of changes as people and teams collaborate on projects together. As developers make changes to the project, any earlier version of the project can be recovered at any time. Developers can review project history to find out: Which changes were made? Who made the changes? When were the changes made? Why were changes nee",
    "sections": [
      {
        "header": "",
        "content": "Learn about the version control system, Git, and how it works with GitHub.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 74
        }
      },
      {
        "header": "About version control and Git",
        "content": "A version control system, or VCS, tracks the history of changes as people and teams collaborate on projects together. As developers make changes to the project, any earlier version of the project can be recovered at any time.\n\nDevelopers can review project history to find out:\n\nVCSs give each contributor a unified and consistent view of a project, surfacing work that's already in progress. Seeing a transparent history of changes, who made them, and how they contribute to the development of a project helps team members stay aligned while working independently.\n\nIn a distributed version control system, every developer has a full copy of the project and project history. Unlike once popular centralized version control systems, DVCSs don't need a constant connection to a central repository. Git is the most popular distributed version control system. Git is commonly used for both open source and commercial software development, with significant benefits for individuals, teams and businesses.\n\nGit lets developers see the entire timeline of their changes, decisions, and progression of any project in one place. From the moment they access the history of a project, the developer has all the context they need to understand it and start contributing.\n\nDevelopers work in every time zone. With a DVCS like Git, collaboration can happen any time while maintaining source code integrity. Using branches, developers can safely propose changes to production code.\n\nBusinesses using Git can break down communication barriers between teams and keep them focused on doing their best work. Plus, Git makes it possible to align experts across a business to collaborate on major projects.\n\n• Which changes were made?\n• Who made the changes?\n• When were the changes made?\n• Why were changes needed?\n\n• Git lets developers see the entire timeline of their changes, decisions, and progression of any project in one place. From the moment they access the history of a project, the developer has all the context they need to understand it and start contributing.\n• Developers work in every time zone. With a DVCS like Git, collaboration can happen any time while maintaining source code integrity. Using branches, developers can safely propose changes to production code.\n• Businesses using Git can break down communication barriers between teams and keep them focused on doing their best work. Plus, Git makes it possible to align experts across a business to collaborate on major projects.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 2483
        }
      },
      {
        "header": "About repositories",
        "content": "A repository, or Git project, encompasses the entire collection of files and folders associated with a project, along with each file's revision history. The file history appears as snapshots in time called commits. The commits can be organized into multiple lines of development called branches. Because Git is a DVCS, repositories are self-contained units and anyone who has a copy of the repository can access the entire codebase and its history. Using the command line or other ease-of-use interfaces, a Git repository also allows for: interaction with the history, cloning the repository, creating branches, committing, merging, comparing changes across versions of code, and more.\n\nThrough platforms like GitHub, Git also provides more opportunities for project transparency and collaboration. Public repositories help teams work together to build the best possible final product.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 885
        }
      },
      {
        "header": "How GitHub works",
        "content": "GitHub hosts Git repositories and provides developers with tools to ship better code through command line features, issues (threaded discussions), pull requests, code review, or the use of a collection of free and for-purchase apps in the GitHub Marketplace. With collaboration layers like the GitHub flow, a community of 100 million developers, and an ecosystem with hundreds of integrations, GitHub changes the way software is built.\n\nGitHub builds collaboration directly into the development process. Work is organized into repositories where developers can outline requirements or direction and set expectations for team members. Then, using the GitHub flow, developers simply create a branch to work on updates, commit changes to save them, open a pull request to propose and discuss changes, and merge pull requests once everyone is on the same page. For more information, see GitHub flow.\n\nFor GitHub plans and costs, see GitHub Pricing. For information on how GitHub Enterprise compares to other options, see Comparing GitHub to other DevOps solutions.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1060
        }
      },
      {
        "header": "Basic Git commands",
        "content": "To use Git, developers use specific commands to copy, create, change, and combine code. These commands can be executed directly from the command line or by using an application like GitHub Desktop. Here are some common commands for using Git:\n\ngit init initializes a brand new Git repository and begins tracking an existing directory. It adds a hidden subfolder within the existing directory that houses the internal data structure required for version control.\n\ngit clone creates a local copy of a project that already exists remotely. The clone includes all the project's files, history, and branches.\n\ngit add stages a change. Git tracks changes to a developer's codebase, but it's necessary to stage and take a snapshot of the changes to include them in the project's history. This command performs staging, the first part of that two-step process. Any changes that are staged will become a part of the next snapshot and a part of the project's history. Staging and committing separately gives developers complete control over the history of their project without changing how they code and work.\n\ngit commit saves the snapshot to the project history and completes the change-tracking process. In short, a commit functions like taking a photo. Anything that's been staged with git add will become a part of the snapshot with git commit.\n\ngit status shows the status of changes as untracked, modified, or staged.\n\ngit branch shows the branches being worked on locally.\n\ngit merge merges lines of development together. This command is typically used to combine changes made on two distinct branches. For example, a developer would merge when they want to combine changes from a feature branch into the main branch for deployment.\n\ngit pull updates the local line of development with updates from its remote counterpart. Developers use this command if a teammate has made commits to a branch on a remote, and they would like to reflect those changes in their local environment.\n\ngit push updates the remote repository with any commits made locally to a branch.\n\nFor more information, see the full reference guide to Git commands.\n\n• git init initializes a brand new Git repository and begins tracking an existing directory. It adds a hidden subfolder within the existing directory that houses the internal data structure required for version control.\n• git clone creates a local copy of a project that already exists remotely. The clone includes all the project's files, history, and branches.\n• git add stages a change. Git tracks changes to a developer's codebase, but it's necessary to stage and take a snapshot of the changes to include them in the project's history. This command performs staging, the first part of that two-step process. Any changes that are staged will become a part of the next snapshot and a part of the project's history. Staging and committing separately gives developers complete control over the history of their project without changing how they code and work.\n• git commit saves the snapshot to the project history and completes the change-tracking process. In short, a commit functions like taking a photo. Anything that's been staged with git add will become a part of the snapshot with git commit.\n• git status shows the status of changes as untracked, modified, or staged.\n• git branch shows the branches being worked on locally.\n• git merge merges lines of development together. This command is typically used to combine changes made on two distinct branches. For example, a developer would merge when they want to combine changes from a feature branch into the main branch for deployment.\n• git pull updates the local line of development with updates from its remote counterpart. Developers use this command if a teammate has made commits to a branch on a remote, and they would like to reflect those changes in their local environment.\n• git push updates the remote repository with any commits made locally to a branch.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 11,
          "content_length": 3959
        }
      },
      {
        "header": "Example: Start a new repository and publish it to GitHub",
        "content": "First, you will need to create a new repository on GitHub. For more information, see Hello World. Do not initialize the repository with a README, .gitignore or License file. This empty repository will await your code.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# create a new directory, and initialize it with git-specific functionsgit init my-repo# change into the `my-repo` directorycdmy-repo# create the first file in the projecttouchREADME.md# git isn't aware of the file, stage itgit add README.md# take a snapshot of the staging areagit commit -m\"add README to initial commit\"# provide the path for the repository you created on githubgit remote add origin https://github.com/YOUR-USERNAME/YOUR-REPOSITORY-NAME.git# push changes to githubgit push --set-upstream origin main\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 217
        }
      },
      {
        "header": "Example: contribute to an existing branch on GitHub",
        "content": "This example assumes that you already have a project called repo on the machine and that a new branch has been pushed to GitHub since the last time changes were made locally.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# change into the `repo` directorycdrepo# update all remote tracking branches, and the currently checked out branchgit pull# change into the existing branch called `feature-a`git checkout feature-a# make changes, for example, edit `file1.md` using the text editor# stage the changed filegit add file1.md# take a snapshot of the staging areagit commit -m\"edit file1\"# push changes to githubgit push\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 174
        }
      },
      {
        "header": "Models for collaborative development",
        "content": "There are two primary ways people collaborate on GitHub:\n\nWith a shared repository, individuals and teams are explicitly designated as contributors with read, write, or administrator access. This simple permission structure, combined with features like protected branches, helps teams progress quickly when they adopt GitHub.\n\nFor an open source project, or for projects to which anyone can contribute, managing individual permissions can be challenging, but a fork and pull model allows anyone who can view the project to contribute. A fork is a copy of a project under a developer's personal account. Every developer has full control of their fork and is free to implement a fix or a new feature. Work completed in forks is either kept separate, or is surfaced back to the original project via a pull request. There, maintainers can review the suggested changes before they're merged. For more information, see Contributing to a project.\n\n• Shared repository\n• Fork and pull",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 976
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/using-git/about-git",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "Pushing commits to a remote repository",
    "summary": "Pushing commits to a remote repositoryUse git push to push commits made on your local branch to a remote repository.In this articleAbout git push The git push command takes two arguments: A remote name, for example, origin A branch name, for example, main For example: git push REMOTE-NAME BRANCH-NAME As an example, you usually run git push origin main to push your local changes to your online repository. Renaming branches To rename a branch, you'd use the same git push command, but you would add",
    "sections": [
      {
        "header": "",
        "content": "Use git push to push commits made on your local branch to a remote repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 78
        }
      },
      {
        "header": "About git push",
        "content": "The git push command takes two arguments:\n\nAs an example, you usually run git push origin main to push your local changes to your online repository.\n\n• A remote name, for example, origin\n• A branch name, for example, main",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push REMOTE-NAME BRANCH-NAME\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 221
        }
      },
      {
        "header": "Renaming branches",
        "content": "To rename a branch, you'd use the same git push command, but you would add one more argument: the name of the new branch. For example:\n\nThis pushes the LOCAL-BRANCH-NAME to your REMOTE-NAME, but it is renamed to REMOTE-BRANCH-NAME.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push REMOTE-NAME LOCAL-BRANCH-NAME:REMOTE-BRANCH-NAME\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 231
        }
      },
      {
        "header": "Dealing with \"non-fast-forward\" errors",
        "content": "If your local copy of a repository is out of sync with, or \"behind,\" the upstream repository you're pushing to, you'll get a message saying non-fast-forward updates were rejected. This means that you must retrieve, or \"fetch,\" the upstream changes, before you are able to push your local changes.\n\nFor more information on this error, see Dealing with non-fast-forward errors.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 375
        }
      },
      {
        "header": "Resolving blocked commits",
        "content": "To maintain the security of the repository you're pushing to, GitHub's push protection automatically protects you from accidentally committing secrets to public repositories on GitHub.com. Exposed secrets can pose serious security risks to your repository and your supply chain. If GitHub detects that the commit you're attempting to push contains a supported secret, it blocks the push. In order to resolve the block, you should either:\n\nTo learn more about push protection, see Push protection for users.\n\n• Remove the secret from your commit(s). For more information, see Resolving a blocked push.\n• Follow the provided URL to see options to allow the push. For more information, see Bypassing push protection",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 712
        }
      },
      {
        "header": "Pushing tags",
        "content": "By default, and without additional parameters, git push sends all matching branches that have the same names as remote branches.\n\nTo push a single tag, you can issue the same command as pushing a branch:\n\nTo push all your tags, you can type the command:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push REMOTE-NAME TAG-NAME\n```",
          "```bash\ngit push REMOTE-NAME --tags\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 253
        }
      },
      {
        "header": "Deleting a remote branch or tag",
        "content": "The syntax to delete a branch is a bit arcane at first glance:\n\nNote that there is a space before the colon. The command resembles the same steps you'd take to rename a branch. However, here, you're telling Git to push nothing into BRANCH-NAME on REMOTE-NAME. Because of this, git push deletes the branch on the remote repository.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit push REMOTE-NAME :BRANCH-NAME\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 330
        }
      },
      {
        "header": "Remotes and forks",
        "content": "You might already know that you can \"fork\" repositories on GitHub.\n\nWhen you clone a repository you own, you provide it with a remote URL that tells Git where to fetch and push updates. If you want to collaborate with the original repository, you'd add a new remote URL, typically called upstream, to your local Git clone:\n\nNow, you can fetch updates and branches from their fork:\n\nWhen you're done making local changes, you can push your local branch to GitHub and initiate a pull request.\n\nFor more information on working with forks, see Syncing a fork.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit remote add upstream THEIR_REMOTE_URL\n```",
          "```bash\ngit fetch upstream#Grab the upstream remote's branches>remote: Counting objects: 75, done.>remote: Compressing objects: 100% (53/53), done.>remote: Total 62 (delta 27), reused 44 (delta 9)>Unpacking objects: 100% (62/62), done.>From https://github.com/OCTOCAT/REPO>* [new branch]      main     -> upstream/main\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 555
        }
      },
      {
        "header": "Further reading",
        "content": "• The \"Remotes\" chapter from the \"Pro Git\" book\n• git remote main page\n• Git cheatsheet\n• Git workflows\n• Git Handbook\n• Troubleshooting the 2 GiB push limit",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 157
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/using-git/pushing-commits-to-a-remote-repository",
    "doc_type": "git",
    "total_sections": 9
  },
  {
    "title": "Getting changes from a remote repository",
    "summary": "Getting changes from a remote repositoryYou can use common Git commands to access remote repositories.In this articleOptions for getting changes These commands are very useful when interacting with a remote repository. clone and fetch download remote code from a repository's remote URL to your local computer, merge is used to merge different people's work together with yours, and pull is a combination of fetch and merge. Cloning a repository To grab a complete copy of another user's repository, ",
    "sections": [
      {
        "header": "",
        "content": "You can use common Git commands to access remote repositories.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 62
        }
      },
      {
        "header": "Options for getting changes",
        "content": "These commands are very useful when interacting with a remote repository. clone and fetch download remote code from a repository's remote URL to your local computer, merge is used to merge different people's work together with yours, and pull is a combination of fetch and merge.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 279
        }
      },
      {
        "header": "Cloning a repository",
        "content": "To grab a complete copy of another user's repository, use git clone like this:\n\nYou can choose from several different URLs when cloning a repository. While logged in to GitHub, these URLs are available on the main page of the repository when you click Code.\n\nWhen you run git clone, the following actions occur:\n\nFor every branch foo in the remote repository, a corresponding remote-tracking branch refs/remotes/origin/foo is created in your local repository. You can usually abbreviate such remote-tracking branch names to origin/foo.\n\n• A new folder called repo is made\n• It is initialized as a Git repository\n• A remote named origin is created, pointing to the URL you cloned from\n• All of the repository's files and commits are downloaded there\n• The default branch is checked out",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$gitclonehttps://github.com/USERNAME/REPOSITORY.git#Clones a repository to your computer\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 784
        }
      },
      {
        "header": "Fetching changes from a remote repository",
        "content": "Use git fetch to retrieve new work done by other people. Fetching from a repository grabs all the new remote-tracking branches and tags without merging those changes into your own branches.\n\nIf you already have a local repository with a remote URL set up for the desired project, you can grab all the new information by using git fetch *remotename* in the terminal:\n\nOtherwise, you can always add a new remote and then fetch. For more information, see Managing remote repositories.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$git fetch REMOTE-NAME#Fetches updates made to a remote repository\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 481
        }
      },
      {
        "header": "Merging changes into your local branch",
        "content": "Merging combines your local changes with changes made by others.\n\nTypically, you'd merge a remote-tracking branch (i.e., a branch fetched from a remote repository) with your local branch:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$git merge REMOTE-NAME/BRANCH-NAME#Merges updates made online with yourlocalwork\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 187
        }
      },
      {
        "header": "Pulling changes from a remote repository",
        "content": "git pull is a convenient shortcut for completing both git fetch and git mergein the same command:\n\nBecause pull performs a merge on the retrieved changes, you should ensure that your local work is committed before running the pull command. If you run into a merge conflict you cannot resolve, or if you decide to quit the merge, you can use git merge --abort to take the branch back to where it was in before you pulled.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$git pull REMOTE-NAME BRANCH-NAME#Grabs online updates and merges them with yourlocalwork\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 420
        }
      },
      {
        "header": "Further reading",
        "content": "• \"Working with Remotes\" from the Pro Git book\n• Troubleshooting connectivity problems",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 86
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/using-git/getting-changes-from-a-remote-repository",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "Dealing with non-fast-forward errors",
    "summary": "Dealing with non-fast-forward errorsSometimes, Git can't make your change to a remote repository without losing commits. When this happens, your push is refused.If another person has pushed to the same branch as you, Git won't be able to push your changes: $ git push origin main > To https://github.com/USERNAME/REPOSITORY.git > ! [rejected] main -> main (non-fast-forward) > error: failed to push some refs to 'https://github.com/USERNAME/REPOSITORY.git' > To prevent you from losing history, non-f",
    "sections": [
      {
        "header": "",
        "content": "Sometimes, Git can't make your change to a remote repository without losing commits. When this happens, your push is refused.\n\nIf another person has pushed to the same branch as you, Git won't be able to push your changes:\n\nYou can fix this by fetching and merging the changes made on the remote branch with the changes that you have made locally:\n\nOr, you can simply use git pull to perform both commands at once:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$git push origin main>To https://github.com/USERNAME/REPOSITORY.git>! [rejected]        main -> main (non-fast-forward)>error: failed to push some refs to'https://github.com/USERNAME/REPOSITORY.git'>To prevent you from losinghistory, non-fast-forward updates were rejected>Merge the remote changes (e.g.'git pull') before pushing again. See the>'Note about fast-forwards'section of'git push --help'fordetails.\n```",
          "```bash\n$git fetch origin#Fetches updates made to an online repository$git merge origin YOUR_BRANCH_NAME#Merges updates made online with yourlocalwork\n```",
          "```bash\n$git pull origin YOUR_BRANCH_NAME#Grabs online updates and merges them with yourlocalwork\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 414
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/using-git/dealing-with-non-fast-forward-errors",
    "doc_type": "git",
    "total_sections": 1
  },
  {
    "title": "Splitting a subfolder out into a new repository",
    "summary": "Splitting a subfolder out into a new repositoryYou can turn a folder within a Git repository into a brand new repository.Platform navigationNote You need Git version 2.22.0 or later to follow these instructions, otherwise git filter-repo will not work. If you create a new clone of the repository, you won't lose any of your Git history or changes when you split a folder into a separate repository. However, note that the new repository won't have the branches and tags of the original repository. O",
    "sections": [
      {
        "header": "",
        "content": "You can turn a folder within a Git repository into a brand new repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 74
        }
      },
      {
        "header": "Platform navigation",
        "content": "You need Git version 2.22.0 or later to follow these instructions, otherwise git filter-repo will not work.\n\nIf you create a new clone of the repository, you won't lose any of your Git history or changes when you split a folder into a separate repository. However, note that the new repository won't have the branches and tags of the original repository.\n\nOpen TerminalTerminalGit Bash.\n\nChange the current working directory to the location where you want to create your new repository.\n\nClone the repository that contains the subfolder.\n\nChange the current working directory to your cloned repository.\n\nTo filter out the subfolder from the rest of the files in the repository, install git-filter-repo, then run git filter-repo with the following arguments.\n\nWindows users should use / to delimit folders.\n\nThe repository should now only contain the files that were in your subfolder(s).\n\nIf you want one specific subfolder to be the new root folder of the new repository, you can use the following command:\n\nCreate a new repository on GitHub.\n\nAt the top of your new repository on GitHub's Quick Setup page, click to copy the remote repository URL.\n\nFor information on the difference between HTTPS and SSH URLs, see About remote repositories.\n\nAdd a new remote name with the URL you copied for your repository. For example, origin or upstream are two common choices.\n\nVerify that the remote URL was added with your new repository name.\n\nPush your changes to the new repository on GitHub.\n\n• Open TerminalTerminalGit Bash.\n• Change the current working directory to the location where you want to create your new repository.\n• Clone the repository that contains the subfolder. git clone https://github.com/USERNAME/REPOSITORY-NAME\n• Change the current working directory to your cloned repository. cd REPOSITORY-NAME\n• To filter out the subfolder from the rest of the files in the repository, install git-filter-repo, then run git filter-repo with the following arguments. FOLDER-NAME: The folder within your project where you'd like to create a separate repository. Tip Windows users should use / to delimit folders. $ git filter-repo --path FOLDER-NAME/ # Filter the specified branch in your directory and remove empty commits The repository should now only contain the files that were in your subfolder(s). If you want one specific subfolder to be the new root folder of the new repository, you can use the following command: $ git filter-repo --subdirectory-filter FOLDER-NAME # Filter the specific branch by using a single sub-directory as the root for the new repository\n• Create a new repository on GitHub.\n• At the top of your new repository on GitHub's Quick Setup page, click to copy the remote repository URL. Tip For information on the difference between HTTPS and SSH URLs, see About remote repositories.\n• Add a new remote name with the URL you copied for your repository. For example, origin or upstream are two common choices. git remote add origin https://github.com/USERNAME/REPOSITORY-NAME.git\n• Verify that the remote URL was added with your new repository name. $ git remote -v # Verify new remote URL > origin https://github.com/USERNAME/NEW-REPOSITORY-NAME.git (fetch) > origin https://github.com/USERNAME/NEW-REPOSITORY-NAME.git (push)\n• Push your changes to the new repository on GitHub. git push -u origin BRANCH-NAME\n\n• FOLDER-NAME: The folder within your project where you'd like to create a separate repository.\n\n[Alert] Note You need Git version 2.22.0 or later to follow these instructions, otherwise git filter-repo will not work.\n\n[Alert] Tip Windows users should use / to delimit folders.\n\n[Alert] Tip For information on the difference between HTTPS and SSH URLs, see About remote repositories.",
        "code_examples": [
          "```bash\ncd REPOSITORY-NAME\n```"
        ],
        "usage_examples": [
          "```bash\ngit clone https://github.com/USERNAME/REPOSITORY-NAME\n```",
          "```bash\n$git filter-repo --path FOLDER-NAME/#Filter the specified branchinyour directory and remove empty commits\n```",
          "```bash\n$git filter-repo --subdirectory-filter FOLDER-NAME#Filter the specific branch by using a single sub-directory as the rootforthe new repository\n```",
          "```bash\ngit remote add origin https://github.com/USERNAME/REPOSITORY-NAME.git\n```",
          "```bash\n$git remote -v#Verify new remote URL>origin  https://github.com/USERNAME/NEW-REPOSITORY-NAME.git (fetch)>origin  https://github.com/USERNAME/NEW-REPOSITORY-NAME.git (push)\n```",
          "```bash\ngit push -u origin BRANCH-NAME\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 16,
          "content_length": 3726
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/using-git/splitting-a-subfolder-out-into-a-new-repository",
    "doc_type": "git",
    "total_sections": 2
  },
  {
    "title": "About Git subtree merges",
    "summary": "About Git subtree mergesIf you need to manage multiple projects within a single repository, you can use a subtree merge to handle all the references.Platform navigationIn this articleAbout subtree merges Typically, a subtree merge is used to contain a repository within a repository. The \"subrepository\" is stored in a folder of the main repository. The best way to explain subtree merges is to show by example. We will: Make an empty repository called test that represents our project. Merge another",
    "sections": [
      {
        "header": "",
        "content": "If you need to manage multiple projects within a single repository, you can use a subtree merge to handle all the references.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 125
        }
      },
      {
        "header": "About subtree merges",
        "content": "Typically, a subtree merge is used to contain a repository within a repository. The \"subrepository\" is stored in a folder of the main repository.\n\nThe best way to explain subtree merges is to show by example. We will:\n\n• Make an empty repository called test that represents our project.\n• Merge another repository into it as a subtree called Spoon-Knife.\n• The test project will use that subproject as if it were part of the same repository.\n• Fetch updates from Spoon-Knife into our test project.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 497
        }
      },
      {
        "header": "Setting up the empty repository for a subtree merge",
        "content": "Open TerminalTerminalGit Bash.\n\nCreate a new directory and navigate to it.\n\nInitialize a new Git repository.\n\nCreate and commit a new file.\n\n• Open TerminalTerminalGit Bash.\n• Create a new directory and navigate to it. mkdir test cd test\n• Initialize a new Git repository. $ git init > Initialized empty Git repository in /Users/octocat/tmp/test/.git/\n• Create and commit a new file. $ touch .gitignore $ git add .gitignore $ git commit -m \"initial commit\" > [main (root-commit) 3146c2a] initial commit > 0 files changed, 0 insertions(+), 0 deletions(-) > create mode 100644 .gitignore",
        "code_examples": [
          "```bash\nmkdir test\ncd test\n```"
        ],
        "usage_examples": [
          "```bash\n$git init>Initialized empty Git repositoryin/Users/octocat/tmp/test/.git/\n```",
          "```bash\n$touch.gitignore$git add .gitignore$git commit -m\"initial commit\">[main (root-commit) 3146c2a] initial commit>0 files changed, 0 insertions(+), 0 deletions(-)>create mode 100644 .gitignore\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 585
        }
      },
      {
        "header": "Adding a new repository as a subtree",
        "content": "Add a new remote URL pointing to the separate project that we're interested in.\n\nMerge the Spoon-Knife project into the local Git project. This doesn't change any of your files locally, but it does prepare Git for the next step.\n\nIf you're using Git 2.9 or above:\n\nIf you're using Git 2.8 or below:\n\nCreate a new directory called spoon-knife, and copy the Git history of the Spoon-Knife project into it.\n\nCommit the changes to keep them safe.\n\nAlthough we've only added one subproject, any number of subprojects can be incorporated into a Git repository.\n\nIf you create a fresh clone of the repository in the future, the remotes you've added will not be created for you. You will have to add them again using the git remote add command.\n\n• Add a new remote URL pointing to the separate project that we're interested in. $ git remote add -f spoon-knife https://github.com/octocat/Spoon-Knife.git > Updating spoon-knife > warning: no common commits > remote: Counting objects: 1732, done. > remote: Compressing objects: 100% (750/750), done. > remote: Total 1732 (delta 1086), reused 1558 (delta 967) > Receiving objects: 100% (1732/1732), 528.19 KiB | 621 KiB/s, done. > Resolving deltas: 100% (1086/1086), done. > From https://github.com/octocat/Spoon-Knife > * [new branch] main -> Spoon-Knife/main\n• Merge the Spoon-Knife project into the local Git project. This doesn't change any of your files locally, but it does prepare Git for the next step. If you're using Git 2.9 or above: $ git merge -s ours --no-commit --allow-unrelated-histories spoon-knife/main > Automatic merge went well; stopped before committing as requested If you're using Git 2.8 or below: $ git merge -s ours --no-commit spoon-knife/main > Automatic merge went well; stopped before committing as requested\n• Create a new directory called spoon-knife, and copy the Git history of the Spoon-Knife project into it. $ git read-tree --prefix=spoon-knife/ -u spoon-knife/main > fatal: refusing to merge unrelated histories\n• Commit the changes to keep them safe. $ git commit -m \"Subtree merged in spoon-knife\" > [main fe0ca25] Subtree merged in spoon-knife\n\n[Alert] Tip If you create a fresh clone of the repository in the future, the remotes you've added will not be created for you. You will have to add them again using the git remote add command.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$git remote add -f spoon-knife https://github.com/octocat/Spoon-Knife.git>Updating spoon-knife>warning: no common commits>remote: Counting objects: 1732,done.>remote: Compressing objects: 100% (750/750),done.>remote: Total 1732 (delta 1086), reused 1558 (delta 967)>Receiving objects: 100% (1732/1732), 528.19 KiB | 621 KiB/s,done.>Resolving deltas: 100% (1086/1086),done.>From https://github.com/octocat/Spoon-Knife>* [new branch]      main     -> Spoon-Knife/main\n```",
          "```bash\n$git merge -s ours --no-commit --allow-unrelated-histories spoon-knife/main>Automatic merge went well; stopped before committing as requested\n```",
          "```bash\n$git merge -s ours --no-commit spoon-knife/main>Automatic merge went well; stopped before committing as requested\n```",
          "```bash\n$git read-tree --prefix=spoon-knife/ -u spoon-knife/main>fatal: refusing to merge unrelated histories\n```",
          "```bash\n$git commit -m\"Subtree merged in spoon-knife\">[main fe0ca25] Subtree mergedinspoon-knife\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 2319
        }
      },
      {
        "header": "Synchronizing with updates and changes",
        "content": "When a subproject is added, it is not automatically kept in sync with the upstream changes. You will need to update the subproject with the following command:\n\nFor the example above, this would be:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit pull -s subtree REMOTE-NAME BRANCH-NAME\n```",
          "```bash\ngit pull -s subtree spoon-knife main\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 197
        }
      },
      {
        "header": "Further reading",
        "content": "• The \"Advanced Merging\" chapter from the Pro Git book\n• How to use the subtree merge strategy",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 94
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/using-git/about-git-subtree-merges",
    "doc_type": "git",
    "total_sections": 6
  },
  {
    "title": "About GitHub Importer",
    "summary": "About GitHub ImporterIf your source code is stored on another Git-based hosting service, you can move the code to GitHub.com using GitHub Importer.In this articleAbout GitHub Importer GitHub Importer is a tool that quickly imports Git repositories from other hosting services to GitHub.com. To get started with GitHub Importer, see Importing a repository with GitHub Importer. Capabilities and limitations of GitHub Importer GitHub Importer imports the source code and commit history of a repository.",
    "sections": [
      {
        "header": "",
        "content": "If your source code is stored on another Git-based hosting service, you can move the code to GitHub.com using GitHub Importer.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 126
        }
      },
      {
        "header": "About GitHub Importer",
        "content": "GitHub Importer is a tool that quickly imports Git repositories from other hosting services to GitHub.com.\n\nTo get started with GitHub Importer, see Importing a repository with GitHub Importer.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 193
        }
      },
      {
        "header": "Capabilities and limitations of GitHub Importer",
        "content": "• GitHub Importer imports the source code and commit history of a repository. It does not import other associated data from the hosting service, such as issues and pull requests.\n• GitHub Importer is only available on GitHub.com.\n• During an import, you can authenticate with your remote repository. The repository must be accessible from the public internet. If the repository is hosted on a private network, GitHub Importer won't be able to access it.\n• GitHub Importer does not support repositories that use version control systems other than Git, such as Mercurial, Subversion, or Team Foundation Version Control (TFVC). For more information about alternatives to GitHub Importer, see About source code imports using the command line.\n• Repositories and individual files on GitHub are subject to size limits. For more information, see About large files on GitHub.\n• GitHub Importer does not move Git Large File Storage (LFS) objects from the source repository to the target repository. If you use Git LFS, you will need to either convert the Git LFS objects to regular files tracked by Git before running the migration, or move the Git LFS objects to the new repository separately after running the migration.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 1213
        }
      },
      {
        "header": "Further reading",
        "content": "• Importing an external Git repository using the command line",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 61
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/importing-your-projects-to-github/importing-source-code-to-github/about-github-importer",
    "doc_type": "git",
    "total_sections": 4
  },
  {
    "title": "Importing a repository with GitHub Importer",
    "summary": "Importing a repository with GitHub ImporterIf you have a project hosted on another Git-based hosting service, you can quickly import it to GitHub using the GitHub Importer tool.In this articleAbout repository imports with GitHub Importer GitHub Importer imports the source code and commit history of Git repositories hosted on external hosting services. For more information about the capabilities and limitations of GitHub Importer, see About GitHub Importer. GitHub uses the email address in the co",
    "sections": [
      {
        "header": "",
        "content": "If you have a project hosted on another Git-based hosting service, you can quickly import it to GitHub using the GitHub Importer tool.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 134
        }
      },
      {
        "header": "About repository imports with GitHub Importer",
        "content": "GitHub Importer imports the source code and commit history of Git repositories hosted on external hosting services. For more information about the capabilities and limitations of GitHub Importer, see About GitHub Importer.\n\nGitHub uses the email address in the commit header to link a commit to a GitHub user. To correctly attribute commits in an imported repository, users will need to add the email address associated with their commits to their GitHub account. For more information, see Adding an email address to your GitHub account.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 537
        }
      },
      {
        "header": "Importing a repository with GitHub Importer",
        "content": "When you import a repository using the GitHub Importer, a new repository will be created. If you already have an existing repository you want to use, you can instead add your local repository to GitHub using Git. For more information, see Adding locally hosted code to GitHub.\n\nIn the upper-right corner of any page on GitHub.com, click , and then click Import repository.\n\nOn the \"Import your project to GitHub\" page, enter the URL for the remote repository hosted on another platform.\n\nIf the source repository is private, enter credentials for authentication. GitHub Importer will use the credentials to perform a git clone operation on the source repository.\n\nChoose an owner and a name for the new repository on GitHub.\n\nChoose the visibility of the new repository. For more information, see About repositories.\n\nYou'll be redirected to a \"Preparing your new repository\" page, where you can track the status of your import. You'll receive an email when the repository has been completely imported.\n\n• In the upper-right corner of any page on GitHub.com, click , and then click Import repository.\n• On the \"Import your project to GitHub\" page, enter the URL for the remote repository hosted on another platform.\n• If the source repository is private, enter credentials for authentication. GitHub Importer will use the credentials to perform a git clone operation on the source repository.\n• Choose an owner and a name for the new repository on GitHub.\n• Choose the visibility of the new repository. For more information, see About repositories.\n• Click Begin import.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1570
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/importing-your-projects-to-github/importing-source-code-to-github/importing-a-repository-with-github-importer",
    "doc_type": "git",
    "total_sections": 3
  },
  {
    "title": "About GitHub Importer",
    "summary": "About GitHub ImporterIf your source code is stored on another Git-based hosting service, you can move the code to GitHub.com using GitHub Importer.In this articleAbout GitHub Importer GitHub Importer is a tool that quickly imports Git repositories from other hosting services to GitHub.com. To get started with GitHub Importer, see Importing a repository with GitHub Importer. Capabilities and limitations of GitHub Importer GitHub Importer imports the source code and commit history of a repository.",
    "sections": [
      {
        "header": "",
        "content": "If your source code is stored on another Git-based hosting service, you can move the code to GitHub.com using GitHub Importer.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 126
        }
      },
      {
        "header": "About GitHub Importer",
        "content": "GitHub Importer is a tool that quickly imports Git repositories from other hosting services to GitHub.com.\n\nTo get started with GitHub Importer, see Importing a repository with GitHub Importer.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 193
        }
      },
      {
        "header": "Capabilities and limitations of GitHub Importer",
        "content": "• GitHub Importer imports the source code and commit history of a repository. It does not import other associated data from the hosting service, such as issues and pull requests.\n• GitHub Importer is only available on GitHub.com.\n• During an import, you can authenticate with your remote repository. The repository must be accessible from the public internet. If the repository is hosted on a private network, GitHub Importer won't be able to access it.\n• GitHub Importer does not support repositories that use version control systems other than Git, such as Mercurial, Subversion, or Team Foundation Version Control (TFVC). For more information about alternatives to GitHub Importer, see About source code imports using the command line.\n• Repositories and individual files on GitHub are subject to size limits. For more information, see About large files on GitHub.\n• GitHub Importer does not move Git Large File Storage (LFS) objects from the source repository to the target repository. If you use Git LFS, you will need to either convert the Git LFS objects to regular files tracked by Git before running the migration, or move the Git LFS objects to the new repository separately after running the migration.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 1213
        }
      },
      {
        "header": "Further reading",
        "content": "• Importing an external Git repository using the command line",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 61
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/importing-your-projects-to-github/importing-source-code-to-github/updating-commit-author-attribution-with-github-importer",
    "doc_type": "git",
    "total_sections": 4
  },
  {
    "title": "Basic writing and formatting syntax",
    "summary": "Basic writing and formatting syntaxCreate sophisticated formatting for your prose and code on GitHub with simple syntax.Who can use this feature?Markdown can be used in the GitHub web interface.In this articleHeadings To create a heading, add one to six # symbols before your heading text. The number of # you use will determine the hierarchy level and typeface size of the heading. # A first-level heading ## A second-level heading ### A third-level heading When you use two or more headings, GitHub",
    "sections": [
      {
        "header": "",
        "content": "Create sophisticated formatting for your prose and code on GitHub with simple syntax.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 85
        }
      },
      {
        "header": "Who can use this feature?",
        "content": "Markdown can be used in the GitHub web interface.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 49
        }
      },
      {
        "header": "Headings",
        "content": "To create a heading, add one to six # symbols before your heading text. The number of # you use will determine the hierarchy level and typeface size of the heading.\n\nWhen you use two or more headings, GitHub automatically generates a table of contents that you can access by clicking within the file header. Each heading title is listed in the table of contents and you can click a title to navigate to the selected section.",
        "code_examples": [
          "```bash\n# A first-level heading## A second-level heading### A third-level heading\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 424
        }
      },
      {
        "header": "Styling text",
        "content": "You can indicate emphasis with bold, italic, strikethrough, subscript, or superscript text in comment fields and .md files.\n\nStyle | Syntax | Keyboard shortcut | Example | Output\n--- | --- | --- | --- | ---\nBold | ** ** or __ __ | Command+B (Mac) or Ctrl+B (Windows/Linux) | **This is bold text** | This is bold text\nItalic | * * or _ _ | Command+I (Mac) or Ctrl+I (Windows/Linux) | _This text is italicized_ | This text is italicized\nStrikethrough | ~~ ~~ or ~ ~ | None | ~~This was mistaken text~~ | This was mistaken text\nBold and nested italic | ** ** and _ _ | None | **This text is _extremely_ important** | This text is extremely important\nAll bold and italic | *** *** | None | ***All this text is important*** | All this text is important\nSubscript | <sub> </sub> | None | This is a <sub>subscript</sub> text | This is a subscript text\nSuperscript | <sup> </sup> | None | This is a <sup>superscript</sup> text | This is a superscript text\nUnderline | <ins> </ins> | None | This is an <ins>underlined</ins> text | This is an underlined text",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 1,
          "content_length": 1048
        }
      },
      {
        "header": "Quoting text",
        "content": "You can quote text with a >.\n\nQuoted text is indented with a vertical line on the left and displayed using gray type.\n\nWhen viewing a conversation, you can automatically quote text in a comment by highlighting the text, then typing R. You can quote an entire comment by clicking , then Quote reply. For more information about keyboard shortcuts, see Keyboard shortcuts.\n\n[Alert] Note When viewing a conversation, you can automatically quote text in a comment by highlighting the text, then typing R. You can quote an entire comment by clicking , then Quote reply. For more information about keyboard shortcuts, see Keyboard shortcuts.",
        "code_examples": [
          "```bash\nText that is not a quote> Text that is a quote\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 634
        }
      },
      {
        "header": "Quoting code",
        "content": "You can call out code or a command within a sentence with single backticks. The text within the backticks will not be formatted. You can also press the Command+E (Mac) or Ctrl+E (Windows/Linux) keyboard shortcut to insert the backticks for a code block within a line of Markdown.\n\nTo format code or text into its own distinct block, use triple backticks.\n\nFor more information, see Creating and highlighting code blocks.\n\nIf you are frequently editing code snippets and tables, you may benefit from enabling a fixed-width font in all comment fields on GitHub. For more information, see About writing and formatting on GitHub.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nUse`git status`to list all new or modified files that haven't yet been committed.\n```",
          "```bash\nSome basic Git commands are:```\ngit status\ngit add\ngit commit\n```\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 625
        }
      },
      {
        "header": "Supported color models",
        "content": "In issues, pull requests, and discussions, you can call out colors within a sentence by using backticks. A supported color model within backticks will display a visualization of the color.\n\nHere are the currently supported color models.\n\n• A supported color model cannot have any leading or trailing spaces within the backticks.\n• The visualization of the color is only supported in issues, pull requests, and discussions.\n\nColor | Syntax | Example | Output\n--- | --- | --- | ---\nHEX | `#RRGGBB` | `#0969DA` | \nRGB | `rgb(R,G,B)` | `rgb(9, 105, 218)` | \nHSL | `hsl(H,S,L)` | `hsl(212, 92%, 45%)` | \n\n[Alert] Note A supported color model cannot have any leading or trailing spaces within the backticks. The visualization of the color is only supported in issues, pull requests, and discussions.",
        "code_examples": [
          "```bash\nThe background color is`#ffffff`for light mode and`#000000`for dark mode.\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 2,
          "content_length": 793
        }
      },
      {
        "header": "Links",
        "content": "You can create an inline link by wrapping link text in brackets [ ], and then wrapping the URL in parentheses ( ). You can also use the keyboard shortcut Command+K to create a link. When you have text selected, you can paste a URL from your clipboard to automatically create a link from the selection.\n\nYou can also create a Markdown hyperlink by highlighting the text and using the keyboard shortcut Command+V. If you'd like to replace the text with the link, use the keyboard shortcut Command+Shift+V.\n\nThis site was built using [GitHub Pages](https://pages.github.com/).\n\nGitHub automatically creates links when valid URLs are written in a comment. For more information, see Autolinked references and URLs.\n\n[Alert] Note GitHub automatically creates links when valid URLs are written in a comment. For more information, see Autolinked references and URLs.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 858
        }
      },
      {
        "header": "Section links",
        "content": "You can link directly to any section that has a heading. To view the automatically generated anchor in a rendered file, hover over the section heading to expose the icon and click the icon to display the anchor in your browser.\n\nIf you need to determine the anchor for a heading in a file you are editing, you can use the following basic rules:\n\nFor more detailed information on the requirements of URI fragments, see RFC 3986: Uniform Resource Identifier (URI): Generic Syntax, Section 3.5.\n\nThe code block below demonstrates the basic rules used to generate anchors from headings in rendered content.\n\nIf you edit a heading, or if you change the order of headings with \"identical\" anchors, you will also need to update any links to those headings as the anchors will change.\n\n• Letters are converted to lower-case.\n• Spaces are replaced by hyphens (-). Any other whitespace or punctuation characters are removed.\n• Leading and trailing whitespace are removed.\n• Markup formatting is removed, leaving only the contents (for example, _italics_ becomes italics).\n• If the automatically generated anchor for a heading is identical to an earlier anchor in the same document, a unique identifier is generated by appending a hyphen and an auto-incrementing integer.\n\n[Alert] Note If you edit a heading, or if you change the order of headings with \"identical\" anchors, you will also need to update any links to those headings as the anchors will change.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# Example headings## Sample Section## This'll be a_Helpful_Section About the Greek Letter Θ!A heading containing characters not allowed in fragments, UTF-8 characters, two consecutive spaces between the first and second words, and formatting.## This heading is not unique in the fileTEXT 1## This heading is not unique in the fileTEXT 2# Links to the example headings aboveLink to the sample section: [Link Text](#sample-section).\n\nLink to the helpful section: [Link Text](#thisll-be-a-helpful-section-about-the-greek-letter-Θ).\n\nLink to the first non-unique section: [Link Text](#this-heading-is-not-unique-in-the-file).\n\nLink to the second non-unique section: [Link Text](#this-heading-is-not-unique-in-the-file-1).\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1447
        }
      },
      {
        "header": "Relative links",
        "content": "You can define relative links and image paths in your rendered files to help readers navigate to other files in your repository.\n\nA relative link is a link that is relative to the current file. For example, if you have a README file in root of your repository, and you have another file in docs/CONTRIBUTING.md, the relative link to CONTRIBUTING.md in your README might look like this:\n\nGitHub will automatically transform your relative link or image path based on whatever branch you're currently on, so that the link or path always works. The path of the link will be relative to the current file. Links starting with / will be relative to the repository root. You can use all relative link operands, such as ./ and ../.\n\nYour link text should be on a single line. The example below will not work.\n\nRelative links are easier for users who clone your repository. Absolute links may not work in clones of your repository - we recommend using relative links to refer to other files within your repository.",
        "code_examples": [
          "```bash\n[Contribution guidelines for this project](docs/CONTRIBUTING.md)\n```",
          "```bash\n[Contribution\nguidelines for this project](docs/CONTRIBUTING.md)\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1004
        }
      },
      {
        "header": "Custom anchors",
        "content": "You can use standard HTML anchor tags (<a name=\"unique-anchor-name\"></a>) to create navigation anchor points for any location in the document. To avoid ambiguous references, use a unique naming scheme for anchor tags, such as adding a prefix to the name attribute value.\n\nCustom anchors will not be included in the document outline/Table of Contents.\n\nYou can link to a custom anchor using the value of the name attribute you gave the anchor. The syntax is exactly the same as when you link to an anchor that is automatically generated for a heading.\n\nCustom anchors are not considered by the automatic naming and numbering behavior of automatic heading links.\n\n[Alert] Note Custom anchors will not be included in the document outline/Table of Contents.\n\n[Alert] Tip Custom anchors are not considered by the automatic naming and numbering behavior of automatic heading links.",
        "code_examples": [
          "```bash\n# Section HeadingSome body text of this section.<aname=\"my-custom-anchor-point\"></a>Some text I want to provide a direct link to, but which doesn't have its own heading.\n\n(… more content…)\n\n[A link to that custom anchor](#my-custom-anchor-point)\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 875
        }
      },
      {
        "header": "Line breaks",
        "content": "If you're writing in issues, pull requests, or discussions in a repository, GitHub will render a line break automatically:\n\nHowever, if you are writing in an .md file, the example above would render on one line without a line break. To create a line break in an .md file, you will need to include one of the following:\n\nInclude two spaces at the end of the first line.\n\nInclude a backslash at the end of the first line.\n\nInclude an HTML single line break tag at the end of the first line.\n\nIf you leave a blank line between two lines, both .md files and Markdown in issues, pull requests, and discussions will render the two lines separated by the blank line:\n\n• Include two spaces at the end of the first line. This example Will span two lines\n• Include a backslash at the end of the first line. This example\\ Will span two lines\n• Include an HTML single line break tag at the end of the first line. This example<br/> Will span two lines",
        "code_examples": [
          "```bash\nThis example\nWill span two lines\n```",
          "```bash\nThis example  \nWill span two lines\n```",
          "```bash\nThis example\\\nWill span two lines\n```",
          "```bash\nThis example<br/>Will span two lines\n```",
          "```bash\nThis example\n\nWill have a blank line separating both lines\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 938
        }
      },
      {
        "header": "Images",
        "content": "You can display an image by adding ! and wrapping the alt text in [ ]. Alt text is a short text equivalent of the information in the image. Then, wrap the link for the image in parentheses ().\n\n![Screenshot of a comment on a GitHub issue showing an image, added in the Markdown, of an Octocat smiling and raising a tentacle.](https://myoctocat.com/assets/images/base-octocat.svg)\n\nGitHub supports embedding images into your issues, pull requests, discussions, comments and .md files. You can display an image from your repository, add a link to an online image, or upload an image. For more information, see Uploading assets.\n\nWhen you want to display an image that is in your repository, use relative links instead of absolute links.\n\nHere are some examples for using relative links to display an image.\n\nThe last two relative links in the table above will work for images in a private repository only if the viewer has at least read access to the private repository that contains these images.\n\nFor more information, see Relative Links.\n\nContext | Relative Link\n--- | ---\nIn a .md file on the same branch | /assets/images/electrocat.png\nIn a .md file on another branch | /../main/assets/images/electrocat.png\nIn issues, pull requests and comments of the repository | ../blob/main/assets/images/electrocat.png?raw=true\nIn a .md file in another repository | /../../../../github/docs/blob/main/assets/images/electrocat.png\nIn issues, pull requests and comments of another repository | ../../../github/docs/blob/main/assets/images/electrocat.png?raw=true\n\n[Alert] Note When you want to display an image that is in your repository, use relative links instead of absolute links.\n\n[Alert] Note The last two relative links in the table above will work for images in a private repository only if the viewer has at least read access to the private repository that contains these images.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 7,
          "content_length": 1878
        }
      },
      {
        "header": "The Picture element",
        "content": "The <picture> HTML element is supported.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 40
        }
      },
      {
        "header": "Lists",
        "content": "You can make an unordered list by preceding one or more lines of text with -, *, or +.\n\nTo order your list, precede each line with a number.",
        "code_examples": [
          "```bash\n-George Washington*John Adams+Thomas Jefferson\n```",
          "```bash\n1.James Madison2.James Monroe3.John Quincy Adams\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 140
        }
      },
      {
        "header": "Nested Lists",
        "content": "You can create a nested list by indenting one or more list items below another item.\n\nTo create a nested list using the web editor on GitHub or a text editor that uses a monospaced font, like Visual Studio Code, you can align your list visually. Type space characters in front of your nested list item until the list marker character (- or *) lies directly below the first character of the text in the item above it.\n\nIn the web-based editor, you can indent or dedent one or more lines of text by first highlighting the desired lines and then using Tab or Shift+Tab respectively.\n\nTo create a nested list in the comment editor on GitHub, which doesn't use a monospaced font, you can look at the list item immediately above the nested list and count the number of characters that appear before the content of the item. Then type that number of space characters in front of the nested list item.\n\nIn this example, you could add a nested list item under the list item 100. First list item by indenting the nested list item a minimum of five spaces, since there are five characters (100. ) before First list item.\n\nYou can create multiple levels of nested lists using the same method. For example, because the first nested list item has seven characters (␣␣␣␣␣-␣) before the nested list content First nested list item, you would need to indent the second nested list item by at least two more characters (nine spaces minimum).\n\nFor more examples, see the GitHub Flavored Markdown Spec.\n\n[Alert] Note In the web-based editor, you can indent or dedent one or more lines of text by first highlighting the desired lines and then using Tab or Shift+Tab respectively.",
        "code_examples": [
          "```bash\n1.First list item-First nested list item-Second nested list item\n```",
          "```bash\n100.First list item-First nested list item\n```",
          "```bash\n100.First list item-First nested list item-Second nested list item\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1657
        }
      },
      {
        "header": "Task lists",
        "content": "To create a task list, preface list items with a hyphen and space followed by [ ]. To mark a task as complete, use [x].\n\nIf a task list item description begins with a parenthesis, you'll need to escape it with \\:\n\n- [ ] \\(Optional) Open a followup issue\n\nFor more information, see About tasklists.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n-[x] #739-[ ] https://github.com/octo-org/octo-repo/issues/740-[ ] Add delight to the experience when all tasks are complete :tada:\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 297
        }
      },
      {
        "header": "Mentioning people and teams",
        "content": "You can mention a person or team on GitHub by typing @ plus their username or team name. This will trigger a notification and bring their attention to the conversation. People will also receive a notification if you edit a comment to mention their username or team name. For more information about notifications, see About notifications.\n\nA person will only be notified about a mention if the person has read access to the repository and, if the repository is owned by an organization, the person is a member of the organization.\n\n@github/support What do you think about these updates?\n\nWhen you mention a parent team, members of its child teams also receive notifications, simplifying communication with multiple groups of people. For more information, see About organization teams.\n\nTyping an @ symbol will bring up a list of people or teams on a project. The list filters as you type, so once you find the name of the person or team you are looking for, you can use the arrow keys to select it and press either tab or enter to complete the name. For teams, enter the @organization/team-name and all members of that team will get subscribed to the conversation.\n\nThe autocomplete results are restricted to repository collaborators and any other participants on the thread.\n\n[Alert] Note A person will only be notified about a mention if the person has read access to the repository and, if the repository is owned by an organization, the person is a member of the organization.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1479
        }
      },
      {
        "header": "Referencing issues and pull requests",
        "content": "You can bring up a list of suggested issues and pull requests within the repository by typing #. Type the issue or pull request number or title to filter the list, and then press either tab or enter to complete the highlighted result.\n\nFor more information, see Autolinked references and URLs.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 293
        }
      },
      {
        "header": "Referencing external resources",
        "content": "If custom autolink references are configured for a repository, then references to external resources, like a JIRA issue or Zendesk ticket, convert into shortened links. To know which autolinks are available in your repository, contact someone with admin permissions to the repository. For more information, see Configuring autolinks to reference external resources.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 365
        }
      },
      {
        "header": "Uploading assets",
        "content": "You can upload assets like images by dragging and dropping, selecting from a file browser, or pasting. You can upload assets to issues, pull requests, comments, and .md files in your repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 194
        }
      },
      {
        "header": "Using emojis",
        "content": "You can add emoji to your writing by typing :EMOJICODE:, a colon followed by the name of the emoji.\n\n@octocat :+1: This PR looks great - it's ready to merge! :shipit:\n\nTyping : will bring up a list of suggested emoji. The list will filter as you type, so once you find the emoji you're looking for, press Tab or Enter to complete the highlighted result.\n\nFor a full list of available emoji and codes, see the Emoji-Cheat-Sheet.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 427
        }
      },
      {
        "header": "Paragraphs",
        "content": "You can create a new paragraph by leaving a blank line between lines of text.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 77
        }
      },
      {
        "header": "Footnotes",
        "content": "You can add footnotes to your content by using this bracket syntax:\n\nThe footnote will render like this:\n\nThe position of a footnote in your Markdown does not influence where the footnote will be rendered. You can write a footnote right after your reference to the footnote, and the footnote will still render at the bottom of the Markdown. Footnotes are not supported in wikis.\n\n[Alert] Note The position of a footnote in your Markdown does not influence where the footnote will be rendered. You can write a footnote right after your reference to the footnote, and the footnote will still render at the bottom of the Markdown. Footnotes are not supported in wikis.",
        "code_examples": [
          "```bash\nHere is a simple footnote[^1].\n\nA footnote can also have multiple lines[^2].\n\n[^1]: My reference.\n[^2]: To add line breaks within a footnote, add 2 spaces to the end of a line.  \nThis is a second line.\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 665
        }
      },
      {
        "header": "Alerts",
        "content": "Alerts, also sometimes known as callouts or admonitions, are a Markdown extension based on the blockquote syntax that you can use to emphasize critical information. On GitHub, they are displayed with distinctive colors and icons to indicate the significance of the content.\n\nUse alerts only when they are crucial for user success and limit them to one or two per article to prevent overloading the reader. Additionally, you should avoid placing alerts consecutively. Alerts cannot be nested within other elements.\n\nTo add an alert, use a special blockquote line specifying the alert type, followed by the alert information in a standard blockquote. Five types of alerts are available:\n\nHere are the rendered alerts:",
        "code_examples": [
          "```bash\n> [!NOTE]> Useful information that users should know, even when skimming content.> [!TIP]> Helpful advice for doing things better or more easily.> [!IMPORTANT]> Key information users need to know to achieve their goal.> [!WARNING]> Urgent info that needs immediate user attention to avoid problems.> [!CAUTION]> Advises about risks or negative outcomes of certain actions.\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 715
        }
      },
      {
        "header": "Hiding content with comments",
        "content": "You can tell GitHub to hide content from the rendered Markdown by placing the content in an HTML comment.",
        "code_examples": [
          "```bash\n<!-- This content will not appear in the rendered Markdown -->\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 105
        }
      },
      {
        "header": "Ignoring Markdown formatting",
        "content": "You can tell GitHub to ignore (or escape) Markdown formatting by using \\ before the Markdown character.\n\nLet's rename \\*our-new-project\\* to \\*our-old-project\\*.\n\nFor more information on backslashes, see Daring Fireball's Markdown Syntax.\n\nThe Markdown formatting will not be ignored in the title of an issue or a pull request.\n\n[Alert] Note The Markdown formatting will not be ignored in the title of an issue or a pull request.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 429
        }
      },
      {
        "header": "Disabling Markdown rendering",
        "content": "When viewing a Markdown file, you can click Code at the top of the file to disable Markdown rendering and view the file's source instead.\n\nDisabling Markdown rendering enables you to use source view features, such as line linking, which is not possible when viewing rendered Markdown files.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 290
        }
      },
      {
        "header": "Further reading",
        "content": "• GitHub Flavored Markdown Spec\n• About writing and formatting on GitHub\n• Working with advanced formatting\n• Quickstart for writing on GitHub",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 142
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax",
    "doc_type": "git",
    "total_sections": 29
  },
  {
    "title": "Quickstart for writing on GitHub",
    "summary": "Quickstart for writing on GitHubLearn advanced formatting features by creating a README for your GitHub profile.Who can use this feature?Markdown can be used in the GitHub web interface.In this articleIntroduction Markdown is an easy-to-read, easy-to-write language for formatting plain text. You can use Markdown syntax, along with some additional HTML tags, to format your writing on GitHub, in places like repository READMEs and comments on pull requests and issues. In this guide, you'll learn so",
    "sections": [
      {
        "header": "",
        "content": "Learn advanced formatting features by creating a README for your GitHub profile.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 80
        }
      },
      {
        "header": "Who can use this feature?",
        "content": "Markdown can be used in the GitHub web interface.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 49
        }
      },
      {
        "header": "Introduction",
        "content": "Markdown is an easy-to-read, easy-to-write language for formatting plain text. You can use Markdown syntax, along with some additional HTML tags, to format your writing on GitHub, in places like repository READMEs and comments on pull requests and issues. In this guide, you'll learn some advanced formatting features by creating or editing a README for your GitHub profile.\n\nIf you're new to Markdown, you might want to start with Basic writing and formatting syntax or the Communicate using Markdown GitHub Skills course.\n\nIf you already have a profile README, you can follow this guide by adding some features to your existing README, or by creating a gist with a Markdown file called something like about-me.md. For more information, see Creating gists.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 757
        }
      },
      {
        "header": "Creating or editing your profile README",
        "content": "Your profile README lets you share information about yourself with the community on GitHub. The README is displayed at the top of your profile page.\n\nIf you don't already have a profile README, you can add one.\n\nIf you already have a profile README, you can edit it from your profile page.\n\nIn the upper-right corner of any page, click your profile picture, then click Your profile.\n\nClick the next to your profile README.\n\n• Create a repository with the same name as your GitHub username, initializing the repository with a README.md file. For more information, see Managing your profile README.\n• Edit the README.md file and delete the template text (beginning ### Hi there) that is automatically added when you create the file.\n\n• In the upper-right corner of any page, click your profile picture, then click Your profile.\n• Click the next to your profile README.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 866
        }
      },
      {
        "header": "Adding an image to suit your visitors",
        "content": "You can include images in your communication on GitHub. Here, you'll add a responsive image, such as a banner, to the top of your profile README.\n\nBy using the HTML <picture> element with the prefers-color-scheme media feature, you can add an image that changes depending on whether a visitor is using light or dark mode. For more information, see Managing your theme settings.\n\nCopy and paste the following markup into your README.md file.\n\nReplace the placeholders in the markup with the URLs of your chosen images. Alternatively, to try the feature first, you can copy the URLs from our example below.\n\nTo make the image accessible for visitors who are using a screen reader, replace YOUR-ALT-TEXT with a description of the image.\n\nTo check the image has rendered correctly, click the Preview tab.\n\nFor more information on using images in Markdown, see Basic writing and formatting syntax.\n\n• Copy and paste the following markup into your README.md file. <picture> <source media=\"(prefers-color-scheme: dark)\" srcset=\"YOUR-DARKMODE-IMAGE\"> <source media=\"(prefers-color-scheme: light)\" srcset=\"YOUR-LIGHTMODE-IMAGE\"> <img alt=\"YOUR-ALT-TEXT\" src=\"YOUR-DEFAULT-IMAGE\"> </picture>\n• Replace the placeholders in the markup with the URLs of your chosen images. Alternatively, to try the feature first, you can copy the URLs from our example below. Replace YOUR-DARKMODE-IMAGE with the URL of an image to display for visitors using dark mode. Replace YOUR-LIGHTMODE-IMAGE with the URL of an image to display for visitors using light mode. Replace YOUR-DEFAULT-IMAGE with the URL of an image to display in case neither of the other images can be matched, for example if the visitor is using a browser that does not support the prefers-color-scheme feature.\n• To make the image accessible for visitors who are using a screen reader, replace YOUR-ALT-TEXT with a description of the image.\n• To check the image has rendered correctly, click the Preview tab.\n\n• Replace YOUR-DARKMODE-IMAGE with the URL of an image to display for visitors using dark mode.\n• Replace YOUR-LIGHTMODE-IMAGE with the URL of an image to display for visitors using light mode.\n• Replace YOUR-DEFAULT-IMAGE with the URL of an image to display in case neither of the other images can be matched, for example if the visitor is using a browser that does not support the prefers-color-scheme feature.\n\n[Example] <picture> <source media=\"(prefers-color-scheme: dark)\" srcset=\"YOUR-DARKMODE-IMAGE\"> <source media=\"(prefers-color-scheme: light)\" srcset=\"YOUR-LIGHTMODE-IMAGE\"> <img alt=\"YOUR-ALT-TEXT\" src=\"YOUR-DEFAULT-IMAGE\"> </picture>",
        "code_examples": [
          "```bash\n<picture><sourcemedia=\"(prefers-color-scheme: dark)\"srcset=\"YOUR-DARKMODE-IMAGE\"><sourcemedia=\"(prefers-color-scheme: light)\"srcset=\"YOUR-LIGHTMODE-IMAGE\"><imgalt=\"YOUR-ALT-TEXT\"src=\"YOUR-DEFAULT-IMAGE\"></picture>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 2600
        }
      },
      {
        "header": "Adding a table",
        "content": "You can use Markdown tables to organize information. Here, you'll use a table to introduce yourself by ranking something, such as your most-used programming languages or frameworks, the things you're spending your time learning, or your favorite hobbies. When a table column contains numbers, it's useful to right-align the column by using the syntax --: below the header row.\n\nReturn to the Edit file tab.\n\nTo introduce yourself, two lines below the </picture> tag, add an ## About me header and a short paragraph about yourself, like the following.\n\nTwo lines below this paragraph, insert a table by copying and pasting the following markup.\n\nIn the column on the right, replace THING-TO-RANK with \"Languages,\" \"Hobbies,\" or anything else, and fill in the column with your list of things.\n\nTo check the table has rendered correctly, click the Preview tab.\n\nFor more information, see Organizing information with tables.\n\n• Return to the Edit file tab.\n• To introduce yourself, two lines below the </picture> tag, add an ## About me header and a short paragraph about yourself, like the following. ## About me Hi, I'm Mona. You might recognize me as GitHub's mascot.\n• Two lines below this paragraph, insert a table by copying and pasting the following markup. | Rank | THING-TO-RANK | |-----:|---------------| | 1| | | 2| | | 3| |\n• In the column on the right, replace THING-TO-RANK with \"Languages,\" \"Hobbies,\" or anything else, and fill in the column with your list of things.\n• To check the table has rendered correctly, click the Preview tab.\n\n[Example] | Rank | THING-TO-RANK | |-----:|---------------| | 1| | | 2| | | 3| |",
        "code_examples": [
          "```bash\n## About meHi, I'm Mona. You might recognize me as GitHub's mascot.\n```",
          "```bash\n| Rank | THING-TO-RANK |\n|-----:|---------------|\n|     1|               |\n|     2|               |\n|     3|               |\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1629
        }
      },
      {
        "header": "Adding a collapsed section",
        "content": "To keep your content tidy, you can use the <details> tag to create an expandable collapsed section.\n\nTo create a collapsed section for the table you created, wrap your table in <details> tags like in the following example.\n\nBetween the <summary> tags, replace THINGS-TO-RANK with whatever you ranked in your table.\n\nOptionally, to make the section display as open by default, add the open attribute to the <details> tag.\n\nTo check the collapsed section has rendered correctly, click the Preview tab.\n\n• To create a collapsed section for the table you created, wrap your table in <details> tags like in the following example. <details> <summary>My top THINGS-TO-RANK</summary> YOUR TABLE </details>\n• Between the <summary> tags, replace THINGS-TO-RANK with whatever you ranked in your table.\n• Optionally, to make the section display as open by default, add the open attribute to the <details> tag. <details open>\n• To check the collapsed section has rendered correctly, click the Preview tab.\n\n[Example] <details> <summary>My top THINGS-TO-RANK</summary> YOUR TABLE </details>",
        "code_examples": [
          "```bash\n<details><summary>My top THINGS-TO-RANK</summary>YOUR TABLE</details>\n```",
          "```bash\n<detailsopen>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1076
        }
      },
      {
        "header": "Adding a quote",
        "content": "Markdown has many other options for formatting your content. Here, you'll add a horizontal rule to divide your page and a blockquote to format your favorite quote.\n\nAt the bottom of your file, two lines below the </details> tag, add a horizontal rule by typing three or more dashes.\n\nBelow the --- line, add a quote by typing markup like the following.\n\nReplace QUOTE with a quote of your choice. Alternatively, copy the quote from our example below.\n\nTo check everything has rendered correctly, click the Preview tab.\n\n• At the bottom of your file, two lines below the </details> tag, add a horizontal rule by typing three or more dashes. ---\n• Below the --- line, add a quote by typing markup like the following. > QUOTE Replace QUOTE with a quote of your choice. Alternatively, copy the quote from our example below.\n• To check everything has rendered correctly, click the Preview tab.",
        "code_examples": [
          "```bash\n> QUOTE\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 888
        }
      },
      {
        "header": "Adding a comment",
        "content": "You can use HTML comment syntax to add a comment that will be hidden in the output. Here, you'll add a comment to remind yourself to update your README later.\n\nTwo lines below the ## About me header, insert a comment by using the following markup.\n\nReplace COMMENT with a \"to-do\" item you remind yourself to do something later (for example, to add more items to the table).\n\nTo check your comment is hidden in the output, click the Preview tab.\n\n• Two lines below the ## About me header, insert a comment by using the following markup. <!-- COMMENT --> Replace COMMENT with a \"to-do\" item you remind yourself to do something later (for example, to add more items to the table).\n• To check your comment is hidden in the output, click the Preview tab.",
        "code_examples": [
          "```bash\n<!-- COMMENT -->\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 749
        }
      },
      {
        "header": "Saving your work",
        "content": "When you're happy with your changes, save your profile README by clicking Commit changes.\n\nCommitting directly to the main branch will make your changes visible to any visitor on your profile. If you want to save your work but aren't ready to make it visible on your profile, you can select Create a new branch for this commit and start a pull request.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 352
        }
      },
      {
        "header": "Next steps",
        "content": "• Continue to learn about advanced formatting features. For example, see Creating diagrams and Creating and highlighting code blocks.\n• Use your new skills as you communicate across GitHub, in issues, pull requests, and discussions. For more information, see Communicating on GitHub.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 283
        }
      }
    ],
    "url": "https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/quickstart-for-writing-on-github",
    "doc_type": "git",
    "total_sections": 11
  },
  {
    "title": "Git Tutorial",
    "summary": "Learn Git [+: Git is a tool that helps you: save and manage different versions of your files and code. work with others, keep track of changes, and undo mistakes.",
    "sections": [
      {
        "header": "Learn Git",
        "content": "Tip: Sign in to track your progress - it's free.\n\n• save and manage different versions of your files and code.\n• work with others, keep track of changes, and undo mistakes.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 172
        }
      },
      {
        "header": "Where to use Git?",
        "content": "Git works on your computer, but you also use it with online services like GitHub, GitLab, or Bitbucket to share your work with others. These are called remote repositories.\n\nIn this tutorial, you'll learn how to use Git for your own projects and how to connect with remote repositories online.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 293
        }
      },
      {
        "header": "Learning by Examples",
        "content": "In this tutorial, we will show you Git commands like this:\n\n[Example] Example git --version git version 2.30.2.windows.1",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 120
        }
      },
      {
        "header": "Example",
        "content": "For new users, using the terminal view can seem a bit complicated.\n\nDon't worry! We will keep it really simple, and learning this way gives you a good grasp of how Git works.\n\nIn the code above, you can see commands (input) and output.\n\nLines like this are commands we input:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit --version\ngit version 2.30.2.windows.1\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 275
        }
      },
      {
        "header": "Example",
        "content": "Lines like this are the output/response to our commands:\n\n[Example] Example git version 2.30.2.windows.1",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit --version\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 104
        }
      },
      {
        "header": "Example",
        "content": "In general, lines with $ in front of it is input.\n\nThese are the commands you can copy and run in your terminal.\n\nTip for Beginners: Don't worry about making mistakes!\n\nWhen you use Git on your own computer, you can't really break anything important.\n\nExperimenting is a great way to learn, and you can always undo or redo changes as you go.\n\n[Info] Tip for Beginners: Don't worry about making mistakes! When you use Git on your own computer, you can't really break anything important. Experimenting is a great way to learn, and you can always undo or redo changes as you go.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit version 2.30.2.windows.1\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 575
        }
      },
      {
        "header": "What Changes When You Switch Platform?",
        "content": "The tutorial can show examples for GitHub, GitLab, or Bitbucket.\n\nThe Git commands are mostly the same, but some steps (like connecting to a remote or pushing code) might look a little different depending on the platform you choose.\n\nUse the menu to see examples for each platform.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 281
        }
      },
      {
        "header": "Why Practice with Exercises?",
        "content": "Practicing with exercises helps you remember the commands and understand how Git works.\n\nTry the exercises and quiz to test your knowledge!",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 139
        }
      },
      {
        "header": "Git Quiz",
        "content": "Test your Git skills with a quiz.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 33
        }
      },
      {
        "header": "Track Your Progress",
        "content": "Note: This is an optional feature. You can study at W3Schools without creating an account.\n\n• View your completed tutorials, exercises, and quizzes\n• Keep an eye on your progress and daily streaks\n• Set goals and create learning paths\n• Create your own personal website",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 269
        }
      }
    ],
    "url": "https://www.w3schools.com/git/default.asp",
    "doc_type": "git",
    "total_sections": 10
  },
  {
    "title": "Git and {{title}} Introduction",
    "summary": "It was created by Linus Torvalds in 2005, and has been maintained by Junio Hamano since then.\n\nNote: Most Git actions (like staging, committing, and viewing history) happen on your own computer. Only Push and Pull interact with remote servers like GitHub, GitLab, or Bitbucket to upload or download changes.",
    "sections": [
      {
        "header": "What is Git?",
        "content": "Git is a popular version control system.\n\nIt was created by Linus Torvalds in 2005, and has been maintained by Junio Hamano since then.\n\n• Tracking code changes\n• Tracking who made changes\n• Coding collaboration",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 211
        }
      },
      {
        "header": "Key Git Concepts",
        "content": "• Repository: A folder where Git tracks your project and its history.\n• Clone: Make a copy of a remote repository on your computer.\n• Stage: Tell Git which changes you want to save next.\n• Commit: Save a snapshot of your staged changes.\n• Branch: Work on different versions or features at the same time.\n• Merge: Combine changes from different branches.\n• Pull: Get the latest changes from a remote repository.\n• Push: Send your changes to a remote repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 460
        }
      },
      {
        "header": "Working with Git",
        "content": "• Initialize Git on a folder, making it a Repository\n• Git now creates a hidden folder to keep track of changes in that folder\n• When a file is changed, added or deleted, it is considered modified\n• You select the modified files you want to Stage\n• The Staged files are Committed, which prompts Git to store a permanent snapshot of the files\n• Git allows you to see the full history of every commit.\n• You can revert back to any previous commit.\n• Git does not store a separate copy of every file in every commit, but keeps track of changes made in each commit!",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 561
        }
      },
      {
        "header": "Why Git?",
        "content": "Note: Most Git actions (like staging, committing, and viewing history) happen on your own computer.\n\nOnly Push and Pull interact with remote servers like GitHub, GitLab, or Bitbucket to upload or download changes.\n\n• Over 70% of developers use Git!\n• Developers can work together from anywhere in the world.\n• Developers can see the full history of the project.\n• Developers can revert to earlier versions of a project.\n\n[Info] Note: Most Git actions (like staging, committing, and viewing history) happen on your own computer. Only Push and Pull interact with remote servers like GitHub, GitLab, or Bitbucket to upload or download changes.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 640
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_intro.asp",
    "doc_type": "git",
    "total_sections": 4
  },
  {
    "title": "Git Install",
    "summary": "After installation, you will be able to use Git from your terminal or command prompt.\n\nTip for Beginners: Installing Git is safe and you can always uninstall it later if you want.",
    "sections": [
      {
        "header": "How to Install Git",
        "content": "You can download Git for free from git-scm.com.\n\nAfter installation, you will be able to use Git from your terminal or command prompt.\n\nTip for Beginners: Installing Git is safe and you can always uninstall it later if you want.\n\n• Windows: Download and run the installer.Click âNextâ to accept the recommended settings.This will install Git and Git Bash.\n• macOS: If you use Homebrew, open Terminal and type brew install git.Or, download the .dmg file and drag Git to your Applications folder.\n• Linux: Open your terminal and use your package manager.For example, on Ubuntu: sudo apt-get install git\n\n[Info] Tip for Beginners: Installing Git is safe and you can always uninstall it later if you want.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 705
        }
      },
      {
        "header": "Git Bash",
        "content": "Git Bash is a terminal for Windows that lets you use Git commands.\n\nLook at our Bash Tutorial to learn more about Bash.\n\nAfter installing Git, you can find Git Bash in your Start menu.\n\nYou can use Git Bash just like the Command Prompt, but with extra Unix commands (like ls and pwd).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 284
        }
      },
      {
        "header": "Example: Open Git Bash",
        "content": "Click Start, type \"Git Bash\", and open the app.\n\n[Example] Example: First Command in Git Bash ls Desktop Documents Downloads Pictures This command lists the files in your current folder.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 186
        }
      },
      {
        "header": "Example: First Command in Git Bash",
        "content": "This command lists the files in your current folder.",
        "code_examples": [
          "```bash\nls\nDesktop  Documents  Downloads  Pictures\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 52
        }
      },
      {
        "header": "Verifying Your Installation",
        "content": "After installing, check that Git works by opening your terminal (or Git Bash on Windows) and running:\n\n[Example] Example: Check Git Version git --version git version 2.43.0.windows.1",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 182
        }
      },
      {
        "header": "Example: Check Git Version",
        "content": "If Git is installed, you will see something like git version X.Y.Z\n\nIf you see an error, try closing and reopening your terminal, or check that Git is in your PATH.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit --version\ngit version 2.43.0.windows.1\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 164
        }
      },
      {
        "header": "Default Editor",
        "content": "During installation, Git asks you to pick a default text editor.\n\nThis is the program that will open when you need to write messages (like for commits).\n\n[Example] Example: Set VS Code as Default Editor git config --global core.editor \"code --wait\"",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 248
        }
      },
      {
        "header": "Example: Set VS Code as Default Editor",
        "content": "If you're not sure, just pick the default (Notepad on Windows). You can always change this later.\n\n[Example] Example: Set Notepad as Default Editor git config --global core.editor \"notepad\"",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit config --global core.editor \"code --wait\"\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 189
        }
      },
      {
        "header": "PATH Environment",
        "content": "Choosing to add Git to your PATH means you can use Git commands in any terminal window.\n\nThis is highly recommended for most users to do this during installation.\n\nIf you skip this, you'll only be able to use Git in Git Bash (on Windows) or Terminal (on macOS and Linux).\n\n[Example] Example: Check if Git is in PATH git --version git version 2.43.0.windows.1",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 358
        }
      },
      {
        "header": "Example: Check if Git is in PATH",
        "content": "If you see an error, you need to add Git to your PATH.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit --version\ngit version 2.43.0.windows.1\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 54
        }
      },
      {
        "header": "How to Add Git to PATH after Installation",
        "content": "After adding Git to your PATH, open a new terminal window and run git --version to check that it works everywhere.\n\n• Windows: If you missed the option during installation, search for \"Environment Variables\" in the Start menu and open it. Click \"Environment Variables...\" and find the \"Path\" variable under \"System variables\". Click \"Edit\", then \"New\", and add the path to your Git bin and cmd folders (e.g., C:\\Program Files\\Git\\bin and C:\\Program Files\\Git\\cmd). Click OK to save. Restart your terminal.\n• macOS: If you installed with Homebrew, your PATH is usually set automatically. If not, open Terminal and add this line to your ~/.zshrc or ~/.bash_profile: export PATH=\"/usr/local/bin:$PATH\" Save the file and run source ~/.zshrc or source ~/.bash_profile.\n• Linux: Most package managers add Git to PATH automatically. If not, add this line to your ~/.bashrc or ~/.profile: export PATH=\"/usr/bin:$PATH\" Save the file and run source ~/.bashrc or source ~/.profile.\n\n• If you missed the option during installation, search for \"Environment Variables\" in the Start menu and open it.\n• Click \"Environment Variables...\" and find the \"Path\" variable under \"System variables\".\n• Click \"Edit\", then \"New\", and add the path to your Git bin and cmd folders (e.g., C:\\Program Files\\Git\\bin and C:\\Program Files\\Git\\cmd).\n• Click OK to save. Restart your terminal.\n\n• If you installed with Homebrew, your PATH is usually set automatically.\n• If not, open Terminal and add this line to your ~/.zshrc or ~/.bash_profile:\n• export PATH=\"/usr/local/bin:$PATH\"\n• Save the file and run source ~/.zshrc or source ~/.bash_profile.\n\n• Most package managers add Git to PATH automatically.\n• If not, add this line to your ~/.bashrc or ~/.profile:\n• export PATH=\"/usr/bin:$PATH\"\n• Save the file and run source ~/.bashrc or source ~/.profile.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nexport PATH=\"/usr/local/bin:$PATH\"\n```",
          "```bash\nexport PATH=\"/usr/bin:$PATH\"\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 1823
        }
      },
      {
        "header": "Line Endings",
        "content": "Git can convert line endings in text files.\n\nOn Windows, it's usually best to select \"Checkout Windows-style, commit Unix-style line endings\".\n\nThis helps prevent problems when you share code with people using different operating systems.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 238
        }
      },
      {
        "header": "Updating or Uninstalling Git",
        "content": "• Update: Download and run the latest installer, or use your package manager (e.g., brew upgrade git or sudo apt-get upgrade git). It's a good idea to keep Git up to date for the latest features and security fixes.\n• Uninstall: Use \"Add or Remove Programs\" on Windows, or your package manager on Mac/Linux.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 306
        }
      },
      {
        "header": "Troubleshooting Git Installation",
        "content": "If you run into problems installing or running Git, don't worry!\n\nHere are solutions to some of the most common issues.\n\nTip: If something doesn't work right away, try closing and reopening your terminal, or restarting your computer.\n\n[Info] Tip: If something doesn't work right away, try closing and reopening your terminal, or restarting your computer.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 354
        }
      },
      {
        "header": "Common Installation Issues",
        "content": "• \"git is not recognized as an internal or external command\" Solution: Git is not in your system's PATH. Make sure you installed Git and restart your terminal. If needed, add Git's bin folder (usually C:\\Program Files\\Git\\bin) to your PATH. If it still doesn't work, try restarting your computer.\n• Permission errors (\"Permission denied\") Solution: On Windows, run Git Bash or your terminal as administrator. On macOS/Linux, use sudo if necessary.\n• SSL or HTTPS errors when cloning/pushing Solution: Check your internet connection. Make sure your Git version is up to date.\n• Wrong version of Git Solution: Check your installed version with git --version. Download the latest version from git-scm.com if needed.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 712
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_install.asp",
    "doc_type": "git",
    "total_sections": 15
  },
  {
    "title": "Git New Files",
    "summary": "A new file is a file that you have created or copied into your project folder, but haven't told Git to watch.",
    "sections": [
      {
        "header": "What is a New File?",
        "content": "A new file is a file that you have created or copied into your project folder, but haven't told Git to watch.\n\nHere are the key things to know:\n\n• Create a new file (with a text editor)\n• ls - List files in the folder\n• git status - Check which files are tracked\n• Understand untracked and tracked files",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 303
        }
      },
      {
        "header": "Create a New File",
        "content": "Your new Git repository is empty.\n\nLet's add a file using your favorite text editor, and save it in your project folder.\n\nIf you need help creating a file, see our HTML Editors page.\n\nFor this example, we'll use a simple HTML file:\n\n[Example] Example: Simple HTML File <!DOCTYPE html> <html><head><title>Hello World!</title> </head><body><h1>Hello world!</h1><p>This is the first file in my new Git Repo.</p> </body></html>",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 423
        }
      },
      {
        "header": "Example: Simple HTML File",
        "content": "Save this as index.html in your project folder.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 47
        }
      },
      {
        "header": "List Files in the Directory",
        "content": "To see which files are in your project folder, use the ls command:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 66
        }
      },
      {
        "header": "Example",
        "content": "ls lists all files in the current folder.\n\nYou should see index.html in the output.",
        "code_examples": [
          "```bash\nls\nindex.html\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 83
        }
      },
      {
        "header": "Check File Status with git status",
        "content": "Now check if Git is tracking your new file:\n\n[Example] Example git status On branch master No commits yet Untracked files: (use \"git add <file>...\" to include in what will be committed) index.html nothing added to commit but untracked files present (use \"git add\" to track)",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 273
        }
      },
      {
        "header": "Example",
        "content": "Git sees index.html, but it is untracked (not yet added to the repository).",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit status\nOn branch master\n\nNo commits yet\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n    index.html\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 75
        }
      },
      {
        "header": "What is an Untracked File?",
        "content": "An untracked file is any file in your project folder that Git is not yet tracking.\n\nThese are files you've created or copied into the folder, but haven't told Git to watch.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 172
        }
      },
      {
        "header": "What is a Tracked File?",
        "content": "A tracked file is a file that Git is watching for changes.\n\nTo make a file tracked, you need to add it to the staging area (covered in the next chapter).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 153
        }
      },
      {
        "header": "Troubleshooting",
        "content": "• File not showing up with ls: Make sure you saved it in the correct folder. Use pwd to check your current directory.\n• File not listed in git status: Make sure you are in the correct folder and that you saved the file.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 219
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_new_files.asp",
    "doc_type": "git",
    "total_sections": 10
  },
  {
    "title": "Git Staging Environment",
    "summary": "The staging environment (or staging area) is like a waiting room for your changes.\n\nYou use it to tell Git exactly which files you want to include in your next commit.",
    "sections": [
      {
        "header": "What is the Staging Environment?",
        "content": "The staging environment (or staging area) is like a waiting room for your changes.\n\nYou use it to tell Git exactly which files you want to include in your next commit.\n\nThis gives you control over what goes into your project history.\n\nHere are some key commands for staging:\n\n• git add <file> - Stage a file\n• git add --all or git add -A - Stage all changes\n• git status - See what is staged\n• git restore --staged <file> - Unstage a file",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 438
        }
      },
      {
        "header": "Stage a File with git add",
        "content": "To add a file to the staging area, use git add <file>:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 54
        }
      },
      {
        "header": "Example",
        "content": "Now index.html is staged. You can check what is staged with git status:\n\n[Example] Example git status On branch master No commits yet Changes to be committed: (use \"git restore --staged <file>...\" to unstage) new file: index.html",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit add index.html\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 229
        }
      },
      {
        "header": "Stage Multiple Files (git add --all, git add -A)",
        "content": "You can stage all changes (new, modified, and deleted files) at once:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 69
        }
      },
      {
        "header": "Example",
        "content": "git add -A does the same thing as git add --all.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit add --all\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 48
        }
      },
      {
        "header": "Check Staged Files with git status",
        "content": "See which files are staged and ready to commit:\n\n[Example] Example git status On branch master No commits yet Changes to be committed: (use \"git restore --staged <file>...\" to unstage) new file: README.md new file: bluestyle.css new file: index.html",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 249
        }
      },
      {
        "header": "How to Unstage a File",
        "content": "If you staged a file by mistake, you can remove it from the staging area (unstage it) with:\n\n[Example] Example git restore --staged index.html",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 142
        }
      },
      {
        "header": "Example",
        "content": "Now index.html is no longer staged. You can also use git reset HEAD index.html for the same effect.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit restore --staged index.html\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 99
        }
      },
      {
        "header": "Troubleshooting",
        "content": "• Staged the wrong file? Use git restore --staged <file> to unstage it.\n• Forgot to stage a file? Just run git add <file> again before you commit.\n• Not sure what's staged? Run git status to see what will be committed.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 218
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_staging_environment.asp",
    "doc_type": "git",
    "total_sections": 9
  },
  {
    "title": "Git Commit",
    "summary": "It records a snapshot of your files at a certain time, with a message describing what changed.",
    "sections": [
      {
        "header": "What is a Commit?",
        "content": "A commit is like a save point in your project.\n\nIt records a snapshot of your files at a certain time, with a message describing what changed.\n\nYou can always go back to a previous commit if you need to.\n\nHere are some key commands for commits:\n\n• git commit -m \"message\" - Commit staged changes with a message\n• git commit -a -m \"message\" - Commit all tracked changes (skip staging)\n• git log - See commit history",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 414
        }
      },
      {
        "header": "How to Commit with a Message (-m)",
        "content": "To save your staged changes, use git commit -m \"your message\":\n\n[Example] Example git commit -m \"First release of Hello World!\" [master (root-commit) 221ec6e] First release of Hello World! 3 files changed, 26 insertions(+) create mode 100644 README.md create mode 100644 bluestyle.css create mode 100644 index.html",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 314
        }
      },
      {
        "header": "Example",
        "content": "Always write a clear message so you and others can understand what changed.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit commit -m \"First release of Hello World!\"\n[master (root-commit) 221ec6e] First release of Hello World!\n 3 files changed, 26 insertions(+)\n create mode 100644 README.md\n create mode 100644 bluestyle.css\n create mode 100644 index.html\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 75
        }
      },
      {
        "header": "Commit All Changes Without Staging (-a)",
        "content": "You can skip the staging step for already tracked files with git commit -a -m \"message\".\n\nThis commits all modified and deleted files, but not new/untracked files.\n\n[Example] Example git commit -a -m \"Quick update to README\" [master 123abcd] Quick update to README 1 file changed, 2 insertions(+)",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 296
        }
      },
      {
        "header": "Example",
        "content": "Warning: Skipping the staging step can make you include unwanted changes. Use with care.\n\nNote: git commit -a does not work for new/untracked files. You must use git add <file> first for new files.\n\n[Warning] Warning: Skipping the staging step can make you include unwanted changes. Use with care. Note: git commit -a does not work for new/untracked files. You must use git add <file> first for new files.\n\n[Example] What happens if you try to commit a new file with -a? $ git commit -a -m \"Try to commit new file\" On branch master No commits yet Untracked files: (use \"git add ...\" to include in what will be committed) index.html nothing added to commit but untracked files present (use \"git add\" to track)",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit commit -a -m \"Quick update to README\"\n[master 123abcd] Quick update to README\n 1 file changed, 2 insertions(+)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 708
        }
      },
      {
        "header": "Write Multi-line Commit Messages",
        "content": "If you just type git commit (no -m), your default editor will open so you can write a detailed, multi-line message:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 115
        }
      },
      {
        "header": "Example",
        "content": "Write a short summary on the first line, leave a blank line, then add more details below.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit commit\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 89
        }
      },
      {
        "header": "Commit Message Best Practices:",
        "content": "• Keep the first line short (50 characters or less).\n• Use the imperative mood (e.g., \"Add feature\" not \"Added feature\").\n• Leave a blank line after the summary, then add more details if needed.\n• Describe why the change was made, not just what changed.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 253
        }
      },
      {
        "header": "Other Useful Commit Options",
        "content": "• Create an empty commit: git commit --allow-empty -m \"Start project\"\n• Use previous commit message (no editor): git commit --no-edit\n• Quickly add staged changes to last commit, keep message: git commit --amend --no-edit\n\n• Forgot to stage a file? If you run git commit -m \"message\" but forgot to git add a file, just add it and commit again. Or use git commit --amend to add it to your last commit.\n• Typo in your commit message? Use git commit --amend -m \"Corrected message\" to fix the last commit message.\n• Accidentally committed the wrong files? You can use git reset --soft HEAD~1 to undo the last commit and keep your changes staged.\n\n[Warning] Troubleshooting Common Commit Mistakes Forgot to stage a file? If you run git commit -m \"message\" but forgot to git add a file, just add it and commit again. Or use git commit --amend to add it to your last commit. Typo in your commit message? Use git commit --amend -m \"Corrected message\" to fix the last commit message. Accidentally committed the wrong files? You can use git reset --soft HEAD~1 to undo the last commit and keep your changes staged.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 1104
        }
      },
      {
        "header": "View Commit History (git log)",
        "content": "To view the history of commits for a repository, you can use the git log command:\n\n[Example] Example git log commit 09f4acd3f8836b7f6fc44ad9e012f82faf861803 (HEAD -> master) Author: w3schools-test <test@w3schools.com> Date: Fri Mar 26 09:35:54 2021 +0100 Updated index.html with a new line commit 221ec6e10aeedbfd02b85264087cd9adc18e4b26 Author: w3schools-test <test@w3schools.com> Date: Fri Mar 26 09:13:07 2021 +0100 First release of Hello World!",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 448
        }
      },
      {
        "header": "Example",
        "content": "For a shorter view, use git log --oneline:\n\n[Example] Example git log --oneline 09f4acd Updated index.html with a new line 221ec6e First release of Hello World!",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log\ncommit 09f4acd3f8836b7f6fc44ad9e012f82faf861803 (HEAD -> master)\nAuthor: w3schools-test <test@w3schools.com>\nDate:   Fri Mar 26 09:35:54 2021 +0100\n\n    Updated index.html with a new line\n\ncommit 221ec6e10aeedbfd02b85264087cd9adc18e4b26\nAuthor: w3schools-test <test@w3schools.com>\nDate:   Fri Mar 26 09:13:07 2021 +0100\n\n    First release of Hello World!\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 160
        }
      },
      {
        "header": "Example",
        "content": "To see which files changed in each commit, use git log --stat:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log --oneline\n09f4acd Updated index.html with a new line\n221ec6e First release of Hello World!\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 62
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_commit.asp",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Git Help",
    "summary": "If you forget how a command works or want to learn about its options, you can use Git's built-in help.",
    "sections": [
      {
        "header": "Why and When to Use Git Help?",
        "content": "Git has many commands and options.\n\nIf you forget how a command works or want to learn about its options, you can use Git's built-in help.\n\nThis is the fastest way to get answers without leaving your terminal.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 209
        }
      },
      {
        "header": "Key Commands for Getting Help",
        "content": "• git help <command> - See the manual page for a command\n• git <command> --help - See help for a command (same as above)\n• git <command> -h - See a quick summary of options\n• git help --all - List all possible Git commands\n• git help -g - List guides and concepts",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 263
        }
      },
      {
        "header": "See Help for a Specific Command (git help <command>)",
        "content": "Shows the full manual page for a specific command, including all options and examples:\n\n[Example] Example: See Help for Commit git help commit GIT-COMMIT(1) NAME git-commit - Record changes to the repository SYNOPSIS git commit [options] [--] <pathspec>... DESCRIPTION Stores the current contents of the index in a new commit together with a log message from the user describing the changes. ...",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 395
        }
      },
      {
        "header": "Example: See Help for Commit",
        "content": "This command opens the full documentation for git commit in your terminal.\n\n• Use the arrow keys or Space to scroll down, b to scroll up.\n• Type / followed by a word to search (e.g., /option), then n for next match.\n• Press q at any time to quit the help view.\n\n[Info] Tip: While viewing help pages: Use the arrow keys or Space to scroll down, b to scroll up. Type / followed by a word to search (e.g., /option), then n for next match. Press q at any time to quit the help view.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit help commit\nGIT-COMMIT(1)\nNAME\n    git-commit - Record changes to the repository\nSYNOPSIS\n    git commit [options] [--] <pathspec>...\nDESCRIPTION\n    Stores the current contents of the index in a new commit\n    together with a log message from the user describing the changes.\n...\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 478
        }
      },
      {
        "header": "See Help with --help (git <command> --help)",
        "content": "This does the same as git help <command>. Most users prefer this form:\n\n[Example] Example: See Help for Status git status --help GIT-STATUS(1) NAME git-status - Show the working tree status SYNOPSIS git status [options] [--] [pathspec...] DESCRIPTION Displays paths that have differences between the index file and the current HEAD commit. ...",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 343
        }
      },
      {
        "header": "Example: See Help for Status",
        "content": "This command opens the manual page for git status.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit status --help\nGIT-STATUS(1)\nNAME\n    git-status - Show the working tree status\nSYNOPSIS\n    git status [options] [--] [pathspec...]\nDESCRIPTION\n    Displays paths that have differences between the index file and the current HEAD commit.\n...\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 50
        }
      },
      {
        "header": "See a Quick Summary with -h (git <command> -h)",
        "content": "Shows a short summary of the command's options, right in the terminal window (does not open the full manual):\n\n[Example] Example: Quick Help for Add git add -h usage: git add [options] [--] <pathspec>... -n, --dry-run dry run -v, --verbose be verbose -i, --interactive interactive picking -p, --patch select hunks interactively -e, --edit edit current diff and apply -u, --update update tracked files -A, --all add changes from all tracked and untracked files ...",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 463
        }
      },
      {
        "header": "Example: Quick Help for Add",
        "content": "This command gives you a brief overview of available options for a command.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit add -h\nusage: git add [options] [--] <pathspec>...\n    -n, --dry-run         dry run\n    -v, --verbose        be verbose\n    -i, --interactive    interactive picking\n    -p, --patch          select hunks interactively\n    -e, --edit           edit current diff and apply\n    -u, --update         update tracked files\n    -A, --all            add changes from all tracked and untracked files\n...\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 75
        }
      },
      {
        "header": "List All Git Commands (git help --all)",
        "content": "Lists every Git command available on your system, grouped by category:\n\nWarning: This will display a very long list of commands\n\n[Warning] Warning: This will display a very long list of commands\n\n[Example] Example $ git help --all See 'git help <command>' to read about a specific subcommand Main Porcelain Commands add Add file contents to the index am Apply a series of patches from a mailbox archive Create an archive of files from a named tree bisect Use binary search to find the commit that introduced a bug branch List, create, or delete branches bundle Move objects and refs by archive checkout Switch branches or restore working tree files cherry-pick Apply the changes introduced by some existing commits citool Graphical alternative to git-commit clean Remove untracked files from the working tree clone Clone a repository into a new directory commit Record changes to the repository describe Give an object a human readable name based on an available ref diff Show changes between commits, commit and working tree, etc fetch Download objects and refs from another repository format-patch Prepare patches for e-mail submission gc Cleanup unnecessary files and optimize the local repository gitk The Git repository browser grep Print lines matching a pattern gui A portable graphical interface to Git init Create an empty Git repository or reinitialize an existing one log Show commit logs maintenance Run tasks to optimize Git repository data merge Join two or more development histories together mv Move or rename a file, a directory, or a symlink notes Add or inspect object notes pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects range-diff Compare two commit ranges (e.g. two versions of a branch) rebase Reapply commits on top of another base tip reset Reset current HEAD to the specified state restore Restore working tree files revert Revert some existing commits rm Remove files from the working tree and from the index shortlog Summarize 'git log' output show Show various types of objects sparse-checkout Initialize and modify the sparse-checkout stash Stash the changes in a dirty working directory away status Show the working tree status submodule Initialize, update or inspect submodules switch Switch branches tag Create, list, delete or verify a tag object signed with GPG worktree Manage multiple working trees Ancillary Commands / Manipulators config Get and set repository or global options fast-export Git data exporter fast-import Backend for fast Git data importers filter-branch Rewrite branches mergetool Run merge conflict resolution tools to resolve merge conflicts pack-refs Pack heads and tags for efficient repository access prune Prune all unreachable objects from the object database reflog Manage reflog information remote Manage set of tracked repositories repack Pack unpacked objects in a repository replace Create, list, delete refs to replace objects Ancillary Commands / Interrogators annotate Annotate file lines with commit information blame Show what revision and author last modified each line of a file bugreport Collect information for user to file a bug report count-objects Count unpacked number of objects and their disk consumption difftool Show changes using common diff tools fsck Verifies the connectivity and validity of the objects in the database gitweb Git web interface (web frontend to Git repositories) help Display help information about Git instaweb Instantly browse your working repository in gitweb merge-tree Show three-way merge without touching index rerere Reuse recorded resolution of conflicted merges show-branch Show branches and their commits verify-commit Check the GPG signature of commits verify-tag Check the GPG signature of tags whatchanged Show logs with difference each commit introduces Interacting with Others archimport Import a GNU Arch repository into Git cvsexportcommit Export a single commit to a CVS checkout cvsimport Salvage your data out of another SCM people love to hate cvsserver A CVS server emulator for Git imap-send Send a collection of patches from stdin to an IMAP folder p4 Import from and submit to Perforce repositories quiltimport Applies a quilt patchset onto the current branch request-pull Generates a summary of pending changes send-email Send a collection of patches as emails svn Bidirectional operation between a Subversion repository and Git Low-level Commands / Manipulators apply Apply a patch to files and/or to the index checkout-index Copy files from the index to the working tree commit-graph Write and verify Git commit-graph files commit-tree Create a new commit object hash-object Compute object ID and optionally creates a blob from a file index-pack Build pack index file for an existing packed archive merge-file Run a three-way file merge merge-index Run a merge for files needing merging mktag Creates a tag object mktree Build a tree-object from ls-tree formatted text multi-pack-index Write and verify multi-pack-indexes pack-objects Create a packed archive of objects prune-packed Remove extra objects that are already in pack files read-tree Reads tree information into the index symbolic-ref Read, modify and delete symbolic refs unpack-objects Unpack objects from a packed archive update-index Register file contents in the working tree to the index update-ref Update the object name stored in a ref safely write-tree Create a tree object from the current index Low-level Commands / Interrogators cat-file Provide content or type and size information for repository objects cherry Find commits yet to be applied to upstream diff-files Compares files in the working tree and the index diff-index Compare a tree to the working tree or index diff-tree Compares the content and mode of blobs found via two tree objects for-each-ref Output information on each ref for-each-repo Run a Git command on a list of repositories get-tar-commit-id Extract commit ID from an archive created using git-archive ls-files Show information about files in the index and the working tree ls-remote List references in a remote repository ls-tree List the contents of a tree object merge-base Find as good common ancestors as possible for a merge name-rev Find symbolic names for given revs pack-redundant Find redundant pack files rev-list Lists commit objects in reverse chronological order rev-parse Pick out and massage parameters show-index Show packed archive index show-ref List references in a local repository unpack-file Creates a temporary file with a blob's contents var Show a Git logical variable verify-pack Validate packed Git archive files Low-level Commands / Syncing Repositories daemon A really simple server for Git repositories fetch-pack Receive missing objects from another repository http-backend Server side implementation of Git over HTTP send-pack Push objects over Git protocol to another repository update-server-info Update auxiliary info file to help dumb servers Low-level Commands / Internal Helpers check-attr Display gitattributes information check-ignore Debug gitignore / exclude files check-mailmap Show canonical names and email addresses of contacts check-ref-format Ensures that a reference name is well formed column Display data in columns credential Retrieve and store user credentials credential-cache Helper to temporarily store passwords in memory credential-store Helper to store credentials on disk fmt-merge-msg Produce a merge commit message interpret-trailers Add or parse structured information in commit messages mailinfo Extracts patch and authorship from a single e-mail message mailsplit Simple UNIX mbox splitter program merge-one-file The standard helper program to use with git-merge-index patch-id Compute unique ID for a patch sh-i18n Git's i18n setup code for shell scripts sh-setup Common Git shell script setup code stripspace Remove unnecessary whitespace External commands askyesno credential-helper-selector flow lfs",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 7981
        }
      },
      {
        "header": "Example",
        "content": "Note: If you find yourself stuck in the list view, SHIFT + G to jump the end of the list, then q to exit the view.\n\n[Note] Note: If you find yourself stuck in the list view, SHIFT + G to jump the end of the list, then q to exit the view.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git help --all\nSee 'git help <command>' to read about a specific subcommand\n\nMain Porcelain Commands\n   add                  Add file contents to the index\n   am                   Apply a series of patches from a mailbox\n   archive              Create an archive of files from a named tree\n   bisect               Use binary search to find the commit that introduced a bug\n   branch               List, create, or delete branches\n   bundle               Move objects and refs by archive\n   checkout             Switch branches or restore working tree files\n   cherry-pick          Apply the changes introduced by some existing commits\n   citool               Graphical alternative to git-commit\n   clean                Remove untracked files from the working tree\n   clone                Clone a repository into a new directory\n   commit               Record changes to the repository\n   describe             Give an object a human readable name based on an available ref\n   diff                 Show changes between commits, commit and working tree, etc\n   fetch                Download objects and refs from another repository\n   format-patch         Prepare patches for e-mail submission\n   gc                   Cleanup unnecessary files and optimize the local repository\n   gitk                 The Git repository browser\n   grep                 Print lines matching a pattern\n   gui                  A portable graphical interface to Git\n   init                 Create an empty Git repository or reinitialize an existing one\n   log                  Show commit logs\n   maintenance          Run tasks to optimize Git repository data\n   merge                Join two or more development histories together\n   mv                   Move or rename a file, a directory, or a symlink\n   notes                Add or inspect object notes\n   pull                 Fetch from and integrate with another repository or a local branch\n   push                 Update remote refs along with associated objects\n   range-diff           Compare two commit ranges (e.g. two versions of a branch)\n   rebase               Reapply commits on top of another base tip\n   reset                Reset current HEAD to the specified state\n   restore              Restore working tree files\n   revert               Revert some existing commits\n   rm                   Remove files from the working tree and from the index\n   shortlog             Summarize 'git log' output\n   show                 Show various types of objects\n   sparse-checkout      Initialize and modify the sparse-checkout\n   stash                Stash the changes in a dirty working directory away\n   status               Show the working tree status\n   submodule            Initialize, update or inspect submodules\n   switch               Switch branches\n   tag                  Create, list, delete or verify a tag object signed with GPG\n   worktree             Manage multiple working trees\n\nAncillary Commands / Manipulators\n   config               Get and set repository or global options\n   fast-export          Git data exporter\n   fast-import          Backend for fast Git data importers\n   filter-branch        Rewrite branches\n   mergetool            Run merge conflict resolution tools to resolve merge conflicts\n   pack-refs            Pack heads and tags for efficient repository access\n   prune                Prune all unreachable objects from the object database\n   reflog               Manage reflog information\n   remote               Manage set of tracked repositories\n   repack               Pack unpacked objects in a repository\n   replace              Create, list, delete refs to replace objects\n\nAncillary Commands / Interrogators\n   annotate             Annotate file lines with commit information\n   blame                Show what revision and author last modified each line of a file\n   bugreport            Collect information for user to file a bug report\n   count-objects        Count unpacked number of objects and their disk consumption\n   difftool             Show changes using common diff tools\n   fsck                 Verifies the connectivity and validity of the objects in the database\n   gitweb               Git web interface (web frontend to Git repositories)\n   help                 Display help information about Git\n   instaweb             Instantly browse your working repository in gitweb\n   merge-tree           Show three-way merge without touching index\n   rerere               Reuse recorded resolution of conflicted merges\n   show-branch          Show branches and their commits\n   verify-commit        Check the GPG signature of commits\n   verify-tag           Check the GPG signature of tags\n   whatchanged          Show logs with difference each commit introduces\n\nInteracting with Others\n   archimport           Import a GNU Arch repository into Git\n   cvsexportcommit      Export a single commit to a CVS checkout\n   cvsimport            Salvage your data out of another SCM people love to hate\n   cvsserver            A CVS server emulator for Git\n   imap-send            Send a collection of patches from stdin to an IMAP folder\n   p4                   Import from and submit to Perforce repositories\n   quiltimport          Applies a quilt patchset onto the current branch\n   request-pull         Generates a summary of pending changes\n   send-email           Send a collection of patches as emails\n   svn                  Bidirectional operation between a Subversion repository and Git\n\nLow-level Commands / Manipulators\n   apply                Apply a patch to files and/or to the index\n   checkout-index       Copy files from the index to the working tree\n   commit-graph         Write and verify Git commit-graph files\n   commit-tree          Create a new commit object\n   hash-object          Compute object ID and optionally creates a blob from a file\n   index-pack           Build pack index file for an existing packed archive\n   merge-file           Run a three-way file merge\n   merge-index          Run a merge for files needing merging\n   mktag                Creates a tag object\n   mktree               Build a tree-object from ls-tree formatted text\n   multi-pack-index     Write and verify multi-pack-indexes\n   pack-objects         Create a packed archive of objects\n   prune-packed         Remove extra objects that are already in pack files\n   read-tree            Reads tree information into the index\n   symbolic-ref         Read, modify and delete symbolic refs\n   unpack-objects       Unpack objects from a packed archive\n   update-index         Register file contents in the working tree to the index\n   update-ref           Update the object name stored in a ref safely\n   write-tree           Create a tree object from the current index\n\nLow-level Commands / Interrogators\n   cat-file             Provide content or type and size information for repository objects\n   cherry               Find commits yet to be applied to upstream\n   diff-files           Compares files in the working tree and the index\n   diff-index           Compare a tree to the working tree or index\n   diff-tree            Compares the content and mode of blobs found via two tree objects\n   for-each-ref         Output information on each ref\n   for-each-repo        Run a Git command on a list of repositories\n   get-tar-commit-id    Extract commit ID from an archive created using git-archive\n   ls-files             Show information about files in the index and the working tree\n   ls-remote            List references in a remote repository\n   ls-tree              List the contents of a tree object\n   merge-base           Find as good common ancestors as possible for a merge\n   name-rev             Find symbolic names for given revs\n   pack-redundant       Find redundant pack files\n   rev-list             Lists commit objects in reverse chronological order\n   rev-parse            Pick out and massage parameters\n   show-index           Show packed archive index\n   show-ref             List references in a local repository\n   unpack-file          Creates a temporary file with a blob's contents\n   var                  Show a Git logical variable\n   verify-pack          Validate packed Git archive files\n\nLow-level Commands / Syncing Repositories\n   daemon               A really simple server for Git repositories\n   fetch-pack           Receive missing objects from another repository\n   http-backend         Server side implementation of Git over HTTP\n   send-pack            Push objects over Git protocol to another repository\n   update-server-info   Update auxiliary info file to help dumb servers\n\nLow-level Commands / Internal Helpers\n   check-attr           Display gitattributes information\n   check-ignore         Debug gitignore / exclude files\n   check-mailmap        Show canonical names and email addresses of contacts\n   check-ref-format     Ensures that a reference name is well formed\n   column               Display data in columns\n   credential           Retrieve and store user credentials\n   credential-cache     Helper to temporarily store passwords in memory\n   credential-store     Helper to store credentials on disk\n   fmt-merge-msg        Produce a merge commit message\n   interpret-trailers   Add or parse structured information in commit messages\n   mailinfo             Extracts patch and authorship from a single e-mail message\n   mailsplit            Simple UNIX mbox splitter program\n   merge-one-file       The standard helper program to use with git-merge-index\n   patch-id             Compute unique ID for a patch\n   sh-i18n              Git's i18n setup code for shell scripts\n   sh-setup             Common Git shell script setup code\n   stripspace           Remove unnecessary whitespace\n\nExternal commands\n   askyesno\n   credential-helper-selector\n   flow\n   lfs\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 237
        }
      },
      {
        "header": "List Guides and Concepts (git help -g)",
        "content": "Shows a list of guides and concept topics for deeper learning:\n\n[Example] Example: List Guides and Concepts git help -g The common Git guides are: attributes Defining attributes per path everyday Everyday Git With 20 Commands Or So glossary A Git glossary of terms revisions Specifying revisions and ranges for Git ...",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 318
        }
      },
      {
        "header": "Example: List Guides and Concepts",
        "content": "This command is great for learning about Git's advanced concepts and best practices.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit help -g\nThe common Git guides are:\n   attributes   Defining attributes per path\n   everyday     Everyday Git With 20 Commands Or So\n   glossary     A Git glossary of terms\n   revisions    Specifying revisions and ranges for Git\n...\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 84
        }
      },
      {
        "header": "Troubleshooting",
        "content": "• How do I quit the help viewer? Press q to exit the help page.\n• Help page won't open? Try git <command> -h for a quick summary instead.\n• How do I search for a word? In the help viewer, press / then type your search term and press Enter.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 239
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_help.asp",
    "doc_type": "git",
    "total_sections": 13
  },
  {
    "title": "Git Branch",
    "summary": "In Git, a branch is like a separate workspace where you can make changes and try new ideas without affecting the main project. Think of it as a \"parallel universe\" for your code.\n\nBranches let you work on different parts of a project, like new features or bug fixes, without interfering with the main branch.",
    "sections": [
      {
        "header": "What is a Git Branch?",
        "content": "In Git, a branch is like a separate workspace where you can make changes and try new ideas without affecting the main project. Think of it as a \"parallel universe\" for your code.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 178
        }
      },
      {
        "header": "Why Use Branches?",
        "content": "Branches let you work on different parts of a project, like new features or bug fixes, without interfering with the main branch.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 128
        }
      },
      {
        "header": "Common Reasons to Create a Branch",
        "content": "• Developing a new feature\n• Fixing a bug\n• Experimenting with ideas",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 68
        }
      },
      {
        "header": "Example: With and Without Git",
        "content": "Let's say you have a large project, and you need to update the design on it.\n\nHow would that work without and with Git:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 119
        }
      },
      {
        "header": "Without Git:",
        "content": "• Make copies of all the relevant files to avoid impacting the live version\n• Start working with the design and find that code depend on code in other files, that also need to be changed!\n• Make copies of the dependant files as well. Making sure that every file dependency references the correct file name\n• EMERGENCY! There is an unrelated error somewhere else in the project that needs to be fixed ASAP!\n• Save all your files, making a note of the names of the copies you were working on\n• Work on the unrelated error and update the code to fix it\n• Go back to the design, and finish the work there\n• Copy the code or rename the files, so the updated design is on the live version\n• (2 weeks later, you realize that the unrelated error was not fixed in the new design version because you copied the files before the fix)",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 822
        }
      },
      {
        "header": "With Git:",
        "content": "Branches allow you to work on different parts of a project without impacting the main branch.\n\nWhen the work is complete, a branch can be merged with the main project.\n\nYou can even switch between branches and work on different projects without them interfering with each other.\n\nBranching in Git is very lightweight and fast!\n\n• With a new branch called new-design, edit the code directly without impacting the main branch\n• EMERGENCY! There is an unrelated error somewhere else in the project that needs to be fixed ASAP!\n• Create a new branch from the main project called small-error-fix\n• Fix the unrelated error and merge the small-error-fix branch with the main branch\n• You go back to the new-design branch, and finish the work there\n• Merge the new-design branch with main (getting alerted to the small error fix that you were missing)",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 843
        }
      },
      {
        "header": "Creating a New Branch",
        "content": "Let's say you want to add a new feature. You can create a new branch for it.\n\nLet add some new features to our index.html page.\n\nWe are working in our local repository, and we do not want to disturb or possibly wreck the main project.\n\nSo we create a new branch:\n\n[Example] Example git branch hello-world-images",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 311
        }
      },
      {
        "header": "Example",
        "content": "Now we created a new branch called \"hello-world-images\"",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit branch hello-world-images\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 55
        }
      },
      {
        "header": "Listing All Branches",
        "content": "Let's confirm that we have created a new branch.\n\nTo see all branches in your repository, use:\n\n[Example] Example git branch hello-world-images * master",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 152
        }
      },
      {
        "header": "Example",
        "content": "We can see the new branch with the name \"hello-world-images\", but the * beside master specifies that we are currently on that branch.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit branch\n  hello-world-images\n* master\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 133
        }
      },
      {
        "header": "Switching Between Branches",
        "content": "checkout is the command used to check out a branch.\n\nMoving us from the current branch, to the one specified at the end of the command:\n\n[Example] Example git checkout hello-world-images Switched to branch 'hello-world-images'",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 226
        }
      },
      {
        "header": "Example",
        "content": "Now you can work in your new branch without affecting the main branch.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout hello-world-images\nSwitched to branch 'hello-world-images'\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 70
        }
      },
      {
        "header": "Working in a Branch",
        "content": "Now we have moved our current workspace from the master branch, to the new branch\n\nOpen your favourite editor and make some changes.\n\nFor this example, we added an image (img_hello_world.jpg) to the working folder and a line of code in the index.html file:\n\n[Example] Example <!DOCTYPE html><html><head><title>Hello World!</title><link rel=\"stylesheet\" href=\"bluestyle.css\"></head><body><h1>Hello world!</h1><div><img src=\"img_hello_world.jpg\" alt=\"Hello World from Space\"style=\"width:100%;max-width:960px\"></div><p>This is the first file in my new Git Repo.</p><p>A new line in our file!</p></body> </html>",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 607
        }
      },
      {
        "header": "Example",
        "content": "We have made changes to a file and added a new file in the working directory (same directory as the main branch).\n\nNow check the status of the current branch:\n\n[Example] Example git status On branch hello-world-images Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git restore <file>...\" to discard changes in working directory) modified: index.html Untracked files: (use \"git add <file>...\" to include in what will be committed) img_hello_world.jpg no changes added to commit (use \"git add\" and/or \"git commit -a\")",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 564
        }
      },
      {
        "header": "Example",
        "content": "So let's go through what happens here:\n\nSo we need to add both files to the Staging Environment for this branch:\n\n• There are changes to our index.html, but the file is not staged for commit\n• img_hello_world.jpg is not tracked",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit status\nOn branch hello-world-images\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n        img_hello_world.jpg\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 227
        }
      },
      {
        "header": "Example",
        "content": "Using --all instead of individual filenames will Stage all changed (new, modified, and deleted) files.\n\nCheck the status of the branch:\n\n[Example] Example git status On branch hello-world-images Changes to be committed: (use \"git restore --staged <file>...\" to unstage) new file: img_hello_world.jpg modified: index.html",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit add --all\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 320
        }
      },
      {
        "header": "Example",
        "content": "We are happy with our changes. So we will commit them to the branch:\n\n[Example] Example git commit -m \"Added image to Hello World\" [hello-world-images 0312c55] Added image to Hello World 2 files changed, 1 insertion(+) create mode 100644 img_hello_world.jpg",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit status\nOn branch hello-world-images\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n    new file: img_hello_world.jpg\n    modified: index.html\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 257
        }
      },
      {
        "header": "Example",
        "content": "Now we have a new branch, that is different from the master branch.\n\nNote: Using the -b option on checkout will create a new branch, and move to it, if it does not exist\n\n[Note] Note: Using the -b option on checkout will create a new branch, and move to it, if it does not exist",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit commit -m \"Added image to Hello World\"\n[hello-world-images 0312c55] Added image to Hello World\n2 files changed, 1 insertion(+)\ncreate mode 100644 img_hello_world.jpg\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 278
        }
      },
      {
        "header": "Switching Between Branches",
        "content": "Now let's see just how quick and easy it is to work with different branches, and how well it works.\n\nWe are currently on the branch hello-world-images. We added an image to this branch, so let's list the files in the current directory:\n\n[Example] Example ls README.md bluestyle.css img_hello_world.jpg index.html",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 312
        }
      },
      {
        "header": "Example",
        "content": "We can see the new file img_hello_world.jpg, and if we open the html file, we can see the code has been altered. All is as it should be.\n\nNow, let's see what happens when we change branch to master\n\n[Example] Example git checkout master Switched to branch 'master'",
        "code_examples": [
          "```bash\nls\nREADME.md  bluestyle.css  img_hello_world.jpg  index.html\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 264
        }
      },
      {
        "header": "Example",
        "content": "The new image is not a part of this branch. List the files in the current directory again:\n\n[Example] Example ls README.md bluestyle.css index.html",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout master\nSwitched to branch 'master'\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 147
        }
      },
      {
        "header": "Example",
        "content": "img_hello_world.jpg is no longer there! And if we open the html file, we can see the code reverted to what it was before the alteration.\n\nSee how easy it is to work with branches? And how this allows you to work on different things?",
        "code_examples": [
          "```bash\nls\nREADME.md  bluestyle.css  index.html\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 232
        }
      },
      {
        "header": "Emergency Branch",
        "content": "Now imagine that we are not yet done with hello-world-images, but we need to fix an error on master.\n\nI don't want to mess with master directly, and I do not want to mess with hello-world-images, since it is not done yet.\n\nSo we create a new branch to deal with the emergency:\n\n[Example] Example git checkout -b emergency-fix Switched to a new branch 'emergency-fix'",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 366
        }
      },
      {
        "header": "Example",
        "content": "Now we have created a new branch from master, and changed to it. We can safely fix the error without disturbing the other branches.\n\nLet's fix our imaginary error:\n\n[Example] Example <!DOCTYPE html><html><head><title>Hello World!</title><link rel=\"stylesheet\" href=\"bluestyle.css\"></head><body><h1>Hello world!</h1><p>This is the first file in my new Git Repo.</p><p>This line is here to show how merging works.</p></body> </html>",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout -b emergency-fix\nSwitched to a new branch 'emergency-fix'\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 430
        }
      },
      {
        "header": "Example",
        "content": "We have made changes in this file, and we need to get those changes to the master branch.\n\n[Example] Example git status On branch emergency-fix Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git restore <file>...\" to discard changes in working directory) modified: index.html no changes added to commit (use \"git add\" and/or \"git commit -a\")",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 390
        }
      },
      {
        "header": "Example",
        "content": "stage the file, and commit:\n\n[Example] Example git add index.html git commit -m \"updated index.html with emergency fix\" [emergency-fix dfa79db] updated index.html with emergency fix 1 file changed, 1 insertion(+), 1 deletion(-)",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit status\nOn branch emergency-fix\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 227
        }
      },
      {
        "header": "Example",
        "content": "Now we have a fix ready for master, and we need to merge the two branches.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit add index.html\ngit commit -m \"updated index.html with emergency fix\"\n[emergency-fix dfa79db] updated index.html with emergency fix\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 74
        }
      },
      {
        "header": "Deleting a Branch",
        "content": "When you're done with a branch, you can delete it:\n\n[Example] Example git branch -d hello-world-images",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 102
        }
      },
      {
        "header": "Example",
        "content": "This deletes the branch named hello-world-images (if it's already merged).",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit branch -d hello-world-images\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 74
        }
      },
      {
        "header": "Best Practices for Working with Branches",
        "content": "• Use clear, descriptive branch names (like feature/login-page or bugfix/header-crash).\n• Keep each branch focused on a single purpose or feature.\n• Regularly merge changes from the main branch to keep your branch up-to-date.\n• Delete branches that are no longer needed to keep your repository clean.\n\n[Info] Use clear, descriptive branch names (like feature/login-page or bugfix/header-crash). Keep each branch focused on a single purpose or feature. Regularly merge changes from the main branch to keep your branch up-to-date. Delete branches that are no longer needed to keep your repository clean.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 601
        }
      },
      {
        "header": "Practical Examples",
        "content": "• Rename a branch: git branch -m old-name new-name\n• List all branches: git branch\n• Switch branches: git checkout branch-name or git switch branch-name\n• Delete a branch (not merged): git branch -D branch-name\n• See which branch you're on: git status",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 251
        }
      },
      {
        "header": "Troubleshooting",
        "content": "If you don't see your changes on the main branch, remember: changes in one branch stay there until you merge them.\n\nWhen deleting a branch, make sure it's merged first. If you try to delete an unmerged branch, Git will prevent you from doing so.\n\nTo force delete an unmerged branch, use git branch -D branch-name.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 313
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_branch.asp",
    "doc_type": "git",
    "total_sections": 32
  },
  {
    "title": "Git Branch Merge",
    "summary": "Merging in Git means combining the changes from one branch into another.\n\nThis is how you bring your work together after working separately on different features or bug fixes.",
    "sections": [
      {
        "header": "What is Merging in Git?",
        "content": "Merging in Git means combining the changes from one branch into another.\n\nThis is how you bring your work together after working separately on different features or bug fixes.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 175
        }
      },
      {
        "header": "Common git merge Options",
        "content": "• git merge - Merge a branch into your current branch\n• git merge --no-ff - Always create a merge commit\n• git merge --squash - Combine changes into a single commit\n• git merge --abort - Abort a merge in progress",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 212
        }
      },
      {
        "header": "Merging Branches (git merge)",
        "content": "To combine the changes from one branch into another, use git merge.\n\nUsually, you first switch to the branch you want to merge into (often main or master), then run the merge command with the branch name you want to combine in.\n\nFirst, we need to change to the master branch:\n\n[Example] Example git checkout master Switched to branch 'master'",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 342
        }
      },
      {
        "header": "Example",
        "content": "Now we merge the current branch (master) with emergency-fix:\n\n[Example] Example git merge emergency-fix Updating 09f4acd..dfa79db Fast-forward index.html | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout master\nSwitched to branch 'master'\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 206
        }
      },
      {
        "header": "Example",
        "content": "Since the emergency-fix branch came directly from master, and no other changes had been made to master while we were working, Git sees this as a continuation of master.\n\nSo it can \"Fast-forward\", just pointing both master and emergency-fix to the same commit.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit merge emergency-fix\nUpdating 09f4acd..dfa79db\nFast-forward\n index.html | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 259
        }
      },
      {
        "header": "Best Practices for Merging Branches",
        "content": "• Always commit or stash your changes before starting a merge.\n• Regularly merge from the main branch into your feature branch to minimize conflicts.\n• Read and resolve conflicts carefullyâdon't just accept all changes blindly.\n• Write clear and descriptive merge commit messages.\n\n[Info] Always commit or stash your changes before starting a merge. Regularly merge from the main branch into your feature branch to minimize conflicts. Read and resolve conflicts carefullyâdon't just accept all changes blindly. Write clear and descriptive merge commit messages.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 565
        }
      },
      {
        "header": "Practical Examples",
        "content": "As master and emergency-fix are essentially the same now, we can delete emergency-fix, as it is no longer needed:\n\n• Abort a merge: git merge --abort\n• Check status during a merge: git status\n• Resolve a conflict and complete the merge: Edit the conflicted file(s), then git add file and git commit\n• Fast-forward merge: Happens when no new commits divergedâGit just moves the branch pointer forward.\n• No-fast-forward merge: Use git merge --no-ff branch to always create a merge commit, preserving branch history.\n\n[Info] Abort a merge: git merge --abort Check status during a merge: git status Resolve a conflict and complete the merge: Edit the conflicted file(s), then git add file and git commit Fast-forward merge: Happens when no new commits divergedâGit just moves the branch pointer forward. No-fast-forward merge: Use git merge --no-ff branch to always create a merge commit, preserving branch history.\n\n[Example] Example git branch -d emergency-fix Deleted branch emergency-fix (was dfa79db).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 1007
        }
      },
      {
        "header": "Non-Fast-Forward Merge (git merge --no-ff)",
        "content": "By default, if your branch can be merged with a fast-forward (no new commits on the base), Git just moves the branch pointer forward.\n\nIf you want to always create a merge commit (to keep history clearer), use git merge --no-ff branchname.\n\n[Example] Example git merge --no-ff feature-branch Merge made by the 'recursive' strategy. index.html | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 395
        }
      },
      {
        "header": "Squash Merge (git merge --squash)",
        "content": "If you want to combine all the changes from a branch into a single commit (instead of keeping every commit), use git merge --squash branchname.\n\nThis is useful for cleaning up commit history before merging.\n\n[Example] Example git merge --squash feature-branch Squash commit -- not updating HEAD Automatic merge went well; stopped before committing as requested",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 360
        }
      },
      {
        "header": "Aborting a Merge (git merge --abort)",
        "content": "If you run into trouble during a merge (like a conflict you don't want to resolve), you can cancel the merge and go back to how things were before with git merge --abort.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 170
        }
      },
      {
        "header": "What is a Merge Conflict?",
        "content": "A merge conflict happens when changes in two branches touch the same part of a file and Git doesn't know which version to keep.\n\nThink of it like two people editing the same sentence in a document in different waysâGit needs your help to decide which version to use.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 268
        }
      },
      {
        "header": "How to Resolve a Merge Conflict",
        "content": "Git will mark the conflict in your file.\n\nYou need to open the file, look for lines like <<<<<<< HEAD and =======, and decide what the final version should be.\n\nThen, stage and commit your changes.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 197
        }
      },
      {
        "header": "Troubleshooting & Tips",
        "content": "• If you want to cancel a merge, use git merge --abort.\n• Always commit or stash your changes before starting a merge.\n• Read the conflict markers carefully and remove them after you've resolved the issue.\n• Use git status to see what files need your attention.\n• If you're unsure, ask a teammate or look up the error message.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 326
        }
      },
      {
        "header": "Merge Conflict Example",
        "content": "Now we can move over to hello-world-images from last chapter, and keep working.\n\nAdd another image file (img_hello_git.jpg) and change index.html, so it shows it:\n\n[Example] Example git checkout hello-world-images Switched to branch 'hello-world-images'",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 253
        }
      },
      {
        "header": "Example",
        "content": "[Example] Example <!DOCTYPE html><html><head><title>Hello World!</title> <link rel=\"stylesheet\" href=\"bluestyle.css\"></head><body> <h1>Hello world!</h1><div><img src=\"img_hello_world.jpg\" alt=\"Hello World from Space\" style=\"width:100%;max-width:960px\"></div><p>This is the first file in my new Git Repo.</p><p>A new line in our file!</p><div><img src=\"img_hello_git.jpg\" alt=\"Hello Git\" style=\"width:100%;max-width:640px\"></div></body></html>",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout hello-world-images\nSwitched to branch 'hello-world-images'\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 442
        }
      },
      {
        "header": "Example",
        "content": "Now, we are done with our work here and can stage and commit for this branch:\n\n[Example] Example git add --all git commit -m \"added new image\" [hello-world-images 1f1584e] added new image 2 files changed, 1 insertion(+) create mode 100644 img_hello_git.jpg",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 256
        }
      },
      {
        "header": "Example",
        "content": "We see that index.html has been changed in both branches.\n\nNow we are ready to merge hello-world-images into master.\n\nBut what will happen to the changes we recently made in master?\n\n[Example] Example git checkout master git merge hello-world-images Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit add --all\ngit commit -m \"added new image\"\n[hello-world-images 1f1584e] added new image\n 2 files changed, 1 insertion(+)\n create mode 100644 img_hello_git.jpg\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 388
        }
      },
      {
        "header": "Example",
        "content": "The merge failed, as there is conflict between the versions for index.html.\n\nLet us check the status:\n\n[Example] Example git status On branch master You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge) Changes to be committed: new file: img_hello_git.jpg new file: img_hello_world.jpg Unmerged paths: (use \"git add <file>...\" to mark resolution) both modified: index.html",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit checkout master\ngit merge hello-world-images\nAuto-merging index.html\nCONFLICT (content): Merge conflict in index.html\nAutomatic merge failed; fix conflicts and then commit the result.\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 425
        }
      },
      {
        "header": "Example",
        "content": "This confirms there is a conflict in index.html, but the image files are ready and staged to be committed.\n\nSo we need to fix that conflict. Open the file in our editor:\n\n[Example] Example <!DOCTYPE html><html><head><title>Hello World!</title><link rel=\"stylesheet\" href=\"bluestyle.css\"></head><body><h1>Hello world!</h1><div><img src=\"img_hello_world.jpg\" alt=\"Hello World from Space\" style=\"width:100%;max-width:960px\"></div><p>This is the first file in my new Git Repo.</p><<<<<<< HEAD<p>This line is here to show how merging works.</p>=======<p>A new line in our file!</p><div><img src=\"img_hello_git.jpg\" alt=\"Hello Git\" style=\"width:100%;max-width:640px\"></div>>>>>>>> hello-world-images </body></html>",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit status\nOn branch master\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nChanges to be committed:\n        new file:   img_hello_git.jpg\n        new file:   img_hello_world.jpg\n\nUnmerged paths:\n  (use \"git add <file>...\" to mark resolution)\n        both modified:   index.html\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 708
        }
      },
      {
        "header": "Example",
        "content": "We can see the differences between the versions and edit it like we want:\n\n[Example] Example <!DOCTYPE html><html><head><title>Hello World!</title><link rel=\"stylesheet\" href=\"bluestyle.css\"></head><body><h1>Hello world!</h1><div><img src=\"img_hello_world.jpg\" alt=\"Hello World from Space\" style=\"width:100%;max-width:960px\"></div><p>This is the first file in my new Git Repo.</p><p>This line is here to show how merging works.</p><div><img src=\"img_hello_git.jpg\" alt=\"Hello Git\" style=\"width:100%;max-width:640px\"></div> </body></html>",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 537
        }
      },
      {
        "header": "Example",
        "content": "Now we can stage index.html and check the status:\n\n[Example] Example git add index.html git status On branch master All conflicts fixed but you are still merging. (use \"git commit\" to conclude merge) Changes to be committed: new file: img_hello_git.jpg new file: img_hello_world.jpg modified: index.html",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 303
        }
      },
      {
        "header": "Example",
        "content": "The conflict has been fixed, and we can use commit to conclude the merge:\n\n[Example] Example git commit -m \"merged with hello-world-images after fixing conflicts\" [master e0b6038] merged with hello-world-images after fixing conflicts",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit add index.html\ngit status\nOn branch master\nAll conflicts fixed but you are still merging.\n  (use \"git commit\" to conclude merge)\n\nChanges to be committed:\n        new file:   img_hello_git.jpg\n        new file:   img_hello_world.jpg\n        modified:   index.html\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 233
        }
      },
      {
        "header": "Example",
        "content": "And delete the hello-world-images branch:\n\n[Example] Example git branch -d hello-world-images Deleted branch hello-world-images (was 1f1584e).",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit commit -m \"merged with hello-world-images after fixing conflicts\"\n[master e0b6038] merged with hello-world-images after fixing conflicts\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 142
        }
      },
      {
        "header": "Example",
        "content": "Now you have a better understanding of how branches and merging works.\n\nTime to start working with a remote repository!",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit branch -d hello-world-images\nDeleted branch hello-world-images (was 1f1584e).\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 119
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_branch_merge.asp",
    "doc_type": "git",
    "total_sections": 24
  },
  {
    "title": "Git {{title}} Getting Started",
    "summary": "Menu Search field × See More Sign In ★ +1 Get Certified Upgrade For Teachers Spaces Get Certified Upgrade For Teachers Spaces\n\nMenu Search field × See More Sign In ★ +1 Get Certified Upgrade For Teachers Spaces Get Certified Upgrade For Teachers Spaces",
    "sections": [
      {
        "header": "Contact Sales",
        "content": "If you want to use W3Schools services as an educational institution, team or enterprise, send us an e-mail:sales@w3schools.com",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 126
        }
      },
      {
        "header": "Report Error",
        "content": "If you want to report an error, or if you want to make a suggestion, send us an e-mail:help@w3schools.com",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 105
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_remote_getstarted.asp",
    "doc_type": "git",
    "total_sections": 2
  },
  {
    "title": "Git {{title}} Send Pull Request",
    "summary": "Menu Search field × See More Sign In ★ +1 Get Certified Upgrade For Teachers Spaces Get Certified Upgrade For Teachers Spaces\n\nMenu Search field × See More Sign In ★ +1 Get Certified Upgrade For Teachers Spaces Get Certified Upgrade For Teachers Spaces",
    "sections": [
      {
        "header": "Contact Sales",
        "content": "If you want to use W3Schools services as an educational institution, team or enterprise, send us an e-mail:sales@w3schools.com",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 126
        }
      },
      {
        "header": "Report Error",
        "content": "If you want to report an error, or if you want to make a suggestion, send us an e-mail:help@w3schools.com",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 105
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_remote_send_pull_request.asp",
    "doc_type": "git",
    "total_sections": 2
  },
  {
    "title": "Git Clone from {{title}}",
    "summary": "Menu Search field × See More Sign In ★ +1 Get Certified Upgrade For Teachers Spaces Get Certified Upgrade For Teachers Spaces\n\nMenu Search field × See More Sign In ★ +1 Get Certified Upgrade For Teachers Spaces Get Certified Upgrade For Teachers Spaces",
    "sections": [
      {
        "header": "Contact Sales",
        "content": "If you want to use W3Schools services as an educational institution, team or enterprise, send us an e-mail:sales@w3schools.com",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 126
        }
      },
      {
        "header": "Report Error",
        "content": "If you want to report an error, or if you want to make a suggestion, send us an e-mail:help@w3schools.com",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 105
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_clone.asp",
    "doc_type": "git",
    "total_sections": 2
  },
  {
    "title": "Git Commit",
    "summary": "Since we have finished our work for now we are ready move from stage to commit for our repo.\n\nAdding commits keep track of our progress and changes as we work. Git considers each commit change point or \"save point\". It is a point in the project you can go back to, if you find a bug, or want to make a change.",
    "sections": [
      {
        "header": "Git Commit",
        "content": "Since we have finished our work for now we are ready move from stage to commit for our repo.\n\nAdding commits keep track of our progress and changes as we work. Git considers each commit change point or \"save point\". It is a point in the project you can go back to, if you find a bug, or want to make a change.\n\nWhen we commit, we should always include a message.\n\nBy adding clear messages to each commit, it is easy for yourself (and others) to see what has changed, and when.\n\n[Example] Example git commit -m \"First release of Hello World!\" [master (root-commit) 221ec6e] First release of Hello World! 3 files changed, 26 insertions(+) create mode 100644 README.md create mode 100644 bluestyle.css create mode 100644 index.html",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 728
        }
      },
      {
        "header": "Example",
        "content": "The commit command performs a commit, and the -m \"message\" adds a message.\n\nThe Staging Enviornment has been committed to our repo, with the message:\"First release of Hello World!\"",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit commit -m \"First release of Hello World!\"\n[master (root-commit) 221ec6e] First release of Hello World!\n 3 files changed, 26 insertions(+)\n create mode 100644 README.md\n create mode 100644 bluestyle.css\n create mode 100644 index.html\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 180
        }
      },
      {
        "header": "Git Commit without Stage",
        "content": "Sometimes, when you make small changes, using the staging enviornment seems like a waste of time. It is possible to commit changes directly, skipping the staging enviornment. The -a option will automatically stage every already tracked file that has been changed.\n\nLets add a small update to index.html:\n\n[Example] Example <!DOCTYPE html> <html><head><title>Hello World!</title><link rel=\"stylesheet\" href=\"bluestyle.css\"> </head><body><h1>Hello world!</h1><p>This is the first file in my new Git Repo.</p><p>A new line in our file!</p> </body></html>",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 551
        }
      },
      {
        "header": "Example",
        "content": "And check the status of our repository. But this time we will use the --short option, to see the changes in a more compact way:\n\n[Example] Example git status --short M index.html",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 178
        }
      },
      {
        "header": "Example",
        "content": "Note: Short status flags are:\n\nWe see the file we expected is modified. So lets commit it directly:\n\n• ?? - Untracked files\n• A - Files added to stage\n• M - Modified files\n• D - Deleted files\n\n[Note] Note: Short status flags are: ?? - Untracked files A - Files added to stage M - Modified files D - Deleted files\n\n[Example] Example git commit -a -m \"Updated index.html with a new line\" [master 09f4acd] Updated index.html with a new line 1 file changed, 1 insertion(+)",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit status --short\n M index.html\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 468
        }
      },
      {
        "header": "Example",
        "content": "Warning: Skipping the Staging Environment is not generally recommended.\n\nSkipping the stage step can sometimes make you include unwanted changes.\n\n[Warning] Warning: Skipping the Staging Environment is not generally recommended. Skipping the stage step can sometimes make you include unwanted changes.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit commit -a -m \"Updated index.html with a new line\"\n[master 09f4acd] Updated index.html with a new line\n 1 file changed, 1 insertion(+)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 301
        }
      },
      {
        "header": "Git Commit Log",
        "content": "To view the history of commits for a repository, you can use the log command:\n\n[Example] Example git log commit 09f4acd3f8836b7f6fc44ad9e012f82faf861803 (HEAD -> master) Author: w3schools-test <test@w3schools.com> Date: Fri Mar 26 09:35:54 2021 +0100 Updated index.html with a new line commit 221ec6e10aeedbfd02b85264087cd9adc18e4b26 Author: w3schools-test <test@w3schools.com> Date: Fri Mar 26 09:13:07 2021 +0100 First release of Hello World!",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 444
        }
      },
      {
        "header": "Exercise:",
        "content": "Insert the missing part of the command do check which version of Git (if any) is installed.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 91
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_undo.asp",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "Git Amend",
    "summary": "Git Amend is a command that allows you to modify the most recent commit.\n\nYou can use it to fix typos, add or remove files, or change the commit message.",
    "sections": [
      {
        "header": "What is Git Amend?",
        "content": "Git Amend is a command that allows you to modify the most recent commit.\n\nYou can use it to fix typos, add or remove files, or change the commit message.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 153
        }
      },
      {
        "header": "When to Use Git Amend",
        "content": "Use Git Amend when you need to make small changes to your last commit.\n\nIt's perfect for fixing mistakes, adding forgotten files, or updating the commit message.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 161
        }
      },
      {
        "header": "Fix Last Commit Message",
        "content": "To change the last commit message, follow these steps:\n\n• Open your terminal and navigate to your repository.\n• Type git commit --amend -m \"New message\" to change the commit message.\n• Press Enter to save the changes.\n\n[Example] Example git commit --amend -m \"Corrected commit message\"",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 285
        }
      },
      {
        "header": "Add Files to Last Commit",
        "content": "To add files to the last commit, follow these steps:\n\n• Open your terminal and navigate to your repository.\n• Type git add <file> to add the file to the staging area.\n• Type git commit --amend to add the file to the last commit.\n• Press Enter to save the changes.\n\n[Example] Example git add forgotten.txt git commit --amend",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 323
        }
      },
      {
        "header": "Remove Files from Last Commit",
        "content": "To remove files from the last commit, follow these steps:\n\n• Open your terminal and navigate to your repository.\n• Type git reset HEAD^ -- <file> to remove the file from the staging area.\n• Type git commit --amend to remove the file from the last commit.\n• Press Enter to save the changes.\n\n[Example] Example git reset HEAD^ -- unwanted.txt git commit --amend 1 file changed, 3 insertions(+), 1 deletion(-)",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 406
        }
      },
      {
        "header": "Example",
        "content": "Now let's check the log:\n\n[Example] Example git log --oneline 07c5bc5 (HEAD -> master) Adding plines to reddme 9a9add8 (origin/master) Added .gitignore 81912ba Corrected spelling error 3fdaa5b Merge pull request #1 from w3schools-test/update-readme 836e5bf (origin/update-readme, update-readme) Updated readme for GitHub Branches daf4f7c (origin/html-skeleton, html-skeleton) Updated index.html with basic meta facaeae (gh-page/master) Merge branch 'master' of https://github.com/w3schools-test/hello-world e7de78f Updated index.html. Resized image 5a04b6f Updated README.md with a line about focus d29d69f Updated README.md with a line about GitHub e0b6038 merged with hello-world-images after fixing conflicts 1f1584e added new image dfa79db updated index.html with emergency fix 0312c55 Added image to Hello World 09f4acd Updated index.html with a new line 221ec6e First release of Hello World!",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit reset HEAD^ -- unwanted.txt\ngit commit --amend\n 1 file changed, 3 insertions(+), 1 deletion(-)\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 897
        }
      },
      {
        "header": "Example",
        "content": "Oh no! the commit message is full of spelling errors.\n\nEmbarrassing. Let's amend that:\n\n[Example] Example git commit --amend -m \"Added lines to README.md\" [master eaa69ce] Added lines to README.md Date: Thu Apr 22 12:18:52 2021 +0200 1 file changed, 3 insertions(+), 1 deletion(-))",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log --oneline\n07c5bc5 (HEAD -> master) Adding plines to reddme\n9a9add8 (origin/master) Added .gitignore\n81912ba Corrected spelling error\n3fdaa5b Merge pull request #1 from w3schools-test/update-readme\n836e5bf (origin/update-readme, update-readme) Updated readme for GitHub Branches\ndaf4f7c (origin/html-skeleton, html-skeleton) Updated index.html with basic meta\nfacaeae (gh-page/master) Merge branch 'master' of https://github.com/w3schools-test/hello-world\ne7de78f Updated index.html. Resized image\n5a04b6f Updated README.md with a line about focus\nd29d69f Updated README.md with a line about GitHub\ne0b6038 merged with hello-world-images after fixing conflicts\n1f1584e added new image\ndfa79db updated index.html with emergency fix\n0312c55 Added image to Hello World\n09f4acd Updated index.html with a new line\n221ec6e First release of Hello World!\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 281
        }
      },
      {
        "header": "Example",
        "content": "And re-check the log:\n\n[Example] Example git log --oneline eaa69ce (HEAD -> master) Added lines to README.md 9a9add8 (origin/master) Added .gitignore 81912ba Corrected spelling error 3fdaa5b Merge pull request #1 from w3schools-test/update-readme 836e5bf (origin/update-readme, update-readme) Updated readme for GitHub Branches daf4f7c (origin/html-skeleton, html-skeleton) Updated index.html with basic meta facaeae (gh-page/master) Merge branch 'master' of https://github.com/w3schools-test/hello-world e7de78f Updated index.html. Resized image 5a04b6f Updated README.md with a line about focus d29d69f Updated README.md with a line about GitHub e0b6038 merged with hello-world-images after fixing conflicts 1f1584e added new image dfa79db updated index.html with emergency fix 0312c55 Added image to Hello World 09f4acd Updated index.html with a new line 221ec6e First release of Hello World!",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit commit --amend -m \"Added lines to README.md\"\n[master eaa69ce] Added lines to README.md\n Date: Thu Apr 22 12:18:52 2021 +0200\n 1 file changed, 3 insertions(+), 1 deletion(-))\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 895
        }
      },
      {
        "header": "Example",
        "content": "We see the previous commit is replaced with our amended one!\n\nWarning: Messing with the commit history of a repository can be dangerous.\n\nIt is usually ok to make these kinds of changes to your own local repository.\n\nHowever, you should avoid making changes that rewrite history to remote repositories, especially if others are working with them.\n\n[Warning] Warning: Messing with the commit history of a repository can be dangerous. It is usually ok to make these kinds of changes to your own local repository. However, you should avoid making changes that rewrite history to remote repositories, especially if others are working with them.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log --oneline\neaa69ce (HEAD -> master) Added lines to README.md\n9a9add8 (origin/master) Added .gitignore\n81912ba Corrected spelling error\n3fdaa5b Merge pull request #1 from w3schools-test/update-readme\n836e5bf (origin/update-readme, update-readme) Updated readme for GitHub Branches\ndaf4f7c (origin/html-skeleton, html-skeleton) Updated index.html with basic meta\nfacaeae (gh-page/master) Merge branch 'master' of https://github.com/w3schools-test/hello-world\ne7de78f Updated index.html. Resized image\n5a04b6f Updated README.md with a line about focus\nd29d69f Updated README.md with a line about GitHub\ne0b6038 merged with hello-world-images after fixing conflicts\n1f1584e added new image\ndfa79db updated index.html with emergency fix\n0312c55 Added image to Hello World\n09f4acd Updated index.html with a new line\n221ec6e First release of Hello World!\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 640
        }
      },
      {
        "header": "Git Amend Files",
        "content": "Adding files with --amend works the same way as above.\n\nJust add them to the staging environment before committing.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 115
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_amend.asp",
    "doc_type": "git",
    "total_sections": 10
  },
  {
    "title": "Git Revert",
    "summary": "The git revert command undoes a previous commit by creating a new commit that reverses the changes.\n\nThis keeps your commit history intact and is the safest way to undo changes in a shared repository.",
    "sections": [
      {
        "header": "What Does Git Revert Do?",
        "content": "The git revert command undoes a previous commit by creating a new commit that reverses the changes.\n\nThis keeps your commit history intact and is the safest way to undo changes in a shared repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 200
        }
      },
      {
        "header": "Summary of Git Revert Commands and Options",
        "content": "• git revert HEAD - Revert the latest commit\n• git revert <commit> - Revert a specific commit\n• git revert HEAD~2 - Revert a commit further back in history\n• git revert --no-edit - Skip commit message editor\n• git log --oneline - Show commit history",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 249
        }
      },
      {
        "header": "How to Find the Commit to Revert",
        "content": "First, you need to find the commit you want to undo.\n\nUse git log --oneline to see a summary of your commit history:\n\n[Example] Example git log --oneline 52418f7 (HEAD -> master) Just a regular update, definitely no accidents here... 9a9add8 (origin/master) Added .gitignore 81912ba Corrected spelling error 3fdaa5b Merge pull request #1 from w3schools-test/update-readme 836e5bf (origin/update-readme, update-readme) Updated readme for GitHub Branches daf4f7c (origin/html-skeleton, html-skeleton) Updated index.html with basic meta facaeae (gh-page/master) Merge branch 'master' of https://github.com/w3schools-test/hello-world e7de78f Updated index.html. Resized image 5a04b6f Updated README.md with a line about focus d29d69f Updated README.md with a line about GitHub e0b6038 merged with hello-world-images after fixing conflicts 1f1584e added new image dfa79db updated index.html with emergency fix 0312c55 Added image to Hello World 09f4acd Updated index.html with a new line 221ec6e First release of Hello World!",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 1020
        }
      },
      {
        "header": "Run Git Revert",
        "content": "Once you've found the commit you want to undo, use git revert to create a new commit that reverses the changes:\n\n[Example] Example git revert HEAD --no-edit [master e56ba1f] Revert \"Just a regular update, definitely no accidents here...\" Date: Thu Apr 22 10:50:13 2021 +0200 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 img_hello_git.jpg",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 359
        }
      },
      {
        "header": "Review Changes After Git Revert",
        "content": "After running git revert, review the changes to make sure everything is as expected:\n\n[Example] Example git log --oneline e56ba1f (HEAD -> master) Revert \"Just a regular update, definitely no accidents here...\" 52418f7 Just a regular update, definitely no accidents here... 9a9add8 (origin/master) Added .gitignore 81912ba Corrected spelling error 3fdaa5b Merge pull request #1 from w3schools-test/update-readme 836e5bf (origin/update-readme, update-readme) Updated readme for GitHub Branches daf4f7c (origin/html-skeleton, html-skeleton) Updated index.html with basic meta facaeae (gh-page/master) Merge branch 'master' of https://github.com/w3schools-test/hello-world e7de78f Updated index.html. Resized image 5a04b6f Updated README.md with a line about focus d29d69f Updated README.md with a line about GitHub e0b6038 merged with hello-world-images after fixing conflicts 1f1584e added new image dfa79db updated index.html with emergency fix 0312c55 Added image to Hello World 09f4acd Updated index.html with a new line 221ec6e First release of Hello World!",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 1060
        }
      },
      {
        "header": "Tips & Best Practices",
        "content": "Here are some tips and best practices to keep in mind when using Git Revert:\n\n• Use git revert instead of git reset when you want to undo a previous commit, but still keep the commit history intact.\n• Use git log --oneline to find the commit you want to undo.\n• Use git revert HEAD --no-edit to create a new commit that reverses the changes.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 341
        }
      },
      {
        "header": "Troubleshooting",
        "content": "Here are some common issues you may encounter when using Git Revert:\n\n• If you get an error message saying \"error: could not revert...\", try using git revert --abort to abort the revert process.\n• If you get an error message saying \"error: could not apply...\", try using git revert --continue to continue the revert process.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 324
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_revert.asp",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "Git Reset",
    "summary": "The git reset command moves your current branch (HEAD) to a different commit.\n\nDepending on the option, it can also change which changes are staged or even delete changes from your working directory.",
    "sections": [
      {
        "header": "What Does Git Reset Do?",
        "content": "The git reset command moves your current branch (HEAD) to a different commit.\n\nDepending on the option, it can also change which changes are staged or even delete changes from your working directory.\n\nUse it to undo commits, unstage files, or clean up your history.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 265
        }
      },
      {
        "header": "Summary of Git Reset Commands and Options",
        "content": "• git reset --soft <commit> - Move HEAD to commit, keep changes staged\n• git reset --mixed <commit> - Move HEAD to commit, unstage changes (default)\n• git reset --hard <commit> - Move HEAD to commit, discard all changes\n• git reset <file> - Unstage a file\n• git log --oneline - Show commit history",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 297
        }
      },
      {
        "header": "How to Find the Commit to Reset To",
        "content": "First, you need to find the commit you want to go back to.\n\nUse git log --oneline to see a summary of your commit history:\n\nStep 2: Move the repository back to that step:\n\nAfter the previous chapter, we have a part in our commit history we could go back to.\n\nLet's try and do that with reset.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 292
        }
      },
      {
        "header": "Git Reset Find Commit in Log",
        "content": "First thing, we need to find the point we want to return to.\n\nTo do that, we need to go through the log.\n\nTo avoid the very long log list, we are going to use the --oneline option, which gives just one line per commit showing:\n\nSo let's find the point we want to reset to:\n\n• The first seven characters of the commit hash - this is what we need to refer to in our reset command.\n• the commit message\n\n[Example] Example git log --oneline e56ba1f (HEAD -> master) Revert \"Just a regular update, definitely no accidents here...\" 52418f7 Just a regular update, definitely no accidents here... 9a9add8 (origin/master) Added .gitignore 81912ba Corrected spelling error 3fdaa5b Merge pull request #1 from w3schools-test/update-readme 836e5bf (origin/update-readme, update-readme) Updated readme for GitHub Branches daf4f7c (origin/html-skeleton, html-skeleton) Updated index.html with basic meta facaeae (gh-page/master) Merge branch 'master' of https://github.com/w3schools-test/hello-world e7de78f Updated index.html. Resized image 5a04b6f Updated README.md with a line about focus d29d69f Updated README.md with a line about GitHub e0b6038 merged with hello-world-images after fixing conflicts 1f1584e added new image dfa79db updated index.html with emergency fix 0312c55 Added image to Hello World 09f4acd Updated index.html with a new line 221ec6e First release of Hello World!",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1375
        }
      },
      {
        "header": "Example",
        "content": "We want to return to the commit: 9a9add8 (origin/master) Added .gitignore, the last one before we started to mess with things.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit log --oneline\ne56ba1f (HEAD -> master) Revert \"Just a regular update, definitely no accidents here...\"\n52418f7 Just a regular update, definitely no accidents here...\n9a9add8 (origin/master) Added .gitignore\n81912ba Corrected spelling error\n3fdaa5b Merge pull request #1 from w3schools-test/update-readme\n836e5bf (origin/update-readme, update-readme) Updated readme for GitHub Branches\ndaf4f7c (origin/html-skeleton, html-skeleton) Updated index.html with basic meta\nfacaeae (gh-page/master) Merge branch 'master' of https://github.com/w3schools-test/hello-world\ne7de78f Updated index.html. Resized image\n5a04b6f Updated README.md with a line about focus\nd29d69f Updated README.md with a line about GitHub\ne0b6038 merged with hello-world-images after fixing conflicts\n1f1584e added new image\ndfa79db updated index.html with emergency fix\n0312c55 Added image to Hello World\n09f4acd Updated index.html with a new line\n221ec6e First release of Hello World!\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 126
        }
      },
      {
        "header": "Git Reset --soft",
        "content": "git reset --soft <commit> moves HEAD to the specified commit, but keeps all your changes staged (in the index).\n\nThis is useful if you want to combine several commits into one, or just want to rewrite history but keep your work ready to commit.\n\n[Example] Example git reset --soft 9a9add8",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 288
        }
      },
      {
        "header": "Example",
        "content": "All changes after 9a9add8 are now staged, ready for a new commit.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit reset --soft 9a9add8\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 65
        }
      },
      {
        "header": "Git Reset --mixed (default)",
        "content": "git reset --mixed <commit> (or just git reset <commit>) moves HEAD to the specified commit and unstages any changes, but keeps them in your working directory.\n\nThis is the default option and is useful if you want to \"undo\" a commit but keep your changes for editing or recommitting.\n\n[Example] Example git reset --mixed 9a9add8",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 327
        }
      },
      {
        "header": "Example",
        "content": "All changes after 9a9add8 are now unstaged, but still in your files.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit reset --mixed 9a9add8\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 68
        }
      },
      {
        "header": "Review Changes",
        "content": "After running Git Reset, review your changes to make sure everything is as expected.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 84
        }
      },
      {
        "header": "Tips & Best Practices",
        "content": "Use Git Reset with caution, as it can rewrite your commit history.\n\nMake sure to communicate with your team before making changes to the remote repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 155
        }
      },
      {
        "header": "Troubleshooting",
        "content": "If you encounter issues with Git Reset, try using git status to see the current state of your repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 105
        }
      },
      {
        "header": "Warnings",
        "content": "Be careful when using Git Reset, as it can delete changes and rewrite your commit history.\n\nMake sure to use it only when necessary.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 132
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_reset.asp",
    "doc_type": "git",
    "total_sections": 13
  },
  {
    "title": "Git Ignore and .gitignore",
    "summary": "The .gitignore file tells Git which files and folders to ignore (not track).\n\nThis is useful for keeping log files, temporary files, build artifacts, or personal files out of your repository.",
    "sections": [
      {
        "header": "What is .gitignore?",
        "content": "The .gitignore file tells Git which files and folders to ignore (not track).\n\nThis is useful for keeping log files, temporary files, build artifacts, or personal files out of your repository.\n\nThe .gitignore file itself is tracked by Git, so everyone using the repository ignores the same files.\n\n• Examples of files to ignore: log files, temporary files, hidden files, personal files, OS/editor files, etc.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 407
        }
      },
      {
        "header": "When to Use .gitignore",
        "content": "• When you want to keep sensitive, local, or unnecessary files out of your repository\n• When sharing a project with others and want to avoid cluttering Git history\n• When working with build tools or editors that create extra files",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 230
        }
      },
      {
        "header": "Create a .gitignore File",
        "content": "• Go to the root of your local Git repository.\n• Create a file named .gitignore:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 80
        }
      },
      {
        "header": "Ignoring Folders",
        "content": "To ignore a folder and everything inside it, use a trailing slash:\n\nThis ignores any folder named temp anywhere in your project.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 128
        }
      },
      {
        "header": "Wildcards & Patterns",
        "content": "Wildcards let you match many files or folders at once:\n\n• * matches any number of characters\n• ? matches a single character\n• [abc] matches any character in the set\n• [!abc] matches any character not in the set\n\n[Example] *.tmp # all .tmp files my?ile.txt # matches my1ile.txt, myAile.txt, etc. log[0-9].txt # log1.txt, log2.txt, ... log9.txt",
        "code_examples": [
          "```bash\n*.tmp      # all .tmp files\nmy?ile.txt # matches my1ile.txt, myAile.txt, etc.\nlog[0-9].txt # log1.txt, log2.txt, ... log9.txt\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 342
        }
      },
      {
        "header": "Negation (!)",
        "content": "Use ! to not ignore something that would otherwise be ignored. This is called an exception:\n\nThis ignores all .log files except important.log.\n\nLines starting with # are comments and are ignored by Git. Blank lines are also ignored. Use comments to explain your rules:\n\n[Example] # Ignore log files *.log # Ignore temp folders temp/",
        "code_examples": [
          "```bash\n*.log\n!important.log\n```",
          "```bash\n# Ignore log files\n*.log\n\n# Ignore temp folders\ntemp/\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 332
        }
      },
      {
        "header": "Local & Personal Ignore Rules",
        "content": "If you want to ignore files only for yourself (not for everyone who uses the repository), add them to .git/info/exclude. This works just like .gitignore but is not shared.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 171
        }
      },
      {
        "header": "Global .gitignore (User Level)",
        "content": "You can set up a global .gitignore file for all your projects. This is great for ignoring OS or editor files everywhere (like .DS_Store or Thumbs.db):\n\nThen add your patterns to ~/.gitignore_global.\n\n[Example] git config --global core.excludesfile ~/.gitignore_global",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit config --global core.excludesfile ~/.gitignore_global\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 267
        }
      },
      {
        "header": "How to Stop Tracking a File",
        "content": "If you add a file to .gitignore but Git is still tracking it, you need to tell Git to stop:\n\nThis removes the file from the repository but keeps it on your computer. Next time you commit, Git will ignore it.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit rm --cached filename.txt\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 207
        }
      },
      {
        "header": "Tips & Troubleshooting",
        "content": "• Check for typosâ.gitignore is case-sensitive!\n• If a file is already tracked, use git rm --cached to stop tracking it.\n• Use comments (#) to explain tricky rules for your teammates.\n• Use git status to see if your ignored files are being tracked.\n• Remember: .gitignore only affects files that are not already tracked by Git.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 329
        }
      },
      {
        "header": "Pattern Syntax",
        "content": "Here are some common patterns and how they match:\n\nPattern | Explanation/Matches | Examples\nBlank lines are ignored\n# text comment | Lines starting with # are ignored\nname | All name files, name folders, and files and folders in any name folder | /name.log/name/file.txt/lib/name.log\nname/ | Ending with / specifies the pattern is for a folder. Matches all files and folders in any name folder | /name/file.txt/name/log/name.logno match:/name.log\nname.file | All files with the name.file | /name.file/lib/name.file\n/name.file | Starting with / specifies the pattern matches only files in the root folder | /name.fileno match: /lib/name.file\nlib/name.file | Patterns specifiing files in specific folders are always realative to root (even if you do not start with / ) | /lib/name.fileno match: name.file/test/lib/name.file\n**/lib/name.file | Starting with ** before / specifies that it matches any folder in the repository. Not just on root. | /lib/name.file/test/lib/name.file\n**/name | All name folders, and files and folders in any name folder | /name/log.file/lib/name/log.file/name/lib/log.file\n/lib/**/name | All name folders, and files and folders in any name folder within the lib folder. | /lib/name/log.file/lib/test/name/log.file/lib/test/ver1/name/log.file no match: /name/log.file\n*.file | All files withe .file extention | /name.file/lib/name.file\n*name/ | All folders ending with name | /lastname/log.file/firstname/log.file\nname?.file | ? matches a single non-specific character | /names.file/name1.fileno match: /names1.file\nname[a-z].file | [range] matches a single character in the specified range (in this case a character in the range of a-z, and also be numberic.) | /names.file/nameb.fileno match: /name1.file\nname[abc].file | [set] matches a single character in the specified set of characters (in this case either a, b, or c) | /namea.file/nameb.fileno match: /names.file\nname[!abc].file | [!set] matches a single character, except the ones spesified in the set of characters (in this case a, b, or c) | /names.file/namex.fileno match: /namesb.file\n*.file | All files withe .file extention | /name.file/lib/name.file\nname/!name/secret.log | ! specifies a negation or exception. Matches all files and folders in any name folder, except name/secret.log | /name/file.txt/name/log/name.logno match:/name/secret.log\n*.file!name.file | ! specifies a negation or exception. All files withe .file extention, except name.file | /log.file/lastname.fileno match: /name.file\n*.file!name/*.filejunk.* | Adding new patterns after a negation will re-ignore a previous negated fileAll files withe .file extention, except the ones in name folder. Unless the file name is junk | /log.file/name/log.fileno match: /name/junk.file",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 1,
          "content_length": 2733
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_ignore.asp",
    "doc_type": "git",
    "total_sections": 11
  },
  {
    "title": "Git Security SSH",
    "summary": "SSH (Secure Shell) is a way to connect securely to remote computers and services, like Git repositories.\n\nSSH uses a pair of keys (public and private) to make sure only you can access your code.",
    "sections": [
      {
        "header": "What is SSH?",
        "content": "SSH (Secure Shell) is a way to connect securely to remote computers and services, like Git repositories.\n\nSSH uses a pair of keys (public and private) to make sure only you can access your code.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 194
        }
      },
      {
        "header": "Summary of SSH Concepts and Commands",
        "content": "• SSH key pair - A public and private key for secure access\n• ssh-keygen - Generate a new SSH key pair\n• ssh-add - Add your private key to the SSH agent\n• ssh -T git@github.com - Test SSH connection\n• ssh-add -l - List loaded SSH keys\n• ssh-add -d - Remove a key from agent",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 0,
          "content_length": 273
        }
      },
      {
        "header": "How SSH Keys Work",
        "content": "SSH keys come in pairs: a public key (like a lock) and a private key (like your own key).\n\nYou share the public key with the server (like GitHub or Bitbucket), but keep the private key safe on your computer.\n\nOnly someone with the private key can access what's locked by the public key.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 286
        }
      },
      {
        "header": "First-Time SSH Key Setup",
        "content": "If you've never used SSH keys before, follow this step to enable the SSH agent on your operating system:\n\n[Example] Example: Enable SSH Agent eval $(ssh-agent -s)",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 162
        }
      },
      {
        "header": "Generating an SSH Key Pair",
        "content": "To create a new SSH key pair, use this command in the terminal (Linux, macOS, or Git Bash for Windows):\n\n[Example] Example: Generate SSH Key ssh-keygen -t rsa -b 4096 -C \"your@email.com\"",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 186
        }
      },
      {
        "header": "Example: Generate SSH Key",
        "content": "Follow the prompts to choose a file location (press Enter to use the default) and set a passphrase (optional, but recommended for extra security).",
        "code_examples": [
          "```bash\nssh-keygen -t rsa -b 4096 -C \"your@email.com\"\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 146
        }
      },
      {
        "header": "Adding Your Key to the SSH Agent",
        "content": "After creating your key, add it to the SSH agent so Git can use it:\n\n[Example] Example: Add Key to SSH Agent ssh-add ~/.ssh/id_rsa",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 130
        }
      },
      {
        "header": "Copying Your Public Key",
        "content": "To use SSH with Git hosting services, you need to copy your public key and add it to your account settings on GitHub, GitLab, or Bitbucket.\n\n• On macOS: pbcopy < ~/.ssh/id_rsa.pub\n• On Windows (Git Bash): clip < ~/.ssh/id_rsa.pub\n• On Linux: cat ~/.ssh/id_rsa.pub (then copy manually)",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 284
        }
      },
      {
        "header": "Listing and Removing SSH Keys",
        "content": "See which keys are loaded in your SSH agent:\n\n[Example] Example: List Loaded SSH Keys ssh-add -l",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 96
        }
      },
      {
        "header": "Example: List Loaded SSH Keys",
        "content": "To remove a key from the agent:\n\n[Example] Example: Remove SSH Key from Agent ssh-add -d ~/.ssh/id_rsa",
        "code_examples": [
          "```bash\nssh-add -l\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 102
        }
      },
      {
        "header": "Troubleshooting SSH",
        "content": "Tip: Never share your private key with anyone. Use a passphrase for extra security.\n\nIf your private key is ever exposed, generate a new key pair and update your Git host immediately.\n\n• If you get \"Permission denied\", make sure your public key is added to your Git host and your private key is loaded in the agent.\n• Check file permissions: private keys should be readable only by you (chmod 600 ~/.ssh/id_rsa).\n• Use ssh -v for verbose output to debug problems.\n• Make sure you're using the correct SSH URL for your remote (starts with git@).\n\n[Note] Tip: Never share your private key with anyone. Use a passphrase for extra security. If your private key is ever exposed, generate a new key pair and update your Git host immediately.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 735
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_security_ssh.asp",
    "doc_type": "git",
    "total_sections": 11
  },
  {
    "title": "Git Exercises",
    "summary": "Test your Git skills with exercises from all categories:\n\nExercises Tip: Sign in to track your progress - it's free. 0/39 done Install3 exercisesOpenDoneConfig3 exercisesOpenDoneGet Started3 exercisesOpenDoneNew Files3 exercisesOpenDoneStaging Environment3 exercisesOpenDoneCommit4 exercisesOpenDoneTagging3 exercisesOpenDoneStash3 exercisesOpenDoneHistory3 exercisesOpenDoneHelp3 exercisesOpenDoneBranch3 exercisesOpenDoneBranch Merge4 exercisesOpenDoneWorkflow4 exercisesOpenDoneBest Practices3 exe",
    "sections": [
      {
        "header": "",
        "content": "Test your Git skills with exercises from all categories:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 56
        }
      },
      {
        "header": "Exercises",
        "content": "Tip: Sign in to track your progress - it's free.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 48
        }
      },
      {
        "header": "Log in to track your progress",
        "content": "If you haven't already, sign up to become a W3Schooler, and get points for every exercise you complete.\n\nAs a logged-in W3Schools user you will have access to many features like having your own web page, track your learning progress, receive personal guided paths, and more.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 274
        }
      },
      {
        "header": "The Exercise",
        "content": "The exercises are a mix of \"multiple choice\" and \"fill in the blanks\" questions. There are between 3 and 9 questions in each category. The answer can be found in the corresponding tutorial chapter. If you're stuck, or answer wrong, you can try again or hit the \"Show Answer\" button to see the correct answer.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 308
        }
      },
      {
        "header": "Kickstart your career",
        "content": "Get certified by completing the course",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 38
        }
      }
    ],
    "url": "https://www.w3schools.com/git/git_exercises.asp",
    "doc_type": "git",
    "total_sections": 5
  },
  {
    "title": "Git",
    "summary": "SYNOPSIS git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p] [--edit | -e] [--[no-]all | -A | --[no-]ignore-removal | [--update | -u]] [--sparse] [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize] [--chmod=(+|-)x] [--pathspec-from-file=<file> [--pathspec-file-nul]] [--] [<pathspec>…]",
    "sections": [
      {
        "header": "NAME",
        "content": "git-add - Add file contents to the index",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 40
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "This command updates the index using the current content found in the working tree, to prepare the content staged for the next commit. It typically adds the current content of existing paths as a whole, but with some options it can also be used to add content with only part of the changes made to the working tree files applied, or remove paths that do not exist in the working tree anymore.\n\nThe \"index\" holds a snapshot of the content of the working tree, and it is this snapshot that is taken as the contents of the next commit. Thus after making any changes to the working tree, and before running the commit command, you must use the add command to add any new or modified files to the index.\n\nThis command can be performed multiple times before a commit. It only adds the content of the specified file(s) at the time the add command is run; if you want subsequent changes included in the next commit, then you must run git add again to add the new content to the index.\n\nThe git status command can be used to obtain a summary of which files have changes that are staged for the next commit.\n\nThe git add command will not add ignored files by default. If any ignored files were explicitly specified on the command line, git add will fail with a list of ignored files. Ignored files reached by directory recursion or filename globbing performed by Git (quote your globs before the shell) will be silently ignored. The git add command can be used to add ignored files with the -f (force) option.\n\nPlease see git-commit[1] for alternative ways to add content to a commit.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1574
        }
      },
      {
        "header": "OPTIONS",
        "content": "Files to add content from. Fileglobs (e.g. *.c) can be given to add all matching files. Also a leading directory name (e.g. dir to add dir/file1 and dir/file2) can be given to update the index to match the current state of the directory as a whole (e.g. specifying dir will record not just a file dir/file1 modified in the working tree, a file dir/file2 added to the working tree, but also a file dir/file3 removed from the working tree). Note that older versions of Git used to ignore removed files; use --no-all option if you want to add modified or new files but ignore removed ones.\n\nFor more details about the <pathspec> syntax, see the pathspec entry in gitglossary[7].\n\nDon’t actually add the file(s), just show if they exist and/or will be ignored.\n\nAllow adding otherwise ignored files.\n\nAllow updating index entries outside of the sparse-checkout cone. Normally, git add refuses to update index entries whose paths do not fit within the sparse-checkout cone, since those files might be removed from the working tree without warning. See git-sparse-checkout[1] for more details.\n\nAdd modified contents in the working tree interactively to the index. Optional path arguments may be supplied to limit operation to a subset of the working tree. See “Interactive mode” for details.\n\nInteractively choose hunks of patch between the index and the work tree and add them to the index. This gives the user a chance to review the difference before adding modified contents to the index.\n\nThis effectively runs add --interactive, but bypasses the initial command menu and directly jumps to the patch subcommand. See “Interactive mode” for details.\n\nGenerate diffs with <n> lines of context. Defaults to diff.context or 3 if the config option is unset.\n\nShow the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n\nOpen the diff vs. the index in an editor and let the user edit it. After the editor was closed, adjust the hunk headers and apply the patch to the index.\n\nThe intent of this option is to pick and choose lines of the patch to apply, or even to modify the contents of lines to be staged. This can be quicker and more flexible than using the interactive hunk selector. However, it is easy to confuse oneself and create a patch that does not apply to the index. See EDITING PATCHES below.\n\nUpdate the index just where it already has an entry matching <pathspec>. This removes as well as modifies index entries to match the working tree, but adds no new files.\n\nIf no <pathspec> is given when -u option is used, all tracked files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories).\n\nUpdate the index not only where the working tree has a file matching <pathspec> but also where the index already has an entry. This adds, modifies, and removes index entries to match the working tree.\n\nIf no <pathspec> is given when -A option is used, all files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories).\n\nUpdate the index by adding new files that are unknown to the index and files modified in the working tree, but ignore files that have been removed from the working tree. This option is a no-op when no <pathspec> is used.\n\nThis option is primarily to help users who are used to older versions of Git, whose git add <pathspec>... was a synonym for git add --no-all <pathspec>..., i.e. ignored removed files.\n\nRecord only the fact that the path will be added later. An entry for the path is placed in the index with no content. This is useful for, among other things, showing the unstaged content of such files with git diff and committing them with git commit -a.\n\nDon’t add the file(s), but only refresh their stat() information in the index.\n\nIf some files could not be added because of errors indexing them, do not abort the operation, but continue adding the others. The command shall still exit with non-zero status. The configuration variable add.ignoreErrors can be set to true to make this the default behaviour.\n\nThis option can only be used together with --dry-run. By using this option the user can check if any of the given files would be ignored, no matter if they are already present in the work tree or not.\n\nBy default, git add will warn when adding an embedded repository to the index without using git submodule add to create an entry in .gitmodules. This option will suppress the warning (e.g., if you are manually performing operations on submodules).\n\nApply the \"clean\" process freshly to all tracked files to forcibly add them again to the index. This is useful after changing core.autocrlf configuration or the text attribute in order to correct files added with wrong CRLF/LF line endings. This option implies -u. Lone CR characters are untouched, thus while a CRLF cleans to LF, a CRCRLF sequence is only partially cleaned to CRLF.\n\nOverride the executable bit of the added files. The executable bit is only changed in the index, the files on disk are left unchanged.\n\nPathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config[1]). See also --pathspec-file-nul and global --literal-pathspecs.\n\nOnly meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).\n\nThis option can be used to separate command-line options from the list of files, (useful when filenames might be mistaken for command-line options).\n\n**<pathspec>...**: Files to add content from. Fileglobs (e.g. *.c) can be given to add all matching files. Also a leading directory name (e.g. dir to add dir/file1 and dir/file2) can be given to update the index to match the current state of the directory as a whole (e.g. specifying dir will record not just a file dir/file1 modified in the working tree, a file dir/file2 added to the working tree, but also a file dir/file3 removed from the working tree). Note that older versions of Git used to ignore removed files; use --no-all option if you want to add modified or new files but ignore removed ones. For more details about the <pathspec> syntax, see the pathspec entry in gitglossary[7].\n**-n**: Don’t actually add the file(s), just show if they exist and/or will be ignored.\n**--dry-run**: Be verbose.\n**-v**: Allow adding otherwise ignored files.\n**--verbose**: Allow updating index entries outside of the sparse-checkout cone. Normally, git add refuses to update index entries whose paths do not fit within the sparse-checkout cone, since those files might be removed from the working tree without warning. See git-sparse-checkout[1] for more details.\n**-f**: Add modified contents in the working tree interactively to the index. Optional path arguments may be supplied to limit operation to a subset of the working tree. See “Interactive mode” for details.\n**--force**: Interactively choose hunks of patch between the index and the work tree and add them to the index. This gives the user a chance to review the difference before adding modified contents to the index. This effectively runs add --interactive, but bypasses the initial command menu and directly jumps to the patch subcommand. See “Interactive mode” for details.\n**--sparse**: Generate diffs with <n> lines of context. Defaults to diff.context or 3 if the config option is unset.\n**-i**: Show the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n**--interactive**: Open the diff vs. the index in an editor and let the user edit it. After the editor was closed, adjust the hunk headers and apply the patch to the index. The intent of this option is to pick and choose lines of the patch to apply, or even to modify the contents of lines to be staged. This can be quicker and more flexible than using the interactive hunk selector. However, it is easy to confuse oneself and create a patch that does not apply to the index. See EDITING PATCHES below.\n**-p**: Update the index just where it already has an entry matching <pathspec>. This removes as well as modifies index entries to match the working tree, but adds no new files. If no <pathspec> is given when -u option is used, all tracked files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories).\n**--patch**: Update the index not only where the working tree has a file matching <pathspec> but also where the index already has an entry. This adds, modifies, and removes index entries to match the working tree. If no <pathspec> is given when -A option is used, all files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories).\n**-U<n>**: Update the index by adding new files that are unknown to the index and files modified in the working tree, but ignore files that have been removed from the working tree. This option is a no-op when no <pathspec> is used. This option is primarily to help users who are used to older versions of Git, whose git add <pathspec>... was a synonym for git add --no-all <pathspec>..., i.e. ignored removed files.\n**--unified=<n>**: Record only the fact that the path will be added later. An entry for the path is placed in the index with no content. This is useful for, among other things, showing the unstaged content of such files with git diff and committing them with git commit -a.\n**--inter-hunk-context=<n>**: Don’t add the file(s), but only refresh their stat() information in the index.\n**-e**: If some files could not be added because of errors indexing them, do not abort the operation, but continue adding the others. The command shall still exit with non-zero status. The configuration variable add.ignoreErrors can be set to true to make this the default behaviour.\n**--edit**: This option can only be used together with --dry-run. By using this option the user can check if any of the given files would be ignored, no matter if they are already present in the work tree or not.\n**-u**: By default, git add will warn when adding an embedded repository to the index without using git submodule add to create an entry in .gitmodules. This option will suppress the warning (e.g., if you are manually performing operations on submodules).\n**--update**: Apply the \"clean\" process freshly to all tracked files to forcibly add them again to the index. This is useful after changing core.autocrlf configuration or the text attribute in order to correct files added with wrong CRLF/LF line endings. This option implies -u. Lone CR characters are untouched, thus while a CRLF cleans to LF, a CRCRLF sequence is only partially cleaned to CRLF.\n**-A**: Override the executable bit of the added files. The executable bit is only changed in the index, the files on disk are left unchanged.\n**--all**: Pathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config[1]). See also --pathspec-file-nul and global --literal-pathspecs.\n**--no-ignore-removal**: Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).\n**--no-all**: This option can be used to separate command-line options from the list of files, (useful when filenames might be mistaken for command-line options).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 28,
          "content_length": 12003
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Adds content from all *.txt files under Documentation directory and its subdirectories:\n\nNote that the asterisk * is quoted from the shell in this example; this lets the command include the files from subdirectories of Documentation/ directory.\n\nConsiders adding content from all git-*.sh scripts:\n\nBecause this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not consider subdir/git-foo.sh.\n\n• Adds content from all *.txt files under Documentation directory and its subdirectories: $ git add Documentation/\\*.txt Note that the asterisk * is quoted from the shell in this example; this lets the command include the files from subdirectories of Documentation/ directory.\n• Considers adding content from all git-*.sh scripts: $ git add git-*.sh Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not consider subdir/git-foo.sh.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git add Documentation/\\*.txt\n```",
          "```bash\n$ git add git-*.sh\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 931
        }
      },
      {
        "header": "INTERACTIVE MODE",
        "content": "When the command enters the interactive mode, it shows the output of the status subcommand, and then goes into its interactive command loop.\n\nThe command loop shows the list of subcommands available, and gives a prompt \"What now> \". In general, when the prompt ends with a single >, you can pick only one of the choices given and type return, like this:\n\nYou also could say s or sta or status above as long as the choice is unique.\n\nThe main command loop has 6 subcommands (plus help and quit).\n\nThis shows the change between HEAD and index (i.e. what will be committed if you say git commit), and between index and working tree files (i.e. what you could stage further before git commit using git add) for each path. A sample output looks like this:\n\nIt shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, binary would have been shown in place of nothing). The other file, add-interactive.c, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).\n\nThis shows the status information and issues an \"Update>>\" prompt. When the prompt ends with double >>, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. \"2-5 7,9\" to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining patches are taken. E.g. \"7-\" to choose 7,8,9 from the list. You can say * to choose everything.\n\nWhat you chose are then highlighted with *, like this:\n\nTo remove selection, prefix the input with - like this:\n\nAfter making the selection, answer with an empty line to stage the contents of working tree files for selected paths in the index.\n\nThis has a very similar UI to update, and the staged information for selected paths are reverted to that of the HEAD version. Reverting new paths makes them untracked.\n\nThis has a very similar UI to update and revert, and lets you add untracked paths to the index.\n\nThis lets you choose one path out of a status like selection. After choosing the path, it presents the diff between the index and the working tree file and asks you if you want to stage the change of each hunk. You can select one of the following options and type return:\n\nAfter deciding the fate for all hunks, if there is any hunk that was chosen, the index is updated with the selected hunks.\n\nYou can omit having to type return here, by setting the configuration variable interactive.singleKey to true.\n\nThis lets you review what will be committed (i.e. between HEAD and index).\n\n**status**: This shows the change between HEAD and index (i.e. what will be committed if you say git commit), and between index and working tree files (i.e. what you could stage further before git commit using git add) for each path. A sample output looks like this: staged unstaged path 1: binary nothing foo.png 2: +403/-35 +1/-1 add-interactive.c It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, binary would have been shown in place of nothing). The other file, add-interactive.c, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).\n**update**: This shows the status information and issues an \"Update>>\" prompt. When the prompt ends with double >>, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. \"2-5 7,9\" to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining patches are taken. E.g. \"7-\" to choose 7,8,9 from the list. You can say * to choose everything. What you chose are then highlighted with *, like this: staged unstaged path 1: binary nothing foo.png * 2: +403/-35 +1/-1 add-interactive.c To remove selection, prefix the input with - like this: Update>> -2 After making the selection, answer with an empty line to stage the contents of working tree files for selected paths in the index.\n**revert**: This has a very similar UI to update, and the staged information for selected paths are reverted to that of the HEAD version. Reverting new paths makes them untracked.\n**add untracked**: This has a very similar UI to update and revert, and lets you add untracked paths to the index.\n**patch**: This lets you choose one path out of a status like selection. After choosing the path, it presents the diff between the index and the working tree file and asks you if you want to stage the change of each hunk. You can select one of the following options and type return: y - stage this hunk n - do not stage this hunk q - quit; do not stage this hunk or any of the remaining ones a - stage this hunk and all later hunks in the file d - do not stage this hunk or any of the later hunks in the file g - select a hunk to go to / - search for a hunk matching the given regex j - leave this hunk undecided, see next undecided hunk J - leave this hunk undecided, see next hunk k - leave this hunk undecided, see previous undecided hunk K - leave this hunk undecided, see previous hunk s - split the current hunk into smaller hunks e - manually edit the current hunk p - print the current hunk ? - print help After deciding the fate for all hunks, if there is any hunk that was chosen, the index is updated with the selected hunks. You can omit having to type return here, by setting the configuration variable interactive.singleKey to true.\n**diff**: This lets you review what will be committed (i.e. between HEAD and index).",
        "code_examples": [
          "```bash\n*** Commands ***\n      1: status       2: update       3: revert       4: add untracked\n      5: patch        6: diff         7: quit         8: help\n    What now> 1\n```",
          "```bash\nstaged     unstaged path\n     1:       binary      nothing foo.png\n     2:     +403/-35        +1/-1 add-interactive.c\n```",
          "```bash\nstaged     unstaged path\n  1:       binary      nothing foo.png\n* 2:     +403/-35        +1/-1 add-interactive.c\n```",
          "```bash\nUpdate>> -2\n```",
          "```bash\ny - stage this hunk\nn - do not stage this hunk\nq - quit; do not stage this hunk or any of the remaining ones\na - stage this hunk and all later hunks in the file\nd - do not stage this hunk or any of the later hunks in the file\ng - select a hunk to go to\n/ - search for a hunk matching the given regex\nj - leave this hunk undecided, see next undecided hunk\nJ - leave this hunk undecided, see next hunk\nk - leave this hunk undecided, see previous undecided hunk\nK - leave this hunk undecided, see previous hunk\ns - split the current hunk into smaller hunks\ne - manually edit the current hunk\np - print the current hunk\n? - print help\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 16,
          "content_length": 5840
        }
      },
      {
        "header": "EDITING PATCHES",
        "content": "Invoking git add -e or selecting e from the interactive hunk selector will open a patch in your editor; after the editor exits, the result is applied to the index. You are free to make arbitrary changes to the patch, but note that some changes may have confusing results, or even result in a patch that cannot be applied. If you want to abort the operation entirely (i.e., stage nothing new in the index), simply delete all lines of the patch. The list below describes some common things you may see in a patch, and which editing operations make sense on them.\n\nAdded content is represented by lines beginning with \"+\". You can prevent staging any addition lines by deleting them.\n\nRemoved content is represented by lines beginning with \"-\". You can prevent staging their removal by converting the \"-\" to a \" \" (space).\n\nModified content is represented by \"-\" lines (removing the old content) followed by \"+\" lines (adding the replacement content). You can prevent staging the modification by converting \"-\" lines to \" \", and removing \"+\" lines. Beware that modifying only half of the pair is likely to introduce confusing changes to the index.\n\nThere are also more complex operations that can be performed. But beware that because the patch is applied only to the index and not the working tree, the working tree will appear to \"undo\" the change in the index. For example, introducing a new line into the index that is in neither the HEAD nor the working tree will stage the new line for commit, but the line will appear to be reverted in the working tree.\n\nAvoid using these constructs, or do so with extreme caution.\n\nContent which does not differ between the index and working tree may be shown on context lines, beginning with a \" \" (space). You can stage context lines for removal by converting the space to a \"-\". The resulting working tree file will appear to re-add the content.\n\nOne can also modify context lines by staging them for removal (by converting \" \" to \"-\") and adding a \"+\" line with the new content. Similarly, one can modify \"+\" lines for existing additions or modifications. In all cases, the new modification will appear reverted in the working tree.\n\nYou may also add new content that does not exist in the patch; simply add new lines, each starting with \"+\". The addition will appear reverted in the working tree.\n\nThere are also several operations which should be avoided entirely, as they will make the patch impossible to apply:\n\nadding context (\" \") or removal (\"-\") lines\n\ndeleting context or removal lines\n\nmodifying the contents of context or removal lines\n\n• adding context (\" \") or removal (\"-\") lines\n• deleting context or removal lines\n• modifying the contents of context or removal lines\n\n**added content**: Added content is represented by lines beginning with \"+\". You can prevent staging any addition lines by deleting them.\n**removed content**: Removed content is represented by lines beginning with \"-\". You can prevent staging their removal by converting the \"-\" to a \" \" (space).\n**modified content**: Modified content is represented by \"-\" lines (removing the old content) followed by \"+\" lines (adding the replacement content). You can prevent staging the modification by converting \"-\" lines to \" \", and removing \"+\" lines. Beware that modifying only half of the pair is likely to introduce confusing changes to the index.\n**removing untouched content**: Content which does not differ between the index and working tree may be shown on context lines, beginning with a \" \" (space). You can stage context lines for removal by converting the space to a \"-\". The resulting working tree file will appear to re-add the content.\n**modifying existing content**: One can also modify context lines by staging them for removal (by converting \" \" to \"-\") and adding a \"+\" line with the new content. Similarly, one can modify \"+\" lines for existing additions or modifications. In all cases, the new modification will appear reverted in the working tree.\n**new content**: You may also add new content that does not exist in the patch; simply add new lines, each starting with \"+\". The addition will appear reverted in the working tree.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 13,
          "content_length": 4169
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Everything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there:\n\nTells git add to continue adding files when some files cannot be added due to indexing errors. Equivalent to the --ignore-errors option. add.ignore-errors is deprecated, as it does not follow the usual naming convention for configuration variables.\n\n**add.ignoreErrors**: Tells git add to continue adding files when some files cannot be added due to indexing errors. Equivalent to the --ignore-errors option. add.ignore-errors is deprecated, as it does not follow the usual naming convention for configuration variables.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 673
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-status[1] git-rm[1] git-reset[1] git-mv[1] git-commit[1] git-update-index[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 80
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-add",
    "doc_type": "git",
    "total_sections": 9
  },
  {
    "title": "Git",
    "summary": "NAME git-am - Apply a series of patches from a mailbox\n\nSYNOPSIS git am [--signoff] [--keep] [--[no-]keep-cr] [--[no-]utf8] [--no-verify] [--[no-]3way] [--interactive] [--committer-date-is-author-date] [--ignore-date] [--ignore-space-change | --ignore-whitespace] [--whitespace=<action>] [-C<n>] [-p<n>] [--directory=<dir>] [--exclude=<path>] [--include=<path>] [--reject] [-q | --quiet] [--[no-]scissors] [-S[<keyid>]] [--patch-format=<format>] [--quoted-cr=<action>] [--empty=(stop|drop|keep)] [(<m",
    "sections": [
      {
        "header": "NAME",
        "content": "git-am - Apply a series of patches from a mailbox",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 49
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Splits mail messages in a mailbox into commit log messages, authorship information, and patches, and applies them to the current branch. You could think of it as a reverse operation of git-format-patch[1] run on a branch with a straight history without merges.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 260
        }
      },
      {
        "header": "OPTIONS",
        "content": "The list of mailbox files to read patches from. If you do not supply this argument, the command reads from the standard input. If you supply directories, they will be treated as Maildirs.\n\nAdd a Signed-off-by trailer to the commit message, using the committer identity of yourself. See the signoff option in git-commit[1] for more information.\n\nPass -k flag to git mailinfo (see git-mailinfo[1]).\n\nPass -b flag to git mailinfo (see git-mailinfo[1]).\n\nWith --keep-cr, call git mailsplit (see git-mailsplit[1]) with the same option, to prevent it from stripping CR at the end of lines. am.keepcr configuration variable can be used to specify the default behaviour. --no-keep-cr is useful to override am.keepcr.\n\nRemove everything in body before a scissors line (see git-mailinfo[1]). Can be activated by default using the mailinfo.scissors configuration variable.\n\nIgnore scissors lines (see git-mailinfo[1]).\n\nThis flag will be passed down to git mailinfo (see git-mailinfo[1]).\n\nHow to handle an e-mail message lacking a patch:\n\nThe e-mail message will be skipped.\n\nAn empty commit will be created, with the contents of the e-mail message as its log.\n\nThe command will fail, stopping in the middle of the current am session. This is the default behavior.\n\nPass the -m flag to git mailinfo (see git-mailinfo[1]), so that the Message-ID header is added to the commit message. The am.messageid configuration variable can be used to specify the default behaviour.\n\nDo not add the Message-ID header to the commit message. no-message-id is useful to override am.messageid.\n\nBe quiet. Only print error messages.\n\nPass -u flag to git mailinfo (see git-mailinfo[1]). The proposed commit log message taken from the e-mail is re-coded into UTF-8 encoding (configuration variable i18n.commitEncoding can be used to specify the project’s preferred encoding if it is not UTF-8).\n\nThis was optional in prior versions of git, but now it is the default. You can use --no-utf8 to override this.\n\nPass -n flag to git mailinfo (see git-mailinfo[1]).\n\nWhen the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. --no-3way can be used to override am.threeWay configuration variable. For more information, see am.threeWay in git-config[1].\n\nAfter the rerere mechanism reuses a recorded resolution on the current conflict to update the files in the working tree, allow it to also update the index with the result of resolution. --no-rerere-autoupdate is a good way to double-check what rerere did and catch potential mismerges, before committing the result to the index with a separate git add.\n\nThese flags are passed to the git apply (see git-apply[1]) program that applies the patch.\n\nValid <action> for the --whitespace option are: nowarn, warn, fix, error, and error-all.\n\nBy default the command will try to detect the patch format automatically. This option allows the user to bypass the automatic detection and specify the patch format that the patch(es) should be interpreted as. Valid formats are mbox, mboxrd, stgit, stgit-series, and hg.\n\nBy default, the pre-applypatch and applypatch-msg hooks are run. When any of --no-verify or -n is given, these are bypassed. See also githooks[5].\n\nBy default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the committer date by using the same value as the author date.\n\nBy default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the author date by using the same value as the committer date.\n\nSkip the current patch. This is only meaningful when restarting an aborted patch.\n\nGPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign.\n\nAfter a patch failure (e.g. attempting to apply conflicting patch), the user has applied it by hand and the index file stores the result of the application. Make a commit using the authorship and commit log extracted from the e-mail message and the current index file, and continue.\n\nWhen a patch failure occurs, <msg> will be printed to the screen before exiting. This overrides the standard message informing you to use --continue or --skip to handle the failure. This is solely for internal use between git rebase and git am.\n\nRestore the original branch and abort the patching operation. Revert the contents of files involved in the am operation to their pre-am state.\n\nAbort the patching operation but keep HEAD and the index untouched.\n\nTry to apply the last conflicting patch again. This is generally only useful for passing extra options to the retry attempt (e.g., --3way), since otherwise you’ll just see the same failure again.\n\nShow the message at which git am has stopped due to conflicts. If raw is specified, show the raw contents of the e-mail message; if diff, show the diff portion only. Defaults to raw.\n\nAfter a patch failure on an input e-mail message lacking a patch, create an empty commit with the contents of the e-mail message as its log message.\n\n**(<mbox>|<Maildir>)…**: The list of mailbox files to read patches from. If you do not supply this argument, the command reads from the standard input. If you supply directories, they will be treated as Maildirs.\n**-s**: Add a Signed-off-by trailer to the commit message, using the committer identity of yourself. See the signoff option in git-commit[1] for more information.\n**--signoff**: Pass -k flag to git mailinfo (see git-mailinfo[1]).\n**-k**: Pass -b flag to git mailinfo (see git-mailinfo[1]).\n**--keep**: With --keep-cr, call git mailsplit (see git-mailsplit[1]) with the same option, to prevent it from stripping CR at the end of lines. am.keepcr configuration variable can be used to specify the default behaviour. --no-keep-cr is useful to override am.keepcr.\n**--keep-non-patch**: Remove everything in body before a scissors line (see git-mailinfo[1]). Can be activated by default using the mailinfo.scissors configuration variable.\n**--[no-]keep-cr**: Ignore scissors lines (see git-mailinfo[1]).\n**-c**: This flag will be passed down to git mailinfo (see git-mailinfo[1]).\n**--scissors**: How to handle an e-mail message lacking a patch: drop The e-mail message will be skipped. keep An empty commit will be created, with the contents of the e-mail message as its log. stop The command will fail, stopping in the middle of the current am session. This is the default behavior.\n**--no-scissors**: The e-mail message will be skipped.\n**--quoted-cr=<action>**: An empty commit will be created, with the contents of the e-mail message as its log.\n**--empty=(drop|keep|stop)**: The command will fail, stopping in the middle of the current am session. This is the default behavior.\n**drop**: Pass the -m flag to git mailinfo (see git-mailinfo[1]), so that the Message-ID header is added to the commit message. The am.messageid configuration variable can be used to specify the default behaviour.\n**keep**: Do not add the Message-ID header to the commit message. no-message-id is useful to override am.messageid.\n**stop**: Be quiet. Only print error messages.\n**-m**: Pass -u flag to git mailinfo (see git-mailinfo[1]). The proposed commit log message taken from the e-mail is re-coded into UTF-8 encoding (configuration variable i18n.commitEncoding can be used to specify the project’s preferred encoding if it is not UTF-8). This was optional in prior versions of git, but now it is the default. You can use --no-utf8 to override this.\n**--message-id**: Pass -n flag to git mailinfo (see git-mailinfo[1]).\n**--no-message-id**: When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. --no-3way can be used to override am.threeWay configuration variable. For more information, see am.threeWay in git-config[1].\n**-q**: After the rerere mechanism reuses a recorded resolution on the current conflict to update the files in the working tree, allow it to also update the index with the result of resolution. --no-rerere-autoupdate is a good way to double-check what rerere did and catch potential mismerges, before committing the result to the index with a separate git add.\n**--quiet**: These flags are passed to the git apply (see git-apply[1]) program that applies the patch. Valid <action> for the --whitespace option are: nowarn, warn, fix, error, and error-all.\n**-u**: By default the command will try to detect the patch format automatically. This option allows the user to bypass the automatic detection and specify the patch format that the patch(es) should be interpreted as. Valid formats are mbox, mboxrd, stgit, stgit-series, and hg.\n**--utf8**: Run interactively.\n**--no-utf8**: By default, the pre-applypatch and applypatch-msg hooks are run. When any of --no-verify or -n is given, these are bypassed. See also githooks[5].\n**-3**: By default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the committer date by using the same value as the author date.\n**--3way**: By default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the author date by using the same value as the committer date.\n**--no-3way**: Skip the current patch. This is only meaningful when restarting an aborted patch.\n**--rerere-autoupdate**: GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign.\n**--no-rerere-autoupdate**: After a patch failure (e.g. attempting to apply conflicting patch), the user has applied it by hand and the index file stores the result of the application. Make a commit using the authorship and commit log extracted from the e-mail message and the current index file, and continue.\n**--ignore-space-change**: When a patch failure occurs, <msg> will be printed to the screen before exiting. This overrides the standard message informing you to use --continue or --skip to handle the failure. This is solely for internal use between git rebase and git am.\n**--ignore-whitespace**: Restore the original branch and abort the patching operation. Revert the contents of files involved in the am operation to their pre-am state.\n**--whitespace=<action>**: Abort the patching operation but keep HEAD and the index untouched.\n**-C<n>**: Try to apply the last conflicting patch again. This is generally only useful for passing extra options to the retry attempt (e.g., --3way), since otherwise you’ll just see the same failure again.\n**-p<n>**: Show the message at which git am has stopped due to conflicts. If raw is specified, show the raw contents of the e-mail message; if diff, show the diff portion only. Defaults to raw.\n**--directory=<dir>**: After a patch failure on an input e-mail message lacking a patch, create an empty commit with the contents of the e-mail message as its log message.\n**drop**: The e-mail message will be skipped.\n**keep**: An empty commit will be created, with the contents of the e-mail message as its log.\n**stop**: The command will fail, stopping in the middle of the current am session. This is the default behavior.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 35,
          "content_length": 11840
        }
      },
      {
        "header": "DISCUSSION",
        "content": "The commit author name is taken from the \"From: \" line of the message, and commit author date is taken from the \"Date: \" line of the message. The \"Subject: \" line is used as the title of the commit, after stripping common prefix \"[PATCH <anything>]\". The \"Subject: \" line is supposed to concisely describe what the commit is about in one line of text.\n\n\"From: \", \"Date: \", and \"Subject: \" lines starting the body override the respective commit author name and title values taken from the headers.\n\nThe commit message is formed by the title taken from the \"Subject: \", a blank line and the body of the message up to where the patch begins. Excess whitespace at the end of each line is automatically stripped.\n\nThe patch is expected to be inline, directly following the message. Any line that is of the form:\n\nthree-dashes and end-of-line, or\n\na line that begins with \"diff -\", or\n\na line that begins with \"Index: \"\n\nis taken as the beginning of a patch, and the commit log message is terminated before the first occurrence of such a line.\n\nWhen initially invoking git am, you give it the names of the mailboxes to process. Upon seeing the first patch that does not apply, it aborts in the middle. You can recover from this in one of two ways:\n\nskip the current patch by re-running the command with the --skip option.\n\nhand resolve the conflict in the working directory, and update the index file to bring it into a state that the patch should have produced. Then run the command with the --continue option.\n\nThe command refuses to process new mailboxes until the current operation is finished, so if you decide to start over from scratch, run git am --abort before running the command with mailbox names.\n\nBefore any patches are applied, ORIG_HEAD is set to the tip of the current branch. This is useful if you have problems with multiple commits, like running git am on the wrong branch or an error in the commits that is more easily fixed by changing the mailbox (e.g. errors in the \"From:\" lines).\n\n• three-dashes and end-of-line, or\n• a line that begins with \"diff -\", or\n• a line that begins with \"Index: \"\n\n• skip the current patch by re-running the command with the --skip option.\n• hand resolve the conflict in the working directory, and update the index file to bring it into a state that the patch should have produced. Then run the command with the --continue option.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 13,
          "content_length": 2377
        }
      },
      {
        "header": "HOOKS",
        "content": "This command can run applypatch-msg, pre-applypatch, and post-applypatch hooks. See githooks[5] for more information.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 117
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Everything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there:\n\nIf true, git-am will call git-mailsplit for patches in mbox format with parameter --keep-cr. In this case git-mailsplit will not remove \\r from lines ending with \\r\\n. Can be overridden by giving --no-keep-cr from the command line. See git-am[1], git-mailsplit[1].\n\nBy default, git am will fail if the patch does not apply cleanly. When set to true, this setting tells git am to fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally (equivalent to giving the --3way option from the command line). Defaults to false. See git-am[1].\n\n**am.keepcr**: If true, git-am will call git-mailsplit for patches in mbox format with parameter --keep-cr. In this case git-mailsplit will not remove \\r from lines ending with \\r\\n. Can be overridden by giving --no-keep-cr from the command line. See git-am[1], git-mailsplit[1].\n**am.threeWay**: By default, git am will fail if the patch does not apply cleanly. When set to true, this setting tells git am to fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally (equivalent to giving the --3way option from the command line). Defaults to false. See git-am[1].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1412
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-apply[1], git-format-patch[1].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 34
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-am",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "Git",
    "summary": "NAME git-archive - Create an archive of files from a named tree\n\ngit-archive - Create an archive of files from a named tree",
    "sections": [
      {
        "header": "NAME",
        "content": "git-archive - Create an archive of files from a named tree",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 58
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Creates an archive of the specified format containing the tree structure for the named tree, and writes it out to the standard output. If <prefix> is specified it is prepended to the filenames in the archive.\n\ngit archive behaves differently when given a tree ID as opposed to a commit ID or tag ID. When a tree ID is provided, the current time is used as the modification time of each file in the archive. On the other hand, when a commit ID or tag ID is provided, the commit time as recorded in the referenced commit object is used instead. Additionally the commit ID is stored in a global extended pax header if the tar format is used; it can be extracted using git get-tar-commit-id. In ZIP files it is stored as a file comment.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 732
        }
      },
      {
        "header": "OPTIONS",
        "content": "Format of the resulting archive. Possible values are tar, zip, tar.gz, tgz, and any format defined using the configuration option tar.<format>.command. If --format is not given, and the output file is specified, the format is inferred from the filename if possible (e.g. writing to foo.zip makes the output to be in the zip format). Otherwise the output format is tar.\n\nShow all available formats.\n\nReport progress to stderr.\n\nPrepend <prefix>/ to paths in the archive. Can be repeated; its rightmost value is used for all tracked files. See below which value gets used by --add-file.\n\nWrite the archive to <file> instead of stdout.\n\nAdd a non-tracked file to the archive. Can be repeated to add multiple files. The path of the file in the archive is built by concatenating the value of the last --prefix option (if any) before this --add-file and the basename of <file>.\n\nAdd the specified contents to the archive. Can be repeated to add multiple files.\n\nThe <path> argument can start and end with a literal double-quote character; the contained file name is interpreted as a C-style string, i.e. the backslash is interpreted as escape character. The path must be quoted if it contains a colon, to avoid the colon from being misinterpreted as the separator between the path and the contents, or if the path begins or ends with a double-quote character.\n\nThe file mode is limited to a regular file, and the option may be subject to platform-dependent command-line limits. For non-trivial cases, write an untracked file and use --add-file instead.\n\nNote that unlike --add-file the path created in the archive is not affected by the --prefix option, as a full <path> can be given as the value of the option.\n\nLook for attributes in .gitattributes files in the working tree as well (see ATTRIBUTES).\n\nSet modification time of archive entries. Without this option the committer time is used if <tree-ish> is a commit or tag, and the current time if it is a tree.\n\nThis can be any options that the archiver backend understands. See next section.\n\nInstead of making a tar archive from the local repository, retrieve a tar archive from a remote repository. Note that the remote repository may place restrictions on which sha1 expressions may be allowed in <tree-ish>. See git-upload-archive[1] for details.\n\nUsed with --remote to specify the path to the git-upload-archive on the remote side.\n\nThe tree or commit to produce an archive for.\n\nWithout an optional path parameter, all files and subdirectories of the current working directory are included in the archive. If one or more paths are specified, only these are included.\n\n**--format=<fmt>**: Format of the resulting archive. Possible values are tar, zip, tar.gz, tgz, and any format defined using the configuration option tar.<format>.command. If --format is not given, and the output file is specified, the format is inferred from the filename if possible (e.g. writing to foo.zip makes the output to be in the zip format). Otherwise the output format is tar.\n**-l**: Show all available formats.\n**--list**: Report progress to stderr.\n**-v**: Prepend <prefix>/ to paths in the archive. Can be repeated; its rightmost value is used for all tracked files. See below which value gets used by --add-file.\n**--verbose**: Write the archive to <file> instead of stdout.\n**--prefix=<prefix>/**: Add a non-tracked file to the archive. Can be repeated to add multiple files. The path of the file in the archive is built by concatenating the value of the last --prefix option (if any) before this --add-file and the basename of <file>.\n**-o <file>**: Add the specified contents to the archive. Can be repeated to add multiple files. The <path> argument can start and end with a literal double-quote character; the contained file name is interpreted as a C-style string, i.e. the backslash is interpreted as escape character. The path must be quoted if it contains a colon, to avoid the colon from being misinterpreted as the separator between the path and the contents, or if the path begins or ends with a double-quote character. The file mode is limited to a regular file, and the option may be subject to platform-dependent command-line limits. For non-trivial cases, write an untracked file and use --add-file instead. Note that unlike --add-file the path created in the archive is not affected by the --prefix option, as a full <path> can be given as the value of the option.\n**--output=<file>**: Look for attributes in .gitattributes files in the working tree as well (see ATTRIBUTES).\n**--add-file=<file>**: Set modification time of archive entries. Without this option the committer time is used if <tree-ish> is a commit or tag, and the current time if it is a tree.\n**--add-virtual-file=<path>:<content>**: This can be any options that the archiver backend understands. See next section.\n**--worktree-attributes**: Instead of making a tar archive from the local repository, retrieve a tar archive from a remote repository. Note that the remote repository may place restrictions on which sha1 expressions may be allowed in <tree-ish>. See git-upload-archive[1] for details.\n**--mtime=<time>**: Used with --remote to specify the path to the git-upload-archive on the remote side.\n**<extra>**: The tree or commit to produce an archive for.\n**--remote=<repo>**: Without an optional path parameter, all files and subdirectories of the current working directory are included in the archive. If one or more paths are specified, only these are included.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 17,
          "content_length": 5496
        }
      },
      {
        "header": "zip",
        "content": "Specify compression level. Larger values allow the command to spend more time to compress to smaller size. Supported values are from -0 (store-only) to -9 (best ratio). Default is -6 if not given.\n\n**-<digit>**: Specify compression level. Larger values allow the command to spend more time to compress to smaller size. Supported values are from -0 (store-only) to -9 (best ratio). Default is -6 if not given.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 408
        }
      },
      {
        "header": "tar",
        "content": "Specify compression level. The value will be passed to the compression command configured in tar.<format>.command. See manual page of the configured command for the list of supported levels and the default level if this option isn’t specified.\n\n**-<number>**: Specify compression level. The value will be passed to the compression command configured in tar.<format>.command. See manual page of the configured command for the list of supported levels and the default level if this option isn’t specified.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 503
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value \"user\" indicates that the archiving user’s umask will be used instead. See umask(2) for details. If --remote is used then only the configuration of the remote repository takes effect.\n\nThis variable specifies a shell command through which the tar output generated by git archive should be piped. The command is executed using the shell with the generated tar file on its standard input, and should produce the final output on its standard output. Any compression-level options will be passed to the command (e.g., -9).\n\nThe tar.gz and tgz formats are defined automatically and use the magic command git archive gzip by default, which invokes an internal implementation of gzip.\n\nIf true, enable the format for use by remote clients via git-upload-archive[1]. Defaults to false for user-defined formats, but true for the tar.gz and tgz formats.\n\n**tar.umask**: This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value \"user\" indicates that the archiving user’s umask will be used instead. See umask(2) for details. If --remote is used then only the configuration of the remote repository takes effect.\n**tar.<format>.command**: This variable specifies a shell command through which the tar output generated by git archive should be piped. The command is executed using the shell with the generated tar file on its standard input, and should produce the final output on its standard output. Any compression-level options will be passed to the command (e.g., -9). The tar.gz and tgz formats are defined automatically and use the magic command git archive gzip by default, which invokes an internal implementation of gzip.\n**tar.<format>.remote**: If true, enable the format for use by remote clients via git-upload-archive[1]. Defaults to false for user-defined formats, but true for the tar.gz and tgz formats.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 2067
        }
      },
      {
        "header": "ATTRIBUTES",
        "content": "Files and directories with the attribute export-ignore won’t be added to archive files. See gitattributes[5] for details.\n\nIf the attribute export-subst is set for a file then Git will expand several placeholders when adding this file to an archive. See gitattributes[5] for details.\n\nNote that attributes are by default taken from the .gitattributes files in the tree that is being archived. If you want to tweak the way the output is generated after the fact (e.g. you committed without adding an appropriate export-ignore in its .gitattributes), adjust the checked out .gitattributes file as necessary and use --worktree-attributes option. Alternatively you can keep necessary attributes that should apply while archiving any tree in your $GIT_DIR/info/attributes file.\n\n**export-ignore**: Files and directories with the attribute export-ignore won’t be added to archive files. See gitattributes[5] for details.\n**export-subst**: If the attribute export-subst is set for a file then Git will expand several placeholders when adding this file to an archive. See gitattributes[5] for details.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1093
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Create a tar archive that contains the contents of the latest commit on the current branch, and extract it in the /var/tmp/junk directory.\n\nCreate a compressed tarball for v1.4.0 release.\n\nSame as above, but using the builtin tar.gz handling.\n\nSame as above, but the format is inferred from the output file.\n\nCreate a compressed tarball for v1.4.0 release, but without a global extended pax header.\n\nPut everything in the current head’s Documentation/ directory into git-1.4.0-docs.zip, with the prefix git-docs/.\n\nCreate a Zip archive that contains the contents of the latest commit on the current branch. Note that the output format is inferred by the extension of the output file.\n\nCreates a tar archive that contains the contents of the latest commit on the current branch with no prefix and the untracked file configure with the prefix build/.\n\nConfigure a \"tar.xz\" format for making LZMA-compressed tarfiles. You can use it specifying --format=tar.xz, or by creating an output file like -o foo.tar.xz.\n\n**git archive --format=tar --prefix=junk/ HEAD | (cd /var/tmp/ && tar xf -)**: Create a tar archive that contains the contents of the latest commit on the current branch, and extract it in the /var/tmp/junk directory.\n**git archive --format=tar --prefix=git-1.4.0/ v1.4.0 | gzip >git-1.4.0.tar.gz**: Create a compressed tarball for v1.4.0 release.\n**git archive --format=tar.gz --prefix=git-1.4.0/ v1.4.0 >git-1.4.0.tar.gz**: Same as above, but using the builtin tar.gz handling.\n**git archive --prefix=git-1.4.0/ -o git-1.4.0.tar.gz v1.4.0**: Same as above, but the format is inferred from the output file.\n**git archive --format=tar --prefix=git-1.4.0/ v1.4.0^{tree} | gzip >git-1.4.0.tar.gz**: Create a compressed tarball for v1.4.0 release, but without a global extended pax header.\n**git archive --format=zip --prefix=git-docs/ HEAD:Documentation/ > git-1.4.0-docs.zip**: Put everything in the current head’s Documentation/ directory into git-1.4.0-docs.zip, with the prefix git-docs/.\n**git archive -o latest.zip HEAD**: Create a Zip archive that contains the contents of the latest commit on the current branch. Note that the output format is inferred by the extension of the output file.\n**git archive -o latest.tar --prefix=build/ --add-file=configure --prefix= HEAD**: Creates a tar archive that contains the contents of the latest commit on the current branch with no prefix and the untracked file configure with the prefix build/.\n**git config tar.tar.xz.command \"xz -c\"**: Configure a \"tar.xz\" format for making LZMA-compressed tarfiles. You can use it specifying --format=tar.xz, or by creating an output file like -o foo.tar.xz.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 2652
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-archive",
    "doc_type": "git",
    "total_sections": 9
  },
  {
    "title": "Git",
    "summary": "NAME git-bisect - Use binary search to find the commit that introduced a bug\n\ngit-bisect - Use binary search to find the commit that introduced a bug",
    "sections": [
      {
        "header": "NAME",
        "content": "git-bisect - Use binary search to find the commit that introduced a bug",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 71
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "The command takes various subcommands, and different options depending on the subcommand:\n\nThis command uses a binary search algorithm to find which commit in your project’s history introduced a bug. You use it by first telling it a \"bad\" commit that is known to contain the bug, and a \"good\" commit that is known to be before the bug was introduced. Then git bisect picks a commit between those two endpoints and asks you whether the selected commit is \"good\" or \"bad\". It continues narrowing down the range until it finds the exact commit that introduced the change.\n\nIn fact, git bisect can be used to find the commit that changed any property of your project; e.g., the commit that fixed a bug, or the commit that caused a benchmark’s performance to improve. To support this more general usage, the terms \"old\" and \"new\" can be used in place of \"good\" and \"bad\", or you can choose your own terms. See section \"Alternate terms\" below for more information.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit bisect start [--term-(bad|new)=<term-new> --term-(good|old)=<term-old>]\n\t  [--no-checkout] [--first-parent] [<bad> [<good>...]] [--] [<pathspec>...]\ngit bisect (bad|new|<term-new>) [<rev>]\ngit bisect (good|old|<term-old>) [<rev>...]\ngit bisect terms [--term-(good|old) | --term-(bad|new)]\ngit bisect skip [(<rev>|<range>)...]\ngit bisect reset [<commit>]\ngit bisect (visualize|view)\ngit bisect replay <logfile>\ngit bisect log\ngit bisect run <cmd> [<arg>...]\ngit bisect help\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 958
        }
      },
      {
        "header": "Basic bisect commands: start, bad, good",
        "content": "As an example, suppose you are trying to find the commit that broke a feature that was known to work in version v2.6.13-rc2 of your project. You start a bisect session as follows:\n\nOnce you have specified at least one bad and one good commit, git bisect selects a commit in the middle of that range of history, checks it out, and outputs something similar to the following:\n\nYou should now compile the checked-out version and test it. If that version works correctly, type\n\nIf that version is broken, type\n\nThen git bisect will respond with something like\n\nKeep repeating the process: compile the tree, test it, and depending on whether it is good or bad run git bisect good or git bisect bad to ask for the next commit that needs testing.\n\nEventually there will be no more revisions left to inspect, and the command will print out a description of the first bad commit. The reference refs/bisect/bad will be left pointing at that commit.",
        "code_examples": [
          "```bash\nBisecting: 675 revisions left to test after this (roughly 10 steps)\n```",
          "```bash\nBisecting: 337 revisions left to test after this (roughly 9 steps)\n```"
        ],
        "usage_examples": [
          "```bash\n$ git bisect start\n$ git bisect bad                 # Current version is bad\n$ git bisect good v2.6.13-rc2    # v2.6.13-rc2 is known to be good\n```",
          "```bash\n$ git bisect good\n```",
          "```bash\n$ git bisect bad\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 938
        }
      },
      {
        "header": "Bisect reset",
        "content": "After a bisect session, to clean up the bisection state and return to the original HEAD, issue the following command:\n\nBy default, this will return your tree to the commit that was checked out before git bisect start. (A new git bisect start will also do that, as it cleans up the old bisection state.)\n\nWith an optional argument, you can return to a different commit instead:\n\nFor example, git bisect reset bisect/bad will check out the first bad revision, while git bisect reset HEAD will leave you on the current bisection commit and avoid switching commits at all.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git bisect reset\n```",
          "```bash\n$ git bisect reset<commit>\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 568
        }
      },
      {
        "header": "Alternate terms",
        "content": "Sometimes you are not looking for the commit that introduced a breakage, but rather for a commit that caused a change between some other \"old\" state and \"new\" state. For example, you might be looking for the commit that introduced a particular fix. Or you might be looking for the first commit in which the source-code filenames were finally all converted to your company’s naming standard. Or whatever.\n\nIn such cases it can be very confusing to use the terms \"good\" and \"bad\" to refer to \"the state before the change\" and \"the state after the change\". So instead, you can use the terms \"old\" and \"new\", respectively, in place of \"good\" and \"bad\". (But note that you cannot mix \"good\" and \"bad\" with \"old\" and \"new\" in a single session.)\n\nIn this more general usage, you provide git bisect with a \"new\" commit that has some property and an \"old\" commit that doesn’t have that property. Each time git bisect checks out a commit, you test if that commit has the property. If it does, mark the commit as \"new\"; otherwise, mark it as \"old\". When the bisection is done, git bisect will report which commit introduced the property.\n\nTo use \"old\" and \"new\" instead of \"good\" and bad, you must run git bisect start without commits as argument and then run the following commands to add the commits:\n\nto indicate that a commit was before the sought change, or\n\nto indicate that it was after.\n\nTo get a reminder of the currently used terms, use\n\nYou can get just the old term with git bisect terms --term-old or git bisect terms --term-good; git bisect terms --term-new and git bisect terms --term-bad can be used to learn how to call the commits more recent than the sought change.\n\nIf you would like to use your own terms instead of \"bad\"/\"good\" or \"new\"/\"old\", you can choose any names you like (except existing bisect subcommands like reset, start, …) by starting the bisection using\n\nFor example, if you are looking for a commit that introduced a performance regression, you might use\n\nOr if you are looking for the commit that fixed a bug, you might use\n\nThen, use git bisect <term-old> and git bisect <term-new> instead of git bisect good and git bisect bad to mark commits.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit bisect old [<rev>]\n```",
          "```bash\ngit bisect new [<rev>...]\n```",
          "```bash\ngit bisect terms\n```",
          "```bash\ngit bisect start --term-old <term-old> --term-new <term-new>\n```",
          "```bash\ngit bisect start --term-old fast --term-new slow\n```",
          "```bash\ngit bisect start --term-new fixed --term-old broken\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 12,
          "content_length": 2172
        }
      },
      {
        "header": "Bisect visualize/view",
        "content": "To see the currently remaining suspects in gitk, issue the following command during the bisection process (the subcommand view can be used as an alternative to visualize):\n\nGit detects a graphical environment through various environment variables: DISPLAY, which is set in X Window System environments on Unix systems. SESSIONNAME, which is set under Cygwin in interactive desktop sessions. MSYSTEM, which is set under Msys2 and Git for Windows. SECURITYSESSIONID, which may be set on macOS in interactive desktop sessions.\n\nIf none of these environment variables is set, git log is used instead. You can also give command-line options such as -p and --stat.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git bisect visualize\n```",
          "```bash\n$ git bisect visualize --stat\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 658
        }
      },
      {
        "header": "Bisect log and bisect replay",
        "content": "After having marked revisions as good or bad, issue the following command to show what has been done so far:\n\nIf you discover that you made a mistake in specifying the status of a revision, you can save the output of this command to a file, edit it to remove the incorrect entries, and then issue the following commands to return to a corrected state:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git bisect log\n```",
          "```bash\n$ git bisect reset\n$ git bisect replay that-file\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 351
        }
      },
      {
        "header": "Avoiding testing a commit",
        "content": "If, in the middle of a bisect session, you know that the suggested revision is not a good one to test (e.g. it fails to build and you know that the failure does not have anything to do with the bug you are chasing), you can manually select a nearby commit and test that one instead.\n\nThen compile and test the chosen revision, and afterwards mark the revision as good or bad in the usual manner.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git bisect good/bad\t\t\t# previous round was good or bad.\nBisecting: 337 revisions left to test after this (roughly 9 steps)\n$ git bisect visualize\t\t\t# oops, that is uninteresting.\n$ git reset --hard HEAD~3\t\t# try 3 revisions before what\n\t\t\t\t\t# was suggested\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 395
        }
      },
      {
        "header": "Bisect skip",
        "content": "Instead of choosing a nearby commit by yourself, you can ask Git to do it for you by issuing the command:\n\nHowever, if you skip a commit adjacent to the one you are looking for, Git will be unable to tell exactly which of those commits was the first bad one.\n\nYou can also skip a range of commits, instead of just one commit, using range notation. For example:\n\nThis tells the bisect process that no commit after v2.5, up to and including v2.6, should be tested.\n\nNote that if you also want to skip the first commit of the range you would issue the command:\n\nThis tells the bisect process that the commits between v2.5 and v2.6 (inclusive) should be skipped.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git bisect skip                 # Current version cannot be tested\n```",
          "```bash\n$ git bisect skip v2.5..v2.6\n```",
          "```bash\n$ git bisect skip v2.5 v2.5..v2.6\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 658
        }
      },
      {
        "header": "Cutting down bisection by giving more parameters to bisect start",
        "content": "You can further cut down the number of trials, if you know what part of the tree is involved in the problem you are tracking down, by specifying pathspec parameters when issuing the bisect start command:\n\nIf you know beforehand more than one good commit, you can narrow the bisect space down by specifying all of the good commits immediately after the bad commit when issuing the bisect start command:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git bisect start -- arch/i386 include/asm-i386\n```",
          "```bash\n$ git bisect start v2.6.20-rc6 v2.6.20-rc4 v2.6.20-rc1 --\n                   # v2.6.20-rc6 is bad\n                   # v2.6.20-rc4 and v2.6.20-rc1 are good\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 401
        }
      },
      {
        "header": "Bisect run",
        "content": "If you have a script that can tell if the current source code is good or bad, you can bisect by issuing the command:\n\nNote that the script (my_script in the above example) should exit with code 0 if the current source code is good/old, and exit with a code between 1 and 127 (inclusive), except 125, if the current source code is bad/new.\n\nAny other exit code will abort the bisect process. It should be noted that a program that terminates via exit(-1) leaves $? = 255, (see the exit(3) manual page), as the value is chopped with & 0377.\n\nThe special exit code 125 should be used when the current source code cannot be tested. If the script exits with this code, the current revision will be skipped (see git bisect skip above). 125 was chosen as the highest sensible value to use for this purpose, because 126 and 127 are used by POSIX shells to signal specific error status (127 is for command not found, 126 is for command found but not executable—these details do not matter, as they are normal errors in the script, as far as bisect run is concerned).\n\nYou may often find that during a bisect session you want to have temporary modifications (e.g. s/#define DEBUG 0/#define DEBUG 1/ in a header file, or \"revision that does not have this commit needs this patch applied to work around another problem this bisection is not interested in\") applied to the revision being tested.\n\nTo cope with such a situation, after the inner git bisect finds the next revision to test, the script can apply the patch before compiling, run the real test, and afterwards decide if the revision (possibly with the needed patch) passed the test and then rewind the tree to the pristine state. Finally the script should exit with the status of the real test to let the git bisect run command loop determine the eventual outcome of the bisect session.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git bisect run my_script arguments\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1834
        }
      },
      {
        "header": "OPTIONS",
        "content": "Do not checkout the new working tree at each iteration of the bisection process. Instead just update the reference named BISECT_HEAD to make it point to the commit that should be tested.\n\nThis option may be useful when the test you would perform in each step does not require a checked out tree.\n\nIf the repository is bare, --no-checkout is assumed.\n\nFollow only the first parent commit upon seeing a merge commit.\n\nIn detecting regressions introduced through the merging of a branch, the merge commit will be identified as introduction of the bug and its ancestors will be ignored.\n\nThis option is particularly useful in avoiding false positives when a merged branch contained broken or non-buildable commits, but the merge itself was OK.\n\n**--no-checkout**: Do not checkout the new working tree at each iteration of the bisection process. Instead just update the reference named BISECT_HEAD to make it point to the commit that should be tested. This option may be useful when the test you would perform in each step does not require a checked out tree. If the repository is bare, --no-checkout is assumed.\n**--first-parent**: Follow only the first parent commit upon seeing a merge commit. In detecting regressions introduced through the merging of a branch, the merge commit will be identified as introduction of the bug and its ancestors will be ignored. This option is particularly useful in avoiding false positives when a merged branch contained broken or non-buildable commits, but the merge itself was OK.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1514
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Automatically bisect a broken build between v1.2 and HEAD:\n\nAutomatically bisect a test failure between origin and HEAD:\n\nAutomatically bisect a broken test case:\n\nHere we use a test.sh custom script. In this script, if make fails, we skip the current commit. check_test_case.sh should exit 0 if the test case passes, and exit 1 otherwise.\n\nIt is safer if both test.sh and check_test_case.sh are outside the repository to prevent interactions between the bisect, make and test processes and the scripts.\n\nAutomatically bisect with temporary modifications (hot-fix):\n\nThis applies modifications from a hot-fix branch before each test run, e.g. in case your build or test environment changed so that older revisions may need a fix which newer ones have already. (Make sure the hot-fix branch is based off a commit which is contained in all revisions which you are bisecting, so that the merge does not pull in too much, or use git cherry-pick instead of git merge.)\n\nAutomatically bisect a broken test case:\n\nThis shows that you can do without a run script if you write the test on a single line.\n\nLocate a good region of the object graph in a damaged repository\n\nIn this case, when git bisect run finishes, bisect/bad will refer to a commit that has at least one parent whose reachable graph is fully traversable in the sense required by git pack objects.\n\nLook for a fix instead of a regression in the code\n\n• Automatically bisect a broken build between v1.2 and HEAD: $ git bisect start HEAD v1.2 -- # HEAD is bad, v1.2 is good $ git bisect run make # \"make\" builds the app $ git bisect reset # quit the bisect session\n• Automatically bisect a test failure between origin and HEAD: $ git bisect start HEAD origin -- # HEAD is bad, origin is good $ git bisect run make test # \"make test\" builds and tests $ git bisect reset # quit the bisect session\n• Automatically bisect a broken test case: $ cat ~/test.sh #!/bin/sh make || exit 125 # this skips broken builds ~/check_test_case.sh # does the test case pass? $ git bisect start HEAD HEAD~10 -- # culprit is among the last 10 $ git bisect run ~/test.sh $ git bisect reset # quit the bisect session Here we use a test.sh custom script. In this script, if make fails, we skip the current commit. check_test_case.sh should exit 0 if the test case passes, and exit 1 otherwise. It is safer if both test.sh and check_test_case.sh are outside the repository to prevent interactions between the bisect, make and test processes and the scripts.\n• Automatically bisect with temporary modifications (hot-fix): $ cat ~/test.sh #!/bin/sh # tweak the working tree by merging the hot-fix branch # and then attempt a build if git merge --no-commit --no-ff hot-fix && make then # run project specific test and report its status ~/check_test_case.sh status=$? else # tell the caller this is untestable status=125 fi # undo the tweak to allow clean flipping to the next commit git reset --hard # return control exit $status This applies modifications from a hot-fix branch before each test run, e.g. in case your build or test environment changed so that older revisions may need a fix which newer ones have already. (Make sure the hot-fix branch is based off a commit which is contained in all revisions which you are bisecting, so that the merge does not pull in too much, or use git cherry-pick instead of git merge.)\n• Automatically bisect a broken test case: $ git bisect start HEAD HEAD~10 -- # culprit is among the last 10 $ git bisect run sh -c \"make || exit 125; ~/check_test_case.sh\" $ git bisect reset # quit the bisect session This shows that you can do without a run script if you write the test on a single line.\n• Locate a good region of the object graph in a damaged repository $ git bisect start HEAD <known-good-commit> [ <boundary-commit> ... ] --no-checkout $ git bisect run sh -c ' GOOD=$(git for-each-ref \"--format=%(objectname)\" refs/bisect/good-*) && git rev-list --objects BISECT_HEAD --not $GOOD >tmp.$$ && git pack-objects --stdout >/dev/null <tmp.$$ rc=$? rm -f tmp.$$ test $rc = 0' $ git bisect reset # quit the bisect session In this case, when git bisect run finishes, bisect/bad will refer to a commit that has at least one parent whose reachable graph is fully traversable in the sense required by git pack objects.\n• Look for a fix instead of a regression in the code $ git bisect start $ git bisect new HEAD # current commit is marked as new $ git bisect old HEAD~10 # the tenth commit from now is marked as old or: $ git bisect start --term-old broken --term-new fixed $ git bisect fixed $ git bisect broken HEAD~10",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git bisect start HEAD v1.2 --      # HEAD is bad, v1.2 is good\n$ git bisect run make                # \"make\" builds the app\n$ git bisect reset                   # quit the bisect session\n```",
          "```bash\n$ git bisect start HEAD origin --    # HEAD is bad, origin is good\n$ git bisect run make test           # \"make test\" builds and tests\n$ git bisect reset                   # quit the bisect session\n```",
          "```bash\n$ cat ~/test.sh\n#!/bin/sh\nmake || exit 125                     # this skips broken builds\n~/check_test_case.sh                 # does the test case pass?\n$ git bisect start HEAD HEAD~10 --   # culprit is among the last 10\n$ git bisect run ~/test.sh\n$ git bisect reset                   # quit the bisect session\n```",
          "```bash\n$ cat ~/test.sh\n#!/bin/sh\n\n# tweak the working tree by merging the hot-fix branch\n# and then attempt a build\nif\tgit merge --no-commit --no-ff hot-fix &&\n\tmake\nthen\n\t# run project specific test and report its status\n\t~/check_test_case.sh\n\tstatus=$?\nelse\n\t# tell the caller this is untestable\n\tstatus=125\nfi\n\n# undo the tweak to allow clean flipping to the next commit\ngit reset --hard\n\n# return control\nexit $status\n```",
          "```bash\n$ git bisect start HEAD HEAD~10 --   # culprit is among the last 10\n$ git bisect run sh -c \"make || exit 125; ~/check_test_case.sh\"\n$ git bisect reset                   # quit the bisect session\n```",
          "```bash\n$ git bisect start HEAD <known-good-commit> [ <boundary-commit> ... ] --no-checkout\n$ git bisect run sh -c '\n\tGOOD=$(git for-each-ref \"--format=%(objectname)\" refs/bisect/good-*) &&\n\tgit rev-list --objects BISECT_HEAD --not $GOOD >tmp.$$ &&\n\tgit pack-objects --stdout >/dev/null <tmp.$$\n\trc=$?\n\trm -f tmp.$$\n\ttest $rc = 0'\n\n$ git bisect reset                   # quit the bisect session\n```",
          "```bash\n$ git bisect start\n$ git bisect new HEAD    # current commit is marked as new\n$ git bisect old HEAD~10 # the tenth commit from now is marked as old\n```",
          "```bash\n$ git bisect start --term-old broken --term-new fixed\n$ git bisect fixed\n$ git bisect broken HEAD~10\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 12,
          "content_length": 4584
        }
      },
      {
        "header": "Getting help",
        "content": "Use git bisect to get a short usage description, and git bisect help or git bisect -h to get a long usage description.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 118
        }
      },
      {
        "header": "SEE ALSO",
        "content": "Fighting regressions with git bisect, git-blame[1].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 51
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-bisect",
    "doc_type": "git",
    "total_sections": 16
  },
  {
    "title": "Git",
    "summary": "SYNOPSIS git branch [--color[=<when>] | --no-color] [--show-current] [-v [--abbrev=<n> | --no-abbrev]] [--column[=<options>] | --no-column] [--sort=<key>] [--merged [<commit>]] [--no-merged [<commit>]] [--contains [<commit>]] [--no-contains [<commit>]] [--points-at <object>] [--format=<format>] [(-r|--remotes) | (-a|--all)] [--list] [<pattern>…] git branch [--track[=(direct|inherit)] | --no-track] [-f] [--recurse-submodules] <branch-name> [<start-point>] git branch (--set-upstream-to=<upstream>|",
    "sections": [
      {
        "header": "NAME",
        "content": "git-branch - List, create, or delete branches",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 45
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "If --list is given, or if there are no non-option arguments, existing branches are listed; the current branch will be highlighted in green and marked with an asterisk. Any branches checked out in linked worktrees will be highlighted in cyan and marked with a plus sign. Option -r causes the remote-tracking branches to be listed, and option -a shows both local and remote branches.\n\nIf a <pattern> is given, it is used as a shell wildcard to restrict the output to matching branches. If multiple patterns are given, a branch is shown if it matches any of the patterns.\n\nNote that when providing a <pattern>, you must use --list; otherwise the command may be interpreted as branch creation.\n\nWith --contains, shows only the branches that contain the named commit (in other words, the branches whose tip commits are descendants of the named commit), --no-contains inverts it. With --merged, only branches merged into the named commit (i.e. the branches whose tip commits are reachable from the named commit) will be listed. With --no-merged only branches not merged into the named commit will be listed. If the <commit> argument is missing it defaults to HEAD (i.e. the tip of the current branch).\n\nThe command’s second form creates a new branch head named <branch-name> which points to the current HEAD, or <start-point> if given. As a special case, for <start-point>, you may use <rev-A>...<rev-B> as a shortcut for the merge base of <rev-A> and <rev-B> if there is exactly one merge base. You can leave out at most one of <rev-A> and <rev-B>, in which case it defaults to HEAD.\n\nNote that this will create the new branch, but it will not switch the working tree to it; use git switch <new-branch> to switch to the new branch.\n\nWhen a local branch is started off a remote-tracking branch, Git sets up the branch (specifically the branch.<name>.remote and branch.<name>.merge configuration entries) so that git pull will appropriately merge from the remote-tracking branch. This behavior may be changed via the global branch.autoSetupMerge configuration flag. That setting can be overridden by using the --track and --no-track options, and changed later using git branch --set-upstream-to.\n\nWith a -m or -M option, <old-branch> will be renamed to <new-branch>. If <old-branch> had a corresponding reflog, it is renamed to match <new-branch>, and a reflog entry is created to remember the branch renaming. If <new-branch> exists, -M must be used to force the rename to happen.\n\nThe -c and -C options have the exact same semantics as -m and -M, except instead of the branch being renamed, it will be copied to a new name, along with its config and reflog.\n\nWith a -d or -D option, <branch-name> will be deleted. You may specify more than one branch for deletion. If the branch currently has a reflog then the reflog will also be deleted.\n\nUse -r together with -d to delete remote-tracking branches. Note, that it only makes sense to delete remote-tracking branches if they no longer exist in the remote repository or if git fetch was configured not to fetch them again. See also the prune subcommand of git-remote[1] for a way to clean up all obsolete remote-tracking branches.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 11,
          "content_length": 3174
        }
      },
      {
        "header": "OPTIONS",
        "content": "Delete a branch. The branch must be fully merged in its upstream branch, or in HEAD if no upstream was set with --track or --set-upstream-to.\n\nShortcut for --delete --force.\n\nCreate the branch’s reflog. This activates recording of all changes made to the branch ref, enabling use of date based sha1 expressions such as <branch-name>@{yesterday}. Note that in non-bare repositories, reflogs are usually enabled by default by the core.logAllRefUpdates config option. The negated form --no-create-reflog only overrides an earlier --create-reflog, but currently does not negate the setting of core.logAllRefUpdates.\n\nReset <branch-name> to <start-point>, even if <branch-name> exists already. Without -f, git branch refuses to change an existing branch. In combination with -d (or --delete), allow deleting the branch irrespective of its merged status, or whether it even points to a valid commit. In combination with -m (or --move), allow renaming the branch even if the new branch name already exists, the same applies for -c (or --copy).\n\nNote that git branch -f <branch-name> [<start-point>], even with -f, refuses to change an existing branch <branch-name> that is checked out in another worktree linked to the same repository.\n\nMove/rename a branch, together with its config and reflog.\n\nShortcut for --move --force.\n\nCopy a branch, together with its config and reflog.\n\nShortcut for --copy --force.\n\nColor branches to highlight current, local, and remote-tracking branches. The value must be always (the default), never, or auto.\n\nTurn off branch colors, even when the configuration file gives the default to color output. Same as --color=never.\n\nSorting and filtering branches are case insensitive.\n\nDo not print a newline after formatted refs where the format expands to the empty string.\n\nDisplay branch listing in columns. See configuration variable column.branch for option syntax. --column and --no-column without options are equivalent to always and never respectively.\n\nThis option is only applicable in non-verbose mode.\n\nSort based on <key>. Prefix - to sort in descending order of the value. You may use the --sort=<key> option multiple times, in which case the last key becomes the primary key. The keys supported are the same as those in git-for-each-ref[1]. Sort order defaults to the value configured for the branch.sort variable if it exists, or to sorting based on the full refname (including refs/... prefix). This lists detached HEAD (if present) first, then local branches and finally remote-tracking branches. See git-config[1].\n\nList or delete (if used with -d) the remote-tracking branches. Combine with --list to match the optional pattern(s).\n\nList both remote-tracking branches and local branches. Combine with --list to match optional pattern(s).\n\nList branches. With optional <pattern>..., e.g. git branch --list maint-*', list only the branches that match the pattern(s).\n\nPrint the name of the current branch. In detached HEAD state, nothing is printed.\n\nWhen in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also git remote show <remote>). Note that the current worktree’s HEAD will not have its path printed (it will always be your current directory).\n\nBe more quiet when creating or deleting a branch, suppressing non-error messages.\n\nIn the verbose listing that show the commit object name, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. The default value is 7 and can be overridden by the core.abbrev config option.\n\nDisplay the full sha1s in the output listing rather than abbreviating them.\n\nWhen creating a new branch, set up branch.<name>.remote and branch.<name>.merge configuration entries to set \"upstream\" tracking configuration for the new branch. This configuration will tell git to show the relationship between the two branches in git status and git branch -v. Furthermore, it directs git pull without arguments to pull from the upstream when the new branch is checked out.\n\nThe exact upstream branch is chosen depending on the optional argument: -t, --track, or --track=direct means to use the start-point branch itself as the upstream; --track=inherit means to copy the upstream configuration of the start-point branch.\n\nThe branch.autoSetupMerge configuration variable specifies how git switch, git checkout and git branch should behave when neither --track nor --no-track are specified:\n\nThe default option, true, behaves as though --track=direct were given whenever the start-point is a remote-tracking branch. false behaves as if --no-track were given. always behaves as though --track=direct were given. inherit behaves as though --track=inherit were given. simple behaves as though --track=direct were given only when the <start-point> is a remote-tracking branch and the new branch has the same name as the remote branch.\n\nSee git-pull[1] and git-config[1] for additional discussion on how the branch.<name>.remote and branch.<name>.merge options are used.\n\nDo not set up \"upstream\" configuration, even if the branch.autoSetupMerge configuration variable is set.\n\nTHIS OPTION IS EXPERIMENTAL! Cause the current command to recurse into submodules if submodule.propagateBranches is enabled. See submodule.propagateBranches in git-config[1]. Currently, only branch creation is supported.\n\nWhen used in branch creation, a new branch <branch-name> will be created in the superproject and all of the submodules in the superproject’s <start-point>. In submodules, the branch will point to the submodule commit in the superproject’s <start-point> but the branch’s tracking information will be set up based on the submodule’s branches and remotes e.g. git branch --recurse-submodules topic origin/main will create the submodule branch \"topic\" that points to the submodule commit in the superproject’s \"origin/main\", but tracks the submodule’s \"origin/main\".\n\nAs this option had confusing syntax, it is no longer supported. Please use --track or --set-upstream-to instead.\n\nSet up <branch-name>'s tracking information so <upstream> is considered <branch-name>'s upstream branch. If no <branch-name> is specified, then it defaults to the current branch.\n\nRemove the upstream information for <branch-name>. If no branch is specified it defaults to the current branch.\n\nOpen an editor and edit the text to explain what the branch is for, to be used by various other commands (e.g. format-patch, request-pull, and merge (if enabled)). Multi-line explanations may be used.\n\nOnly list branches which contain <commit> (HEAD if not specified). Implies --list.\n\nOnly list branches which don’t contain <commit> (HEAD if not specified). Implies --list.\n\nOnly list branches whose tips are reachable from <commit> (HEAD if not specified). Implies --list.\n\nOnly list branches whose tips are not reachable from <commit> (HEAD if not specified). Implies --list.\n\nOnly list branches of <object>.\n\nA string that interpolates %(fieldname) from a branch ref being shown and the object it points at. <format> is the same as that of git-for-each-ref[1].\n\nThe name of the branch to create or delete. The new branch name must pass all checks defined by git-check-ref-format[1]. Some of these checks may restrict the characters allowed in a branch name.\n\nThe new branch head will point to this commit. It may be given as a branch name, a commit-id, or a tag. If this option is omitted, the current HEAD will be used instead.\n\nThe name of an existing branch. If this option is omitted, the name of the current branch will be used instead.\n\nThe new name for an existing branch. The same restrictions as for <branch-name> apply.\n\n**-d**: Delete a branch. The branch must be fully merged in its upstream branch, or in HEAD if no upstream was set with --track or --set-upstream-to.\n**--delete**: Shortcut for --delete --force.\n**-D**: Create the branch’s reflog. This activates recording of all changes made to the branch ref, enabling use of date based sha1 expressions such as <branch-name>@{yesterday}. Note that in non-bare repositories, reflogs are usually enabled by default by the core.logAllRefUpdates config option. The negated form --no-create-reflog only overrides an earlier --create-reflog, but currently does not negate the setting of core.logAllRefUpdates.\n**--create-reflog**: Reset <branch-name> to <start-point>, even if <branch-name> exists already. Without -f, git branch refuses to change an existing branch. In combination with -d (or --delete), allow deleting the branch irrespective of its merged status, or whether it even points to a valid commit. In combination with -m (or --move), allow renaming the branch even if the new branch name already exists, the same applies for -c (or --copy). Note that git branch -f <branch-name> [<start-point>], even with -f, refuses to change an existing branch <branch-name> that is checked out in another worktree linked to the same repository.\n**-f**: Move/rename a branch, together with its config and reflog.\n**--force**: Shortcut for --move --force.\n**-m**: Copy a branch, together with its config and reflog.\n**--move**: Shortcut for --copy --force.\n**-M**: Color branches to highlight current, local, and remote-tracking branches. The value must be always (the default), never, or auto.\n**-c**: Turn off branch colors, even when the configuration file gives the default to color output. Same as --color=never.\n**--copy**: Sorting and filtering branches are case insensitive.\n**-C**: Do not print a newline after formatted refs where the format expands to the empty string.\n**--color[=<when>]**: Display branch listing in columns. See configuration variable column.branch for option syntax. --column and --no-column without options are equivalent to always and never respectively. This option is only applicable in non-verbose mode.\n**--no-color**: Sort based on <key>. Prefix - to sort in descending order of the value. You may use the --sort=<key> option multiple times, in which case the last key becomes the primary key. The keys supported are the same as those in git-for-each-ref[1]. Sort order defaults to the value configured for the branch.sort variable if it exists, or to sorting based on the full refname (including refs/... prefix). This lists detached HEAD (if present) first, then local branches and finally remote-tracking branches. See git-config[1].\n**-i**: List or delete (if used with -d) the remote-tracking branches. Combine with --list to match the optional pattern(s).\n**--ignore-case**: List both remote-tracking branches and local branches. Combine with --list to match optional pattern(s).\n**--omit-empty**: List branches. With optional <pattern>..., e.g. git branch --list maint-*', list only the branches that match the pattern(s).\n**--column[=<options>]**: Print the name of the current branch. In detached HEAD state, nothing is printed.\n**--no-column**: When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also git remote show <remote>). Note that the current worktree’s HEAD will not have its path printed (it will always be your current directory).\n**--sort=<key>**: Be more quiet when creating or deleting a branch, suppressing non-error messages.\n**-r**: In the verbose listing that show the commit object name, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. The default value is 7 and can be overridden by the core.abbrev config option.\n**--remotes**: Display the full sha1s in the output listing rather than abbreviating them.\n**-a**: When creating a new branch, set up branch.<name>.remote and branch.<name>.merge configuration entries to set \"upstream\" tracking configuration for the new branch. This configuration will tell git to show the relationship between the two branches in git status and git branch -v. Furthermore, it directs git pull without arguments to pull from the upstream when the new branch is checked out. The exact upstream branch is chosen depending on the optional argument: -t, --track, or --track=direct means to use the start-point branch itself as the upstream; --track=inherit means to copy the upstream configuration of the start-point branch. The branch.autoSetupMerge configuration variable specifies how git switch, git checkout and git branch should behave when neither --track nor --no-track are specified: The default option, true, behaves as though --track=direct were given whenever the start-point is a remote-tracking branch. false behaves as if --no-track were given. always behaves as though --track=direct were given. inherit behaves as though --track=inherit were given. simple behaves as though --track=direct were given only when the <start-point> is a remote-tracking branch and the new branch has the same name as the remote branch. See git-pull[1] and git-config[1] for additional discussion on how the branch.<name>.remote and branch.<name>.merge options are used.\n**--all**: Do not set up \"upstream\" configuration, even if the branch.autoSetupMerge configuration variable is set.\n**-l**: THIS OPTION IS EXPERIMENTAL! Cause the current command to recurse into submodules if submodule.propagateBranches is enabled. See submodule.propagateBranches in git-config[1]. Currently, only branch creation is supported. When used in branch creation, a new branch <branch-name> will be created in the superproject and all of the submodules in the superproject’s <start-point>. In submodules, the branch will point to the submodule commit in the superproject’s <start-point> but the branch’s tracking information will be set up based on the submodule’s branches and remotes e.g. git branch --recurse-submodules topic origin/main will create the submodule branch \"topic\" that points to the submodule commit in the superproject’s \"origin/main\", but tracks the submodule’s \"origin/main\".\n**--list**: As this option had confusing syntax, it is no longer supported. Please use --track or --set-upstream-to instead.\n**--show-current**: Set up <branch-name>'s tracking information so <upstream> is considered <branch-name>'s upstream branch. If no <branch-name> is specified, then it defaults to the current branch.\n**-v**: Remove the upstream information for <branch-name>. If no branch is specified it defaults to the current branch.\n**-vv**: Open an editor and edit the text to explain what the branch is for, to be used by various other commands (e.g. format-patch, request-pull, and merge (if enabled)). Multi-line explanations may be used.\n**--verbose**: Only list branches which contain <commit> (HEAD if not specified). Implies --list.\n**-q**: Only list branches which don’t contain <commit> (HEAD if not specified). Implies --list.\n**--quiet**: Only list branches whose tips are reachable from <commit> (HEAD if not specified). Implies --list.\n**--abbrev=<n>**: Only list branches whose tips are not reachable from <commit> (HEAD if not specified). Implies --list.\n**--no-abbrev**: Only list branches of <object>.\n**-t**: A string that interpolates %(fieldname) from a branch ref being shown and the object it points at. <format> is the same as that of git-for-each-ref[1].\n**--track[=(direct|inherit)]**: The name of the branch to create or delete. The new branch name must pass all checks defined by git-check-ref-format[1]. Some of these checks may restrict the characters allowed in a branch name.\n**--no-track**: The new branch head will point to this commit. It may be given as a branch name, a commit-id, or a tag. If this option is omitted, the current HEAD will be used instead.\n**--recurse-submodules**: The name of an existing branch. If this option is omitted, the name of the current branch will be used instead.\n**--set-upstream**: The new name for an existing branch. The same restrictions as for <branch-name> apply.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 46,
          "content_length": 16053
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "pager.branch is only respected when listing branches, i.e., when --list is used or implied. The default is to use a pager. See git-config[1].\n\nEverything above this line in this section isn’t included from the git-config[1] documentation. The content that follows is the same as what’s found there:\n\nTells git branch, git switch and git checkout to set up new branches so that git-pull[1] will appropriately merge from the starting point branch. Note that even if this option is not set, this behavior can be chosen per-branch using the --track and --no-track options. This option defaults to true. The valid settings are:\n\nno automatic setup is done\n\nautomatic setup is done when the starting point is a remote-tracking branch\n\nautomatic setup is done when the starting point is either a local branch or remote-tracking branch\n\nif the starting point has a tracking configuration, it is copied to the new branch\n\nautomatic setup is done only when the starting point is a remote-tracking branch and the new branch has the same name as the remote branch.\n\nWhen a new branch is created with git branch, git switch or git checkout that tracks another branch, this variable tells Git to set up pull to rebase instead of merge (see branch.<name>.rebase). The valid settings are:\n\nrebase is never automatically set to true.\n\nrebase is set to true for tracked branches of other local branches.\n\nrebase is set to true for tracked branches of remote-tracking branches.\n\nrebase will be set to true for all tracking branches.\n\nSee branch.autoSetupMerge for details on how to set up a branch to track another branch. This option defaults to never.\n\nThis variable controls the sort ordering of branches when displayed by git-branch[1]. Without the --sort=<value> option provided, the value of this variable will be used as the default. See git-for-each-ref[1] field names for valid values.\n\nWhen on branch <name>, it tells git fetch and git push which remote to fetch from or push to. The remote to push to may be overridden with remote.pushDefault (for all branches). The remote to push to, for the current branch, may be further overridden by branch.<name>.pushRemote. If no remote is configured, or if you are not on any branch and there is more than one remote defined in the repository, it defaults to origin for fetching and remote.pushDefault for pushing. Additionally, . (a period) is the current local repository (a dot-repository), see branch.<name>.merge's final note below.\n\nWhen on branch <name>, it overrides branch.<name>.remote for pushing. It also overrides remote.pushDefault for pushing from branch <name>. When you pull from one place (e.g. your upstream) and push to another place (e.g. your own publishing repository), you would want to set remote.pushDefault to specify the remote to push to for all branches, and use this option to override it for a specific branch.\n\nDefines, together with branch.<name>.remote, the upstream branch for the given branch. It tells git fetch/git pull/git rebase which branch to merge and can also affect git push (see push.default). When in branch <name>, it tells git fetch the default refspec to be marked for merging in FETCH_HEAD. The value is handled like the remote part of a refspec, and must match a ref which is fetched from the remote given by branch.<name>.remote. The merge information is used by git pull (which first calls git fetch) to lookup the default branch for merging. Without this option, git pull defaults to merge the first refspec fetched. Specify multiple values to get an octopus merge. If you wish to setup git pull so that it merges into <name> from another branch in the local repository, you can point branch.<name>.merge to the desired branch, and use the relative path setting . (a period) for branch.<name>.remote.\n\nSets default options for merging into branch <name>. The syntax and supported options are the same as those of git-merge[1], but option values containing whitespace characters are currently not supported.\n\nWhen true, rebase the branch <name> on top of the fetched branch, instead of merging the default branch from the default remote when git pull is run. See pull.rebase for doing this in a non branch-specific manner.\n\nWhen merges (or just m), pass the --rebase-merges option to git rebase so that the local merge commits are included in the rebase (see git-rebase[1] for details).\n\nWhen the value is interactive (or just i), the rebase is run in interactive mode.\n\nNOTE: this is a possibly dangerous operation; do not use it unless you understand the implications (see git-rebase[1] for details).\n\nBranch description, can be edited with git branch --edit-description. Branch description is automatically added to the format-patch cover letter or request-pull summary.\n\n**branch.autoSetupMerge**: Tells git branch, git switch and git checkout to set up new branches so that git-pull[1] will appropriately merge from the starting point branch. Note that even if this option is not set, this behavior can be chosen per-branch using the --track and --no-track options. This option defaults to true. The valid settings are: false no automatic setup is done true automatic setup is done when the starting point is a remote-tracking branch always automatic setup is done when the starting point is either a local branch or remote-tracking branch inherit if the starting point has a tracking configuration, it is copied to the new branch simple automatic setup is done only when the starting point is a remote-tracking branch and the new branch has the same name as the remote branch.\n**false**: no automatic setup is done\n**true**: automatic setup is done when the starting point is a remote-tracking branch\n**always**: automatic setup is done when the starting point is either a local branch or remote-tracking branch\n**inherit**: if the starting point has a tracking configuration, it is copied to the new branch\n**simple**: automatic setup is done only when the starting point is a remote-tracking branch and the new branch has the same name as the remote branch.\n**branch.autoSetupRebase**: When a new branch is created with git branch, git switch or git checkout that tracks another branch, this variable tells Git to set up pull to rebase instead of merge (see branch.<name>.rebase). The valid settings are: never rebase is never automatically set to true. local rebase is set to true for tracked branches of other local branches. remote rebase is set to true for tracked branches of remote-tracking branches. always rebase will be set to true for all tracking branches. See branch.autoSetupMerge for details on how to set up a branch to track another branch. This option defaults to never.\n**never**: rebase is never automatically set to true.\n**local**: rebase is set to true for tracked branches of other local branches.\n**remote**: rebase is set to true for tracked branches of remote-tracking branches.\n**always**: rebase will be set to true for all tracking branches.\n**branch.sort**: This variable controls the sort ordering of branches when displayed by git-branch[1]. Without the --sort=<value> option provided, the value of this variable will be used as the default. See git-for-each-ref[1] field names for valid values.\n**branch.<name>.remote**: When on branch <name>, it tells git fetch and git push which remote to fetch from or push to. The remote to push to may be overridden with remote.pushDefault (for all branches). The remote to push to, for the current branch, may be further overridden by branch.<name>.pushRemote. If no remote is configured, or if you are not on any branch and there is more than one remote defined in the repository, it defaults to origin for fetching and remote.pushDefault for pushing. Additionally, . (a period) is the current local repository (a dot-repository), see branch.<name>.merge's final note below.\n**branch.<name>.pushRemote**: When on branch <name>, it overrides branch.<name>.remote for pushing. It also overrides remote.pushDefault for pushing from branch <name>. When you pull from one place (e.g. your upstream) and push to another place (e.g. your own publishing repository), you would want to set remote.pushDefault to specify the remote to push to for all branches, and use this option to override it for a specific branch.\n**branch.<name>.merge**: Defines, together with branch.<name>.remote, the upstream branch for the given branch. It tells git fetch/git pull/git rebase which branch to merge and can also affect git push (see push.default). When in branch <name>, it tells git fetch the default refspec to be marked for merging in FETCH_HEAD. The value is handled like the remote part of a refspec, and must match a ref which is fetched from the remote given by branch.<name>.remote. The merge information is used by git pull (which first calls git fetch) to lookup the default branch for merging. Without this option, git pull defaults to merge the first refspec fetched. Specify multiple values to get an octopus merge. If you wish to setup git pull so that it merges into <name> from another branch in the local repository, you can point branch.<name>.merge to the desired branch, and use the relative path setting . (a period) for branch.<name>.remote.\n**branch.<name>.mergeOptions**: Sets default options for merging into branch <name>. The syntax and supported options are the same as those of git-merge[1], but option values containing whitespace characters are currently not supported.\n**branch.<name>.rebase**: When true, rebase the branch <name> on top of the fetched branch, instead of merging the default branch from the default remote when git pull is run. See pull.rebase for doing this in a non branch-specific manner. When merges (or just m), pass the --rebase-merges option to git rebase so that the local merge commits are included in the rebase (see git-rebase[1] for details). When the value is interactive (or just i), the rebase is run in interactive mode. NOTE: this is a possibly dangerous operation; do not use it unless you understand the implications (see git-rebase[1] for details).\n**branch.<name>.description**: Branch description, can be edited with git branch --edit-description. Branch description is automatically added to the format-patch cover letter or request-pull summary.\n**false**: no automatic setup is done\n**true**: automatic setup is done when the starting point is a remote-tracking branch\n**always**: automatic setup is done when the starting point is either a local branch or remote-tracking branch\n**inherit**: if the starting point has a tracking configuration, it is copied to the new branch\n**simple**: automatic setup is done only when the starting point is a remote-tracking branch and the new branch has the same name as the remote branch.\n**never**: rebase is never automatically set to true.\n**local**: rebase is set to true for tracked branches of other local branches.\n**remote**: rebase is set to true for tracked branches of remote-tracking branches.\n**always**: rebase will be set to true for all tracking branches.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 24,
          "content_length": 11038
        }
      },
      {
        "header": "EXAMPLES",
        "content": "This step and the next one could be combined into a single step with \"checkout -b my2.6.14 v2.6.14\".\n\nDelete the remote-tracking branches \"todo\", \"html\" and \"man\". The next git fetch or git pull will create them again unless you configure them not to. See git-fetch[1].\n\nDelete the \"test\" branch even if the \"master\" branch (or whichever branch is currently checked out) does not have all commits from the test branch.\n\nUsing -a would conflate <remote> with any local branches you happen to have been prefixed with the same <remote> pattern.\n\nfor-each-ref can take a wide range of options. See git-for-each-ref[1]\n\nPatterns will normally need quoting.\n\n• This step and the next one could be combined into a single step with \"checkout -b my2.6.14 v2.6.14\".\n\n• Delete the remote-tracking branches \"todo\", \"html\" and \"man\". The next git fetch or git pull will create them again unless you configure them not to. See git-fetch[1].\n• Delete the \"test\" branch even if the \"master\" branch (or whichever branch is currently checked out) does not have all commits from the test branch.\n\n• Using -a would conflate <remote> with any local branches you happen to have been prefixed with the same <remote> pattern.\n• for-each-ref can take a wide range of options. See git-for-each-ref[1]\n\n**Start development from a known tag**: $ git clone git://git.kernel.org/pub/scm/.../linux-2.6 my2.6 $ cd my2.6 $ git branch my2.6.14 v2.6.14 (1) $ git switch my2.6.14 This step and the next one could be combined into a single step with \"checkout -b my2.6.14 v2.6.14\".\n**Delete an unneeded branch**: $ git clone git://git.kernel.org/.../git.git my.git $ cd my.git $ git branch -d -r origin/todo origin/html origin/man (1) $ git branch -D test (2) Delete the remote-tracking branches \"todo\", \"html\" and \"man\". The next git fetch or git pull will create them again unless you configure them not to. See git-fetch[1]. Delete the \"test\" branch even if the \"master\" branch (or whichever branch is currently checked out) does not have all commits from the test branch.\n**Listing branches from a specific remote**: $ git branch -r -l '<remote>/<pattern>' (1) $ git for-each-ref 'refs/remotes/<remote>/<pattern>' (2) Using -a would conflate <remote> with any local branches you happen to have been prefixed with the same <remote> pattern. for-each-ref can take a wide range of options. See git-for-each-ref[1]",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git clone git://git.kernel.org/pub/scm/.../linux-2.6 my2.6\n$ cd my2.6\n$ git branch my2.6.14 v2.6.14(1)$ git switch my2.6.14\n```",
          "```bash\n$ git clone git://git.kernel.org/.../git.git my.git\n$ cd my.git\n$ git branch -d -r origin/todo origin/html origin/man(1)$ git branch -D test(2)\n```",
          "```bash\n$ git branch -r -l '<remote>/<pattern>'(1)$ git for-each-ref 'refs/remotes/<remote>/<pattern>'(2)\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 2377
        }
      },
      {
        "header": "NOTES",
        "content": "If you are creating a branch that you want to switch to immediately, it is easier to use the git switch command with its -c option to do the same thing with a single command.\n\nThe options --contains, --no-contains, --merged and --no-merged serve four related but different purposes:\n\n--contains <commit> is used to find all branches which will need special attention if <commit> were to be rebased or amended, since those branches contain the specified <commit>.\n\n--no-contains <commit> is the inverse of that, i.e. branches that don’t contain the specified <commit>.\n\n--merged is used to find all branches which can be safely deleted, since those branches are fully contained by HEAD.\n\n--no-merged is used to find branches which are candidates for merging into HEAD, since those branches are not fully contained by HEAD.\n\nWhen combining multiple --contains and --no-contains filters, only references that contain at least one of the --contains commits and contain none of the --no-contains commits are shown.\n\nWhen combining multiple --merged and --no-merged filters, only references that are reachable from at least one of the --merged commits and from none of the --no-merged commits are shown.\n\n• --contains <commit> is used to find all branches which will need special attention if <commit> were to be rebased or amended, since those branches contain the specified <commit>.\n• --no-contains <commit> is the inverse of that, i.e. branches that don’t contain the specified <commit>.\n• --merged is used to find all branches which can be safely deleted, since those branches are fully contained by HEAD.\n• --no-merged is used to find branches which are candidates for merging into HEAD, since those branches are not fully contained by HEAD.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1741
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-check-ref-format[1], git-fetch[1], git-remote[1], \"Understanding history: What is a branch?\" in the Git User’s Manual.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 122
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-branch",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "Git",
    "summary": "SYNOPSIS git bundle create [-q | --quiet | --progress] [--version=<version>] <file> <git-rev-list-args> git bundle verify [-q | --quiet] <file> git bundle list-heads <file> [<refname>…] git bundle unbundle [--progress] <file> [<refname>…]",
    "sections": [
      {
        "header": "NAME",
        "content": "git-bundle - Move objects and refs by archive",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 45
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Create, unpack, and manipulate \"bundle\" files. Bundles are used for the \"offline\" transfer of Git objects without an active \"server\" sitting on the other side of the network connection.\n\nThey can be used to create both incremental and full backups of a repository (see the \"full backup\" example in \"EXAMPLES\"), and to relay the state of the references in one repository to another (see the second example).\n\nGit commands that fetch or otherwise \"read\" via protocols such as ssh:// and https:// can also operate on bundle files. It is possible git-clone[1] a new repository from a bundle, to use git-fetch[1] to fetch from one, and to list the references contained within it with git-ls-remote[1]. There’s no corresponding \"write\" support, i.e. a git push into a bundle is not supported.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 786
        }
      },
      {
        "header": "BUNDLE FORMAT",
        "content": "Bundles are .pack files (see git-pack-objects[1]) with a header indicating what references are contained within the bundle.\n\nLike the packed archive format itself bundles can either be self-contained, or be created using exclusions. See the \"OBJECT PREREQUISITES\" section below.\n\nBundles created using revision exclusions are \"thin packs\" created using the --thin option to git-pack-objects[1], and unbundled using the --fix-thin option to git-index-pack[1].\n\nThere is no option to create a \"thick pack\" when using revision exclusions, and users should not be concerned about the difference. By using \"thin packs\", bundles created using exclusions are smaller in size. That they’re \"thin\" under the hood is merely noted here as a curiosity, and as a reference to other documentation.\n\nSee gitformat-bundle[5] for more details and the discussion of \"thin pack\" in gitformat-pack[5] for further details.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 901
        }
      },
      {
        "header": "OPTIONS",
        "content": "Used to create a bundle named file. This requires the <git-rev-list-args> arguments to define the bundle contents. options contains the options specific to the git bundle create subcommand. If file is -, the bundle is written to stdout.\n\nUsed to check that a bundle file is valid and will apply cleanly to the current repository. This includes checks on the bundle format itself as well as checking that the prerequisite commits exist and are fully linked in the current repository. Then, git bundle prints a list of missing commits, if any. Finally, information about additional capabilities, such as \"object filter\", is printed. See \"Capabilities\" in gitformat-bundle[5] for more information. The exit code is zero for success, but will be nonzero if the bundle file is invalid. If file is -, the bundle is read from stdin.\n\nLists the references defined in the bundle. If followed by a list of references, only references matching those given are printed out. If file is -, the bundle is read from stdin.\n\nPasses the objects in the bundle to git index-pack for storage in the repository, then prints the names of all defined references. If a list of references is given, only references matching those in the list are printed. This command is really plumbing, intended to be called only by git fetch. If file is -, the bundle is read from stdin.\n\nA list of arguments, acceptable to git rev-parse and git rev-list (and containing a named ref, see SPECIFYING REFERENCES below), that specifies the specific objects and references to transport. For example, master~10..master causes the current master reference to be packaged along with all objects added since its 10th ancestor commit. There is no explicit limit to the number of references and objects that may be packaged.\n\nA list of references used to limit the references reported as available. This is principally of use to git fetch, which expects to receive only those references asked for and not necessarily everything in the pack (in this case, git bundle acts like git fetch-pack).\n\nProgress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.\n\nSpecify the bundle version. Version 2 is the older format and can only be used with SHA-1 repositories; the newer version 3 contains capabilities that permit extensions. The default is the oldest supported format, based on the hash algorithm in use.\n\nThis flag makes the command not to report its progress on the standard error stream.\n\n**create [options] <file> <git-rev-list-args>**: Used to create a bundle named file. This requires the <git-rev-list-args> arguments to define the bundle contents. options contains the options specific to the git bundle create subcommand. If file is -, the bundle is written to stdout.\n**verify <file>**: Used to check that a bundle file is valid and will apply cleanly to the current repository. This includes checks on the bundle format itself as well as checking that the prerequisite commits exist and are fully linked in the current repository. Then, git bundle prints a list of missing commits, if any. Finally, information about additional capabilities, such as \"object filter\", is printed. See \"Capabilities\" in gitformat-bundle[5] for more information. The exit code is zero for success, but will be nonzero if the bundle file is invalid. If file is -, the bundle is read from stdin.\n**list-heads <file>**: Lists the references defined in the bundle. If followed by a list of references, only references matching those given are printed out. If file is -, the bundle is read from stdin.\n**unbundle <file>**: Passes the objects in the bundle to git index-pack for storage in the repository, then prints the names of all defined references. If a list of references is given, only references matching those in the list are printed. This command is really plumbing, intended to be called only by git fetch. If file is -, the bundle is read from stdin.\n**<git-rev-list-args>**: A list of arguments, acceptable to git rev-parse and git rev-list (and containing a named ref, see SPECIFYING REFERENCES below), that specifies the specific objects and references to transport. For example, master~10..master causes the current master reference to be packaged along with all objects added since its 10th ancestor commit. There is no explicit limit to the number of references and objects that may be packaged.\n**[<refname>…]**: A list of references used to limit the references reported as available. This is principally of use to git fetch, which expects to receive only those references asked for and not necessarily everything in the pack (in this case, git bundle acts like git fetch-pack).\n**--progress**: Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.\n**--version=<version>**: Specify the bundle version. Version 2 is the older format and can only be used with SHA-1 repositories; the newer version 3 contains capabilities that permit extensions. The default is the oldest supported format, based on the hash algorithm in use.\n**-q**: This flag makes the command not to report its progress on the standard error stream.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 5408
        }
      },
      {
        "header": "SPECIFYING REFERENCES",
        "content": "Revisions must be accompanied by reference names to be packaged in a bundle. Alternatively --all can be used to package all refs.\n\nMore than one reference may be packaged, and more than one set of prerequisite objects can be specified. The objects packaged are those not contained in the union of the prerequisites.\n\nThe git bundle create command resolves the reference names for you using the same rules as git rev-parse --abbrev-ref=loose. Each prerequisite can be specified explicitly (e.g. ^master~10), or implicitly (e.g. master~10..master, --since=10.days.ago master).\n\nAll of these simple cases are OK (assuming we have a \"master\" and \"next\" branch):\n\nAnd so are these (and the same but omitted --stdin examples):\n\nA revision name or a range whose right-hand-side cannot be resolved to a reference is not accepted:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git bundle create master.bundle master\n$ echo master | git bundle create master.bundle --stdin\n$ git bundle create master-and-next.bundle master next\n$ (echo master; echo next) | git bundle create master-and-next.bundle --stdin\n```",
          "```bash\n$ git bundle create recent-master.bundle master~10..master\n$ git bundle create recent-updates.bundle master~10..master next~5..next\n```",
          "```bash\n$ git bundle create HEAD.bundle $(git rev-parse HEAD)\nfatal: Refusing to create empty bundle.\n$ git bundle create master-yesterday.bundle master~10..master~5\nfatal: Refusing to create empty bundle.\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 821
        }
      },
      {
        "header": "OBJECT PREREQUISITES",
        "content": "When creating bundles it is possible to create a self-contained bundle that can be unbundled in a repository with no common history, as well as providing negative revisions to exclude objects needed in the earlier parts of the history.\n\nFeeding a revision such as new to git bundle create will create a bundle file that contains all the objects reachable from the revision new. That bundle can be unbundled in any repository to obtain a full history that leads to the revision new:\n\nA revision range such as old..new will produce a bundle file that will require the revision old (and any objects reachable from it) to exist for the bundle to be \"unbundle\"-able:\n\nA self-contained bundle without any prerequisites can be extracted into anywhere, even into an empty repository, or be cloned from (i.e., new, but not old..new).\n\nIt is okay to err on the side of caution, causing the bundle file to contain objects already in the destination, as these are ignored when unpacking at the destination.\n\nIf you want to provide the same set of refs that a clone directly from the source repository would get, use --branches --tags for the <git-rev-list-args>.\n\nThe git bundle verify command can be used to check whether your recipient repository has the required prerequisite commits for a bundle.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git bundle create full.bundle new\n```",
          "```bash\n$ git bundle create full.bundle old..new\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1288
        }
      },
      {
        "header": "EXAMPLES",
        "content": "We’ll discuss two cases:\n\nTaking a full backup of a repository\n\nTransferring the history of a repository to another machine when the two machines have no direct connection\n\nFirst let’s consider a full backup of the repository. The following command will take a full backup of the repository in the sense that all refs are included in the bundle:\n\nBut note again that this is only for the refs, i.e. you will only include refs and commits reachable from those refs. You will not include other local state, such as the contents of the index, working tree, the stash, per-repository configuration, hooks, etc.\n\nYou can later recover that repository by using for example git-clone[1]:\n\nFor the next example, assume you want to transfer the history from a repository R1 on machine A to another repository R2 on machine B. For whatever reason, direct connection between A and B is not allowed, but we can move data from A to B via some mechanism (CD, email, etc.). We want to update R2 with development made on the branch master in R1.\n\nTo bootstrap the process, you can first create a bundle that does not have any prerequisites. You can use a tag to remember up to what commit you last processed, in order to make it easy to later update the other repository with an incremental bundle:\n\nThen you transfer file.bundle to the target machine B. Because this bundle does not require any existing object to be extracted, you can create a new repository on machine B by cloning from it:\n\nThis will define a remote called \"origin\" in the resulting repository that lets you fetch and pull from the bundle. The $GIT_DIR/config file in R2 will have an entry like this:\n\nTo update the resulting mine.git repository, you can fetch or pull after replacing the bundle stored at /home/me/tmp/file.bundle with incremental updates.\n\nAfter working some more in the original repository, you can create an incremental bundle to update the other repository:\n\nYou then transfer the bundle to the other machine to replace /home/me/tmp/file.bundle, and pull from it.\n\nIf you know up to what commit the intended recipient repository should have the necessary objects, you can use that knowledge to specify the prerequisites, giving a cut-off point to limit the revisions and objects that go in the resulting bundle. The previous example used the lastR2bundle tag for this purpose, but you can use any other options that you would give to the git-log[1] command. Here are more examples:\n\nYou can use a tag that is present in both:\n\nYou can use a prerequisite based on time:\n\nYou can use the number of commits:\n\nYou can run git-bundle verify to see if you can extract from a bundle that was created with a prerequisite:\n\nThis will list what commits you must have in order to extract from the bundle and will error out if you do not have them.\n\nA bundle from a recipient repository’s point of view is just like a regular repository which it fetches or pulls from. You can, for example, map references when fetching:\n\nYou can also see what references it offers:\n\n• Taking a full backup of a repository\n• Transferring the history of a repository to another machine when the two machines have no direct connection",
        "code_examples": [
          "```bash\n[remote \"origin\"]\n    url = /home/me/tmp/file.bundle\n    fetch = refs/heads/*:refs/remotes/origin/*\n```"
        ],
        "usage_examples": [
          "```bash\n$ git bundle create backup.bundle --all\n```",
          "```bash\n$ git clone backup.bundle <new directory>\n```",
          "```bash\nmachineA$ cd R1\nmachineA$ git bundle create file.bundle master\nmachineA$ git tag -f lastR2bundle master\n```",
          "```bash\nmachineB$ git clone -b master /home/me/tmp/file.bundle R2\n```",
          "```bash\nmachineA$ cd R1\nmachineA$ git bundle create file.bundle lastR2bundle..master\nmachineA$ git tag -f lastR2bundle master\n```",
          "```bash\nmachineB$ cd R2\nmachineB$ git pull\n```",
          "```bash\n$ git bundle create mybundle v1.0.0..master\n```",
          "```bash\n$ git bundle create mybundle --since=10.days master\n```",
          "```bash\n$ git bundle create mybundle -10 master\n```",
          "```bash\n$ git bundle verify mybundle\n```",
          "```bash\n$ git fetch mybundle master:localRef\n```",
          "```bash\n$ git ls-remote mybundle\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 21,
          "content_length": 3179
        }
      },
      {
        "header": "DISCUSSION",
        "content": "A naive way to make a full backup of a repository is to use something to the effect of cp -r <repo> <destination>. This is discouraged since the repository could be written to during the copy operation. In turn some files at <destination> could be corrupted.\n\nThis is why it is recommended to use Git tooling for making repository backups, either with this command or with e.g. git-clone[1]. But keep in mind that these tools will not help you backup state other than refs and commits. In other words they will not help you backup contents of the index, working tree, the stash, per-repository configuration, hooks, etc.\n\nSee also gitfaq[7], section \"TRANSFERS\" for a discussion of the problems associated with file syncing across systems.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 739
        }
      },
      {
        "header": "FILE FORMAT",
        "content": "See gitformat-bundle[5].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-bundle",
    "doc_type": "git",
    "total_sections": 10
  },
  {
    "title": "Git",
    "summary": "NAME git-checkout - Switch branches or restore working tree files\n\ngit-checkout - Switch branches or restore working tree files",
    "sections": [
      {
        "header": "NAME",
        "content": "git-checkout - Switch branches or restore working tree files",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 60
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Updates files in the working tree to match the version in the index or the specified tree. If no pathspec was given, git checkout will also update HEAD to set the specified branch as the current branch.\n\nTo prepare for working on <branch>, switch to it by updating the index and the files in the working tree, and by pointing HEAD at the branch. Local modifications to the files in the working tree are kept, so that they can be committed to the <branch>.\n\nIf <branch> is not found but there does exist a tracking branch in exactly one remote (call it <remote>) with a matching name and --no-guess is not specified, treat as equivalent to\n\nYou could omit <branch>, in which case the command degenerates to \"check out the current branch\", which is a glorified no-op with rather expensive side-effects to show only the tracking information, if it exists, for the current branch.\n\nSpecifying -b causes a new branch to be created as if git-branch[1] were called and then checked out. In this case you can use the --track or --no-track options, which will be passed to git branch. As a convenience, --track without -b implies branch creation; see the description of --track below.\n\nIf -B is given, <new-branch> is created if it doesn’t exist; otherwise, it is reset. This is the transactional equivalent of\n\nthat is to say, the branch is not reset/created unless \"git checkout\" is successful (e.g., when the branch is in use in another worktree, not just the current branch stays the same, but the branch is not reset to the start-point, either).\n\nPrepare to work on top of <commit>, by detaching HEAD at it (see \"DETACHED HEAD\" section), and updating the index and the files in the working tree. Local modifications to the files in the working tree are kept, so that the resulting working tree will be the state recorded in the commit plus the local modifications.\n\nWhen the <commit> argument is a branch name, the --detach option can be used to detach HEAD at the tip of the branch (git checkout <branch> would check out that branch without detaching HEAD).\n\nOmitting <branch> detaches HEAD at the tip of the current branch.\n\nOverwrite the contents of the files that match the pathspec. When the <tree-ish> (most often a commit) is not given, overwrite working tree with the contents in the index. When the <tree-ish> is given, overwrite both the index and the working tree with the contents at the <tree-ish>.\n\nThe index may contain unmerged entries because of a previous failed merge. By default, if you try to check out such an entry from the index, the checkout operation will fail and nothing will be checked out. Using -f will ignore these unmerged entries. The contents from a specific side of the merge can be checked out of the index by using --ours or --theirs. With -m, changes made to the working tree file can be discarded to re-create the original conflicted merge result.\n\nThis is similar to the previous mode, but lets you use the interactive interface to show the \"diff\" output and choose which hunks to use in the result. See below for the description of --patch option.\n\n**git checkout [<branch>]**: To prepare for working on <branch>, switch to it by updating the index and the files in the working tree, and by pointing HEAD at the branch. Local modifications to the files in the working tree are kept, so that they can be committed to the <branch>. If <branch> is not found but there does exist a tracking branch in exactly one remote (call it <remote>) with a matching name and --no-guess is not specified, treat as equivalent to $ git checkout -b <branch> --track <remote>/<branch> You could omit <branch>, in which case the command degenerates to \"check out the current branch\", which is a glorified no-op with rather expensive side-effects to show only the tracking information, if it exists, for the current branch.\n**git checkout (-b|-B) <new-branch> [<start-point>]**: Specifying -b causes a new branch to be created as if git-branch[1] were called and then checked out. In this case you can use the --track or --no-track options, which will be passed to git branch. As a convenience, --track without -b implies branch creation; see the description of --track below. If -B is given, <new-branch> is created if it doesn’t exist; otherwise, it is reset. This is the transactional equivalent of $ git branch -f <branch> [<start-point>] $ git checkout <branch> that is to say, the branch is not reset/created unless \"git checkout\" is successful (e.g., when the branch is in use in another worktree, not just the current branch stays the same, but the branch is not reset to the start-point, either).\n**git checkout --detach [<branch>]**: Prepare to work on top of <commit>, by detaching HEAD at it (see \"DETACHED HEAD\" section), and updating the index and the files in the working tree. Local modifications to the files in the working tree are kept, so that the resulting working tree will be the state recorded in the commit plus the local modifications. When the <commit> argument is a branch name, the --detach option can be used to detach HEAD at the tip of the branch (git checkout <branch> would check out that branch without detaching HEAD). Omitting <branch> detaches HEAD at the tip of the current branch.\n**git checkout [--detach] <commit>**: Overwrite the contents of the files that match the pathspec. When the <tree-ish> (most often a commit) is not given, overwrite working tree with the contents in the index. When the <tree-ish> is given, overwrite both the index and the working tree with the contents at the <tree-ish>. The index may contain unmerged entries because of a previous failed merge. By default, if you try to check out such an entry from the index, the checkout operation will fail and nothing will be checked out. Using -f will ignore these unmerged entries. The contents from a specific side of the merge can be checked out of the index by using --ours or --theirs. With -m, changes made to the working tree file can be discarded to re-create the original conflicted merge result.\n**git checkout [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] <pathspec>...**: This is similar to the previous mode, but lets you use the interactive interface to show the \"diff\" output and choose which hunks to use in the result. See below for the description of --patch option.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git checkout -b<branch>--track <remote>/<branch>\n```",
          "```bash\n$ git branch -f<branch>[<start-point>]\n$ git checkout<branch>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 13,
          "content_length": 6328
        }
      },
      {
        "header": "OPTIONS",
        "content": "Quiet, suppress feedback messages.\n\nProgress status is reported on the standard error stream by default when it is attached to a terminal, unless --quiet is specified. This flag enables progress reporting even if not attached to a terminal, regardless of --quiet.\n\nWhen switching branches, proceed even if the index or the working tree differs from HEAD, and even if there are untracked files in the way. This is used to throw away local changes and any untracked files or directories that are in the way.\n\nWhen checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored.\n\nWhen checking out paths from the index, check out stage #2 (ours) or #3 (theirs) for unmerged paths.\n\nNote that during git rebase and git pull --rebase, ours and theirs may appear swapped; --ours gives the version from the branch the changes are rebased onto, while --theirs gives the version from the branch that holds your work that is being rebased.\n\nThis is because rebase is used in a workflow that treats the history at the remote as the shared canonical one, and treats the work done on the branch you are rebasing as the third-party work to be integrated, and you are temporarily assuming the role of the keeper of the canonical history during the rebase. As the keeper of the canonical history, you need to view the history from the remote as ours (i.e. \"our shared canonical history\"), while what you did on your side branch as theirs (i.e. \"one contributor’s work on top of it\").\n\nCreate a new branch named <new-branch>, start it at <start-point>, and check the resulting branch out; see git-branch[1] for details.\n\nCreates the branch <new-branch>, start it at <start-point>; if it already exists, then reset it to <start-point>. And then check the resulting branch out. This is equivalent to running git branch with -f followed by git checkout of that branch; see git-branch[1] for details.\n\nWhen creating a new branch, set up \"upstream\" configuration. See --track in git-branch[1] for details.\n\nIf no -b option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the \"*\". This would tell us to use hack as the local branch when branching off of origin/hack (or remotes/origin/hack, or even refs/remotes/origin/hack). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with -b in such a case.\n\nDo not set up \"upstream\" configuration, even if the branch.autoSetupMerge configuration variable is true.\n\nIf <branch> is not found but there does exist a tracking branch in exactly one remote (call it <remote>) with a matching name, treat as equivalent to\n\nIf the branch exists in multiple remotes and one of them is named by the checkout.defaultRemote configuration variable, we’ll use that one for the purposes of disambiguation, even if the <branch> isn’t unique across all remotes. Set it to e.g. checkout.defaultRemote=origin to always checkout remote branches from there if <branch> is ambiguous but exists on the origin remote. See also checkout.defaultRemote in git-config[1].\n\n--guess is the default behavior. Use --no-guess to disable it.\n\nThe default behavior can be set via the checkout.guess configuration variable.\n\nCreate the new branch’s reflog; see git-branch[1] for details.\n\nRather than checking out a branch to work on it, check out a commit for inspection and discardable experiments. This is the default behavior of git checkout <commit> when <commit> is not a branch name. See the \"DETACHED HEAD\" section below for details.\n\nCreate a new unborn branch, named <new-branch>, started from <start-point> and switch to it. The first commit made on this new branch will have no parents and it will be the root of a new history totally disconnected from all the other branches and commits.\n\nThe index and the working tree are adjusted as if you had previously run git checkout <start-point>. This allows you to start a new history that records a set of paths similar to <start-point> by easily running git commit -a to make the root commit.\n\nThis can be useful when you want to publish the tree from a commit without exposing its full history. You might want to do this to publish an open source branch of a project whose current tree is \"clean\", but whose full history contains proprietary or otherwise encumbered bits of code.\n\nIf you want to start a disconnected history that records a set of paths that is totally different from the one of <start-point>, then you should clear the index and the working tree right after creating the orphan branch by running git rm -rf . from the top level of the working tree. Afterwards you will be ready to prepare your new files, repopulating the working tree, by copying them from elsewhere, extracting a tarball, etc.\n\nIn sparse checkout mode, git checkout -- <path>... would update only entries matched by <paths> and sparse patterns in $GIT_DIR/info/sparse-checkout. This option ignores the sparse patterns and adds back any files in <path>....\n\nWhen switching branches, if you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.\n\nWhen a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with git add (or git rm if the merge should result in deletion of the path).\n\nWhen checking out paths from the index, this option lets you recreate the conflicted merge in the specified paths. This option cannot be used when checking out paths from a tree-ish.\n\nWhen switching branches with --merge, staged changes may be lost.\n\nThe same as --merge option above, but changes the way the conflicting hunks are presented, overriding the merge.conflictStyle configuration variable. Possible values are merge (default), diff3, and zdiff3.\n\nInteractively select hunks in the difference between the <tree-ish> (or the index, if unspecified) and the working tree. The chosen hunks are then applied in reverse to the working tree (and if a <tree-ish> was specified, the index).\n\nThis means that you can use git checkout -p to selectively discard edits from your current working tree. See the \"Interactive Mode\" section of git-add[1] to learn how to operate the --patch mode.\n\nNote that this option uses the no overlay mode by default (see also --overlay), and currently doesn’t support overlay mode.\n\nGenerate diffs with <n> lines of context. Defaults to diff.context or 3 if the config option is unset.\n\nShow the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n\ngit checkout refuses when the wanted branch is already checked out or otherwise in use by another worktree. This option makes it check the branch out anyway. In other words, the branch can be in use by more than one worktree.\n\nSilently overwrite ignored files when switching branches. This is the default behavior. Use --no-overwrite-ignore to abort the operation when the new branch contains ignored files.\n\nUsing --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless -f is used. If nothing (or --no-recurse-submodules) is used, submodules working trees will not be updated. Just like git-submodule[1], this will detach HEAD of the submodule.\n\nIn the default overlay mode, git checkout never removes files from the index or the working tree. When specifying --no-overlay, files that appear in the index and working tree, but not in <tree-ish> are removed, to make them match <tree-ish> exactly.\n\nPathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config[1]). See also --pathspec-file-nul and global --literal-pathspecs.\n\nOnly meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).\n\nBranch to checkout; if it refers to a branch (i.e., a name that, when prepended with \"refs/heads/\", is a valid ref), then that branch is checked out. Otherwise, if it refers to a valid commit, your HEAD becomes \"detached\" and you are no longer on any branch (see below for details).\n\nYou can use the @{-N} syntax to refer to the N-th last branch/commit checked out using \"git checkout\" operation. You may also specify - which is synonymous to @{-1}.\n\nAs a special case, you may use <rev-a>...<rev-b> as a shortcut for the merge base of <rev-a> and <rev-b> if there is exactly one merge base. You can leave out at most one of <rev-a> and <rev-b>, in which case it defaults to HEAD.\n\nName for the new branch.\n\nThe name of a commit at which to start the new branch; see git-branch[1] for details. Defaults to HEAD.\n\nAs a special case, you may use <rev-a>...<rev-b> as a shortcut for the merge base of <rev-a> and <rev-b> if there is exactly one merge base. You can leave out at most one of <rev-a> and <rev-b>, in which case it defaults to HEAD.\n\nTree to checkout from (when paths are given). If not specified, the index will be used.\n\nAs a special case, you may use <rev-a>...<rev-b> as a shortcut for the merge base of <rev-a> and <rev-b> if there is exactly one merge base. You can leave out at most one of <rev-a> and <rev-b>, in which case it defaults to HEAD.\n\nDo not interpret any more arguments as options.\n\nLimits the paths affected by the operation.\n\nFor more details, see the pathspec entry in gitglossary[7].\n\n**-q**: Quiet, suppress feedback messages.\n**--quiet**: Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --quiet is specified. This flag enables progress reporting even if not attached to a terminal, regardless of --quiet.\n**--progress**: When switching branches, proceed even if the index or the working tree differs from HEAD, and even if there are untracked files in the way. This is used to throw away local changes and any untracked files or directories that are in the way. When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored.\n**--no-progress**: When checking out paths from the index, check out stage #2 (ours) or #3 (theirs) for unmerged paths. Note that during git rebase and git pull --rebase, ours and theirs may appear swapped; --ours gives the version from the branch the changes are rebased onto, while --theirs gives the version from the branch that holds your work that is being rebased. This is because rebase is used in a workflow that treats the history at the remote as the shared canonical one, and treats the work done on the branch you are rebasing as the third-party work to be integrated, and you are temporarily assuming the role of the keeper of the canonical history during the rebase. As the keeper of the canonical history, you need to view the history from the remote as ours (i.e. \"our shared canonical history\"), while what you did on your side branch as theirs (i.e. \"one contributor’s work on top of it\").\n**-f**: Create a new branch named <new-branch>, start it at <start-point>, and check the resulting branch out; see git-branch[1] for details.\n**--force**: Creates the branch <new-branch>, start it at <start-point>; if it already exists, then reset it to <start-point>. And then check the resulting branch out. This is equivalent to running git branch with -f followed by git checkout of that branch; see git-branch[1] for details.\n**--ours**: When creating a new branch, set up \"upstream\" configuration. See --track in git-branch[1] for details. If no -b option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the \"*\". This would tell us to use hack as the local branch when branching off of origin/hack (or remotes/origin/hack, or even refs/remotes/origin/hack). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with -b in such a case.\n**--theirs**: Do not set up \"upstream\" configuration, even if the branch.autoSetupMerge configuration variable is true.\n**-b <new-branch>**: If <branch> is not found but there does exist a tracking branch in exactly one remote (call it <remote>) with a matching name, treat as equivalent to $ git checkout -b <branch> --track <remote>/<branch> If the branch exists in multiple remotes and one of them is named by the checkout.defaultRemote configuration variable, we’ll use that one for the purposes of disambiguation, even if the <branch> isn’t unique across all remotes. Set it to e.g. checkout.defaultRemote=origin to always checkout remote branches from there if <branch> is ambiguous but exists on the origin remote. See also checkout.defaultRemote in git-config[1]. --guess is the default behavior. Use --no-guess to disable it. The default behavior can be set via the checkout.guess configuration variable.\n**-B <new-branch>**: Create the new branch’s reflog; see git-branch[1] for details.\n**-t**: Rather than checking out a branch to work on it, check out a commit for inspection and discardable experiments. This is the default behavior of git checkout <commit> when <commit> is not a branch name. See the \"DETACHED HEAD\" section below for details.\n**--track[=(direct|inherit)]**: Create a new unborn branch, named <new-branch>, started from <start-point> and switch to it. The first commit made on this new branch will have no parents and it will be the root of a new history totally disconnected from all the other branches and commits. The index and the working tree are adjusted as if you had previously run git checkout <start-point>. This allows you to start a new history that records a set of paths similar to <start-point> by easily running git commit -a to make the root commit. This can be useful when you want to publish the tree from a commit without exposing its full history. You might want to do this to publish an open source branch of a project whose current tree is \"clean\", but whose full history contains proprietary or otherwise encumbered bits of code. If you want to start a disconnected history that records a set of paths that is totally different from the one of <start-point>, then you should clear the index and the working tree right after creating the orphan branch by running git rm -rf . from the top level of the working tree. Afterwards you will be ready to prepare your new files, repopulating the working tree, by copying them from elsewhere, extracting a tarball, etc.\n**--no-track**: In sparse checkout mode, git checkout -- <path>... would update only entries matched by <paths> and sparse patterns in $GIT_DIR/info/sparse-checkout. This option ignores the sparse patterns and adds back any files in <path>....\n**--guess**: When switching branches, if you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch. When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with git add (or git rm if the merge should result in deletion of the path). When checking out paths from the index, this option lets you recreate the conflicted merge in the specified paths. This option cannot be used when checking out paths from a tree-ish. When switching branches with --merge, staged changes may be lost.\n**--no-guess**: The same as --merge option above, but changes the way the conflicting hunks are presented, overriding the merge.conflictStyle configuration variable. Possible values are merge (default), diff3, and zdiff3.\n**-l**: Interactively select hunks in the difference between the <tree-ish> (or the index, if unspecified) and the working tree. The chosen hunks are then applied in reverse to the working tree (and if a <tree-ish> was specified, the index). This means that you can use git checkout -p to selectively discard edits from your current working tree. See the \"Interactive Mode\" section of git-add[1] to learn how to operate the --patch mode. Note that this option uses the no overlay mode by default (see also --overlay), and currently doesn’t support overlay mode.\n**-d**: Generate diffs with <n> lines of context. Defaults to diff.context or 3 if the config option is unset.\n**--detach**: Show the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n**--orphan <new-branch>**: git checkout refuses when the wanted branch is already checked out or otherwise in use by another worktree. This option makes it check the branch out anyway. In other words, the branch can be in use by more than one worktree.\n**--ignore-skip-worktree-bits**: Silently overwrite ignored files when switching branches. This is the default behavior. Use --no-overwrite-ignore to abort the operation when the new branch contains ignored files.\n**-m**: Using --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless -f is used. If nothing (or --no-recurse-submodules) is used, submodules working trees will not be updated. Just like git-submodule[1], this will detach HEAD of the submodule.\n**--merge**: In the default overlay mode, git checkout never removes files from the index or the working tree. When specifying --no-overlay, files that appear in the index and working tree, but not in <tree-ish> are removed, to make them match <tree-ish> exactly.\n**--conflict=<style>**: Pathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config[1]). See also --pathspec-file-nul and global --literal-pathspecs.\n**-p**: Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).\n**--patch**: Branch to checkout; if it refers to a branch (i.e., a name that, when prepended with \"refs/heads/\", is a valid ref), then that branch is checked out. Otherwise, if it refers to a valid commit, your HEAD becomes \"detached\" and you are no longer on any branch (see below for details). You can use the @{-N} syntax to refer to the N-th last branch/commit checked out using \"git checkout\" operation. You may also specify - which is synonymous to @{-1}. As a special case, you may use <rev-a>...<rev-b> as a shortcut for the merge base of <rev-a> and <rev-b> if there is exactly one merge base. You can leave out at most one of <rev-a> and <rev-b>, in which case it defaults to HEAD.\n**-U<n>**: Name for the new branch.\n**--unified=<n>**: The name of a commit at which to start the new branch; see git-branch[1] for details. Defaults to HEAD. As a special case, you may use <rev-a>...<rev-b> as a shortcut for the merge base of <rev-a> and <rev-b> if there is exactly one merge base. You can leave out at most one of <rev-a> and <rev-b>, in which case it defaults to HEAD.\n**--inter-hunk-context=<n>**: Tree to checkout from (when paths are given). If not specified, the index will be used. As a special case, you may use <rev-a>...<rev-b> as a shortcut for the merge base of <rev-a> and <rev-b> if there is exactly one merge base. You can leave out at most one of <rev-a> and <rev-b>, in which case it defaults to HEAD.\n**--ignore-other-worktrees**: Do not interpret any more arguments as options.\n**--overwrite-ignore**: Limits the paths affected by the operation. For more details, see the pathspec entry in gitglossary[7].",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git checkout -b<branch>--track <remote>/<branch>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 50,
          "content_length": 20974
        }
      },
      {
        "header": "DETACHED HEAD",
        "content": "HEAD normally refers to a named branch (e.g. master). Meanwhile, each branch refers to a specific commit. Let’s look at a repo with three commits, one of them tagged, and with branch master checked out:\n\nWhen a commit is created in this state, the branch is updated to refer to the new commit. Specifically, git commit creates a new commit d, whose parent is commit c, and then updates branch master to refer to new commit d. HEAD still refers to branch master and so indirectly now refers to commit d:\n\nIt is sometimes useful to be able to checkout a commit that is not at the tip of any named branch, or even to create a new commit that is not referenced by a named branch. Let’s look at what happens when we checkout commit b (here we show two ways this may be done):\n\nNotice that regardless of which checkout command we use, HEAD now refers directly to commit b. This is known as being in detached HEAD state. It means simply that HEAD refers to a specific commit, as opposed to referring to a named branch. Let’s see what happens when we create a commit:\n\nThere is now a new commit e, but it is referenced only by HEAD. We can of course add yet another commit in this state:\n\nIn fact, we can perform all the normal Git operations. But, let’s look at what happens when we then checkout master:\n\nIt is important to realize that at this point nothing refers to commit f. Eventually commit f (and by extension commit e) will be deleted by the routine Git garbage collection process, unless we create a reference before that happens. If we have not yet moved away from commit f, any of these will create a reference to it:\n\ncreates a new branch foo, which refers to commit f, and then updates HEAD to refer to branch foo. In other words, we’ll no longer be in detached HEAD state after this command.\n\nsimilarly creates a new branch foo, which refers to commit f, but leaves HEAD detached.\n\ncreates a new tag foo, which refers to commit f, leaving HEAD detached.\n\nIf we have moved away from commit f, then we must first recover its object name (typically by using git reflog), and then we can create a reference to it. For example, to see the last two commits to which HEAD referred, we can use either of these commands:\n\n• creates a new branch foo, which refers to commit f, and then updates HEAD to refer to branch foo. In other words, we’ll no longer be in detached HEAD state after this command.\n• similarly creates a new branch foo, which refers to commit f, but leaves HEAD detached.\n• creates a new tag foo, which refers to commit f, leaving HEAD detached.",
        "code_examples": [
          "```bash\nHEAD (refers to branch 'master')\n            |\n            v\na---b---c  branch 'master' (refers to commit 'c')\n    ^\n    |\n  tag 'v2.0' (refers to commit 'b')\n```"
        ],
        "usage_examples": [
          "```bash\n$ edit; git add; git commit\n\n               HEAD (refers to branch 'master')\n                |\n                v\na---b---c---d  branch 'master' (refers to commit 'd')\n    ^\n    |\n  tag 'v2.0' (refers to commit 'b')\n```",
          "```bash\n$ git checkout v2.0  # or\n$ git checkout master^^\n\n   HEAD (refers to commit 'b')\n    |\n    v\na---b---c---d  branch 'master' (refers to commit 'd')\n    ^\n    |\n  tag 'v2.0' (refers to commit 'b')\n```",
          "```bash\n$ edit; git add; git commit\n\n     HEAD (refers to commit 'e')\n      |\n      v\n      e\n     /\na---b---c---d  branch 'master' (refers to commit 'd')\n    ^\n    |\n  tag 'v2.0' (refers to commit 'b')\n```",
          "```bash\n$ edit; git add; git commit\n\n\t HEAD (refers to commit 'f')\n\t  |\n\t  v\n      e---f\n     /\na---b---c---d  branch 'master' (refers to commit 'd')\n    ^\n    |\n  tag 'v2.0' (refers to commit 'b')\n```",
          "```bash\n$ git checkout master\n\n               HEAD (refers to branch 'master')\n      e---f     |\n     /          v\na---b---c---d  branch 'master' (refers to commit 'd')\n    ^\n    |\n  tag 'v2.0' (refers to commit 'b')\n```",
          "```bash\n$ git checkout -b foo  # or \"git switch -c foo\"(1)$ git branch foo(2)$ git tag foo(3)\n```",
          "```bash\n$ git reflog -2 HEAD # or\n$ git log -g -2 HEAD\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 11,
          "content_length": 2562
        }
      },
      {
        "header": "ARGUMENT DISAMBIGUATION",
        "content": "When there is only one argument given and it is not -- (e.g. git checkout abc), and when the argument is both a valid <tree-ish> (e.g. a branch abc exists) and a valid <pathspec> (e.g. a file or a directory whose name is \"abc\" exists), Git would usually ask you to disambiguate. Because checking out a branch is so common an operation, however, git checkout abc takes \"abc\" as a <tree-ish> in such a situation. Use git checkout -- <pathspec> if you want to checkout these paths out of the index.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 495
        }
      },
      {
        "header": "1. Paths",
        "content": "The following sequence checks out the master branch, reverts the Makefile to two revisions back, deletes hello.c by mistake, and gets it back from the index.\n\ntake a file out of another commit\n\nrestore hello.c from the index\n\nIf you want to check out all C source files out of the index, you can say\n\nNote the quotes around *.c. The file hello.c will also be checked out, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell).\n\nIf you have an unfortunate branch that is named hello.c, this step would be confused as an instruction to switch to that branch. You should instead write:\n\n• switch branch\n• take a file out of another commit\n• restore hello.c from the index",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git checkout master(1)$ git checkout master~2 Makefile(2)$ rm -f hello.c\n$ git checkout hello.c(3)\n```",
          "```bash\n$ git checkout -- '*.c'\n```",
          "```bash\n$ git checkout -- hello.c\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 766
        }
      },
      {
        "header": "2. Merge",
        "content": "After working in the wrong branch, switching to the correct branch would be done using:\n\nHowever, your \"wrong\" branch and correct mytopic branch may differ in files that you have modified locally, in which case the above checkout would fail like this:\n\nYou can give the -m flag to the command, which would try a three-way merge:\n\nAfter this three-way merge, the local modifications are not registered in your index file, so git diff would show you what changes you made since the tip of the new branch.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git checkout mytopic\n```",
          "```bash\n$ git checkout mytopic\nerror: You have local changes to 'frotz'; not switching branches.\n```",
          "```bash\n$ git checkout -m mytopic\nAuto-merging frotz\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 502
        }
      },
      {
        "header": "3. Merge conflict",
        "content": "When a merge conflict happens during switching branches with the -m option, you would see something like this:\n\nAt this point, git diff shows the changes cleanly merged as in the previous example, as well as the changes in the conflicted files. Edit and resolve the conflict and mark it resolved with git add as usual:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git checkout -m mytopic\nAuto-merging frotz\nERROR: Merge conflict in frotz\nfatal: merge program failed\n```",
          "```bash\n$ edit frotz\n$ git add frotz\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 318
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Everything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there:\n\nWhen you run git checkout <something> or git switch <something> and only have one remote, it may implicitly fall back on checking out and tracking e.g. origin/<something>. This stops working as soon as you have more than one remote with a <something> reference. This setting allows for setting the name of a preferred remote that should always win when it comes to disambiguation. The typical use-case is to set this to origin.\n\nCurrently this is used by git-switch[1] and git-checkout[1] when git checkout <something> or git switch <something> will checkout the <something> branch on another remote, and by git-worktree[1] when git worktree add refers to a remote branch. This setting might be used for other checkout-like commands or functionality in the future.\n\nProvides the default value for the --guess or --no-guess option in git checkout and git switch. See git-switch[1] and git-checkout[1].\n\nThe number of parallel workers to use when updating the working tree. The default is one, i.e. sequential execution. If set to a value less than one, Git will use as many workers as the number of logical cores available. This setting and checkout.thresholdForParallelism affect all commands that perform checkout. E.g. checkout, clone, reset, sparse-checkout, etc.\n\nWhen running parallel checkout with a small number of files, the cost of subprocess spawning and inter-process communication might outweigh the parallelization gains. This setting allows you to define the minimum number of files for which parallel checkout should be attempted. The default is 100.\n\n**checkout.defaultRemote**: When you run git checkout <something> or git switch <something> and only have one remote, it may implicitly fall back on checking out and tracking e.g. origin/<something>. This stops working as soon as you have more than one remote with a <something> reference. This setting allows for setting the name of a preferred remote that should always win when it comes to disambiguation. The typical use-case is to set this to origin. Currently this is used by git-switch[1] and git-checkout[1] when git checkout <something> or git switch <something> will checkout the <something> branch on another remote, and by git-worktree[1] when git worktree add refers to a remote branch. This setting might be used for other checkout-like commands or functionality in the future.\n**checkout.guess**: Provides the default value for the --guess or --no-guess option in git checkout and git switch. See git-switch[1] and git-checkout[1].\n**checkout.workers**: The number of parallel workers to use when updating the working tree. The default is one, i.e. sequential execution. If set to a value less than one, Git will use as many workers as the number of logical cores available. This setting and checkout.thresholdForParallelism affect all commands that perform checkout. E.g. checkout, clone, reset, sparse-checkout, etc. Note Parallel checkout usually delivers better performance for repositories located on SSDs or over NFS. For repositories on spinning disks and/or machines with a small number of cores, the default sequential checkout often performs better. The size and compression level of a repository might also influence how well the parallel version performs.\n**checkout.thresholdForParallelism**: When running parallel checkout with a small number of files, the cost of subprocess spawning and inter-process communication might outweigh the parallelization gains. This setting allows you to define the minimum number of files for which parallel checkout should be attempted. The default is 100.\n\nNote | Parallel checkout usually delivers better performance for repositories located on SSDs or over NFS. For repositories on spinning disks and/or machines with a small number of cores, the default sequential checkout often performs better. The size and compression level of a repository might also influence how well the parallel version performs.\n\n[Note] Note Parallel checkout usually delivers better performance for repositories located on SSDs or over NFS. For repositories on spinning disks and/or machines with a small number of cores, the default sequential checkout often performs better. The size and compression level of a repository might also influence how well the parallel version performs.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 6,
          "content_length": 4447
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-switch[1], git-restore[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 29
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-checkout",
    "doc_type": "git",
    "total_sections": 11
  },
  {
    "title": "Git",
    "summary": "NAME git-cherry-pick - Apply the changes introduced by some existing commits\n\ngit-cherry-pick - Apply the changes introduced by some existing commits",
    "sections": [
      {
        "header": "NAME",
        "content": "git-cherry-pick - Apply the changes introduced by some existing commits",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 71
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Given one or more existing commits, apply the change each one introduces, recording a new commit for each. This requires your working tree to be clean (no modifications from the HEAD commit).\n\nWhen it is not obvious how to apply a change, the following happens:\n\nThe current branch and HEAD pointer stay at the last commit successfully made.\n\nThe CHERRY_PICK_HEAD ref is set to point at the commit that introduced the change that is difficult to apply.\n\nPaths in which the change applied cleanly are updated both in the index file and in your working tree.\n\nFor conflicting paths, the index file records up to three versions, as described in the \"TRUE MERGE\" section of git-merge[1]. The working tree files will include a description of the conflict bracketed by the usual conflict markers <<<<<<< and >>>>>>>.\n\nNo other modifications are made.\n\nSee git-merge[1] for some hints on resolving such conflicts.\n\n• The current branch and HEAD pointer stay at the last commit successfully made.\n• The CHERRY_PICK_HEAD ref is set to point at the commit that introduced the change that is difficult to apply.\n• Paths in which the change applied cleanly are updated both in the index file and in your working tree.\n• For conflicting paths, the index file records up to three versions, as described in the \"TRUE MERGE\" section of git-merge[1]. The working tree files will include a description of the conflict bracketed by the usual conflict markers <<<<<<< and >>>>>>>.\n• No other modifications are made.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1495
        }
      },
      {
        "header": "OPTIONS",
        "content": "Commits to cherry-pick. For a more complete list of ways to spell commits, see gitrevisions[7]. Sets of commits can be passed but no traversal is done by default, as if the --no-walk option was specified, see git-rev-list[1]. Note that specifying a range will feed all <commit>… arguments to a single revision walk (see a later example that uses maint master..next).\n\nWith this option, git cherry-pick will let you edit the commit message prior to committing.\n\nThis option determines how the commit message will be cleaned up before being passed on to the commit machinery. See git-commit[1] for more details. In particular, if the <mode> is given a value of scissors, scissors will be appended to MERGE_MSG before being passed on in the case of a conflict.\n\nWhen recording the commit, append a line that says \"(cherry picked from commit …)\" to the original commit message in order to indicate which commit this change was cherry-picked from. This is done only for cherry picks without conflicts. Do not use this option if you are cherry-picking from your private branch because the information is useless to the recipient. If on the other hand you are cherry-picking between two publicly visible branches (e.g. backporting a fix to a maintenance branch for an older release from a development branch), adding this information can be useful.\n\nIt used to be that the command defaulted to do -x described above, and -r was to disable it. Now the default is not to do -x so this option is a no-op.\n\nUsually you cannot cherry-pick a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows cherry-pick to replay the change relative to the specified parent.\n\nUsually the command automatically creates a sequence of commits. This flag applies the changes necessary to cherry-pick each named commit to your working tree and the index, without making any commit. In addition, when this option is used, your index does not have to match the HEAD commit. The cherry-pick is done against the beginning state of your index.\n\nThis is useful when cherry-picking more than one commits' effect to your index in a row.\n\nAdd a Signed-off-by trailer at the end of the commit message. See the signoff option in git-commit[1] for more information.\n\nGPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign.\n\nIf the current HEAD is the same as the parent of the cherry-pick’ed commit, then a fast forward to this commit will be performed.\n\nBy default, cherry-picking an empty commit will fail, indicating that an explicit invocation of git commit --allow-empty is required. This option overrides that behavior, allowing empty commits to be preserved automatically in a cherry-pick. Note that when \"--ff\" is in effect, empty commits that meet the \"fast-forward\" requirement will be kept even without this option. Note also, that use of this option only keeps commits that were initially empty (i.e. the commit recorded the same tree as its parent). Commits which are made empty due to a previous commit will cause the cherry-pick to fail. To force the inclusion of those commits, use --empty=keep.\n\nBy default, cherry-picking a commit with an empty message will fail. This option overrides that behavior, allowing commits with empty messages to be cherry picked.\n\nHow to handle commits being cherry-picked that are redundant with changes already in the current history.\n\nThe commit will be dropped.\n\nThe commit will be kept. Implies --allow-empty.\n\nThe cherry-pick will stop when the commit is applied, allowing you to examine the commit. This is the default behavior.\n\nNote that --empty=drop and --empty=stop only specify how to handle a commit that was not initially empty, but rather became empty due to a previous commit. Commits that were initially empty will still cause the cherry-pick to fail unless one of --empty=keep or --allow-empty are specified.\n\nDeprecated synonym for --empty=keep.\n\nUse the given merge strategy. Should only be used once. See the MERGE STRATEGIES section in git-merge[1] for details.\n\nPass the merge strategy-specific option through to the merge strategy. See git-merge[1] for details.\n\nAfter the rerere mechanism reuses a recorded resolution on the current conflict to update the files in the working tree, allow it to also update the index with the result of resolution. --no-rerere-autoupdate is a good way to double-check what rerere did and catch potential mismerges, before committing the result to the index with a separate git add.\n\n**<commit>…**: Commits to cherry-pick. For a more complete list of ways to spell commits, see gitrevisions[7]. Sets of commits can be passed but no traversal is done by default, as if the --no-walk option was specified, see git-rev-list[1]. Note that specifying a range will feed all <commit>… arguments to a single revision walk (see a later example that uses maint master..next).\n**-e**: With this option, git cherry-pick will let you edit the commit message prior to committing.\n**--edit**: This option determines how the commit message will be cleaned up before being passed on to the commit machinery. See git-commit[1] for more details. In particular, if the <mode> is given a value of scissors, scissors will be appended to MERGE_MSG before being passed on in the case of a conflict.\n**--cleanup=<mode>**: When recording the commit, append a line that says \"(cherry picked from commit …)\" to the original commit message in order to indicate which commit this change was cherry-picked from. This is done only for cherry picks without conflicts. Do not use this option if you are cherry-picking from your private branch because the information is useless to the recipient. If on the other hand you are cherry-picking between two publicly visible branches (e.g. backporting a fix to a maintenance branch for an older release from a development branch), adding this information can be useful.\n**-x**: It used to be that the command defaulted to do -x described above, and -r was to disable it. Now the default is not to do -x so this option is a no-op.\n**-r**: Usually you cannot cherry-pick a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows cherry-pick to replay the change relative to the specified parent.\n**-m <parent-number>**: Usually the command automatically creates a sequence of commits. This flag applies the changes necessary to cherry-pick each named commit to your working tree and the index, without making any commit. In addition, when this option is used, your index does not have to match the HEAD commit. The cherry-pick is done against the beginning state of your index. This is useful when cherry-picking more than one commits' effect to your index in a row.\n**--mainline <parent-number>**: Add a Signed-off-by trailer at the end of the commit message. See the signoff option in git-commit[1] for more information.\n**-n**: GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign.\n**--no-commit**: If the current HEAD is the same as the parent of the cherry-pick’ed commit, then a fast forward to this commit will be performed.\n**-s**: By default, cherry-picking an empty commit will fail, indicating that an explicit invocation of git commit --allow-empty is required. This option overrides that behavior, allowing empty commits to be preserved automatically in a cherry-pick. Note that when \"--ff\" is in effect, empty commits that meet the \"fast-forward\" requirement will be kept even without this option. Note also, that use of this option only keeps commits that were initially empty (i.e. the commit recorded the same tree as its parent). Commits which are made empty due to a previous commit will cause the cherry-pick to fail. To force the inclusion of those commits, use --empty=keep.\n**--signoff**: By default, cherry-picking a commit with an empty message will fail. This option overrides that behavior, allowing commits with empty messages to be cherry picked.\n**-S[<keyid>]**: How to handle commits being cherry-picked that are redundant with changes already in the current history. drop The commit will be dropped. keep The commit will be kept. Implies --allow-empty. stop The cherry-pick will stop when the commit is applied, allowing you to examine the commit. This is the default behavior. Note that --empty=drop and --empty=stop only specify how to handle a commit that was not initially empty, but rather became empty due to a previous commit. Commits that were initially empty will still cause the cherry-pick to fail unless one of --empty=keep or --allow-empty are specified.\n**--gpg-sign[=<keyid>]**: The commit will be dropped.\n**--no-gpg-sign**: The commit will be kept. Implies --allow-empty.\n**--ff**: The cherry-pick will stop when the commit is applied, allowing you to examine the commit. This is the default behavior.\n**--allow-empty**: Deprecated synonym for --empty=keep.\n**--allow-empty-message**: Use the given merge strategy. Should only be used once. See the MERGE STRATEGIES section in git-merge[1] for details.\n**--empty=(drop|keep|stop)**: Pass the merge strategy-specific option through to the merge strategy. See git-merge[1] for details.\n**drop**: After the rerere mechanism reuses a recorded resolution on the current conflict to update the files in the working tree, allow it to also update the index with the result of resolution. --no-rerere-autoupdate is a good way to double-check what rerere did and catch potential mismerges, before committing the result to the index with a separate git add.\n**drop**: The commit will be dropped.\n**keep**: The commit will be kept. Implies --allow-empty.\n**stop**: The cherry-pick will stop when the commit is applied, allowing you to examine the commit. This is the default behavior.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 22,
          "content_length": 10285
        }
      },
      {
        "header": "SEQUENCER SUBCOMMANDS",
        "content": "Continue the operation in progress using the information in .git/sequencer. Can be used to continue after resolving conflicts in a failed cherry-pick or revert.\n\nSkip the current commit and continue with the rest of the sequence.\n\nForget about the current operation in progress. Can be used to clear the sequencer state after a failed cherry-pick or revert.\n\nCancel the operation and return to the pre-sequence state.\n\n**--continue**: Continue the operation in progress using the information in .git/sequencer. Can be used to continue after resolving conflicts in a failed cherry-pick or revert.\n**--skip**: Skip the current commit and continue with the rest of the sequence.\n**--quit**: Forget about the current operation in progress. Can be used to clear the sequencer state after a failed cherry-pick or revert.\n**--abort**: Cancel the operation and return to the pre-sequence state.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 886
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Apply the change introduced by the commit at the tip of the master branch and create a new commit with this change.\n\nApply the changes introduced by all commits that are ancestors of master but not of HEAD to produce new commits.\n\nApply the changes introduced by all commits that are ancestors of maint or next, but not master or any of its ancestors. Note that the latter does not mean maint and everything between master and next; specifically, maint will not be used if it is included in master.\n\nApply the changes introduced by the fifth and third last commits pointed to by master and create 2 new commits with these changes.\n\nApply to the working tree and the index the changes introduced by the second last commit pointed to by master and by the last commit pointed to by next, but do not create any commit with these changes.\n\nIf history is linear and HEAD is an ancestor of next, update the working tree and advance the HEAD pointer to match next. Otherwise, apply the changes introduced by those commits that are in next but not HEAD to the current branch, creating a new commit for each new change.\n\nApply the changes introduced by all commits on the master branch that touched README to the working tree and index, so the result can be inspected and made into a single new commit if suitable.\n\nThe following sequence attempts to backport a patch, bails out because the code the patch applies to has changed too much, and then tries again, this time exercising more care about matching up context lines.\n\napply the change that would be shown by git show topic^. In this example, the patch does not apply cleanly, so information about the conflict is written to the index and working tree and no new commit results.\n\nsummarize changes to be reconciled\n\ncancel the cherry-pick. In other words, return to the pre-cherry-pick state, preserving any local modifications you had in the working tree.\n\ntry to apply the change introduced by topic^ again, spending extra time to avoid mistakes based on incorrectly matching context lines.\n\n• apply the change that would be shown by git show topic^. In this example, the patch does not apply cleanly, so information about the conflict is written to the index and working tree and no new commit results.\n• summarize changes to be reconciled\n• cancel the cherry-pick. In other words, return to the pre-cherry-pick state, preserving any local modifications you had in the working tree.\n• try to apply the change introduced by topic^ again, spending extra time to avoid mistakes based on incorrectly matching context lines.\n\n**git cherry-pick master**: Apply the change introduced by the commit at the tip of the master branch and create a new commit with this change.\n**git cherry-pick ..master**: Apply the changes introduced by all commits that are ancestors of master but not of HEAD to produce new commits.\n**git cherry-pick ^HEAD master**: Apply the changes introduced by all commits that are ancestors of maint or next, but not master or any of its ancestors. Note that the latter does not mean maint and everything between master and next; specifically, maint will not be used if it is included in master.\n**git cherry-pick maint next ^master**: Apply the changes introduced by the fifth and third last commits pointed to by master and create 2 new commits with these changes.\n**git cherry-pick maint master..next**: Apply to the working tree and the index the changes introduced by the second last commit pointed to by master and by the last commit pointed to by next, but do not create any commit with these changes.\n**git cherry-pick master~4 master~2**: If history is linear and HEAD is an ancestor of next, update the working tree and advance the HEAD pointer to match next. Otherwise, apply the changes introduced by those commits that are in next but not HEAD to the current branch, creating a new commit for each new change.\n**git cherry-pick -n master~1 next**: Apply the changes introduced by all commits on the master branch that touched README to the working tree and index, so the result can be inspected and made into a single new commit if suitable.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git cherry-pick topic^(1)$ git diff(2)$ git cherry-pick --abort(3)$ git cherry-pick -Xpatience topic^(4)\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 12,
          "content_length": 4118
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-cherry-pick",
    "doc_type": "git",
    "total_sections": 6
  },
  {
    "title": "Git",
    "summary": "NAME git-citool - Graphical alternative to git-commit",
    "sections": [
      {
        "header": "NAME",
        "content": "git-citool - Graphical alternative to git-commit",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 48
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "A Tcl/Tk based graphical interface to review modified files, stage them into the index, enter a commit message and record the new commit onto the current branch. This interface is an alternative to the less interactive git commit program.\n\ngit citool is actually a standard alias for git gui citool. See git-gui[1] for more details.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 332
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-citool",
    "doc_type": "git",
    "total_sections": 3
  },
  {
    "title": "Git",
    "summary": "NAME git-clean - Remove untracked files from the working tree\n\ngit-clean - Remove untracked files from the working tree",
    "sections": [
      {
        "header": "NAME",
        "content": "git-clean - Remove untracked files from the working tree",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 56
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Cleans the working tree by recursively removing files that are not under version control, starting from the current directory.\n\nNormally, only files unknown to Git are removed, but if the -x option is specified, ignored files are also removed. This can, for example, be useful to remove all build products.\n\nIf any optional <pathspec>... arguments are given, only those paths that match the pathspec are affected.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 413
        }
      },
      {
        "header": "OPTIONS",
        "content": "Normally, when no <pathspec> is specified, git clean will not recurse into untracked directories to avoid removing too much. Specify -d to have it recurse into such directories as well. If a <pathspec> is specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions for nested git directories mentioned under --force) will be removed.\n\nIf the Git configuration variable clean.requireForce is not set to false, git clean will refuse to delete files or directories unless given -f. Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory) unless a second -f is given.\n\nShow what would be done and clean files interactively. See “Interactive mode” for details. Configuration variable clean.requireForce is ignored, as this mode gives its own safety protection by going interactive.\n\nDon’t actually remove anything, just show what would be done. Configuration variable clean.requireForce is ignored, as nothing will be deleted anyway.\n\nBe quiet, only report errors, but not the files that are successfully removed.\n\nUse the given exclude pattern in addition to the standard ignore rules (see gitignore[5]).\n\nDon’t use the standard ignore rules (see gitignore[5]), but still use the ignore rules given with -e options from the command line. This allows removing all untracked files, including build products. This can be used (possibly in conjunction with git restore or git reset) to create a pristine working directory to test a clean build.\n\nRemove only files ignored by Git. This may be useful to rebuild everything from scratch, but keep manually created files.\n\n**-d**: Normally, when no <pathspec> is specified, git clean will not recurse into untracked directories to avoid removing too much. Specify -d to have it recurse into such directories as well. If a <pathspec> is specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions for nested git directories mentioned under --force) will be removed.\n**-f**: If the Git configuration variable clean.requireForce is not set to false, git clean will refuse to delete files or directories unless given -f. Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory) unless a second -f is given.\n**--force**: Show what would be done and clean files interactively. See “Interactive mode” for details. Configuration variable clean.requireForce is ignored, as this mode gives its own safety protection by going interactive.\n**-i**: Don’t actually remove anything, just show what would be done. Configuration variable clean.requireForce is ignored, as nothing will be deleted anyway.\n**--interactive**: Be quiet, only report errors, but not the files that are successfully removed.\n**-n**: Use the given exclude pattern in addition to the standard ignore rules (see gitignore[5]).\n**--dry-run**: Don’t use the standard ignore rules (see gitignore[5]), but still use the ignore rules given with -e options from the command line. This allows removing all untracked files, including build products. This can be used (possibly in conjunction with git restore or git reset) to create a pristine working directory to test a clean build.\n**-q**: Remove only files ignored by Git. This may be useful to rebuild everything from scratch, but keep manually created files.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 3356
        }
      },
      {
        "header": "Interactive mode",
        "content": "When the command enters the interactive mode, it shows the files and directories to be cleaned, and goes into its interactive command loop.\n\nThe command loop shows the list of subcommands available, and gives a prompt \"What now> \". In general, when the prompt ends with a single >, you can pick only one of the choices given and type return, like this:\n\nYou also could say c or clean above as long as the choice is unique.\n\nThe main command loop has 6 subcommands.\n\nStart cleaning files and directories, and then quit.\n\nThis shows the files and directories to be deleted and issues an \"Input ignore patterns>>\" prompt. You can input space-separated patterns to exclude files and directories from deletion. E.g. \"*.c *.h\" will exclude files ending with \".c\" and \".h\" from deletion. When you are satisfied with the filtered result, press ENTER (empty) back to the main menu.\n\nThis shows the files and directories to be deleted and issues an \"Select items to delete>>\" prompt. When the prompt ends with double >> like this, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. \"2-5 7,9\" to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining items are selected. E.g. \"7-\" to choose 7,8,9 from the list. You can say * to choose everything. Also when you are satisfied with the filtered result, press ENTER (empty) back to the main menu.\n\nThis will start to clean, and you must confirm one by one in order to delete items. Please note that this action is not as efficient as the above two actions.\n\nThis lets you quit without doing any cleaning.\n\nShow brief usage of interactive git-clean.\n\n**clean**: Start cleaning files and directories, and then quit.\n**filter by pattern**: This shows the files and directories to be deleted and issues an \"Input ignore patterns>>\" prompt. You can input space-separated patterns to exclude files and directories from deletion. E.g. \"*.c *.h\" will exclude files ending with \".c\" and \".h\" from deletion. When you are satisfied with the filtered result, press ENTER (empty) back to the main menu.\n**select by numbers**: This shows the files and directories to be deleted and issues an \"Select items to delete>>\" prompt. When the prompt ends with double >> like this, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. \"2-5 7,9\" to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining items are selected. E.g. \"7-\" to choose 7,8,9 from the list. You can say * to choose everything. Also when you are satisfied with the filtered result, press ENTER (empty) back to the main menu.\n**ask each**: This will start to clean, and you must confirm one by one in order to delete items. Please note that this action is not as efficient as the above two actions.\n**quit**: This lets you quit without doing any cleaning.\n**help**: Show brief usage of interactive git-clean.",
        "code_examples": [
          "```bash\n*** Commands ***\n\t1: clean                2: filter by pattern    3: select by numbers\n\t4: ask each             5: quit                 6: help\n    What now> 1\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 2978
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Everything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there:\n\nA boolean to make git-clean refuse to delete files unless -f is given. Defaults to true.\n\n**clean.requireForce**: A boolean to make git-clean refuse to delete files unless -f is given. Defaults to true.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 355
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-clean",
    "doc_type": "git",
    "total_sections": 6
  },
  {
    "title": "Git",
    "summary": "NAME git-clone - Clone a repository into a new directory\n\ngit-clone - Clone a repository into a new directory",
    "sections": [
      {
        "header": "NAME",
        "content": "git-clone - Clone a repository into a new directory",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 51
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Clones a repository into a newly created directory, creates remote-tracking branches for each branch in the cloned repository (visible using git branch --remotes), and creates and checks out an initial branch that is forked from the cloned repository’s currently active branch.\n\nAfter the clone, a plain git fetch without arguments will update all the remote-tracking branches, and a git pull without arguments will in addition merge the remote master branch into the current master branch, if any (this is untrue when --single-branch is given; see below).\n\nThis default configuration is achieved by creating references to the remote branch heads under refs/remotes/origin and by initializing remote.origin.url and remote.origin.fetch configuration variables.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 759
        }
      },
      {
        "header": "OPTIONS",
        "content": "When the repository to clone from is on a local machine, this flag bypasses the normal \"Git aware\" transport mechanism and clones the repository by making a copy of HEAD and everything under objects and refs directories. The files under .git/objects/ directory are hardlinked to save space when possible.\n\nIf the repository is specified as a local path (e.g., /path/to/repo), this is the default, and --local is essentially a no-op. If the repository is specified as a URL, then this flag is ignored (and we never use the local optimizations). Specifying --no-local will override the default when /path/to/repo is given, using the regular Git transport instead.\n\nIf the repository’s $GIT_DIR/objects has symbolic links or is a symbolic link, the clone will fail. This is a security measure to prevent the unintentional copying of files by dereferencing the symbolic links.\n\nThis option does not work with repositories owned by other users for security reasons, and --no-local must be specified for the clone to succeed.\n\nNOTE: this operation can race with concurrent modification to the source repository, similar to running cp -r <src> <dst> while modifying <src>.\n\nForce the cloning process from a repository on a local filesystem to copy the files under the .git/objects directory instead of using hardlinks. This may be desirable if you are trying to make a back-up of your repository.\n\nWhen the repository to clone is on the local machine, instead of using hard links, automatically setup .git/objects/info/alternates to share the objects with the source repository. The resulting repository starts out without any object of its own.\n\nNOTE: this is a possibly dangerous operation; do not use it unless you understand what it does. If you clone your repository using this option and then delete branches (or use any other Git command that makes any existing commit unreferenced) in the source repository, some objects may become unreferenced (or dangling). These objects may be removed by normal Git operations (such as git commit) which automatically call git maintenance run --auto. (See git-maintenance[1].) If these objects are removed and were referenced by the cloned repository, then the cloned repository will become corrupt.\n\nNote that running git repack without the --local option in a repository cloned with --shared will copy objects from the source repository into a pack in the cloned repository, removing the disk space savings of clone --shared. It is safe, however, to run git gc, which uses the --local option by default.\n\nIf you want to break the dependency of a repository cloned with --shared on its source repository, you can simply run git repack -a to copy all objects from the source repository into a pack in the cloned repository.\n\nIf the reference <repository> is on the local machine, automatically setup .git/objects/info/alternates to obtain objects from the reference <repository>. Using an already existing repository as an alternate will require fewer objects to be copied from the repository being cloned, reducing network and local storage costs. When using the --reference-if-able, a non existing directory is skipped with a warning instead of aborting the clone.\n\nNOTE: see the NOTE for the --shared option, and also the --dissociate option.\n\nBorrow the objects from reference repositories specified with the --reference options only to reduce network transfer, and stop borrowing from them after a clone is made by making necessary local copies of borrowed objects. This option can also be used when cloning locally from a repository that already borrows objects from another repository—the new repository will borrow objects from the same repository, and this option can be used to stop the borrowing.\n\nOperate quietly. Progress is not reported to the standard error stream.\n\nRun verbosely. Does not affect the reporting of progress status to the standard error stream.\n\nProgress status is reported on the standard error stream by default when it is attached to a terminal, unless --quiet is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.\n\nTransmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. The server’s handling of server options, including unknown ones, is server-specific. When multiple --server-option=<option> are given, they are all sent to the other side in the order listed on the command line. When no --server-option=<option> is given from the command line, the values of configuration variable remote.<name>.serverOption are used instead.\n\nNo checkout of HEAD is performed after the clone is complete.\n\nFail if the source repository is a shallow repository. The clone.rejectShallow configuration variable can be used to specify the default.\n\nMake a bare Git repository. That is, instead of creating <directory> and placing the administrative files in <directory>/.git, make the <directory> itself the $GIT_DIR. This obviously implies the --no-checkout because there is nowhere to check out the working tree. Also the branch heads at the remote are copied directly to corresponding local branch heads, without mapping them to refs/remotes/origin/. When this option is used, neither remote-tracking branches nor the related configuration variables are created.\n\nEmploy a sparse-checkout, with only files in the toplevel directory initially being present. The git-sparse-checkout[1] command can be used to grow the working directory as needed.\n\nUse the partial clone feature and request that the server sends a subset of reachable objects according to a given object filter. When using --filter, the supplied <filter-spec> is used for the partial clone filter. For example, --filter=blob:none will filter out all blobs (file contents) until needed by Git. Also, --filter=blob:limit=<size> will filter out all blobs of size at least <size>. For more details on filter specifications, see the --filter option in git-rev-list[1].\n\nAlso apply the partial clone filter to any submodules in the repository. Requires --filter and --recurse-submodules. This can be turned on by default by setting the clone.filterSubmodules config option.\n\nSet up a mirror of the source repository. This implies --bare. Compared to --bare, --mirror not only maps local branches of the source to local branches of the target, it maps all refs (including remote-tracking branches, notes etc.) and sets up a refspec configuration such that all these refs are overwritten by a git remote update in the target repository.\n\nInstead of using the remote name origin to keep track of the upstream repository, use <name>. Overrides clone.defaultRemoteName from the config.\n\nInstead of pointing the newly created HEAD to the branch pointed to by the cloned repository’s HEAD, point to <name> branch instead. In a non-bare repository, this is the branch that will be checked out. --branch can also take tags and detaches the HEAD at that commit in the resulting repository.\n\nCreate a new repository, and fetch the history leading to the given revision <rev> (and nothing else), without making any remote-tracking branch, and without making any local branch, and detach HEAD to <rev>. The argument can be a ref name (e.g. refs/heads/main or refs/tags/v1.0) that peels down to a commit, or a hexadecimal object name. This option is incompatible with --branch and --mirror.\n\nWhen given, and the repository to clone from is accessed via ssh, this specifies a non-default path for the command run on the other end.\n\nSpecify the directory from which templates will be used; (See the \"TEMPLATE DIRECTORY\" section of git-init[1].)\n\nSet a configuration variable in the newly-created repository; this takes effect immediately after the repository is initialized, but before the remote history is fetched or any files checked out. The <key> is in the same format as expected by git-config[1] (e.g., core.eol=true). If multiple values are given for the same key, each value will be written to the config file. This makes it safe, for example, to add additional fetch refspecs to the origin remote.\n\nDue to limitations of the current implementation, some configuration variables do not take effect until after the initial fetch and checkout. Configuration variables known to not take effect are: remote.<name>.mirror and remote.<name>.tagOpt. Use the corresponding --mirror and --no-tags options instead.\n\nCreate a shallow clone with a history truncated to the specified number of commits. Implies --single-branch unless --no-single-branch is given to fetch the histories near the tips of all branches. If you want to clone submodules shallowly, also pass --shallow-submodules.\n\nCreate a shallow clone with a history after the specified time.\n\nCreate a shallow clone with a history, excluding commits reachable from a specified remote branch or tag. This option can be specified multiple times.\n\nClone only the history leading to the tip of a single branch, either specified by the --branch option or the primary branch remote’s HEAD points at. Further fetches into the resulting repository will only update the remote-tracking branch for the branch this option was used for the initial cloning. If the HEAD at the remote did not point at any branch when --single-branch clone was made, no remote-tracking branch is created.\n\nControl whether or not tags will be cloned. When --no-tags is given, the option will be become permanent by setting the remote.<remote>.tagOpt=--no-tags configuration. This ensures that future git pull and git fetch won’t follow any tags. Subsequent explicit tag fetches will still work (see git-fetch[1]).\n\nBy default, tags are cloned and passing --tags is thus typically a no-op, unless it cancels out a previous --no-tags.\n\nCan be used in conjunction with --single-branch to clone and maintain a branch with no references other than a single cloned branch. This is useful e.g. to maintain minimal clones of the default branch of some repository for search indexing.\n\nAfter the clone is created, initialize and clone submodules within based on the provided <pathspec>. If no =<pathspec> is provided, all submodules are initialized and cloned. This option can be given multiple times for pathspecs consisting of multiple entries. The resulting clone has submodule.active set to the provided pathspec, or \".\" (meaning all submodules) if no pathspec is provided.\n\nSubmodules are initialized and cloned using their default settings. This is equivalent to running git submodule update --init --recursive <pathspec> immediately after the clone is finished. This option is ignored if the cloned repository does not have a worktree/checkout (i.e. if any of --no-checkout/-n, --bare, or --mirror is given)\n\nAll submodules which are cloned will be shallow with a depth of 1.\n\nAll submodules which are cloned will use the status of the submodule’s remote-tracking branch to update the submodule, rather than the superproject’s recorded SHA-1. Equivalent to passing --remote to git submodule update.\n\nInstead of placing the cloned repository where it is supposed to be, place the cloned repository at the specified directory, then make a filesystem-agnostic Git symbolic link to there. The result is Git repository can be separated from working tree.\n\nSpecify the given ref storage format for the repository. The valid values are:\n\nfiles for loose files with packed-refs. This is the default.\n\nreftable for the reftable format. This format is experimental and its internals are subject to change.\n\nThe number of submodules fetched at the same time. Defaults to the submodule.fetchJobs option.\n\nThe (possibly remote) <repository> to clone from. See the GIT URLS section below for more information on specifying repositories.\n\nThe name of a new directory to clone into. The \"humanish\" part of the source repository is used if no <directory> is explicitly given (repo for /path/to/repo.git and foo for host.xz:foo/.git). Cloning into an existing directory is only allowed if the directory is empty.\n\nBefore fetching from the remote, fetch a bundle from the given <uri> and unbundle the data into the local repository. The refs in the bundle will be stored under the hidden refs/bundle/* namespace. This option is incompatible with --depth, --shallow-since, and --shallow-exclude.\n\n• files for loose files with packed-refs. This is the default.\n• reftable for the reftable format. This format is experimental and its internals are subject to change.\n\n**-l**: When the repository to clone from is on a local machine, this flag bypasses the normal \"Git aware\" transport mechanism and clones the repository by making a copy of HEAD and everything under objects and refs directories. The files under .git/objects/ directory are hardlinked to save space when possible. If the repository is specified as a local path (e.g., /path/to/repo), this is the default, and --local is essentially a no-op. If the repository is specified as a URL, then this flag is ignored (and we never use the local optimizations). Specifying --no-local will override the default when /path/to/repo is given, using the regular Git transport instead. If the repository’s $GIT_DIR/objects has symbolic links or is a symbolic link, the clone will fail. This is a security measure to prevent the unintentional copying of files by dereferencing the symbolic links. This option does not work with repositories owned by other users for security reasons, and --no-local must be specified for the clone to succeed. NOTE: this operation can race with concurrent modification to the source repository, similar to running cp -r <src> <dst> while modifying <src>.\n**--local**: Force the cloning process from a repository on a local filesystem to copy the files under the .git/objects directory instead of using hardlinks. This may be desirable if you are trying to make a back-up of your repository.\n**--no-hardlinks**: When the repository to clone is on the local machine, instead of using hard links, automatically setup .git/objects/info/alternates to share the objects with the source repository. The resulting repository starts out without any object of its own. NOTE: this is a possibly dangerous operation; do not use it unless you understand what it does. If you clone your repository using this option and then delete branches (or use any other Git command that makes any existing commit unreferenced) in the source repository, some objects may become unreferenced (or dangling). These objects may be removed by normal Git operations (such as git commit) which automatically call git maintenance run --auto. (See git-maintenance[1].) If these objects are removed and were referenced by the cloned repository, then the cloned repository will become corrupt. Note that running git repack without the --local option in a repository cloned with --shared will copy objects from the source repository into a pack in the cloned repository, removing the disk space savings of clone --shared. It is safe, however, to run git gc, which uses the --local option by default. If you want to break the dependency of a repository cloned with --shared on its source repository, you can simply run git repack -a to copy all objects from the source repository into a pack in the cloned repository.\n**-s**: If the reference <repository> is on the local machine, automatically setup .git/objects/info/alternates to obtain objects from the reference <repository>. Using an already existing repository as an alternate will require fewer objects to be copied from the repository being cloned, reducing network and local storage costs. When using the --reference-if-able, a non existing directory is skipped with a warning instead of aborting the clone. NOTE: see the NOTE for the --shared option, and also the --dissociate option.\n**--shared**: Borrow the objects from reference repositories specified with the --reference options only to reduce network transfer, and stop borrowing from them after a clone is made by making necessary local copies of borrowed objects. This option can also be used when cloning locally from a repository that already borrows objects from another repository—the new repository will borrow objects from the same repository, and this option can be used to stop the borrowing.\n**--reference[-if-able] <repository>**: Operate quietly. Progress is not reported to the standard error stream.\n**--dissociate**: Run verbosely. Does not affect the reporting of progress status to the standard error stream.\n**-q**: Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --quiet is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.\n**--quiet**: Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. The server’s handling of server options, including unknown ones, is server-specific. When multiple --server-option=<option> are given, they are all sent to the other side in the order listed on the command line. When no --server-option=<option> is given from the command line, the values of configuration variable remote.<name>.serverOption are used instead.\n**-v**: No checkout of HEAD is performed after the clone is complete.\n**--verbose**: Fail if the source repository is a shallow repository. The clone.rejectShallow configuration variable can be used to specify the default.\n**--progress**: Make a bare Git repository. That is, instead of creating <directory> and placing the administrative files in <directory>/.git, make the <directory> itself the $GIT_DIR. This obviously implies the --no-checkout because there is nowhere to check out the working tree. Also the branch heads at the remote are copied directly to corresponding local branch heads, without mapping them to refs/remotes/origin/. When this option is used, neither remote-tracking branches nor the related configuration variables are created.\n**--server-option=<option>**: Employ a sparse-checkout, with only files in the toplevel directory initially being present. The git-sparse-checkout[1] command can be used to grow the working directory as needed.\n**-n**: Use the partial clone feature and request that the server sends a subset of reachable objects according to a given object filter. When using --filter, the supplied <filter-spec> is used for the partial clone filter. For example, --filter=blob:none will filter out all blobs (file contents) until needed by Git. Also, --filter=blob:limit=<size> will filter out all blobs of size at least <size>. For more details on filter specifications, see the --filter option in git-rev-list[1].\n**--no-checkout**: Also apply the partial clone filter to any submodules in the repository. Requires --filter and --recurse-submodules. This can be turned on by default by setting the clone.filterSubmodules config option.\n**--[no-]reject-shallow**: Set up a mirror of the source repository. This implies --bare. Compared to --bare, --mirror not only maps local branches of the source to local branches of the target, it maps all refs (including remote-tracking branches, notes etc.) and sets up a refspec configuration such that all these refs are overwritten by a git remote update in the target repository.\n**--bare**: Instead of using the remote name origin to keep track of the upstream repository, use <name>. Overrides clone.defaultRemoteName from the config.\n**--sparse**: Instead of pointing the newly created HEAD to the branch pointed to by the cloned repository’s HEAD, point to <name> branch instead. In a non-bare repository, this is the branch that will be checked out. --branch can also take tags and detaches the HEAD at that commit in the resulting repository.\n**--filter=<filter-spec>**: Create a new repository, and fetch the history leading to the given revision <rev> (and nothing else), without making any remote-tracking branch, and without making any local branch, and detach HEAD to <rev>. The argument can be a ref name (e.g. refs/heads/main or refs/tags/v1.0) that peels down to a commit, or a hexadecimal object name. This option is incompatible with --branch and --mirror.\n**--also-filter-submodules**: When given, and the repository to clone from is accessed via ssh, this specifies a non-default path for the command run on the other end.\n**--mirror**: Specify the directory from which templates will be used; (See the \"TEMPLATE DIRECTORY\" section of git-init[1].)\n**-o <name>**: Set a configuration variable in the newly-created repository; this takes effect immediately after the repository is initialized, but before the remote history is fetched or any files checked out. The <key> is in the same format as expected by git-config[1] (e.g., core.eol=true). If multiple values are given for the same key, each value will be written to the config file. This makes it safe, for example, to add additional fetch refspecs to the origin remote. Due to limitations of the current implementation, some configuration variables do not take effect until after the initial fetch and checkout. Configuration variables known to not take effect are: remote.<name>.mirror and remote.<name>.tagOpt. Use the corresponding --mirror and --no-tags options instead.\n**--origin <name>**: Create a shallow clone with a history truncated to the specified number of commits. Implies --single-branch unless --no-single-branch is given to fetch the histories near the tips of all branches. If you want to clone submodules shallowly, also pass --shallow-submodules.\n**-b <name>**: Create a shallow clone with a history after the specified time.\n**--branch <name>**: Create a shallow clone with a history, excluding commits reachable from a specified remote branch or tag. This option can be specified multiple times.\n**--revision=<rev>**: Clone only the history leading to the tip of a single branch, either specified by the --branch option or the primary branch remote’s HEAD points at. Further fetches into the resulting repository will only update the remote-tracking branch for the branch this option was used for the initial cloning. If the HEAD at the remote did not point at any branch when --single-branch clone was made, no remote-tracking branch is created.\n**-u <upload-pack>**: Control whether or not tags will be cloned. When --no-tags is given, the option will be become permanent by setting the remote.<remote>.tagOpt=--no-tags configuration. This ensures that future git pull and git fetch won’t follow any tags. Subsequent explicit tag fetches will still work (see git-fetch[1]). By default, tags are cloned and passing --tags is thus typically a no-op, unless it cancels out a previous --no-tags. Can be used in conjunction with --single-branch to clone and maintain a branch with no references other than a single cloned branch. This is useful e.g. to maintain minimal clones of the default branch of some repository for search indexing.\n**--upload-pack <upload-pack>**: After the clone is created, initialize and clone submodules within based on the provided <pathspec>. If no =<pathspec> is provided, all submodules are initialized and cloned. This option can be given multiple times for pathspecs consisting of multiple entries. The resulting clone has submodule.active set to the provided pathspec, or \".\" (meaning all submodules) if no pathspec is provided. Submodules are initialized and cloned using their default settings. This is equivalent to running git submodule update --init --recursive <pathspec> immediately after the clone is finished. This option is ignored if the cloned repository does not have a worktree/checkout (i.e. if any of --no-checkout/-n, --bare, or --mirror is given)\n**--template=<template-directory>**: All submodules which are cloned will be shallow with a depth of 1.\n**-c <key>=<value>**: All submodules which are cloned will use the status of the submodule’s remote-tracking branch to update the submodule, rather than the superproject’s recorded SHA-1. Equivalent to passing --remote to git submodule update.\n**--config <key>=<value>**: Instead of placing the cloned repository where it is supposed to be, place the cloned repository at the specified directory, then make a filesystem-agnostic Git symbolic link to there. The result is Git repository can be separated from working tree.\n**--depth <depth>**: Specify the given ref storage format for the repository. The valid values are: files for loose files with packed-refs. This is the default. reftable for the reftable format. This format is experimental and its internals are subject to change.\n**--shallow-since=<date>**: The number of submodules fetched at the same time. Defaults to the submodule.fetchJobs option.\n**--shallow-exclude=<ref>**: The (possibly remote) <repository> to clone from. See the GIT URLS section below for more information on specifying repositories.\n**--[no-]single-branch**: The name of a new directory to clone into. The \"humanish\" part of the source repository is used if no <directory> is explicitly given (repo for /path/to/repo.git and foo for host.xz:foo/.git). Cloning into an existing directory is only allowed if the directory is empty.\n**--[no-]tags**: Before fetching from the remote, fetch a bundle from the given <uri> and unbundle the data into the local repository. The refs in the bundle will be stored under the hidden refs/bundle/* namespace. This option is incompatible with --depth, --shallow-since, and --shallow-exclude.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 50,
          "content_length": 25536
        }
      },
      {
        "header": "GIT URLS",
        "content": "In general, URLs contain information about the transport protocol, the address of the remote server, and the path to the repository. Depending on the transport protocol, some of this information may be absent.\n\nGit supports ssh, git, http, and https protocols (in addition, ftp and ftps can be used for fetching, but this is inefficient and deprecated; do not use them).\n\nThe native transport (i.e. git:// URL) does no authentication and should be used with caution on unsecured networks.\n\nThe following syntaxes may be used with them:\n\nssh://[<user>@]<host>[:<port>]/<path-to-git-repo>\n\ngit://<host>[:<port>]/<path-to-git-repo>\n\nhttp[s]://<host>[:<port>]/<path-to-git-repo>\n\nftp[s]://<host>[:<port>]/<path-to-git-repo>\n\nAn alternative scp-like syntax may also be used with the ssh protocol:\n\n[<user>@]<host>:/<path-to-git-repo>\n\nThis syntax is only recognized if there are no slashes before the first colon. This helps differentiate a local path that contains a colon. For example the local path foo:bar could be specified as an absolute path or ./foo:bar to avoid being misinterpreted as an ssh url.\n\nThe ssh and git protocols additionally support ~<username> expansion:\n\nssh://[<user>@]<host>[:<port>]/~<user>/<path-to-git-repo>\n\ngit://<host>[:<port>]/~<user>/<path-to-git-repo>\n\n[<user>@]<host>:~<user>/<path-to-git-repo>\n\nFor local repositories, also supported by Git natively, the following syntaxes may be used:\n\nfile:///path/to/repo.git/\n\nThese two syntaxes are mostly equivalent, except the former implies --local option.\n\ngit clone, git fetch and git pull, but not git push, will also accept a suitable bundle file. See git-bundle[1].\n\nWhen Git doesn’t know how to handle a certain transport protocol, it attempts to use the remote-<transport> remote helper, if one exists. To explicitly request a remote helper, the following syntax may be used:\n\n<transport>::<address>\n\nwhere <address> may be a path, a server and path, or an arbitrary URL-like string recognized by the specific remote helper being invoked. See gitremote-helpers[7] for details.\n\nIf there are a large number of similarly-named remote repositories and you want to use a different format for them (such that the URLs you use will be rewritten into URLs that work), you can create a configuration section of the form:\n\nFor example, with this:\n\na URL like \"work:repo.git\" or like \"host.xz:/path/to/repo.git\" will be rewritten in any context that takes a URL to be \"git://git.host.xz/repo.git\".\n\nIf you want to rewrite URLs for push only, you can create a configuration section of the form:\n\nFor example, with this:\n\na URL like \"git://example.org/path/to/repo.git\" will be rewritten to \"ssh://example.org/path/to/repo.git\" for pushes, but pulls will still use the original URL.\n\n• ssh://[<user>@]<host>[:<port>]/<path-to-git-repo>\n• git://<host>[:<port>]/<path-to-git-repo>\n• http[s]://<host>[:<port>]/<path-to-git-repo>\n• ftp[s]://<host>[:<port>]/<path-to-git-repo>\n\n• [<user>@]<host>:/<path-to-git-repo>\n\n• ssh://[<user>@]<host>[:<port>]/~<user>/<path-to-git-repo>\n• git://<host>[:<port>]/~<user>/<path-to-git-repo>\n• [<user>@]<host>:~<user>/<path-to-git-repo>\n\n• /path/to/repo.git/\n• file:///path/to/repo.git/\n\n• <transport>::<address>",
        "code_examples": [
          "```bash\n[url \"<actual-url-base>\"]\n\t\tinsteadOf =<other-url-base>\n```",
          "```bash\n[url \"<actual-url-base>\"]\n\t\tpushInsteadOf =<other-url-base>\n```"
        ],
        "usage_examples": [
          "```bash\n[url \"git://git.host.xz/\"]\n\t\tinsteadOf = host.xz:/path/to/\n\t\tinsteadOf = work:\n```",
          "```bash\n[url \"ssh://example.org/\"]\n\t\tpushInsteadOf = git://example.org/\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 28,
          "content_length": 3212
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Clone from upstream:\n\nMake a local clone that borrows from the current directory, without checking things out:\n\nClone from upstream while borrowing from an existing local directory:\n\nCreate a bare repository to publish your changes to the public:\n\nClone a local repository from a different user:\n\n• Clone from upstream: $ git clone git://git.kernel.org/pub/scm/.../linux.git my-linux $ cd my-linux $ make\n• Make a local clone that borrows from the current directory, without checking things out: $ git clone -l -s -n . ../copy $ cd ../copy $ git show-branch\n• Clone from upstream while borrowing from an existing local directory: $ git clone --reference /git/linux.git \\ git://git.kernel.org/pub/scm/.../linux.git \\ my-linux $ cd my-linux\n• Create a bare repository to publish your changes to the public: $ git clone --bare -l /home/proj/.git /pub/scm/proj.git\n• Clone a local repository from a different user: $ git clone --no-local /home/otheruser/proj.git /pub/scm/proj.git",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git clone git://git.kernel.org/pub/scm/.../linux.git my-linux\n$ cd my-linux\n$ make\n```",
          "```bash\n$ git clone -l -s -n . ../copy\n$ cd ../copy\n$ git show-branch\n```",
          "```bash\n$ git clone --reference /git/linux.git \\\n\tgit://git.kernel.org/pub/scm/.../linux.git \\\n\tmy-linux\n$ cd my-linux\n```",
          "```bash\n$ git clone --bare -l /home/proj/.git /pub/scm/proj.git\n```",
          "```bash\n$ git clone --no-local /home/otheruser/proj.git /pub/scm/proj.git\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 976
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Everything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there:\n\nSpecify the directory from which templates will be copied. (See the \"TEMPLATE DIRECTORY\" section of git-init[1].)\n\nAllows overriding the default branch name e.g. when initializing a new repository.\n\nAllows overriding the default object format for new repositories. See --object-format= in git-init[1]. Both the command line option and the GIT_DEFAULT_HASH environment variable take precedence over this config.\n\nAllows overriding the default ref storage format for new repositories. See --ref-format= in git-init[1]. Both the command line option and the GIT_DEFAULT_REF_FORMAT environment variable take precedence over this config.\n\nThe name of the remote to create when cloning a repository. Defaults to origin. It can be overridden by passing the --origin command-line option.\n\nReject cloning a repository if it is a shallow one; this can be overridden by passing the --reject-shallow option on the command line.\n\nIf a partial clone filter is provided (see --filter in git-rev-list[1]) and --recurse-submodules is used, also apply the filter to submodules.\n\n**init.templateDir**: Specify the directory from which templates will be copied. (See the \"TEMPLATE DIRECTORY\" section of git-init[1].)\n**init.defaultBranch**: Allows overriding the default branch name e.g. when initializing a new repository.\n**init.defaultObjectFormat**: Allows overriding the default object format for new repositories. See --object-format= in git-init[1]. Both the command line option and the GIT_DEFAULT_HASH environment variable take precedence over this config.\n**init.defaultRefFormat**: Allows overriding the default ref storage format for new repositories. See --ref-format= in git-init[1]. Both the command line option and the GIT_DEFAULT_REF_FORMAT environment variable take precedence over this config.\n**clone.defaultRemoteName**: The name of the remote to create when cloning a repository. Defaults to origin. It can be overridden by passing the --origin command-line option.\n**clone.rejectShallow**: Reject cloning a repository if it is a shallow one; this can be overridden by passing the --reject-shallow option on the command line.\n**clone.filterSubmodules**: If a partial clone filter is provided (see --filter in git-rev-list[1]) and --recurse-submodules is used, also apply the filter to submodules.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 2450
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-clone",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "Git",
    "summary": "SYNOPSIS git commit [-a | --interactive | --patch] [-s] [-v] [-u[<mode>]] [--amend] [--dry-run] <commit>_ | --fixup [(amend|reword):\"><commit>] [-F <file> | -m <msg>] [--reset-author] [--allow-empty] [--allow-empty-message] [--no-verify] [-e] [--author=<author>] [--date=<date>] [--cleanup=<mode>] [--[no-]status] [-i | -o] [--pathspec-from-file=<file> [--pathspec-file-nul]] [(--trailer <token>[(=|:)<value>])…] [-S[<keyid>]] [--] [<pathspec>…]",
    "sections": [
      {
        "header": "NAME",
        "content": "git-commit - Record changes to the repository",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 45
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Create a new commit containing the current contents of the index and the given log message describing the changes. The new commit is a direct child of HEAD, usually the tip of the current branch, and the branch is updated to point to it (unless no branch is associated with the working tree, in which case HEAD is \"detached\" as described in git-checkout[1]).\n\nThe content to be committed can be specified in several ways:\n\nby using git-add[1] to incrementally \"add\" changes to the index before using the commit command (Note: even modified files must be \"added\");\n\nby using git-rm[1] to remove files from the working tree and the index, again before using the commit command;\n\nby listing files as arguments to the commit command (without --interactive or --patch switch), in which case the commit will ignore changes staged in the index, and instead record the current content of the listed files (which must already be known to Git);\n\nby using the -a switch with the commit command to automatically \"add\" changes from all known files (i.e. all files that are already listed in the index) and to automatically \"rm\" files in the index that have been removed from the working tree, and then perform the actual commit;\n\nby using the --interactive or --patch switches with the commit command to decide one by one which files or hunks should be part of the commit in addition to contents in the index, before finalizing the operation. See the “Interactive Mode” section of git-add[1] to learn how to operate these modes.\n\nThe --dry-run option can be used to obtain a summary of what is included by any of the above for the next commit by giving the same set of parameters (options and paths).\n\nIf you make a commit and then find a mistake immediately after that, you can recover from it with git reset.\n\n• by using git-add[1] to incrementally \"add\" changes to the index before using the commit command (Note: even modified files must be \"added\");\n• by using git-rm[1] to remove files from the working tree and the index, again before using the commit command;\n• by listing files as arguments to the commit command (without --interactive or --patch switch), in which case the commit will ignore changes staged in the index, and instead record the current content of the listed files (which must already be known to Git);\n• by using the -a switch with the commit command to automatically \"add\" changes from all known files (i.e. all files that are already listed in the index) and to automatically \"rm\" files in the index that have been removed from the working tree, and then perform the actual commit;\n• by using the --interactive or --patch switches with the commit command to decide one by one which files or hunks should be part of the commit in addition to contents in the index, before finalizing the operation. See the “Interactive Mode” section of git-add[1] to learn how to operate these modes.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 2897
        }
      },
      {
        "header": "OPTIONS",
        "content": "Automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected.\n\nUse the interactive patch selection interface to choose which changes to commit. See git-add[1] for details.\n\nGenerate diffs with <n> lines of context. Defaults to diff.context or 3 if the config option is unset.\n\nShow the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n\nTake an existing <commit> object, and reuse the log message and the authorship information (including the timestamp) when creating the commit.\n\nLike -C, but with -c the editor is invoked, so that the user can further edit the commit message.\n\nCreate a new commit which \"fixes up\" <commit> when applied with git rebase --autosquash. Plain --fixup=<commit> creates a \"fixup!\" commit which changes the content of <commit> but leaves its log message untouched. --fixup=amend:<commit> is similar but creates an \"amend!\" commit which also replaces the log message of <commit> with the log message of the \"amend!\" commit. --fixup=reword:<commit> creates an \"amend!\" commit which replaces the log message of <commit> with its own log message but makes no changes to the content of <commit>.\n\nThe commit created by plain --fixup=<commit> has a title composed of \"fixup!\" followed by the title of <commit>, and is recognized specially by git rebase --autosquash. The -m option may be used to supplement the log message of the created commit, but the additional commentary will be thrown away once the \"fixup!\" commit is squashed into <commit> by git rebase --autosquash.\n\nThe commit created by --fixup=amend:<commit> is similar but its title is instead prefixed with \"amend!\". The log message of <commit> is copied into the log message of the \"amend!\" commit and opened in an editor so it can be refined. When git rebase --autosquash squashes the \"amend!\" commit into <commit>, the log message of <commit> is replaced by the refined log message from the \"amend!\" commit. It is an error for the \"amend!\" commit’s log message to be empty unless --allow-empty-message is specified.\n\n--fixup=reword:<commit> is shorthand for --fixup=amend:<commit> --only. It creates an \"amend!\" commit with only a log message (ignoring any changes staged in the index). When squashed by git rebase --autosquash, it replaces the log message of <commit> without making any other changes.\n\nNeither \"fixup!\" nor \"amend!\" commits change authorship of <commit> when applied by git rebase --autosquash. See git-rebase[1] for details.\n\nConstruct a commit message for use with git rebase --autosquash. The commit message title is taken from the specified commit with a prefix of \"squash! \". Can be used with additional commit message options (-m/-c/-C/-F). See git-rebase[1] for details.\n\nWhen used with -C/-c/--amend options, or when committing after a conflicting cherry-pick, declare that the authorship of the resulting commit now belongs to the committer. This also renews the author timestamp.\n\nWhen doing a dry-run, give the output in the short-format. See git-status[1] for details. Implies --dry-run.\n\nShow the branch and tracking info even in short-format.\n\nWhen doing a dry-run, give the output in a porcelain-ready format. See git-status[1] for details. Implies --dry-run.\n\nWhen doing a dry-run, give the output in the long-format. Implies --dry-run.\n\nWhen showing short or porcelain status output, print the filename verbatim and terminate the entries with NUL, instead of LF. If no format is given, implies the --porcelain output format. Without the -z option, filenames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n\nTake the commit message from <file>. Use - to read the message from the standard input.\n\nOverride the commit author. Specify an explicit author using the standard A U Thor <author@example.com> format. Otherwise <author> is assumed to be a pattern and is used to search for an existing commit by that author (i.e. git rev-list --all -i --author=<author>); the commit author is then copied from the first such commit found.\n\nOverride the author date used in the commit.\n\nUse <msg> as the commit message. If multiple -m options are given, their values are concatenated as separate paragraphs.\n\nThe -m option is mutually exclusive with -c, -C, and -F.\n\nWhen editing the commit message, start the editor with the contents in <file>. The commit.template configuration variable is often used to give this option implicitly to the command. This mechanism can be used by projects that want to guide participants with some hints on what to write in the message in what order. If the user exits the editor without editing the message, the commit is aborted. This has no effect when a message is given by other means, e.g. with the -m or -F options.\n\nAdd a Signed-off-by trailer by the committer at the end of the commit log message. The meaning of a signoff depends on the project to which you’re committing. For example, it may certify that the committer has the rights to submit the work under the project’s license or agrees to some contributor representation, such as a Developer Certificate of Origin. (See https://developercertificate.org for the one used by the Linux kernel and Git projects.) Consult the documentation or leadership of the project to which you’re contributing to understand how the signoffs are used in that project.\n\nThe --no-signoff option can be used to countermand an earlier --signoff option on the command line.\n\nSpecify a (<token>, <value>) pair that should be applied as a trailer. (e.g. git commit --trailer \"Signed-off-by:C O Mitter \\ <committer@example.com>\" --trailer \"Helped-by:C O Mitter \\ <committer@example.com>\" will add the Signed-off-by trailer and the Helped-by trailer to the commit message.) The trailer.* configuration variables (git-interpret-trailers[1]) can be used to define if a duplicated trailer is omitted, where in the run of trailers each trailer would appear, and other details.\n\nBypass the pre-commit and commit-msg hooks. See also githooks[5].\n\nUsually recording a commit that has the exact same tree as its sole parent commit is a mistake, and the command prevents you from making such a commit. This option bypasses the safety, and is primarily for use by foreign SCM interface scripts.\n\nCreate a commit with an empty commit message without using plumbing commands like git-commit-tree[1]. Like --allow-empty, this command is primarily for use by foreign SCM interface scripts.\n\nDetermine how the supplied commit message should be cleaned up before committing. The <mode> can be strip, whitespace, verbatim, scissors or default.\n\nStrip leading and trailing empty lines, trailing whitespace, commentary and collapse consecutive empty lines.\n\nSame as strip except #commentary is not removed.\n\nDo not change the message at all.\n\nSame as whitespace except that everything from (and including) the line found below is truncated, if the message is to be edited. \"#\" can be customized with core.commentChar.\n\nSame as strip if the message is to be edited. Otherwise whitespace.\n\nThe default can be changed by the commit.cleanup configuration variable (see git-config[1]).\n\nLet the user further edit the message taken from <file> with -F <file>, command line with -m <message>, and from <commit> with -C <commit>.\n\nUse the selected commit message without launching an editor. For example, git commit --amend --no-edit amends a commit without changing its commit message.\n\nReplace the tip of the current branch by creating a new commit. The recorded tree is prepared as usual (including the effect of the -i and -o options and explicit pathspec), and the message from the original commit is used as the starting point, instead of an empty message, when no other message is specified from the command line via options such as -m, -F, -c, etc. The new commit has the same parents and author as the current one (the --reset-author option can countermand this).\n\nIt is a rough equivalent for:\n\nbut can be used to amend a merge commit.\n\nYou should understand the implications of rewriting history if you amend a commit that has already been published. (See the \"RECOVERING FROM UPSTREAM REBASE\" section in git-rebase[1].)\n\nBypass the post-rewrite hook.\n\nBefore making a commit out of staged contents so far, stage the contents of paths given on the command line as well. This is usually not what you want unless you are concluding a conflicted merge.\n\nMake a commit by taking the updated working tree contents of the paths specified on the command line, disregarding any contents that have been staged for other paths. This is the default mode of operation of git commit if any paths are given on the command line, in which case this option can be omitted. If this option is specified together with --amend, then no paths need to be specified, which can be used to amend the last commit without committing changes that have already been staged. If used together with --allow-empty paths are also not required, and an empty commit will be created.\n\nPass pathspec in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config[1]). See also --pathspec-file-nul and global --literal-pathspecs.\n\nOnly meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).\n\nShow untracked files.\n\nThe <mode> parameter is optional (defaults to all), and is used to specify the handling of untracked files; when -u is not used, the default is normal, i.e. show untracked files and directories.\n\nThe possible options are:\n\nShow no untracked files\n\nShows untracked files and directories\n\nAlso shows individual files in untracked directories.\n\nAll usual spellings for Boolean value true are taken as normal and false as no. The default can be changed using the status.showUntrackedFiles configuration variable documented in git-config[1].\n\nShow unified diff between the HEAD commit and what would be committed at the bottom of the commit message template to help the user describe the commit by reminding what changes the commit has. Note that this diff output doesn’t have its lines prefixed with #. This diff will not be a part of the commit message. See the commit.verbose configuration variable in git-config[1].\n\nIf specified twice, show in addition the unified diff between what would be committed and the worktree files, i.e. the unstaged changes to tracked files.\n\nSuppress commit summary message.\n\nDo not create a commit, but show a list of paths that are to be committed, paths with local changes that will be left uncommitted and paths that are untracked.\n\nInclude the output of git-status[1] in the commit message template when using an editor to prepare the commit message. Defaults to on, but can be used to override configuration variable commit.status.\n\nDo not include the output of git-status[1] in the commit message template when using an editor to prepare the default commit message.\n\nGPG-sign commits. The <key-id> is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign.\n\nDo not interpret any more arguments as options.\n\nWhen <pathspec> is given on the command line, commit the contents of the files that match the pathspec without recording the changes already added to the index. The contents of these files are also staged for the next commit on top of what have been staged before.\n\nFor more details, see the pathspec entry in gitglossary[7].\n\n**-a**: Automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected.\n**--all**: Use the interactive patch selection interface to choose which changes to commit. See git-add[1] for details.\n**-p**: Generate diffs with <n> lines of context. Defaults to diff.context or 3 if the config option is unset.\n**--patch**: Show the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n**-U<n>**: Take an existing <commit> object, and reuse the log message and the authorship information (including the timestamp) when creating the commit.\n**--unified=<n>**: Like -C, but with -c the editor is invoked, so that the user can further edit the commit message.\n**--inter-hunk-context=<n>**: Create a new commit which \"fixes up\" <commit> when applied with git rebase --autosquash. Plain --fixup=<commit> creates a \"fixup!\" commit which changes the content of <commit> but leaves its log message untouched. --fixup=amend:<commit> is similar but creates an \"amend!\" commit which also replaces the log message of <commit> with the log message of the \"amend!\" commit. --fixup=reword:<commit> creates an \"amend!\" commit which replaces the log message of <commit> with its own log message but makes no changes to the content of <commit>. The commit created by plain --fixup=<commit> has a title composed of \"fixup!\" followed by the title of <commit>, and is recognized specially by git rebase --autosquash. The -m option may be used to supplement the log message of the created commit, but the additional commentary will be thrown away once the \"fixup!\" commit is squashed into <commit> by git rebase --autosquash. The commit created by --fixup=amend:<commit> is similar but its title is instead prefixed with \"amend!\". The log message of <commit> is copied into the log message of the \"amend!\" commit and opened in an editor so it can be refined. When git rebase --autosquash squashes the \"amend!\" commit into <commit>, the log message of <commit> is replaced by the refined log message from the \"amend!\" commit. It is an error for the \"amend!\" commit’s log message to be empty unless --allow-empty-message is specified. --fixup=reword:<commit> is shorthand for --fixup=amend:<commit> --only. It creates an \"amend!\" commit with only a log message (ignoring any changes staged in the index). When squashed by git rebase --autosquash, it replaces the log message of <commit> without making any other changes. Neither \"fixup!\" nor \"amend!\" commits change authorship of <commit> when applied by git rebase --autosquash. See git-rebase[1] for details.\n**-C <commit>**: Construct a commit message for use with git rebase --autosquash. The commit message title is taken from the specified commit with a prefix of \"squash! \". Can be used with additional commit message options (-m/-c/-C/-F). See git-rebase[1] for details.\n**--reuse-message=<commit>**: When used with -C/-c/--amend options, or when committing after a conflicting cherry-pick, declare that the authorship of the resulting commit now belongs to the committer. This also renews the author timestamp.\n**-c <commit>**: When doing a dry-run, give the output in the short-format. See git-status[1] for details. Implies --dry-run.\n**--reedit-message=<commit>**: Show the branch and tracking info even in short-format.\n**--fixup=[(amend|reword):]<commit>**: When doing a dry-run, give the output in a porcelain-ready format. See git-status[1] for details. Implies --dry-run.\n**--squash=<commit>**: When doing a dry-run, give the output in the long-format. Implies --dry-run.\n**--reset-author**: When showing short or porcelain status output, print the filename verbatim and terminate the entries with NUL, instead of LF. If no format is given, implies the --porcelain output format. Without the -z option, filenames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n**--short**: Take the commit message from <file>. Use - to read the message from the standard input.\n**--branch**: Override the commit author. Specify an explicit author using the standard A U Thor <author@example.com> format. Otherwise <author> is assumed to be a pattern and is used to search for an existing commit by that author (i.e. git rev-list --all -i --author=<author>); the commit author is then copied from the first such commit found.\n**--porcelain**: Override the author date used in the commit.\n**--long**: Use <msg> as the commit message. If multiple -m options are given, their values are concatenated as separate paragraphs. The -m option is mutually exclusive with -c, -C, and -F.\n**-z**: When editing the commit message, start the editor with the contents in <file>. The commit.template configuration variable is often used to give this option implicitly to the command. This mechanism can be used by projects that want to guide participants with some hints on what to write in the message in what order. If the user exits the editor without editing the message, the commit is aborted. This has no effect when a message is given by other means, e.g. with the -m or -F options.\n**--null**: Add a Signed-off-by trailer by the committer at the end of the commit log message. The meaning of a signoff depends on the project to which you’re committing. For example, it may certify that the committer has the rights to submit the work under the project’s license or agrees to some contributor representation, such as a Developer Certificate of Origin. (See https://developercertificate.org for the one used by the Linux kernel and Git projects.) Consult the documentation or leadership of the project to which you’re contributing to understand how the signoffs are used in that project. The --no-signoff option can be used to countermand an earlier --signoff option on the command line.\n**-F <file>**: Specify a (<token>, <value>) pair that should be applied as a trailer. (e.g. git commit --trailer \"Signed-off-by:C O Mitter \\ <committer@example.com>\" --trailer \"Helped-by:C O Mitter \\ <committer@example.com>\" will add the Signed-off-by trailer and the Helped-by trailer to the commit message.) The trailer.* configuration variables (git-interpret-trailers[1]) can be used to define if a duplicated trailer is omitted, where in the run of trailers each trailer would appear, and other details.\n**--file=<file>**: Bypass the pre-commit and commit-msg hooks. See also githooks[5].\n**--author=<author>**: Usually recording a commit that has the exact same tree as its sole parent commit is a mistake, and the command prevents you from making such a commit. This option bypasses the safety, and is primarily for use by foreign SCM interface scripts.\n**--date=<date>**: Create a commit with an empty commit message without using plumbing commands like git-commit-tree[1]. Like --allow-empty, this command is primarily for use by foreign SCM interface scripts.\n**-m <msg>**: Determine how the supplied commit message should be cleaned up before committing. The <mode> can be strip, whitespace, verbatim, scissors or default. strip Strip leading and trailing empty lines, trailing whitespace, commentary and collapse consecutive empty lines. whitespace Same as strip except #commentary is not removed. verbatim Do not change the message at all. scissors Same as whitespace except that everything from (and including) the line found below is truncated, if the message is to be edited. \"#\" can be customized with core.commentChar. # ------------------------ >8 ------------------------ default Same as strip if the message is to be edited. Otherwise whitespace. The default can be changed by the commit.cleanup configuration variable (see git-config[1]).\n**--message=<msg>**: Strip leading and trailing empty lines, trailing whitespace, commentary and collapse consecutive empty lines.\n**-t <file>**: Same as strip except #commentary is not removed.\n**--template=<file>**: Do not change the message at all.\n**-s**: Same as whitespace except that everything from (and including) the line found below is truncated, if the message is to be edited. \"#\" can be customized with core.commentChar. # ------------------------ >8 ------------------------\n**--signoff**: Same as strip if the message is to be edited. Otherwise whitespace.\n**--no-signoff**: Let the user further edit the message taken from <file> with -F <file>, command line with -m <message>, and from <commit> with -C <commit>.\n**--trailer <token>[(=|:)<value>]**: Use the selected commit message without launching an editor. For example, git commit --amend --no-edit amends a commit without changing its commit message.\n**-n**: Replace the tip of the current branch by creating a new commit. The recorded tree is prepared as usual (including the effect of the -i and -o options and explicit pathspec), and the message from the original commit is used as the starting point, instead of an empty message, when no other message is specified from the command line via options such as -m, -F, -c, etc. The new commit has the same parents and author as the current one (the --reset-author option can countermand this). It is a rough equivalent for: $ git reset --soft HEAD^ $ ... do something else to come up with the right tree ... $ git commit -c ORIG_HEAD but can be used to amend a merge commit. You should understand the implications of rewriting history if you amend a commit that has already been published. (See the \"RECOVERING FROM UPSTREAM REBASE\" section in git-rebase[1].)\n**--[no-]verify**: Bypass the post-rewrite hook.\n**--allow-empty**: Before making a commit out of staged contents so far, stage the contents of paths given on the command line as well. This is usually not what you want unless you are concluding a conflicted merge.\n**--allow-empty-message**: Make a commit by taking the updated working tree contents of the paths specified on the command line, disregarding any contents that have been staged for other paths. This is the default mode of operation of git commit if any paths are given on the command line, in which case this option can be omitted. If this option is specified together with --amend, then no paths need to be specified, which can be used to amend the last commit without committing changes that have already been staged. If used together with --allow-empty paths are also not required, and an empty commit will be created.\n**--cleanup=<mode>**: Pass pathspec in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config[1]). See also --pathspec-file-nul and global --literal-pathspecs.\n**strip**: Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).\n**whitespace**: Show untracked files. The <mode> parameter is optional (defaults to all), and is used to specify the handling of untracked files; when -u is not used, the default is normal, i.e. show untracked files and directories. The possible options are: no Show no untracked files normal Shows untracked files and directories all Also shows individual files in untracked directories. All usual spellings for Boolean value true are taken as normal and false as no. The default can be changed using the status.showUntrackedFiles configuration variable documented in git-config[1].\n**verbatim**: Show no untracked files\n**scissors**: Shows untracked files and directories\n**default**: Also shows individual files in untracked directories.\n**-e**: Show unified diff between the HEAD commit and what would be committed at the bottom of the commit message template to help the user describe the commit by reminding what changes the commit has. Note that this diff output doesn’t have its lines prefixed with #. This diff will not be a part of the commit message. See the commit.verbose configuration variable in git-config[1]. If specified twice, show in addition the unified diff between what would be committed and the worktree files, i.e. the unstaged changes to tracked files.\n**--edit**: Suppress commit summary message.\n**--no-edit**: Do not create a commit, but show a list of paths that are to be committed, paths with local changes that will be left uncommitted and paths that are untracked.\n**--amend**: Include the output of git-status[1] in the commit message template when using an editor to prepare the commit message. Defaults to on, but can be used to override configuration variable commit.status.\n**--no-post-rewrite**: Do not include the output of git-status[1] in the commit message template when using an editor to prepare the default commit message.\n**-i**: GPG-sign commits. The <key-id> is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign.\n**--include**: Do not interpret any more arguments as options.\n**-o**: When <pathspec> is given on the command line, commit the contents of the files that match the pathspec without recording the changes already added to the index. The contents of these files are also staged for the next commit on top of what have been staged before. For more details, see the pathspec entry in gitglossary[7].\n**strip**: Strip leading and trailing empty lines, trailing whitespace, commentary and collapse consecutive empty lines.\n**whitespace**: Same as strip except #commentary is not removed.\n**verbatim**: Do not change the message at all.\n**scissors**: Same as whitespace except that everything from (and including) the line found below is truncated, if the message is to be edited. \"#\" can be customized with core.commentChar. # ------------------------ >8 ------------------------\n**default**: Same as strip if the message is to be edited. Otherwise whitespace.\n**no**: Show no untracked files\n**normal**: Shows untracked files and directories\n**all**: Also shows individual files in untracked directories.",
        "code_examples": [
          "```bash\n# ------------------------ >8 ------------------------\n```"
        ],
        "usage_examples": [
          "```bash\n$ git reset --soft HEAD^\n\t$ ... do something else to come up with the right tree ...\n\t$ git commit -c ORIG_HEAD\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 65,
          "content_length": 26192
        }
      },
      {
        "header": "EXAMPLES",
        "content": "When recording your own work, the contents of modified files in your working tree are temporarily stored to a staging area called the \"index\" with git add. A file can be reverted back, only in the index but not in the working tree, to that of the last commit with git restore --staged <file>, which effectively reverts git add and prevents the changes to this file from participating in the next commit. After building the state to be committed incrementally with these commands, git commit (without any pathname parameter) is used to record what has been staged so far. This is the most basic form of the command. An example:\n\nInstead of staging files after each individual change, you can tell git commit to notice the changes to the files whose contents are tracked in your working tree and do corresponding git add and git rm for you. That is, this example does the same as the earlier example if there is no other change in your working tree:\n\nThe command git commit -a first looks at your working tree, notices that you have modified hello.c and removed goodbye.c, and performs necessary git add and git rm for you.\n\nAfter staging changes to many files, you can alter the order the changes are recorded in, by giving pathnames to git commit. When pathnames are given, the command makes a commit that only records the changes made to the named paths:\n\nThis makes a commit that records the modification to Makefile. The changes staged for hello.c and hello.h are not included in the resulting commit. However, their changes are not lost — they are still staged and merely held back. After the above sequence, if you do:\n\nthis second commit would record the changes to hello.c and hello.h as expected.\n\nAfter a merge (initiated by git merge or git pull) stops because of conflicts, cleanly merged paths are already staged to be committed for you, and paths that conflicted are left in unmerged state. You would have to first check which paths are conflicting with git status and after fixing them manually in your working tree, you would stage the result as usual with git add:\n\nAfter resolving conflicts and staging the result, git ls-files -u would stop mentioning the conflicted path. When you are done, run git commit to finally record the merge:\n\nAs with the case to record your own changes, you can use -a option to save typing. One difference is that during a merge resolution, you cannot use git commit with pathnames to alter the order the changes are committed, because the merge should be recorded as a single commit. In fact, the command refuses to run when given pathnames (but see -i option).",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ edit hello.c\n$ git rm goodbye.c\n$ git add hello.c\n$ git commit\n```",
          "```bash\n$ edit hello.c\n$ rm goodbye.c\n$ git commit -a\n```",
          "```bash\n$ edit hello.c hello.h\n$ git add hello.c hello.h\n$ edit Makefile\n$ git commit Makefile\n```",
          "```bash\n$ git commit\n```",
          "```bash\n$ git status | grep unmerged\nunmerged: hello.c\n$ edit hello.c\n$ git add hello.c\n```",
          "```bash\n$ git commit\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 2609
        }
      },
      {
        "header": "COMMIT INFORMATION",
        "content": "Author and committer information is taken from the following environment variables, if set:\n\n(nb \"<\", \">\" and \"\\n\"s are stripped)\n\nThe author and committer names are by convention some form of a personal name (that is, the name by which other humans refer to you), although Git does not enforce or require any particular form. Arbitrary Unicode may be used, subject to the constraints listed above. This name has no effect on authentication; for that, see the credential.username variable in git-config[1].\n\nIn case (some of) these environment variables are not set, the information is taken from the configuration items user.name and user.email, or, if not present, the environment variable EMAIL, or, if that is not set, system user name and the hostname used for outgoing mail (taken from /etc/mailname and falling back to the fully qualified hostname when that file does not exist).\n\nThe author.name and committer.name and their corresponding email options override user.name and user.email if set and are overridden themselves by the environment variables.\n\nThe typical usage is to set just the user.name and user.email variables; the other options are provided for more complex use cases.\n\n• GIT_AUTHOR_NAME\n• GIT_AUTHOR_EMAIL\n• GIT_AUTHOR_DATE\n• GIT_COMMITTER_NAME\n• GIT_COMMITTER_EMAIL\n• GIT_COMMITTER_DATE",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1314
        }
      },
      {
        "header": "DATE FORMATS",
        "content": "The GIT_AUTHOR_DATE and GIT_COMMITTER_DATE environment variables support the following date formats:\n\nIt is <unix-timestamp> <time-zone-offset>, where <unix-timestamp> is the number of seconds since the UNIX epoch. <time-zone-offset> is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is +0100.\n\nThe standard date format as described by RFC 2822, for example Thu, 07 Apr 2005 22:13:13 +0200.\n\nTime and date specified by the ISO 8601 standard, for example 2005-04-07T22:13:13. The parser accepts a space instead of the T character as well. Fractional parts of a second will be ignored, for example 2005-04-07T22:13:13.019 will be treated as 2005-04-07T22:13:13.\n\nIn addition to recognizing all date formats above, the --date option will also try to make sense of other, more human-centric date formats, such as relative dates like \"yesterday\" or \"last Friday at noon\".\n\n**Git internal format**: It is <unix-timestamp> <time-zone-offset>, where <unix-timestamp> is the number of seconds since the UNIX epoch. <time-zone-offset> is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is +0100.\n**RFC 2822**: The standard date format as described by RFC 2822, for example Thu, 07 Apr 2005 22:13:13 +0200.\n**ISO 8601**: Time and date specified by the ISO 8601 standard, for example 2005-04-07T22:13:13. The parser accepts a space instead of the T character as well. Fractional parts of a second will be ignored, for example 2005-04-07T22:13:13.019 will be treated as 2005-04-07T22:13:13. Note In addition, the date part is accepted in the following formats: YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY.\n\nNote | In addition, the date part is accepted in the following formats: YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY.\n\n[Note] Note In addition, the date part is accepted in the following formats: YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 5,
          "content_length": 1894
        }
      },
      {
        "header": "DISCUSSION",
        "content": "Though not required, it’s a good idea to begin the commit message with a single short (no more than 50 characters) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, git-format-patch[1] turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.\n\nGit is to some extent character encoding agnostic.\n\nThe contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the core level.\n\nPath names are encoded in UTF-8 normalization form C. This applies to tree objects, the index file, ref names, as well as path names in command line arguments, environment variables and config files (.git/config (see git-config[1]), gitignore[5], gitattributes[5] and gitmodules[5]).\n\nNote that Git at the core level treats path names simply as sequences of non-NUL bytes, there are no path name encoding conversions (except on Mac and Windows). Therefore, using non-ASCII path names will mostly work even on platforms and file systems that use legacy extended ASCII encodings. However, repositories created on such systems will not work properly on UTF-8-based systems (e.g. Linux, Mac, Windows) and vice versa. Additionally, many Git-based tools simply assume path names to be UTF-8 and will fail to display other encodings correctly.\n\nCommit log messages are typically encoded in UTF-8, but other extended ASCII encodings are also supported. This includes ISO-8859-x, CP125x and many others, but not UTF-16/32, EBCDIC and CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.).\n\nAlthough we encourage that the commit log messages are encoded in UTF-8, both the core and Git Porcelain are designed not to force UTF-8 on projects. If all participants of a particular project find it more convenient to use legacy encodings, Git does not forbid it. However, there are a few things to keep in mind.\n\ngit commit and git commit-tree issue a warning if the commit log message given to it does not look like a valid UTF-8 string, unless you explicitly say your project uses a legacy encoding. The way to say this is to have i18n.commitEncoding in .git/config file, like this:\n\nCommit objects created with the above setting record the value of i18n.commitEncoding in their encoding header. This is to help other people who look at them later. Lack of this header implies that the commit log message is encoded in UTF-8.\n\ngit log, git show, git blame and friends look at the encoding header of a commit object, and try to re-code the log message into UTF-8 unless otherwise specified. You can specify the desired output encoding with i18n.logOutputEncoding in .git/config file, like this:\n\nIf you do not have this configuration variable, the value of i18n.commitEncoding is used instead.\n\nNote that we deliberately chose not to re-code the commit log message when a commit is made to force UTF-8 at the commit object level, because re-coding to UTF-8 is not necessarily a reversible operation.\n\n• The contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the core level.\n• Path names are encoded in UTF-8 normalization form C. This applies to tree objects, the index file, ref names, as well as path names in command line arguments, environment variables and config files (.git/config (see git-config[1]), gitignore[5], gitattributes[5] and gitmodules[5]). Note that Git at the core level treats path names simply as sequences of non-NUL bytes, there are no path name encoding conversions (except on Mac and Windows). Therefore, using non-ASCII path names will mostly work even on platforms and file systems that use legacy extended ASCII encodings. However, repositories created on such systems will not work properly on UTF-8-based systems (e.g. Linux, Mac, Windows) and vice versa. Additionally, many Git-based tools simply assume path names to be UTF-8 and will fail to display other encodings correctly.\n• Commit log messages are typically encoded in UTF-8, but other extended ASCII encodings are also supported. This includes ISO-8859-x, CP125x and many others, but not UTF-16/32, EBCDIC and CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.).\n\n• git commit and git commit-tree issue a warning if the commit log message given to it does not look like a valid UTF-8 string, unless you explicitly say your project uses a legacy encoding. The way to say this is to have i18n.commitEncoding in .git/config file, like this: [i18n] commitEncoding = ISO-8859-1 Commit objects created with the above setting record the value of i18n.commitEncoding in their encoding header. This is to help other people who look at them later. Lack of this header implies that the commit log message is encoded in UTF-8.\n• git log, git show, git blame and friends look at the encoding header of a commit object, and try to re-code the log message into UTF-8 unless otherwise specified. You can specify the desired output encoding with i18n.logOutputEncoding in .git/config file, like this: [i18n] logOutputEncoding = ISO-8859-1 If you do not have this configuration variable, the value of i18n.commitEncoding is used instead.",
        "code_examples": [
          "```bash\n[i18n]\n\tcommitEncoding = ISO-8859-1\n```",
          "```bash\n[i18n]\n\tlogOutputEncoding = ISO-8859-1\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 12,
          "content_length": 5329
        }
      },
      {
        "header": "ENVIRONMENT AND CONFIGURATION VARIABLES",
        "content": "The editor used to edit the commit log message will be chosen from the GIT_EDITOR environment variable, the core.editor configuration variable, the VISUAL environment variable, or the EDITOR environment variable (in that order). See git-var[1] for details.\n\nEverything above this line in this section isn’t included from the git-config[1] documentation. The content that follows is the same as what’s found there:\n\nThis setting overrides the default of the --cleanup option in git commit. Changing the default can be useful when you always want to keep lines that begin with the comment character (core.commentChar, default #) in your log message, in which case you would do git config commit.cleanup whitespace (note that you will have to remove the help lines that begin with the comment character in the commit log template yourself, if you do this).\n\nA boolean to specify whether all commits should be GPG signed. Use of this option when doing operations such as rebase can result in a large number of commits being signed. It may be convenient to use an agent to avoid typing your GPG passphrase several times.\n\nA boolean to enable/disable inclusion of status information in the commit message template when using an editor to prepare the commit message. Defaults to true.\n\nSpecify the pathname of a file to use as the template for new commit messages.\n\nA boolean or int to specify the level of verbosity with git commit.\n\n**commit.cleanup**: This setting overrides the default of the --cleanup option in git commit. Changing the default can be useful when you always want to keep lines that begin with the comment character (core.commentChar, default #) in your log message, in which case you would do git config commit.cleanup whitespace (note that you will have to remove the help lines that begin with the comment character in the commit log template yourself, if you do this).\n**commit.gpgSign**: A boolean to specify whether all commits should be GPG signed. Use of this option when doing operations such as rebase can result in a large number of commits being signed. It may be convenient to use an agent to avoid typing your GPG passphrase several times.\n**commit.status**: A boolean to enable/disable inclusion of status information in the commit message template when using an editor to prepare the commit message. Defaults to true.\n**commit.template**: Specify the pathname of a file to use as the template for new commit messages.\n**commit.verbose**: A boolean or int to specify the level of verbosity with git commit.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 2535
        }
      },
      {
        "header": "HOOKS",
        "content": "This command can run commit-msg, prepare-commit-msg, pre-commit, post-commit and post-rewrite hooks. See githooks[5] for more information.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 138
        }
      },
      {
        "header": "FILES",
        "content": "This file contains the commit message of a commit in progress. If git commit exits due to an error before creating a commit, any commit message that has been provided by the user (e.g., in an editor session) will be available in this file, but will be overwritten by the next invocation of git commit.\n\n**$GIT_DIR/COMMIT_EDITMSG**: This file contains the commit message of a commit in progress. If git commit exits due to an error before creating a commit, any commit message that has been provided by the user (e.g., in an editor session) will be available in this file, but will be overwritten by the next invocation of git commit.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 633
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-add[1], git-rm[1], git-mv[1], git-merge[1], git-commit-tree[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 66
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-commit",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Git",
    "summary": "NAME git-describe - Give an object a human readable name based on an available ref\n\ngit-describe - Give an object a human readable name based on an available ref",
    "sections": [
      {
        "header": "NAME",
        "content": "git-describe - Give an object a human readable name based on an available ref",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 77
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "The command finds the most recent tag that is reachable from a commit. If the tag points to the commit, then only the tag is shown. Otherwise, it suffixes the tag name with the number of additional commits on top of the tagged object and the abbreviated object name of the most recent commit. The result is a \"human-readable\" object name which can also be used to identify the commit to other git commands.\n\nBy default (without --all or --tags) git describe only shows annotated tags. For more information about creating annotated tags see the -a and -s options to git-tag[1].\n\nIf the given object refers to a blob, it will be described as <commit-ish>:<path>, such that the blob can be found at <path> in the <commit-ish>, which itself describes the first commit in which this blob occurs in a reverse revision walk from HEAD.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 827
        }
      },
      {
        "header": "OPTIONS",
        "content": "Commit-ish object names to describe. Defaults to HEAD if omitted.\n\nDescribe the state of the working tree. When the working tree matches HEAD, the output is the same as \"git describe HEAD\". If the working tree has local modification \"-dirty\" is appended to it. If a repository is corrupt and Git cannot determine if there is local modification, Git will error out, unless ‘--broken’ is given, which appends the suffix \"-broken\" instead.\n\nInstead of using only the annotated tags, use any ref found in refs/ namespace. This option enables matching any known branch, remote-tracking branch, or lightweight tag.\n\nInstead of using only the annotated tags, use any tag found in refs/tags namespace. This option enables matching a lightweight (non-annotated) tag.\n\nInstead of finding the tag that predates the commit, find the tag that comes after the commit, and thus contains it. Automatically implies --tags.\n\nInstead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <n> digits, or as many digits as needed to form a unique object name. An <n> of 0 will suppress long format, only showing the closest tag.\n\nInstead of considering only the 10 most recent tags as candidates to describe the input commit-ish consider up to <n> candidates. Increasing <n> above 10 will take slightly longer but may produce a more accurate result. An <n> of 0 will cause only exact matches to be output.\n\nOnly output exact matches (a tag directly references the supplied commit). This is a synonym for --candidates=0.\n\nVerbosely display information about the searching strategy being employed to standard error. The tag name will still be printed to standard out.\n\nAlways output the long format (the tag, the number of commits and the abbreviated commit name) even when it matches a tag. This is useful when you want to see parts of the commit object name in \"describe\" output, even when the commit in question happens to be a tagged version. Instead of just emitting the tag name, it will describe such a commit as v1.2-0-gdeadbee (0th commit since tag v1.2 that points at object deadbee….).\n\nOnly consider tags matching the given glob(7) pattern, excluding the \"refs/tags/\" prefix. If used with --all, it also considers local branches and remote-tracking references matching the pattern, excluding respectively \"refs/heads/\" and \"refs/remotes/\" prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated, and tags matching any of the patterns will be considered. Use --no-match to clear and reset the list of patterns.\n\nDo not consider tags matching the given glob(7) pattern, excluding the \"refs/tags/\" prefix. If used with --all, it also does not consider local branches and remote-tracking references matching the pattern, excluding respectively \"refs/heads/\" and \"refs/remotes/\" prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated and tags matching any of the patterns will be excluded. When combined with --match a tag will be considered when it matches at least one --match pattern and does not match any of the --exclude patterns. Use --no-exclude to clear and reset the list of patterns.\n\nShow uniquely abbreviated commit object as fallback.\n\nFollow only the first parent commit upon seeing a merge commit. This is useful when you wish to not match tags on branches merged in the history of the target commit.\n\n**<commit-ish>…**: Commit-ish object names to describe. Defaults to HEAD if omitted.\n**--dirty[=<mark>]**: Describe the state of the working tree. When the working tree matches HEAD, the output is the same as \"git describe HEAD\". If the working tree has local modification \"-dirty\" is appended to it. If a repository is corrupt and Git cannot determine if there is local modification, Git will error out, unless ‘--broken’ is given, which appends the suffix \"-broken\" instead.\n**--broken[=<mark>]**: Instead of using only the annotated tags, use any ref found in refs/ namespace. This option enables matching any known branch, remote-tracking branch, or lightweight tag.\n**--all**: Instead of using only the annotated tags, use any tag found in refs/tags namespace. This option enables matching a lightweight (non-annotated) tag.\n**--tags**: Instead of finding the tag that predates the commit, find the tag that comes after the commit, and thus contains it. Automatically implies --tags.\n**--contains**: Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <n> digits, or as many digits as needed to form a unique object name. An <n> of 0 will suppress long format, only showing the closest tag.\n**--abbrev=<n>**: Instead of considering only the 10 most recent tags as candidates to describe the input commit-ish consider up to <n> candidates. Increasing <n> above 10 will take slightly longer but may produce a more accurate result. An <n> of 0 will cause only exact matches to be output.\n**--candidates=<n>**: Only output exact matches (a tag directly references the supplied commit). This is a synonym for --candidates=0.\n**--exact-match**: Verbosely display information about the searching strategy being employed to standard error. The tag name will still be printed to standard out.\n**--debug**: Always output the long format (the tag, the number of commits and the abbreviated commit name) even when it matches a tag. This is useful when you want to see parts of the commit object name in \"describe\" output, even when the commit in question happens to be a tagged version. Instead of just emitting the tag name, it will describe such a commit as v1.2-0-gdeadbee (0th commit since tag v1.2 that points at object deadbee….).\n**--long**: Only consider tags matching the given glob(7) pattern, excluding the \"refs/tags/\" prefix. If used with --all, it also considers local branches and remote-tracking references matching the pattern, excluding respectively \"refs/heads/\" and \"refs/remotes/\" prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated, and tags matching any of the patterns will be considered. Use --no-match to clear and reset the list of patterns.\n**--match <pattern>**: Do not consider tags matching the given glob(7) pattern, excluding the \"refs/tags/\" prefix. If used with --all, it also does not consider local branches and remote-tracking references matching the pattern, excluding respectively \"refs/heads/\" and \"refs/remotes/\" prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated and tags matching any of the patterns will be excluded. When combined with --match a tag will be considered when it matches at least one --match pattern and does not match any of the --exclude patterns. Use --no-exclude to clear and reset the list of patterns.\n**--exclude <pattern>**: Show uniquely abbreviated commit object as fallback.\n**--always**: Follow only the first parent commit upon seeing a merge commit. This is useful when you wish to not match tags on branches merged in the history of the target commit.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 14,
          "content_length": 7342
        }
      },
      {
        "header": "EXAMPLES",
        "content": "With something like git.git current tree, I get:\n\ni.e. the current head of my \"parent\" branch is based on v1.0.4, but since it has a few commits on top of that, describe has added the number of additional commits (\"14\") and an abbreviated object name for the commit itself (\"2414721\") at the end.\n\nThe number of additional commits is the number of commits which would be displayed by \"git log v1.0.4..parent\". The hash suffix is \"-g\" + an unambiguous abbreviation for the tip commit of parent (which was 2414721b194453f058079d897d13c4e377f92dc6). The length of the abbreviation scales as the repository grows, using the approximate number of objects in the repository and a bit of math around the birthday paradox, and defaults to a minimum of 7. The \"g\" prefix stands for \"git\" and is used to allow describing the version of a software depending on the SCM the software is managed with. This is useful in an environment where people may use different SCMs.\n\nDoing a git describe on a tag-name will just show the tag name:\n\nWith --all, the command can use branch heads as references, so the output shows the reference path as well:\n\nWith --abbrev set to 0, the command can be used to find the closest tagname without any suffix:\n\nNote that the suffix you get if you type these commands today may be longer than what Linus saw above when he ran these commands, as your Git repository may have new commits whose object names begin with 975b that did not exist back then, and \"-g975b\" suffix alone may not be sufficient to disambiguate these commits.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n[torvalds@g5 git]$ git describe parent\nv1.0.4-14-g2414721\n```",
          "```bash\n[torvalds@g5 git]$ git describe v1.0.4\nv1.0.4\n```",
          "```bash\n[torvalds@g5 git]$ git describe --all --abbrev=4 v1.0.5^2\ntags/v1.0.0-21-g975b\n```",
          "```bash\n[torvalds@g5 git]$ git describe --all --abbrev=4 HEAD^\nheads/lt/describe-7-g975b\n```",
          "```bash\n[torvalds@g5 git]$ git describe --abbrev=0 v1.0.5^2\ntags/v1.0.0\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1547
        }
      },
      {
        "header": "SEARCH STRATEGY",
        "content": "For each commit-ish supplied, git describe will first look for a tag which tags exactly that commit. Annotated tags will always be preferred over lightweight tags, and tags with newer dates will always be preferred over tags with older dates. If an exact match is found, its name will be output and searching will stop.\n\nIf an exact match was not found, git describe will walk back through the commit history to locate an ancestor commit which has been tagged. The ancestor’s tag will be output along with an abbreviation of the input commit-ish’s SHA-1. If --first-parent was specified then the walk will only consider the first parent of each commit.\n\nIf multiple tags were found during the walk then the tag which has the fewest commits different from the input commit-ish will be selected and output. Here fewest commits different is defined as the number of commits which would be shown by git log tag..input will be the smallest number of commits possible.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 962
        }
      },
      {
        "header": "BUGS",
        "content": "Tree objects as well as tag objects not pointing at commits, cannot be described. When describing blobs, the lightweight tags pointing at blobs are ignored, but the blob is still described as <commit-ish>:<path> despite the lightweight tag being favorable.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 256
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-describe",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "Git",
    "summary": "NAME git-diff - Show changes between commits, commit and working tree, etc\n\ngit-diff - Show changes between commits, commit and working tree, etc",
    "sections": [
      {
        "header": "NAME",
        "content": "git-diff - Show changes between commits, commit and working tree, etc",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 69
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Show changes between the working tree and the index or a tree, changes between the index and a tree, changes between two trees, changes resulting from a merge, changes between two blob objects, or changes between two files on disk.\n\nThis form is to view the changes you made relative to the index (staging area for the next commit). In other words, the differences are what you could tell Git to further add to the index but you still haven’t. You can stage these changes by using git-add[1].\n\nThis form is to compare the given two paths on the filesystem. You can omit the --no-index option when running the command in a working tree controlled by Git and at least one of the paths points outside the working tree, or when running the command outside a working tree controlled by Git. This form implies --exit-code. If both paths point to directories, additional pathspecs may be provided. These will limit the files included in the difference. All such pathspecs must be relative as they apply to both sides of the diff.\n\nThis form is to view the changes you staged for the next commit relative to the named <commit>. Typically you would want comparison with the latest commit, so if you do not give <commit>, it defaults to HEAD. If HEAD does not exist (e.g. unborn branches) and <commit> is not given, it shows all staged changes. --staged is a synonym of --cached.\n\nIf --merge-base is given, instead of using <commit>, use the merge base of <commit> and HEAD. git diff --cached --merge-base A is equivalent to git diff --cached $(git merge-base A HEAD).\n\nThis form is to view the changes you have in your working tree relative to the named <commit>. You can use HEAD to compare it with the latest commit, or a branch name to compare with the tip of a different branch.\n\nIf --merge-base is given, instead of using <commit>, use the merge base of <commit> and HEAD. git diff --merge-base A is equivalent to git diff $(git merge-base A HEAD).\n\nThis is to view the changes between two arbitrary <commit>.\n\nIf --merge-base is given, use the merge base of the two commits for the \"before\" side. git diff --merge-base A B is equivalent to git diff $(git merge-base A B) B.\n\nThis form is to view the results of a merge commit. The first listed <commit> must be the merge itself; the remaining two or more commits should be its parents. Convenient ways to produce the desired set of revisions are to use the suffixes @ and ^!. If A is a merge commit, then git diff A A^@, git diff A^! and git show A all give the same combined diff.\n\nThis is synonymous to the earlier form (without the ..) for viewing the changes between two arbitrary <commit>. If <commit> on one side is omitted, it will have the same effect as using HEAD instead.\n\nThis form is to view the changes on the branch containing and up to the second <commit>, starting at a common ancestor of both <commit>. git diff A...B is equivalent to git diff $(git merge-base A B) B. You can omit any one of <commit>, which has the same effect as using HEAD instead.\n\nJust in case you are doing something exotic, it should be noted that all of the <commit> in the above description, except in the --merge-base case and in the last two forms that use .. notations, can be any <tree>. A tree of interest is the one pointed to by the ref named AUTO_MERGE, which is written by the ort merge strategy upon hitting merge conflicts (see git-merge[1]). Comparing the working tree with AUTO_MERGE shows changes you’ve made so far to resolve textual conflicts (see the examples below).\n\nFor a more complete list of ways to spell <commit>, see \"SPECIFYING REVISIONS\" section in gitrevisions[7]. However, diff is about comparing two endpoints, not ranges, and the range notations (<commit>..<commit> and <commit>...<commit>) do not mean a range as defined in the \"SPECIFYING RANGES\" section in gitrevisions[7].\n\nThis form is to view the differences between the raw contents of two blob objects.\n\n**git diff [<options>] [--] [<path>...]**: This form is to view the changes you made relative to the index (staging area for the next commit). In other words, the differences are what you could tell Git to further add to the index but you still haven’t. You can stage these changes by using git-add[1].\n**git diff [<options>] --no-index [--] <path> <path> [<pathspec>...]**: This form is to compare the given two paths on the filesystem. You can omit the --no-index option when running the command in a working tree controlled by Git and at least one of the paths points outside the working tree, or when running the command outside a working tree controlled by Git. This form implies --exit-code. If both paths point to directories, additional pathspecs may be provided. These will limit the files included in the difference. All such pathspecs must be relative as they apply to both sides of the diff.\n**git diff [<options>] --cached [--merge-base] [<commit>] [--] [<path>...]**: This form is to view the changes you staged for the next commit relative to the named <commit>. Typically you would want comparison with the latest commit, so if you do not give <commit>, it defaults to HEAD. If HEAD does not exist (e.g. unborn branches) and <commit> is not given, it shows all staged changes. --staged is a synonym of --cached. If --merge-base is given, instead of using <commit>, use the merge base of <commit> and HEAD. git diff --cached --merge-base A is equivalent to git diff --cached $(git merge-base A HEAD).\n**git diff [<options>] [--merge-base] <commit> [--] [<path>...]**: This form is to view the changes you have in your working tree relative to the named <commit>. You can use HEAD to compare it with the latest commit, or a branch name to compare with the tip of a different branch. If --merge-base is given, instead of using <commit>, use the merge base of <commit> and HEAD. git diff --merge-base A is equivalent to git diff $(git merge-base A HEAD).\n**git diff [<options>] [--merge-base] <commit> <commit> [--] [<path>...]**: This is to view the changes between two arbitrary <commit>. If --merge-base is given, use the merge base of the two commits for the \"before\" side. git diff --merge-base A B is equivalent to git diff $(git merge-base A B) B.\n**git diff [<options>] <commit> <commit>...<commit> [--] [<path>...]**: This form is to view the results of a merge commit. The first listed <commit> must be the merge itself; the remaining two or more commits should be its parents. Convenient ways to produce the desired set of revisions are to use the suffixes @ and ^!. If A is a merge commit, then git diff A A^@, git diff A^! and git show A all give the same combined diff.\n**git diff [<options>] <commit>..<commit> [--] [<path>...]**: This is synonymous to the earlier form (without the ..) for viewing the changes between two arbitrary <commit>. If <commit> on one side is omitted, it will have the same effect as using HEAD instead.\n**git diff [<options>] <commit>...<commit> [--] [<path>...]**: This form is to view the changes on the branch containing and up to the second <commit>, starting at a common ancestor of both <commit>. git diff A...B is equivalent to git diff $(git merge-base A B) B. You can omit any one of <commit>, which has the same effect as using HEAD instead.\n**git diff [<options>] <blob> <blob>**: This form is to view the differences between the raw contents of two blob objects.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 15,
          "content_length": 7363
        }
      },
      {
        "header": "OPTIONS",
        "content": "Generate patch (see Generating patch text with -p). This is the default.\n\nSuppress all output from the diff machinery. Useful for commands like git show that show the patch by default to squelch their output, or to cancel the effect of options like --patch, --stat earlier on the command line in an alias.\n\nGenerate diffs with <n> lines of context instead of the usual three. Implies --patch.\n\nOutput to a specific file instead of stdout.\n\nSpecify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively.\n\nGenerate the diff in raw format.\n\nSynonym for -p --raw.\n\nEnable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.\n\nDisable the indent heuristic.\n\nSpend extra time to make sure the smallest possible diff is produced.\n\nGenerate a diff using the \"patience diff\" algorithm.\n\nGenerate a diff using the \"histogram diff\" algorithm.\n\nGenerate a diff using the \"anchored diff\" algorithm.\n\nThis option may be specified more than once.\n\nIf a line exists in both the source and destination, exists only once, and starts with <text>, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the \"patience diff\" algorithm internally.\n\nChoose a diff algorithm. The variants are as follows:\n\nThe basic greedy diff algorithm. Currently, this is the default.\n\nSpend extra time to make sure the smallest possible diff is produced.\n\nUse \"patience diff\" algorithm when generating patches.\n\nThis algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n\nFor instance, if you configured the diff.algorithm variable to a non-default value and want to use the default one, then you have to use --diff-algorithm=default option.\n\nGenerate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by <width>. The width of the filename part can be limited by giving another width <name-width> after a comma or by setting diff.statNameWidth=<name-width>. The width of the graph part can be limited by using --stat-graph-width=<graph-width> or by setting diff.statGraphWidth=<graph-width>. Using --stat or --stat-graph-width affects all commands generating a stat graph, while setting diff.statNameWidth or diff.statGraphWidth does not affect git format-patch. By giving a third parameter <count>, you can limit the output to the first <count> lines, followed by ... if there are more.\n\nThese parameters can also be set individually with --stat-width=<width>, --stat-name-width=<name-width> and --stat-count=<count>.\n\nOutput a condensed summary of extended header information such as file creations or deletions (\"new\" or \"gone\", optionally +l if it’s a symlink) and mode changes (+x or -x for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies --stat.\n\nSimilar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly. For binary files, outputs two - instead of saying 0 0.\n\nOutput only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines.\n\nOutput the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config[1]). The following parameters are available:\n\nCompute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n\nCompute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n\nCompute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n\nCount changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n\nAn integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n\nExample: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative.\n\nSynonym for --dirstat=cumulative.\n\nSynonym for --dirstat=files,<param>,....\n\nOutput a condensed summary of extended header information such as creations, renames and mode changes.\n\nSynonym for -p --stat.\n\nWhen --raw, --numstat, --name-only or --name-status has been given, do not munge pathnames and use NULs as output field terminators.\n\nWithout this option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n\nShow only the name of each changed file in the post-image tree. The file names are often encoded in UTF-8. For more information see the discussion about encoding in the git-log[1] manual page.\n\nShow only the name(s) and status of each changed file. See the description of the --diff-filter option on what the status letters mean. Just like --name-only the file names are often encoded in UTF-8.\n\nSpecify how differences in submodules are shown. When specifying --submodule=short the short format is used. This format just shows the names of the commits at the beginning and end of the range. When --submodule or --submodule=log is specified, the log format is used. This format lists the commits in the range like git-submodule[1] summary does. When --submodule=diff is specified, the diff format is used. This format shows an inline diff of the changes in the submodule contents between the commit range. Defaults to diff.submodule or the short format if the config option is unset.\n\nShow colored diff. --color (i.e. without =<when>) is the same as --color=always. <when> can be one of always, never, or auto. It can be changed by the color.ui and color.diff configuration settings.\n\nTurn off colored diff. This can be used to override configuration settings. It is the same as --color=never.\n\nMoved lines of code are colored differently. It can be changed by the diff.colorMoved configuration setting. The <mode> defaults to no if the option is not given and to zebra if the option with no mode is given. The mode must be one of:\n\nMoved lines are not highlighted.\n\nIs a synonym for zebra. This may change to a more sensible mode in the future.\n\nAny line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.\n\nBlocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart.\n\nBlocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected.\n\nSimilar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n\nTurn off move detection. This can be used to override configuration settings. It is the same as --color-moved=no.\n\nThis configures how whitespace is ignored when performing the move detection for --color-moved. It can be set by the diff.colorMovedWS configuration setting. These modes can be given as a comma separated list:\n\nDo not ignore whitespace when performing move detection.\n\nIgnore changes in whitespace at EOL.\n\nIgnore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n\nIgnore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n\nInitially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n\nDo not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as --color-moved-ws=no.\n\nBy default, words are delimited by whitespace; see --word-diff-regex below. The <mode> defaults to plain, and must be one of:\n\nHighlight changed words using only colors. Implies --color.\n\nShow words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.\n\nUse a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own.\n\nDisable word diff again.\n\nNote that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled.\n\nUse <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies --word-diff unless it was already enabled.\n\nEvery non-overlapping match of the <regex> is considered a word. Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences. You may want to append |[^[:space:]] to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline.\n\nFor example, --word-diff-regex=. will treat each character as a word and, correspondingly, show differences character by character.\n\nThe regex can also be set via a diff driver or configuration option, see gitattributes[5] or git-config[1]. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.\n\nEquivalent to --word-diff=color plus (if a regex was specified) --word-diff-regex=<regex>.\n\nTurn off rename detection, even when the configuration file gives the default to do so.\n\nWhether to use empty blobs as rename source.\n\nWarn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by core.whitespace configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.\n\nHighlight whitespace errors in the context, old or new lines of the diff. Multiple values are separated by comma, none resets previous values, default reset the list to new and all is a shorthand for old,new,context. When this option is not given, and the configuration variable diff.wsErrorHighlight is not set, only whitespace errors in new lines are highlighted. The whitespace errors are colored with color.diff.whitespace.\n\nInstead of the first handful of characters, show the full pre- and post-image blob object names on the \"index\" line when generating patch format output.\n\nIn addition to --full-index, output a binary diff that can be applied with git-apply. Implies --patch.\n\nInstead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. In diff-patch output format, --full-index takes higher precedence, i.e. if --full-index is specified, full blob names will be shown regardless of --abbrev. Non default number of digits can be specified with --abbrev=<n>.\n\nBreak complete rewrite changes into pairs of delete and create. This serves two purposes:\n\nIt affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number <m> controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).\n\nWhen used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number <n> controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file.\n\nDetect renames. If <n> is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed. Without a % sign, the number is to be read as a fraction, with a decimal point before it. I.e., -M5 becomes 0.5, and is thus the same as -M50%. Similarly, -M05 is the same as -M5%. To limit detection to exact renames, use -M100%. The default similarity index is 50%.\n\nDetect copies as well as renames. See also --find-copies-harder. If <n> is specified, it has the same meaning as for -M<n>.\n\nFor performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one -C option has the same effect.\n\nOmit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.\n\nWhen used together with -B, omit also the preimage in the deletion part of a delete/create pair.\n\nThe -M and -C options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources. (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.) For N sources and destinations, this exhaustive check is O(N^2). This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number. Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited.\n\nSelect only files that are Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have their type (i.e. regular file, symlink, submodule, …) changed (T), are Unmerged (U), are Unknown (X), or have had their pairing Broken (B). Any combination of the filter characters (including none) can be used. When * (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected.\n\nAlso, these upper-case letters can be downcased to exclude. E.g. --diff-filter=ad excludes added and deleted paths.\n\nNote that not all diffs can feature all types. For instance, copied and renamed entries cannot appear if detection for those types is disabled.\n\nLook for differences that change the number of occurrences of the specified <string> (i.e. addition/deletion) in a file. Intended for the scripter’s use.\n\nIt is useful when you’re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into -S, and keep going until you get the very first version of the block.\n\nBinary files are searched as well.\n\nLook for differences whose patch text contains added/removed lines that match <regex>.\n\nTo illustrate the difference between -S<regex> --pickaxe-regex and -G<regex>, consider a commit with the following diff in the same file:\n\nWhile git log -G\"frotz\\(nitfol\" will show this commit, git log -S\"frotz\\(nitfol\" --pickaxe-regex will not (because the number of occurrences of that string did not change).\n\nUnless --text is supplied patches of binary files without a textconv filter will be ignored.\n\nSee the pickaxe entry in gitdiffcore[7] for more information.\n\nLook for differences that change the number of occurrences of the specified object. Similar to -S, just the argument is different in that it doesn’t search for a specific string but for a specific object id.\n\nThe object can be a blob or a submodule commit. It implies the -t option in git-log to also find trees.\n\nWhen -S or -G finds a change, show all the changes in that changeset, not just the files that contain the change in <string>.\n\nTreat the <string> given to -S as an extended POSIX regular expression to match.\n\nControl the order in which files appear in the output. This overrides the diff.orderFile configuration variable (see git-config[1]). To cancel diff.orderFile, use -O/dev/null.\n\nThe output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.\n\n<orderfile> is parsed as follows:\n\nBlank lines are ignored, so they can be used as separators for readability.\n\nLines starting with a hash (\"#\") are ignored, so they can be used for comments. Add a backslash (\"\\\") to the beginning of the pattern if it starts with a hash.\n\nEach other line contains a single pattern.\n\nPatterns have the same syntax and semantics as patterns used for fnmatch(3) without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern. For example, the pattern \"foo*bar\" matches \"fooasdfbar\" and \"foo/bar/baz/asdf\" but not \"foobarx\".\n\nDiscard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to). These options were invented primarily for the use of the git difftool command, and may not be very useful otherwise.\n\nSwap two inputs; that is, show differences from index or on-disk file to tree contents.\n\nWhen run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative.\n\nTreat all files as text.\n\nIgnore carriage-return at the end of line when doing a comparison.\n\nIgnore changes in whitespace at EOL.\n\nIgnore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n\nIgnore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n\nIgnore changes whose lines are all blank.\n\nIgnore changes whose all lines match <regex>. This option may be specified more than once.\n\nShow the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n\nShow whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see \"Defining a custom hunk-header\" in gitattributes[5]).\n\nMake the program exit with codes similar to diff(1). That is, it exits with 1 if there were differences and 0 means no differences.\n\nDisable all output of the program. Implies --exit-code. Disables execution of external diff helpers whose exit code is not trusted, i.e. their respective configuration option diff.trustExitCode or diff.<driver>.trustExitCode or environment variable GIT_EXTERNAL_DIFF_TRUST_EXIT_CODE is false.\n\nAllow an external diff helper to be executed. If you set an external diff driver with gitattributes[5], you need to use this option with git-log[1] and friends.\n\nDisallow external diff drivers.\n\nAllow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes[5] for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff[1] and git-log[1], but not for git-format-patch[1] or diff plumbing commands.\n\nIgnore changes to submodules in the diff generation. all is the default. Using none will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config[1] or gitmodules[5]. When untracked is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using dirty ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using all hides all changes to submodules.\n\nShow the given source <prefix> instead of \"a/\".\n\nShow the given destination <prefix> instead of \"b/\".\n\nDo not show any source or destination prefix.\n\nUse the default source and destination prefixes (\"a/\" and \"b/\"). This overrides configuration variables such as diff.noprefix, diff.srcPrefix, diff.dstPrefix, and diff.mnemonicPrefix (see git-config[1]).\n\nPrepend an additional <prefix> to every line of output.\n\nBy default entries added by git add -N appear as an existing empty file in git diff and a new file in git diff --cached. This option makes the entry appear as a new file in git diff and non-existent in git diff --cached. This option could be reverted with --ita-visible-in-index. Both options are experimental and could be removed in future.\n\nFor more detailed explanation on these common options, see also gitdiffcore[7].\n\nCompare the working tree with\n\nthe \"base\" version (stage #1) when using -1 or --base,\n\n\"our branch\" (stage #2) when using -2 or --ours, or\n\n\"their branch\" (stage #3) when using -3 or --theirs.\n\nThe index contains these stages only for unmerged entries i.e. while resolving conflicts. See git-read-tree[1] section \"3-Way Merge\" for detailed information.\n\nOmit diff output for unmerged entries and just show \"Unmerged\". Can be used only when comparing the working tree with the index.\n\nThe <path> parameters, when given, are used to limit the diff to the named paths (you can give directory names and get diff for all files under them).\n\n• Blank lines are ignored, so they can be used as separators for readability.\n• Lines starting with a hash (\"#\") are ignored, so they can be used for comments. Add a backslash (\"\\\") to the beginning of the pattern if it starts with a hash.\n• Each other line contains a single pattern.\n\n• the \"base\" version (stage #1) when using -1 or --base,\n• \"our branch\" (stage #2) when using -2 or --ours, or\n• \"their branch\" (stage #3) when using -3 or --theirs.\n\n**-p**: Generate patch (see Generating patch text with -p). This is the default.\n**-u**: Suppress all output from the diff machinery. Useful for commands like git show that show the patch by default to squelch their output, or to cancel the effect of options like --patch, --stat earlier on the command line in an alias.\n**--patch**: Generate diffs with <n> lines of context instead of the usual three. Implies --patch.\n**-s**: Output to a specific file instead of stdout.\n**--no-patch**: Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively.\n**-U<n>**: Generate the diff in raw format.\n**--unified=<n>**: Synonym for -p --raw.\n**--output=<file>**: Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.\n**--output-indicator-new=<char>**: Disable the indent heuristic.\n**--output-indicator-old=<char>**: Spend extra time to make sure the smallest possible diff is produced.\n**--output-indicator-context=<char>**: Generate a diff using the \"patience diff\" algorithm.\n**--raw**: Generate a diff using the \"histogram diff\" algorithm.\n**--patch-with-raw**: Generate a diff using the \"anchored diff\" algorithm. This option may be specified more than once. If a line exists in both the source and destination, exists only once, and starts with <text>, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the \"patience diff\" algorithm internally.\n**--indent-heuristic**: Choose a diff algorithm. The variants are as follows: default myers The basic greedy diff algorithm. Currently, this is the default. minimal Spend extra time to make sure the smallest possible diff is produced. patience Use \"patience diff\" algorithm when generating patches. histogram This algorithm extends the patience algorithm to \"support low-occurrence common elements\". For instance, if you configured the diff.algorithm variable to a non-default value and want to use the default one, then you have to use --diff-algorithm=default option.\n**--no-indent-heuristic**: The basic greedy diff algorithm. Currently, this is the default.\n**--minimal**: Spend extra time to make sure the smallest possible diff is produced.\n**--patience**: Use \"patience diff\" algorithm when generating patches.\n**--histogram**: This algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n**--anchored=<text>**: Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by <width>. The width of the filename part can be limited by giving another width <name-width> after a comma or by setting diff.statNameWidth=<name-width>. The width of the graph part can be limited by using --stat-graph-width=<graph-width> or by setting diff.statGraphWidth=<graph-width>. Using --stat or --stat-graph-width affects all commands generating a stat graph, while setting diff.statNameWidth or diff.statGraphWidth does not affect git format-patch. By giving a third parameter <count>, you can limit the output to the first <count> lines, followed by ... if there are more. These parameters can also be set individually with --stat-width=<width>, --stat-name-width=<name-width> and --stat-count=<count>.\n**--diff-algorithm=(patience|minimal|histogram|myers)**: Output a condensed summary of extended header information such as file creations or deletions (\"new\" or \"gone\", optionally +l if it’s a symlink) and mode changes (+x or -x for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies --stat.\n**default**: Similar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly. For binary files, outputs two - instead of saying 0 0.\n**myers**: Output only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines.\n**minimal**: Output the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config[1]). The following parameters are available: changes Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given. lines Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options. files Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all. cumulative Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter. <limit> An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output. Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative.\n**patience**: Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n**histogram**: Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n**--stat[=<width>[,<name-width>[,<count>]]]**: Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n**--compact-summary**: Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n**--numstat**: An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n**--shortstat**: Synonym for --dirstat=cumulative.\n**-X [<param>,...]**: Synonym for --dirstat=files,<param>,....\n**--dirstat[=<param>,...]**: Output a condensed summary of extended header information such as creations, renames and mode changes.\n**changes**: Synonym for -p --stat.\n**lines**: When --raw, --numstat, --name-only or --name-status has been given, do not munge pathnames and use NULs as output field terminators. Without this option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n**files**: Show only the name of each changed file in the post-image tree. The file names are often encoded in UTF-8. For more information see the discussion about encoding in the git-log[1] manual page.\n**cumulative**: Show only the name(s) and status of each changed file. See the description of the --diff-filter option on what the status letters mean. Just like --name-only the file names are often encoded in UTF-8.\n**<limit>**: Specify how differences in submodules are shown. When specifying --submodule=short the short format is used. This format just shows the names of the commits at the beginning and end of the range. When --submodule or --submodule=log is specified, the log format is used. This format lists the commits in the range like git-submodule[1] summary does. When --submodule=diff is specified, the diff format is used. This format shows an inline diff of the changes in the submodule contents between the commit range. Defaults to diff.submodule or the short format if the config option is unset.\n**--cumulative**: Show colored diff. --color (i.e. without =<when>) is the same as --color=always. <when> can be one of always, never, or auto. It can be changed by the color.ui and color.diff configuration settings.\n**--dirstat-by-file[=<param>,...]**: Turn off colored diff. This can be used to override configuration settings. It is the same as --color=never.\n**--summary**: Moved lines of code are colored differently. It can be changed by the diff.colorMoved configuration setting. The <mode> defaults to no if the option is not given and to zebra if the option with no mode is given. The mode must be one of: no Moved lines are not highlighted. default Is a synonym for zebra. This may change to a more sensible mode in the future. plain Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation. blocks Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart. zebra Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected. dimmed-zebra Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n**--patch-with-stat**: Moved lines are not highlighted.\n**-z**: Is a synonym for zebra. This may change to a more sensible mode in the future.\n**--name-only**: Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.\n**--name-status**: Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart.\n**--submodule[=<format>]**: Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected.\n**--color[=<when>]**: Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n**--no-color**: Turn off move detection. This can be used to override configuration settings. It is the same as --color-moved=no.\n**--color-moved[=<mode>]**: This configures how whitespace is ignored when performing the move detection for --color-moved. It can be set by the diff.colorMovedWS configuration setting. These modes can be given as a comma separated list: no Do not ignore whitespace when performing move detection. ignore-space-at-eol Ignore changes in whitespace at EOL. ignore-space-change Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent. ignore-all-space Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none. allow-indentation-change Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n**no**: Do not ignore whitespace when performing move detection.\n**default**: Ignore changes in whitespace at EOL.\n**plain**: Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n**blocks**: Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n**zebra**: Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n**dimmed-zebra**: Do not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as --color-moved-ws=no.\n**--no-color-moved**: By default, words are delimited by whitespace; see --word-diff-regex below. The <mode> defaults to plain, and must be one of: color Highlight changed words using only colors. Implies --color. plain Show words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous. porcelain Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own. none Disable word diff again. Note that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled.\n**--color-moved-ws=<mode>,...**: Highlight changed words using only colors. Implies --color.\n**no**: Show words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.\n**ignore-space-at-eol**: Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own.\n**ignore-space-change**: Disable word diff again.\n**ignore-all-space**: Use <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies --word-diff unless it was already enabled. Every non-overlapping match of the <regex> is considered a word. Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences. You may want to append |[^[:space:]] to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline. For example, --word-diff-regex=. will treat each character as a word and, correspondingly, show differences character by character. The regex can also be set via a diff driver or configuration option, see gitattributes[5] or git-config[1]. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.\n**allow-indentation-change**: Equivalent to --word-diff=color plus (if a regex was specified) --word-diff-regex=<regex>.\n**--no-color-moved-ws**: Turn off rename detection, even when the configuration file gives the default to do so.\n**--word-diff[=<mode>]**: Whether to use empty blobs as rename source.\n**color**: Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by core.whitespace configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.\n**plain**: Highlight whitespace errors in the context, old or new lines of the diff. Multiple values are separated by comma, none resets previous values, default reset the list to new and all is a shorthand for old,new,context. When this option is not given, and the configuration variable diff.wsErrorHighlight is not set, only whitespace errors in new lines are highlighted. The whitespace errors are colored with color.diff.whitespace.\n**porcelain**: Instead of the first handful of characters, show the full pre- and post-image blob object names on the \"index\" line when generating patch format output.\n**none**: In addition to --full-index, output a binary diff that can be applied with git-apply. Implies --patch.\n**--word-diff-regex=<regex>**: Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. In diff-patch output format, --full-index takes higher precedence, i.e. if --full-index is specified, full blob names will be shown regardless of --abbrev. Non default number of digits can be specified with --abbrev=<n>.\n**--color-words[=<regex>]**: Break complete rewrite changes into pairs of delete and create. This serves two purposes: It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number <m> controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines). When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number <n> controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file.\n**--no-renames**: Detect renames. If <n> is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed. Without a % sign, the number is to be read as a fraction, with a decimal point before it. I.e., -M5 becomes 0.5, and is thus the same as -M50%. Similarly, -M05 is the same as -M5%. To limit detection to exact renames, use -M100%. The default similarity index is 50%.\n**--[no-]rename-empty**: Detect copies as well as renames. See also --find-copies-harder. If <n> is specified, it has the same meaning as for -M<n>.\n**--check**: For performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one -C option has the same effect.\n**--ws-error-highlight=<kind>**: Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option. When used together with -B, omit also the preimage in the deletion part of a delete/create pair.\n**--full-index**: The -M and -C options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources. (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.) For N sources and destinations, this exhaustive check is O(N^2). This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number. Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited.\n**--binary**: Select only files that are Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have their type (i.e. regular file, symlink, submodule, …) changed (T), are Unmerged (U), are Unknown (X), or have had their pairing Broken (B). Any combination of the filter characters (including none) can be used. When * (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected. Also, these upper-case letters can be downcased to exclude. E.g. --diff-filter=ad excludes added and deleted paths. Note that not all diffs can feature all types. For instance, copied and renamed entries cannot appear if detection for those types is disabled.\n**--abbrev[=<n>]**: Look for differences that change the number of occurrences of the specified <string> (i.e. addition/deletion) in a file. Intended for the scripter’s use. It is useful when you’re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into -S, and keep going until you get the very first version of the block. Binary files are searched as well.\n**-B[<n>][/<m>]**: Look for differences whose patch text contains added/removed lines that match <regex>. To illustrate the difference between -S<regex> --pickaxe-regex and -G<regex>, consider a commit with the following diff in the same file: + return frotz(nitfol, two->ptr, 1, 0); ... - hit = frotz(nitfol, mf2.ptr, 1, 0); While git log -G\"frotz\\(nitfol\" will show this commit, git log -S\"frotz\\(nitfol\" --pickaxe-regex will not (because the number of occurrences of that string did not change). Unless --text is supplied patches of binary files without a textconv filter will be ignored. See the pickaxe entry in gitdiffcore[7] for more information.\n**--break-rewrites[=[<n>][/<m>]]**: Look for differences that change the number of occurrences of the specified object. Similar to -S, just the argument is different in that it doesn’t search for a specific string but for a specific object id. The object can be a blob or a submodule commit. It implies the -t option in git-log to also find trees.\n**-M[<n>]**: When -S or -G finds a change, show all the changes in that changeset, not just the files that contain the change in <string>.\n**--find-renames[=<n>]**: Treat the <string> given to -S as an extended POSIX regular expression to match.\n**-C[<n>]**: Control the order in which files appear in the output. This overrides the diff.orderFile configuration variable (see git-config[1]). To cancel diff.orderFile, use -O/dev/null. The output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order. <orderfile> is parsed as follows: Blank lines are ignored, so they can be used as separators for readability. Lines starting with a hash (\"#\") are ignored, so they can be used for comments. Add a backslash (\"\\\") to the beginning of the pattern if it starts with a hash. Each other line contains a single pattern. Patterns have the same syntax and semantics as patterns used for fnmatch(3) without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern. For example, the pattern \"foo*bar\" matches \"fooasdfbar\" and \"foo/bar/baz/asdf\" but not \"foobarx\".\n**--find-copies[=<n>]**: Discard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to). These options were invented primarily for the use of the git difftool command, and may not be very useful otherwise.\n**--find-copies-harder**: Swap two inputs; that is, show differences from index or on-disk file to tree contents.\n**-D**: When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative.\n**--irreversible-delete**: Treat all files as text.\n**-l<num>**: Ignore carriage-return at the end of line when doing a comparison.\n**--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]**: Ignore changes in whitespace at EOL.\n**-S<string>**: Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n**-G<regex>**: Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n**--find-object=<object-id>**: Ignore changes whose lines are all blank.\n**--pickaxe-all**: Ignore changes whose all lines match <regex>. This option may be specified more than once.\n**--pickaxe-regex**: Show the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n**-O<orderfile>**: Show whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see \"Defining a custom hunk-header\" in gitattributes[5]).\n**--skip-to=<file>**: Make the program exit with codes similar to diff(1). That is, it exits with 1 if there were differences and 0 means no differences.\n**--rotate-to=<file>**: Disable all output of the program. Implies --exit-code. Disables execution of external diff helpers whose exit code is not trusted, i.e. their respective configuration option diff.trustExitCode or diff.<driver>.trustExitCode or environment variable GIT_EXTERNAL_DIFF_TRUST_EXIT_CODE is false.\n**-R**: Allow an external diff helper to be executed. If you set an external diff driver with gitattributes[5], you need to use this option with git-log[1] and friends.\n**--relative[=<path>]**: Disallow external diff drivers.\n**--no-relative**: Allow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes[5] for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff[1] and git-log[1], but not for git-format-patch[1] or diff plumbing commands.\n**-a**: Ignore changes to submodules in the diff generation. all is the default. Using none will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config[1] or gitmodules[5]. When untracked is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using dirty ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using all hides all changes to submodules.\n**--text**: Show the given source <prefix> instead of \"a/\".\n**--ignore-cr-at-eol**: Show the given destination <prefix> instead of \"b/\".\n**--ignore-space-at-eol**: Do not show any source or destination prefix.\n**-b**: Use the default source and destination prefixes (\"a/\" and \"b/\"). This overrides configuration variables such as diff.noprefix, diff.srcPrefix, diff.dstPrefix, and diff.mnemonicPrefix (see git-config[1]).\n**--ignore-space-change**: Prepend an additional <prefix> to every line of output.\n**-w**: By default entries added by git add -N appear as an existing empty file in git diff and a new file in git diff --cached. This option makes the entry appear as a new file in git diff and non-existent in git diff --cached. This option could be reverted with --ita-visible-in-index. Both options are experimental and could be removed in future.\n**default**: The basic greedy diff algorithm. Currently, this is the default.\n**myers**: Spend extra time to make sure the smallest possible diff is produced.\n**minimal**: Use \"patience diff\" algorithm when generating patches.\n**patience**: This algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n**changes**: Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n**lines**: Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n**files**: Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n**cumulative**: Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n**<limit>**: An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n**no**: Moved lines are not highlighted.\n**default**: Is a synonym for zebra. This may change to a more sensible mode in the future.\n**plain**: Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.\n**blocks**: Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart.\n**zebra**: Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected.\n**dimmed-zebra**: Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n**no**: Do not ignore whitespace when performing move detection.\n**ignore-space-at-eol**: Ignore changes in whitespace at EOL.\n**ignore-space-change**: Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n**ignore-all-space**: Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n**allow-indentation-change**: Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n**color**: Highlight changed words using only colors. Implies --color.\n**plain**: Show words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.\n**porcelain**: Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own.\n**none**: Disable word diff again.\n**-1**: Compare the working tree with the \"base\" version (stage #1) when using -1 or --base, \"our branch\" (stage #2) when using -2 or --ours, or \"their branch\" (stage #3) when using -3 or --theirs. The index contains these stages only for unmerged entries i.e. while resolving conflicts. See git-read-tree[1] section \"3-Way Merge\" for detailed information.\n**--base**: Omit diff output for unmerged entries and just show \"Unmerged\". Can be used only when comparing the working tree with the index.\n**-2**: The <path> parameters, when given, are used to limit the diff to the named paths (you can give directory names and get diff for all files under them).",
        "code_examples": [
          "```bash\n+    return frotz(nitfol, two->ptr, 1, 0);\n...\n-    hit = frotz(nitfol, mf2.ptr, 1, 0);\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 140,
          "content_length": 61062
        }
      },
      {
        "header": "Raw output format",
        "content": "The raw output format from git-diff-index, git-diff-tree, git-diff-files and git diff --raw are very similar.\n\nThese commands all compare two sets of things; what is compared differs:\n\ncompares the <tree-ish> and the files on the filesystem.\n\ncompares the <tree-ish> and the index.\n\ncompares the trees named by the two arguments.\n\ncompares the index and the files on the filesystem.\n\nThe git-diff-tree command begins its output by printing the hash of what is being compared. After that, all the commands print one output line per changed file.\n\nAn output line is formatted this way:\n\nThat is, from the left to the right:\n\nmode for \"src\"; 000000 if creation or unmerged.\n\nmode for \"dst\"; 000000 if deletion or unmerged.\n\nsha1 for \"src\"; 0{40} if creation or unmerged.\n\nsha1 for \"dst\"; 0{40} if deletion, unmerged or \"work tree out of sync with the index\".\n\nstatus, followed by optional \"score\" number.\n\na tab or a NUL when -z option is used.\n\na tab or a NUL when -z option is used; only exists for C or R.\n\npath for \"dst\"; only exists for C or R.\n\nan LF or a NUL when -z option is used, to terminate the record.\n\nPossible status letters are:\n\nA: addition of a file\n\nC: copy of a file into a new one\n\nD: deletion of a file\n\nM: modification of the contents or mode of a file\n\nR: renaming of a file\n\nT: change in the type of the file (regular file, symbolic link or submodule)\n\nU: file is unmerged (you must complete the merge before it can be committed)\n\nX: \"unknown\" change type (most probably a bug, please report it)\n\nStatus letters C and R are always followed by a score (denoting the percentage of similarity between the source and target of the move or copy). Status letter M may be followed by a score (denoting the percentage of dissimilarity) for file rewrites.\n\nThe sha1 for \"dst\" is shown as all 0’s if a file on the filesystem is out of sync with the index.\n\nWithout the -z option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]). Using -z the filename is output verbatim and the line is terminated by a NUL byte.\n\n• mode for \"src\"; 000000 if creation or unmerged.\n• mode for \"dst\"; 000000 if deletion or unmerged.\n• sha1 for \"src\"; 0{40} if creation or unmerged.\n• sha1 for \"dst\"; 0{40} if deletion, unmerged or \"work tree out of sync with the index\".\n• status, followed by optional \"score\" number.\n• a tab or a NUL when -z option is used.\n• path for \"src\"\n• a tab or a NUL when -z option is used; only exists for C or R.\n• path for \"dst\"; only exists for C or R.\n• an LF or a NUL when -z option is used, to terminate the record.\n\n• A: addition of a file\n• C: copy of a file into a new one\n• D: deletion of a file\n• M: modification of the contents or mode of a file\n• R: renaming of a file\n• T: change in the type of the file (regular file, symbolic link or submodule)\n• U: file is unmerged (you must complete the merge before it can be committed)\n• X: \"unknown\" change type (most probably a bug, please report it)\n\n**git-diff-index <tree-ish>**: compares the <tree-ish> and the files on the filesystem.\n**git-diff-index --cached <tree-ish>**: compares the <tree-ish> and the index.\n**git-diff-tree [-r] <tree-ish-1> <tree-ish-2> [<pattern>...]**: compares the trees named by the two arguments.\n**git-diff-files [<pattern>...]**: compares the index and the files on the filesystem.",
        "code_examples": [
          "```bash\nin-place edit  :100644 100644 bcd1234 0123456 M file0\ncopy-edit      :100644 100644 abcd123 1234567 C68 file1 file2\nrename-edit    :100644 100644 abcd123 1234567 R86 file1 file3\ncreate         :000000 100644 0000000 1234567 A file4\ndelete         :100644 000000 1234567 0000000 D file5\nunmerged       :000000 000000 0000000 0000000 U file6\n```",
          "```bash\n:100644 100644 5be4a4a 0000000 M file.c\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 30,
          "content_length": 3370
        }
      },
      {
        "header": "diff format for merges",
        "content": "git-diff-tree, git-diff-files and git-diff --raw can take -c or --cc option to generate diff output also for merge commits. The output differs from the format described above in the following way:\n\nthere is a colon for each parent\n\nthere are more \"src\" modes and \"src\" sha1\n\nstatus is concatenated status characters for each parent\n\nno optional \"score\" number\n\ntab-separated pathname(s) of the file\n\nFor -c and --cc, only the destination or final path is shown even if the file was renamed on any side of history. With --combined-all-paths, the name of the path in each parent is shown followed by the name of the path in the merge commit.\n\nExamples for -c and --cc without --combined-all-paths:\n\nExamples when --combined-all-paths added to either -c or --cc:\n\nNote that combined diff lists only files which were modified from all parents.\n\n• there is a colon for each parent\n• there are more \"src\" modes and \"src\" sha1\n• status is concatenated status characters for each parent\n• no optional \"score\" number\n• tab-separated pathname(s) of the file",
        "code_examples": [
          "```bash\n::100644 100644 100644 fabadb8 cc95eb0 4866510 MM\tdesc.c\n::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM\tbar.sh\n::100644 100644 100644 e07d6c5 9042e82 ee91881 RR\tphooey.c\n```",
          "```bash\n::100644 100644 100644 fabadb8 cc95eb0 4866510 MM\tdesc.c\tdesc.c\tdesc.c\n::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM\tfoo.sh\tbar.sh\tbar.sh\n::100644 100644 100644 e07d6c5 9042e82 ee91881 RR\tfooey.c\tfuey.c\tphooey.c\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 1047
        }
      },
      {
        "header": "Generating patch text with -p",
        "content": "Running git-diff[1], git-log[1], git-show[1], git-diff-index[1], git-diff-tree[1], or git-diff-files[1] with the -p option produces patch text. You can customize the creation of patch text via the GIT_EXTERNAL_DIFF and the GIT_DIFF_OPTS environment variables (see git[1]), and the diff attribute (see gitattributes[5]).\n\nWhat the -p option produces is slightly different from the traditional diff format:\n\nIt is preceded by a \"git diff\" header that looks like this:\n\nThe a/ and b/ filenames are the same unless rename/copy is involved. Especially, even for a creation or a deletion, /dev/null is not used in place of the a/ or b/ filenames.\n\nWhen a rename/copy is involved, file1 and file2 show the name of the source file of the rename/copy and the name of the file that the rename/copy produces, respectively.\n\nIt is followed by one or more extended header lines:\n\nFile modes <mode> are printed as 6-digit octal numbers including the file type and file permission bits.\n\nPath names in extended headers do not include the a/ and b/ prefixes.\n\nThe similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one.\n\nThe index line includes the blob object names before and after the change. The <mode> is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.\n\nPathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n\nAll the file1 files in the output refer to files before the commit, and all the file2 files refer to files after the commit. It is incorrect to apply each change to each file sequentially. For example, this patch will swap a and b:\n\nHunk headers mention the name of the function to which the hunk applies. See \"Defining a custom hunk-header\" in gitattributes[5] for details of how to tailor this to specific languages.\n\n• It is preceded by a \"git diff\" header that looks like this: diff --git a/file1 b/file2 The a/ and b/ filenames are the same unless rename/copy is involved. Especially, even for a creation or a deletion, /dev/null is not used in place of the a/ or b/ filenames. When a rename/copy is involved, file1 and file2 show the name of the source file of the rename/copy and the name of the file that the rename/copy produces, respectively.\n• It is followed by one or more extended header lines: old mode <mode> new mode <mode> deleted file mode <mode> new file mode <mode> copy from <path> copy to <path> rename from <path> rename to <path> similarity index <number> dissimilarity index <number> index <hash>..<hash> <mode> File modes <mode> are printed as 6-digit octal numbers including the file type and file permission bits. Path names in extended headers do not include the a/ and b/ prefixes. The similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one. The index line includes the blob object names before and after the change. The <mode> is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.\n• Pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n• All the file1 files in the output refer to files before the commit, and all the file2 files refer to files after the commit. It is incorrect to apply each change to each file sequentially. For example, this patch will swap a and b: diff --git a/a b/b rename from a rename to b diff --git a/b b/a rename from b rename to a\n• Hunk headers mention the name of the function to which the hunk applies. See \"Defining a custom hunk-header\" in gitattributes[5] for details of how to tailor this to specific languages.",
        "code_examples": [
          "```bash\noldmode<mode>newmode<mode>deletedfilemode<mode>newfilemode<mode>copyfrom<path>copyto<path>renamefrom<path>renameto<path>similarityindex<number>dissimilarityindex<number>index<hash>..<hash><mode>\n```"
        ],
        "usage_examples": [
          "```bash\ndiff --git a/file1 b/file2\n```",
          "```bash\ndiff --git a/a b/b\nrename from a\nrename to b\ndiff --git a/b b/a\nrename from b\nrename to a\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 13,
          "content_length": 4196
        }
      },
      {
        "header": "Combined diff format",
        "content": "Any diff-generating command can take the -c or --cc option to produce a combined diff when showing a merge. This is the default format when showing merges with git-diff[1] or git-show[1]. Note also that you can give suitable --diff-merges option to any of these commands to force generation of diffs in a specific format.\n\nA \"combined diff\" format looks like this:\n\nIt is preceded by a \"git diff\" header, that looks like this (when the -c option is used):\n\nor like this (when the --cc option is used):\n\nIt is followed by one or more extended header lines (this example shows a merge with two parents):\n\nThe mode <mode>,<mode>..<mode> line appears only if at least one of the <mode> is different from the rest. Extended headers with information about detected content movement (renames and copying detection) are designed to work with the diff of two <tree-ish> and are not used by combined diff format.\n\nIt is followed by a two-line from-file/to-file header:\n\nSimilar to the two-line header for the traditional unified diff format, /dev/null is used to signal created or deleted files.\n\nHowever, if the --combined-all-paths option is provided, instead of a two-line from-file/to-file, you get an N+1 line from-file/to-file header, where N is the number of parents in the merge commit:\n\nThis extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents.\n\nChunk header format is modified to prevent people from accidentally feeding it to patch -p1. Combined diff format was created for review of merge commit changes, and was not meant to be applied. The change is similar to the change in the extended index header:\n\nThere are (number of parents + 1) @ characters in the chunk header for combined diff format.\n\nUnlike the traditional unified diff format, which shows two files A and B with a single column that has - (minus — appears in A but removed in B), + (plus — missing in A but added to B), or \" \" (space — unchanged) prefix, this format compares two or more files file1, file2,… with one file X, and shows how X differs from each of fileN. One column for each of fileN is prepended to the output line to note how X’s line is different from it.\n\nA - character in the column N means that the line appears in fileN but it does not appear in the result. A + character in the column N means that the line appears in the result, and fileN does not have that line (in other words, the line was added, from the point of view of that parent).\n\nIn the above example output, the function signature was changed from both files (hence two - removals from both file1 and file2, plus ++ to mean one line that was added does not appear in either file1 or file2). Also, eight other lines are the same from file1 but do not appear in file2 (hence prefixed with +).\n\nWhen shown by git diff-tree -c, it compares the parents of a merge commit with the merge result (i.e. file1..fileN are the parents). When shown by git diff-files -c, it compares the two unresolved merge parents with the working tree file (i.e. file1 is stage 2 aka \"our version\", file2 is stage 3 aka \"their version\").\n\n• It is preceded by a \"git diff\" header, that looks like this (when the -c option is used): diff --combined file or like this (when the --cc option is used): diff --cc file\n• It is followed by one or more extended header lines (this example shows a merge with two parents): index <hash>,<hash>..<hash> mode <mode>,<mode>..<mode> new file mode <mode> deleted file mode <mode>,<mode> The mode <mode>,<mode>..<mode> line appears only if at least one of the <mode> is different from the rest. Extended headers with information about detected content movement (renames and copying detection) are designed to work with the diff of two <tree-ish> and are not used by combined diff format.\n• It is followed by a two-line from-file/to-file header: --- a/file +++ b/file Similar to the two-line header for the traditional unified diff format, /dev/null is used to signal created or deleted files. However, if the --combined-all-paths option is provided, instead of a two-line from-file/to-file, you get an N+1 line from-file/to-file header, where N is the number of parents in the merge commit: --- a/file --- a/file --- a/file +++ b/file This extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents.\n• Chunk header format is modified to prevent people from accidentally feeding it to patch -p1. Combined diff format was created for review of merge commit changes, and was not meant to be applied. The change is similar to the change in the extended index header: @@@ <from-file-range> <from-file-range> <to-file-range> @@@ There are (number of parents + 1) @ characters in the chunk header for combined diff format.",
        "code_examples": [
          "```bash\ndiff --combined describe.c\nindex fabadb8,cc95eb0..4866510\n--- a/describe.c\n+++ b/describe.c\n@@@ -98,20 -98,12 +98,20 @@@\n\treturn (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;\n  }\n\n- static void describe(char *arg)\n -static void describe(struct commit *cmit, int last_one)\n++static void describe(char *arg, int last_one)\n  {\n +\tunsigned char sha1[20];\n +\tstruct commit *cmit;\n\tstruct commit_list *list;\n\tstatic int initialized = 0;\n\tstruct commit_name *n;\n\n +\tif (get_sha1(arg, sha1) < 0)\n +\t\tusage(describe_usage);\n +\tcmit = lookup_commit_reference(sha1);\n +\tif (!cmit)\n +\t\tusage(describe_usage);\n +\n\tif (!initialized) {\n\t\tinitialized = 1;\n\t\tfor_each_ref(get_name);\n```",
          "```bash\ndiff --combined file\n```",
          "```bash\ndiff --cc file\n```",
          "```bash\nindex<hash>,<hash>..<hash>mode<mode>,<mode>..<mode>newfilemode<mode>deletedfilemode<mode>,<mode>\n```",
          "```bash\n--- a/file\n+++ b/file\n```",
          "```bash\n--- a/file\n--- a/file\n--- a/file\n+++ b/file\n```",
          "```bash\n@@@ <from-file-range> <from-file-range> <to-file-range> @@@\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 16,
          "content_length": 4844
        }
      },
      {
        "header": "other diff formats",
        "content": "The --summary option describes newly added, deleted, renamed and copied files. The --stat option adds diffstat(1) graph to the output. These options can be combined with other options, such as -p, and are meant for human consumption.\n\nWhen showing a change that involves a rename or a copy, --stat output formats the pathnames compactly by combining common prefix and suffix of the pathnames. For example, a change that moves arch/i386/Makefile to arch/x86/Makefile while modifying 4 lines will be shown like this:\n\nThe --numstat option gives the diffstat(1) information but is designed for easier machine consumption. An entry in --numstat output looks like this:\n\nThat is, from left to right:\n\nthe number of added lines;\n\nthe number of deleted lines;\n\npathname (possibly with rename/copy information);\n\nWhen -z output option is in effect, the output is formatted this way:\n\nthe number of added lines;\n\nthe number of deleted lines;\n\na NUL (only exists if renamed/copied);\n\npathname in preimage;\n\na NUL (only exists if renamed/copied);\n\npathname in postimage (only exists if renamed/copied);\n\nThe extra NUL before the preimage path in renamed case is to allow scripts that read the output to tell if the current record being read is a single-path record or a rename/copy record without reading ahead. After reading added and deleted lines, reading up to NUL would yield the pathname, but if that is NUL, the record will show two paths.\n\n• the number of added lines;\n• the number of deleted lines;\n• pathname (possibly with rename/copy information);\n\n• the number of added lines;\n• the number of deleted lines;\n• a NUL (only exists if renamed/copied);\n• pathname in preimage;\n• a NUL (only exists if renamed/copied);\n• pathname in postimage (only exists if renamed/copied);",
        "code_examples": [
          "```bash\narch/{i386 => x86}/Makefile    |   4 +--\n```",
          "```bash\n1\t2\tREADME\n3\t1\tarch/{i386 => x86}/Makefile\n```",
          "```bash\n1\t2\tREADME NUL\n3\t1\tNUL arch/i386/Makefile NUL arch/x86/Makefile NUL\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 15,
          "content_length": 1772
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Changes in the working tree not yet staged for the next commit.\n\nChanges between the index and your last commit; what you would be committing if you run git commit without -a option.\n\nChanges in the working tree since your last commit; what you would be committing if you run git commit -a\n\nChanges in the working tree you’ve made to resolve textual conflicts so far.\n\nInstead of using the tip of the current branch, compare with the tip of \"test\" branch.\n\nInstead of comparing with the tip of \"test\" branch, compare with the tip of the current branch, but limit the comparison to the file \"test\".\n\nCompare the version before the last commit and the last commit.\n\nChanges between the tips of the topic and the master branches.\n\nChanges that occurred on the master branch since when the topic branch was started off it.\n\nShow only modification, rename, and copy, but not addition or deletion.\n\nShow only names and the nature of change, but not actual diff output.\n\nLimit diff output to named subtrees.\n\nSpend extra cycles to find renames, copies and complete rewrites (very expensive).\n\nOutput diff in reverse.\n\n• Changes in the working tree not yet staged for the next commit.\n• Changes between the index and your last commit; what you would be committing if you run git commit without -a option.\n• Changes in the working tree since your last commit; what you would be committing if you run git commit -a\n• Changes in the working tree you’ve made to resolve textual conflicts so far.\n\n• Instead of using the tip of the current branch, compare with the tip of \"test\" branch.\n• Instead of comparing with the tip of \"test\" branch, compare with the tip of the current branch, but limit the comparison to the file \"test\".\n• Compare the version before the last commit and the last commit.\n\n• Changes between the tips of the topic and the master branches.\n• Same as above.\n• Changes that occurred on the master branch since when the topic branch was started off it.\n\n• Show only modification, rename, and copy, but not addition or deletion.\n• Show only names and the nature of change, but not actual diff output.\n• Limit diff output to named subtrees.\n\n• Spend extra cycles to find renames, copies and complete rewrites (very expensive).\n• Output diff in reverse.\n\n**Various ways to check your working tree**: $ git diff (1) $ git diff --cached (2) $ git diff HEAD (3) $ git diff AUTO_MERGE (4) Changes in the working tree not yet staged for the next commit. Changes between the index and your last commit; what you would be committing if you run git commit without -a option. Changes in the working tree since your last commit; what you would be committing if you run git commit -a Changes in the working tree you’ve made to resolve textual conflicts so far.\n**Comparing with arbitrary commits**: $ git diff test (1) $ git diff HEAD -- ./test (2) $ git diff HEAD^ HEAD (3) Instead of using the tip of the current branch, compare with the tip of \"test\" branch. Instead of comparing with the tip of \"test\" branch, compare with the tip of the current branch, but limit the comparison to the file \"test\". Compare the version before the last commit and the last commit.\n**Comparing branches**: $ git diff topic master (1) $ git diff topic..master (2) $ git diff topic...master (3) Changes between the tips of the topic and the master branches. Same as above. Changes that occurred on the master branch since when the topic branch was started off it.\n**Limiting the diff output**: $ git diff --diff-filter=MRC (1) $ git diff --name-status (2) $ git diff arch/i386 include/asm-i386 (3) Show only modification, rename, and copy, but not addition or deletion. Show only names and the nature of change, but not actual diff output. Limit diff output to named subtrees.\n**Munging the diff output**: $ git diff --find-copies-harder -B -C (1) $ git diff -R (2) Spend extra cycles to find renames, copies and complete rewrites (very expensive). Output diff in reverse.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git diff(1)$ git diff --cached(2)$ git diff HEAD(3)$ git diff AUTO_MERGE(4)\n```",
          "```bash\n$ git diff test(1)$ git diff HEAD -- ./test(2)$ git diff HEAD^ HEAD(3)\n```",
          "```bash\n$ git diff topic master(1)$ git diff topic..master(2)$ git diff topic...master(3)\n```",
          "```bash\n$ git diff --diff-filter=MRC(1)$ git diff --name-status(2)$ git diff arch/i386 include/asm-i386(3)\n```",
          "```bash\n$ git diff --find-copies-harder -B -C(1)$ git diff -R(2)\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 14,
          "content_length": 3947
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Everything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there:\n\nWhen using git diff to compare with work tree files, do not consider stat-only changes as changed. Instead, silently run git update-index --refresh to update the cached stat information for paths whose contents in the work tree match the contents in the index. This option defaults to true. Note that this affects only git diff Porcelain, and not lower level diff commands such as git diff-files.\n\nA comma separated list of --dirstat parameters specifying the default behavior of the --dirstat option to git diff and friends. The defaults can be overridden on the command line (using --dirstat=<param>,...). The fallback defaults (when not changed by diff.dirstat) are changes,noncumulative,3. The following parameters are available:\n\nCompute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n\nCompute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n\nCompute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n\nCount changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n\nAn integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n\nExample: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: files,10,cumulative.\n\nLimit the width of the filename part in --stat output. If set, applies to all commands generating --stat output except format-patch.\n\nLimit the width of the graph part in --stat output. If set, applies to all commands generating --stat output except format-patch.\n\nGenerate diffs with <n> lines of context instead of the default of 3. This value is overridden by the -U option.\n\nShow the context between diff hunks, up to the specified number of lines, thereby fusing the hunks that are close to each other. This value serves as the default for the --inter-hunk-context command line option.\n\nIf this config variable is set, diff generation is not performed using the internal diff machinery, but using the given command. Can be overridden with the GIT_EXTERNAL_DIFF environment variable. The command is called with parameters as described under \"git Diffs\" in git[1]. Note: if you want to use an external diff program only on a subset of your files, you might want to use gitattributes[5] instead.\n\nIf this boolean value is set to true then the diff.external command is expected to return exit code 0 if it considers the input files to be equal or 1 if it considers them to be different, like diff(1). If it is set to false, which is the default, then the command is expected to return exit code 0 regardless of equality. Any other exit code causes Git to report a fatal error.\n\nSets the default value of --ignore-submodules. Note that this affects only git diff Porcelain, and not lower level diff commands such as git diff-files. git checkout and git switch also honor this setting when reporting uncommitted changes. Setting it to all disables the submodule summary normally shown by git commit and git status when status.submoduleSummary is set unless it is overridden by using the --ignore-submodules command-line option. The git submodule commands are not affected by this setting. By default this is set to untracked so that any untracked submodules are ignored.\n\nIf set, git diff uses a prefix pair that is different from the standard a/ and b/ depending on what is being compared. When this configuration is in effect, reverse diff output also swaps the order of the prefixes:\n\ncompares the (i)ndex and the (w)ork tree;\n\ncompares a (c)ommit and the (w)ork tree;\n\ncompares a (c)ommit and the (i)ndex;\n\ncompares an (o)bject and a (w)ork tree entity;\n\ncompares two non-git things <a> and <b>.\n\nIf set, git diff does not show any source or destination prefix.\n\nIf set, git diff uses this source prefix. Defaults to a/.\n\nIf set, git diff uses this destination prefix. Defaults to b/.\n\nIf set to true, git diff does not show changes outside of the directory and show pathnames relative to the current directory.\n\nFile indicating how to order files within a diff. See the -O option for details. If diff.orderFile is a relative pathname, it is treated as relative to the top of the working tree.\n\nThe number of files to consider in the exhaustive portion of copy/rename detection; equivalent to the git diff option -l. If not set, the default value is currently 1000. This setting has no effect if rename detection is turned off.\n\nWhether and how Git detects renames. If set to false, rename detection is disabled. If set to true, basic rename detection is enabled. If set to copies or copy, Git will detect copies, as well. Defaults to true. Note that this affects only git diff Porcelain like git-diff[1] and git-log[1], and not lower level commands such as git-diff-files[1].\n\nA boolean to inhibit the standard behavior of printing a space before each empty output line. Defaults to false.\n\nSpecify the format in which differences in submodules are shown. The short format just shows the names of the commits at the beginning and end of the range. The log format lists the commits in the range like git-submodule[1] summary does. The diff format shows an inline diff of the changed contents of the submodule. Defaults to short.\n\nA POSIX Extended Regular Expression used to determine what is a \"word\" when performing word-by-word difference calculations. Character sequences that match the regular expression are \"words\", all other characters are ignorable whitespace.\n\nThe custom diff driver command. See gitattributes[5] for details.\n\nIf this boolean value is set to true then the diff.<driver>.command command is expected to return exit code 0 if it considers the input files to be equal or 1 if it considers them to be different, like diff(1). If it is set to false, which is the default, then the command is expected to return exit code 0 regardless of equality. Any other exit code causes Git to report a fatal error.\n\nThe regular expression that the diff driver should use to recognize the hunk header. A built-in pattern may also be used. See gitattributes[5] for details.\n\nSet this option to true to make the diff driver treat files as binary. See gitattributes[5] for details.\n\nThe command that the diff driver should call to generate the text-converted version of a file. The result of the conversion is used to generate a human-readable diff. See gitattributes[5] for details.\n\nThe regular expression that the diff driver should use to split words in a line. See gitattributes[5] for details.\n\nSet this option to true to make the diff driver cache the text conversion outputs. See gitattributes[5] for details.\n\nSet this option to false to disable the default heuristics that shift diff hunk boundaries to make patches easier to read.\n\nChoose a diff algorithm. The variants are as follows:\n\nThe basic greedy diff algorithm. Currently, this is the default.\n\nSpend extra time to make sure the smallest possible diff is produced.\n\nUse \"patience diff\" algorithm when generating patches.\n\nThis algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n\nHighlight whitespace errors in the context, old or new lines of the diff. Multiple values are separated by comma, none resets previous values, default reset the list to new and all is a shorthand for old,new,context. The whitespace errors are colored with color.diff.whitespace. The command line option --ws-error-highlight=<kind> overrides this setting.\n\nIf set to either a valid <mode> or a true value, moved lines in a diff are colored differently. For details of valid modes see --color-moved. If simply set to true the default color mode will be used. When set to false, moved lines are not colored.\n\nWhen moved lines are colored using e.g. the diff.colorMoved setting, this option controls the mode how spaces are treated. For details of valid modes see --color-moved-ws in git-diff[1].\n\n**diff.autoRefreshIndex**: When using git diff to compare with work tree files, do not consider stat-only changes as changed. Instead, silently run git update-index --refresh to update the cached stat information for paths whose contents in the work tree match the contents in the index. This option defaults to true. Note that this affects only git diff Porcelain, and not lower level diff commands such as git diff-files.\n**diff.dirstat**: A comma separated list of --dirstat parameters specifying the default behavior of the --dirstat option to git diff and friends. The defaults can be overridden on the command line (using --dirstat=<param>,...). The fallback defaults (when not changed by diff.dirstat) are changes,noncumulative,3. The following parameters are available: changes Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given. lines Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options. files Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all. cumulative Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter. <limit> An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output. Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: files,10,cumulative.\n**changes**: Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n**lines**: Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n**files**: Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n**cumulative**: Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n**<limit>**: An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n**diff.statNameWidth**: Limit the width of the filename part in --stat output. If set, applies to all commands generating --stat output except format-patch.\n**diff.statGraphWidth**: Limit the width of the graph part in --stat output. If set, applies to all commands generating --stat output except format-patch.\n**diff.context**: Generate diffs with <n> lines of context instead of the default of 3. This value is overridden by the -U option.\n**diff.interHunkContext**: Show the context between diff hunks, up to the specified number of lines, thereby fusing the hunks that are close to each other. This value serves as the default for the --inter-hunk-context command line option.\n**diff.external**: If this config variable is set, diff generation is not performed using the internal diff machinery, but using the given command. Can be overridden with the GIT_EXTERNAL_DIFF environment variable. The command is called with parameters as described under \"git Diffs\" in git[1]. Note: if you want to use an external diff program only on a subset of your files, you might want to use gitattributes[5] instead.\n**diff.trustExitCode**: If this boolean value is set to true then the diff.external command is expected to return exit code 0 if it considers the input files to be equal or 1 if it considers them to be different, like diff(1). If it is set to false, which is the default, then the command is expected to return exit code 0 regardless of equality. Any other exit code causes Git to report a fatal error.\n**diff.ignoreSubmodules**: Sets the default value of --ignore-submodules. Note that this affects only git diff Porcelain, and not lower level diff commands such as git diff-files. git checkout and git switch also honor this setting when reporting uncommitted changes. Setting it to all disables the submodule summary normally shown by git commit and git status when status.submoduleSummary is set unless it is overridden by using the --ignore-submodules command-line option. The git submodule commands are not affected by this setting. By default this is set to untracked so that any untracked submodules are ignored.\n**diff.mnemonicPrefix**: If set, git diff uses a prefix pair that is different from the standard a/ and b/ depending on what is being compared. When this configuration is in effect, reverse diff output also swaps the order of the prefixes: git diff compares the (i)ndex and the (w)ork tree; git diff HEAD compares a (c)ommit and the (w)ork tree; git diff --cached compares a (c)ommit and the (i)ndex; git diff HEAD:<file1> <file2> compares an (o)bject and a (w)ork tree entity; git diff --no-index <a> <b> compares two non-git things <a> and <b>.\n**git diff**: compares the (i)ndex and the (w)ork tree;\n**git diff HEAD**: compares a (c)ommit and the (w)ork tree;\n**git diff --cached**: compares a (c)ommit and the (i)ndex;\n**git diff HEAD:<file1> <file2>**: compares an (o)bject and a (w)ork tree entity;\n**git diff --no-index <a> <b>**: compares two non-git things <a> and <b>.\n**diff.noPrefix**: If set, git diff does not show any source or destination prefix.\n**diff.srcPrefix**: If set, git diff uses this source prefix. Defaults to a/.\n**diff.dstPrefix**: If set, git diff uses this destination prefix. Defaults to b/.\n**diff.relative**: If set to true, git diff does not show changes outside of the directory and show pathnames relative to the current directory.\n**diff.orderFile**: File indicating how to order files within a diff. See the -O option for details. If diff.orderFile is a relative pathname, it is treated as relative to the top of the working tree.\n**diff.renameLimit**: The number of files to consider in the exhaustive portion of copy/rename detection; equivalent to the git diff option -l. If not set, the default value is currently 1000. This setting has no effect if rename detection is turned off.\n**diff.renames**: Whether and how Git detects renames. If set to false, rename detection is disabled. If set to true, basic rename detection is enabled. If set to copies or copy, Git will detect copies, as well. Defaults to true. Note that this affects only git diff Porcelain like git-diff[1] and git-log[1], and not lower level commands such as git-diff-files[1].\n**diff.suppressBlankEmpty**: A boolean to inhibit the standard behavior of printing a space before each empty output line. Defaults to false.\n**diff.submodule**: Specify the format in which differences in submodules are shown. The short format just shows the names of the commits at the beginning and end of the range. The log format lists the commits in the range like git-submodule[1] summary does. The diff format shows an inline diff of the changed contents of the submodule. Defaults to short.\n**diff.wordRegex**: A POSIX Extended Regular Expression used to determine what is a \"word\" when performing word-by-word difference calculations. Character sequences that match the regular expression are \"words\", all other characters are ignorable whitespace.\n**diff.<driver>.command**: The custom diff driver command. See gitattributes[5] for details.\n**diff.<driver>.trustExitCode**: If this boolean value is set to true then the diff.<driver>.command command is expected to return exit code 0 if it considers the input files to be equal or 1 if it considers them to be different, like diff(1). If it is set to false, which is the default, then the command is expected to return exit code 0 regardless of equality. Any other exit code causes Git to report a fatal error.\n**diff.<driver>.xfuncname**: The regular expression that the diff driver should use to recognize the hunk header. A built-in pattern may also be used. See gitattributes[5] for details.\n**diff.<driver>.binary**: Set this option to true to make the diff driver treat files as binary. See gitattributes[5] for details.\n**diff.<driver>.textconv**: The command that the diff driver should call to generate the text-converted version of a file. The result of the conversion is used to generate a human-readable diff. See gitattributes[5] for details.\n**diff.<driver>.wordRegex**: The regular expression that the diff driver should use to split words in a line. See gitattributes[5] for details.\n**diff.<driver>.cachetextconv**: Set this option to true to make the diff driver cache the text conversion outputs. See gitattributes[5] for details.\n**diff.indentHeuristic**: Set this option to false to disable the default heuristics that shift diff hunk boundaries to make patches easier to read.\n**diff.algorithm**: Choose a diff algorithm. The variants are as follows: default myers The basic greedy diff algorithm. Currently, this is the default. minimal Spend extra time to make sure the smallest possible diff is produced. patience Use \"patience diff\" algorithm when generating patches. histogram This algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n**default**: The basic greedy diff algorithm. Currently, this is the default.\n**myers**: Spend extra time to make sure the smallest possible diff is produced.\n**minimal**: Use \"patience diff\" algorithm when generating patches.\n**patience**: This algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n**histogram**: Highlight whitespace errors in the context, old or new lines of the diff. Multiple values are separated by comma, none resets previous values, default reset the list to new and all is a shorthand for old,new,context. The whitespace errors are colored with color.diff.whitespace. The command line option --ws-error-highlight=<kind> overrides this setting.\n**diff.wsErrorHighlight**: If set to either a valid <mode> or a true value, moved lines in a diff are colored differently. For details of valid modes see --color-moved. If simply set to true the default color mode will be used. When set to false, moved lines are not colored.\n**diff.colorMoved**: When moved lines are colored using e.g. the diff.colorMoved setting, this option controls the mode how spaces are treated. For details of valid modes see --color-moved-ws in git-diff[1].\n**changes**: Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n**lines**: Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n**files**: Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n**cumulative**: Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n**<limit>**: An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n**git diff**: compares the (i)ndex and the (w)ork tree;\n**git diff HEAD**: compares a (c)ommit and the (w)ork tree;\n**git diff --cached**: compares a (c)ommit and the (i)ndex;\n**git diff HEAD:<file1> <file2>**: compares an (o)bject and a (w)ork tree entity;\n**git diff --no-index <a> <b>**: compares two non-git things <a> and <b>.\n**default**: The basic greedy diff algorithm. Currently, this is the default.\n**myers**: Spend extra time to make sure the smallest possible diff is produced.\n**minimal**: Use \"patience diff\" algorithm when generating patches.\n**patience**: This algorithm extends the patience algorithm to \"support low-occurrence common elements\".",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 48,
          "content_length": 23285
        }
      },
      {
        "header": "SEE ALSO",
        "content": "diff(1), git-difftool[1], git-log[1], gitdiffcore[7], git-format-patch[1], git-apply[1], git-show[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 100
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-diff",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Git",
    "summary": "NAME git-fetch - Download objects and refs from another repository\n\ngit-fetch - Download objects and refs from another repository",
    "sections": [
      {
        "header": "NAME",
        "content": "git-fetch - Download objects and refs from another repository",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 61
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Fetch branches and/or tags (collectively, \"refs\") from one or more other repositories, along with the objects necessary to complete their histories. Remote-tracking branches are updated (see the description of <refspec> below for ways to control this behavior).\n\nBy default, any tag that points into the histories being fetched is also fetched; the effect is to fetch tags that point at branches that you are interested in. This default behavior can be changed by using the --tags or --no-tags options or by configuring remote.<name>.tagOpt. By using a refspec that fetches tags explicitly, you can fetch tags that do not point into branches you are interested in as well.\n\ngit fetch can fetch from either a single named repository or URL, or from several repositories at once if <group> is given and there is a remotes.<group> entry in the configuration file. (See git-config[1]).\n\nWhen no remote is specified, by default the origin remote will be used, unless there’s an upstream branch configured for the current branch.\n\nThe names of refs that are fetched, together with the object names they point at, are written to .git/FETCH_HEAD. This information may be used by scripts or other git commands, such as git-pull[1].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1222
        }
      },
      {
        "header": "OPTIONS",
        "content": "Fetch all remotes, except for the ones that has the remote.<name>.skipFetchAll configuration variable set. This overrides the configuration variable fetch.all.\n\nAppend ref names and object names of fetched refs to the existing contents of .git/FETCH_HEAD. Without this option old data in .git/FETCH_HEAD will be overwritten.\n\nUse an atomic transaction to update local refs. Either all refs are updated, or on error, no refs are updated.\n\nLimit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a shallow repository created by git clone with --depth=<depth> option (see git-clone[1]), deepen or shorten the history to the specified number of commits. Tags for the deepened commits are not fetched.\n\nSimilar to --depth, except it specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history.\n\nDeepen or shorten the history of a shallow repository to include all reachable commits after <date>.\n\nDeepen or shorten the history of a shallow repository to exclude commits reachable from a specified remote branch or tag. This option can be specified multiple times.\n\nIf the source repository is complete, convert a shallow repository to a complete one, removing all the limitations imposed by shallow repositories.\n\nIf the source repository is shallow, fetch as much as possible so that the current repository has the same history as the source repository.\n\nBy default when fetching from a shallow repository, git fetch refuses refs that require updating .git/shallow. This option updates .git/shallow and accepts such refs.\n\nBy default, Git will report, to the server, commits reachable from all local refs to find common commits in an attempt to reduce the size of the to-be-received packfile. If specified, Git will only report commits reachable from the given tips. This is useful to speed up fetches when the user knows which local ref is likely to have commits in common with the upstream ref being fetched.\n\nThis option may be specified more than once; if so, Git will report commits reachable from any of the given commits.\n\nThe argument to this option may be a glob on ref names, a ref, or the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is equivalent to specifying this option multiple times, one for each matching ref name.\n\nSee also the fetch.negotiationAlgorithm and push.negotiate configuration variables documented in git-config[1], and the --negotiate-only option below.\n\nDo not fetch anything from the server, and instead print the ancestors of the provided --negotiation-tip=* arguments, which we have in common with the server.\n\nThis is incompatible with --recurse-submodules=[yes|on-demand]. Internally this is used to implement the push.negotiate option, see git-config[1].\n\nShow what would be done, without making any changes.\n\nPrint the output to standard output in an easy-to-parse format for scripts. See section OUTPUT in git-fetch[1] for details.\n\nThis is incompatible with --recurse-submodules=[yes|on-demand] and takes precedence over the fetch.output config option.\n\nWrite the list of remote refs fetched in the FETCH_HEAD file directly under $GIT_DIR. This is the default. Passing --no-write-fetch-head from the command line tells Git not to write the file. Under --dry-run option, the file is never written.\n\nWhen git fetch is used with <src>:<dst> refspec, it may refuse to update the local branch as discussed in the <refspec> part below. This option overrides that check.\n\nKeep downloaded pack.\n\nAllow several <repository> and <group> arguments to be specified. No <refspec>s may be specified.\n\nRun git maintenance run --auto at the end to perform automatic repository maintenance if needed. (--[no-]auto-gc is a synonym.) This is enabled by default.\n\nWrite a commit-graph after fetching. This overrides the config setting fetch.writeCommitGraph.\n\nModify the configured refspec to place all refs into the refs/prefetch/ namespace. See the prefetch task in git-maintenance[1].\n\nBefore fetching, remove any remote-tracking references that no longer exist on the remote. Tags are not subject to pruning if they are fetched only because of the default tag auto-following or due to a --tags option. However, if tags are fetched due to an explicit refspec (either on the command line or in the remote configuration, for example if the remote was cloned with the --mirror option), then they are also subject to pruning. Supplying --prune-tags is a shorthand for providing the tag refspec.\n\nSee the PRUNING section below for more details.\n\nBefore fetching, remove any local tags that no longer exist on the remote if --prune is enabled. This option should be used more carefully, unlike --prune it will remove any local references (local tags) that have been created. This option is a shorthand for providing the explicit tag refspec along with --prune, see the discussion about that in its documentation.\n\nSee the PRUNING section below for more details.\n\nBy default, tags that point at objects that are downloaded from the remote repository are fetched and stored locally. This option disables this automatic tag following. The default behavior for a remote may be specified with the remote.<name>.tagOpt setting. See git-config[1].\n\nInstead of negotiating with the server to avoid transferring commits and associated objects that are already present locally, this option fetches all objects as a fresh clone would. Use this to reapply a partial clone filter from configuration or using --filter= when the filter definition has changed. Automatic post-fetch maintenance will perform object database pack consolidation to remove any duplicate objects.\n\nWhen fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of remote.*.fetch configuration variables for the remote repository. Providing an empty <refspec> to the --refmap option causes Git to ignore the configured refspecs and rely entirely on the refspecs supplied as command-line arguments. See section on \"Configured Remote-tracking Branches\" for details.\n\nFetch all tags from the remote (i.e., fetch remote tags refs/tags/* into local tags with the same name), in addition to whatever else would otherwise be fetched. Using this option alone does not subject tags to pruning, even if --prune is used (though tags may be pruned anyway if they are also the destination of an explicit refspec; see --prune).\n\nThis option controls if and under what conditions new commits of submodules should be fetched too. When recursing through submodules, git fetch always attempts to fetch \"changed\" submodules, that is, a submodule that has commits that are referenced by a newly fetched superproject commit but are missing in the local submodule clone. A changed submodule can be fetched as long as it is present locally e.g. in $GIT_DIR/modules/ (see gitsubmodules[7]); if the upstream adds a new submodule, that submodule cannot be fetched until it is cloned e.g. by git submodule update.\n\nWhen set to on-demand, only changed submodules are fetched. When set to yes, all populated submodules are fetched and submodules that are both unpopulated and changed are fetched. When set to no, submodules are never fetched.\n\nWhen unspecified, this uses the value of fetch.recurseSubmodules if it is set (see git-config[1]), defaulting to on-demand if unset. When this option is used without any value, it defaults to yes.\n\nNumber of parallel children to be used for all forms of fetching.\n\nIf the --multiple option was specified, the different remotes will be fetched in parallel. If multiple submodules are fetched, they will be fetched in parallel. To control them independently, use the config settings fetch.parallel and submodule.fetchJobs (see git-config[1]).\n\nTypically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel.\n\nDisable recursive fetching of submodules (this has the same effect as using the --recurse-submodules=no option).\n\nIf the remote is fetched successfully, add upstream (tracking) reference, used by argument-less git-pull[1] and other commands. For more information, see branch.<name>.merge and branch.<name>.remote in git-config[1].\n\nPrepend <path> to paths printed in informative messages such as \"Fetching submodule foo\". This option is used internally when recursing over submodules.\n\nThis option is used internally to temporarily provide a non-negative default value for the --recurse-submodules option. All other methods of configuring fetch’s submodule recursion (such as settings in gitmodules[5] and git-config[1]) override this option, as does specifying --[no-]recurse-submodules directly.\n\nBy default git fetch refuses to update the head which corresponds to the current branch. This flag disables the check. This is purely for the internal use for git pull to communicate with git fetch, and unless you are implementing your own Porcelain you are not supposed to use it.\n\nWhen given, and the repository to fetch from is handled by git fetch-pack, --exec=<upload-pack> is passed to the command to specify non-default path for the command run on the other end.\n\nPass --quiet to git-fetch-pack and silence any other internally used git commands. Progress is not reported to the standard error stream.\n\nProgress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.\n\nTransmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. The server’s handling of server options, including unknown ones, is server-specific. When multiple --server-option=<option> are given, they are all sent to the other side in the order listed on the command line. When no --server-option=<option> is given from the command line, the values of configuration variable remote.<name>.serverOption are used instead.\n\nBy default, git checks if a branch is force-updated during fetch. This can be disabled through fetch.showForcedUpdates, but the --show-forced-updates option guarantees this check occurs. See git-config[1].\n\nBy default, git checks if a branch is force-updated during fetch. Pass --no-show-forced-updates or set fetch.showForcedUpdates to false to skip this check for performance reasons. If used during git-pull the --ff-only option will still check for forced updates before attempting a fast-forward update. See git-config[1].\n\nUse IPv4 addresses only, ignoring IPv6 addresses.\n\nUse IPv6 addresses only, ignoring IPv4 addresses.\n\nThe \"remote\" repository that is the source of a fetch or pull operation. This parameter can be either a URL (see the section GIT URLS below) or the name of a remote (see the section REMOTES below).\n\nA name referring to a list of repositories as the value of remotes.<group> in the configuration file. (See git-config[1]).\n\nSpecifies which refs to fetch and which local refs to update. When no <refspec>s appear on the command line, the refs to fetch are read from remote.<repository>.fetch variables instead (see CONFIGURED REMOTE-TRACKING BRANCHES below).\n\nThe format of a <refspec> parameter is an optional plus +, followed by the source <src>, followed by a colon :, followed by the destination <dst>. The colon can be omitted when <dst> is empty. <src> is typically a ref, or a glob pattern with a single * that is used to match a set of refs, but it can also be a fully spelled hex object name.\n\nA <refspec> may contain a * in its <src> to indicate a simple pattern match. Such a refspec functions like a glob that matches any ref with the pattern. A pattern <refspec> must have one and only one * in both the <src> and <dst>. It will map refs to the destination by replacing the * with the contents matched from the source.\n\nIf a refspec is prefixed by ^, it will be interpreted as a negative refspec. Rather than specifying which refs to fetch or which local refs to update, such a refspec will instead specify refs to exclude. A ref will be considered to match if it matches at least one positive refspec, and does not match any negative refspec. Negative refspecs can be useful to restrict the scope of a pattern refspec so that it will not include specific refs. Negative refspecs can themselves be pattern refspecs. However, they may only contain a <src> and do not specify a <dst>. Fully spelled out hex object names are also not supported.\n\ntag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>; it requests fetching everything up to the given tag.\n\nThe remote ref that matches <src> is fetched, and if <dst> is not an empty string, an attempt is made to update the local ref that matches it.\n\nWhether that update is allowed without --force depends on the ref namespace it’s being fetched to, the type of object being fetched, and whether the update is considered to be a fast-forward. Generally, the same rules apply for fetching as when pushing, see the <refspec>... section of git-push[1] for what those are. Exceptions to those rules particular to git fetch are noted below.\n\nUntil Git version 2.20, and unlike when pushing with git-push[1], any updates to refs/tags/* would be accepted without + in the refspec (or --force). When fetching, we promiscuously considered all tag updates from a remote to be forced fetches. Since Git version 2.20, fetching to update refs/tags/* works the same way as when pushing. I.e. any updates will be rejected without + in the refspec (or --force).\n\nUnlike when pushing with git-push[1], any updates outside of refs/{tags,heads}/* will be accepted without + in the refspec (or --force), whether that’s swapping e.g. a tree object for a blob, or a commit for another commit that doesn’t have the previous commit as an ancestor etc.\n\nUnlike when pushing with git-push[1], there is no configuration which’ll amend these rules, and nothing like a pre-fetch hook analogous to the pre-receive hook.\n\nAs with pushing with git-push[1], all of the rules described above about what’s not allowed as an update can be overridden by adding an optional leading + to a refspec (or using the --force command line option). The only exception to this is that no amount of forcing will make the refs/heads/* namespace accept a non-commit object.\n\nRead refspecs, one per line, from stdin in addition to those provided as arguments. The \"tag <name>\" format is not supported.\n\n**--[no-]all**: Fetch all remotes, except for the ones that has the remote.<name>.skipFetchAll configuration variable set. This overrides the configuration variable fetch.all.\n**-a**: Append ref names and object names of fetched refs to the existing contents of .git/FETCH_HEAD. Without this option old data in .git/FETCH_HEAD will be overwritten.\n**--append**: Use an atomic transaction to update local refs. Either all refs are updated, or on error, no refs are updated.\n**--atomic**: Limit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a shallow repository created by git clone with --depth=<depth> option (see git-clone[1]), deepen or shorten the history to the specified number of commits. Tags for the deepened commits are not fetched.\n**--depth=<depth>**: Similar to --depth, except it specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history.\n**--deepen=<depth>**: Deepen or shorten the history of a shallow repository to include all reachable commits after <date>.\n**--shallow-since=<date>**: Deepen or shorten the history of a shallow repository to exclude commits reachable from a specified remote branch or tag. This option can be specified multiple times.\n**--shallow-exclude=<ref>**: If the source repository is complete, convert a shallow repository to a complete one, removing all the limitations imposed by shallow repositories. If the source repository is shallow, fetch as much as possible so that the current repository has the same history as the source repository.\n**--unshallow**: By default when fetching from a shallow repository, git fetch refuses refs that require updating .git/shallow. This option updates .git/shallow and accepts such refs.\n**--update-shallow**: By default, Git will report, to the server, commits reachable from all local refs to find common commits in an attempt to reduce the size of the to-be-received packfile. If specified, Git will only report commits reachable from the given tips. This is useful to speed up fetches when the user knows which local ref is likely to have commits in common with the upstream ref being fetched. This option may be specified more than once; if so, Git will report commits reachable from any of the given commits. The argument to this option may be a glob on ref names, a ref, or the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is equivalent to specifying this option multiple times, one for each matching ref name. See also the fetch.negotiationAlgorithm and push.negotiate configuration variables documented in git-config[1], and the --negotiate-only option below.\n**--negotiation-tip=<commit|glob>**: Do not fetch anything from the server, and instead print the ancestors of the provided --negotiation-tip=* arguments, which we have in common with the server. This is incompatible with --recurse-submodules=[yes|on-demand]. Internally this is used to implement the push.negotiate option, see git-config[1].\n**--negotiate-only**: Show what would be done, without making any changes.\n**--dry-run**: Print the output to standard output in an easy-to-parse format for scripts. See section OUTPUT in git-fetch[1] for details. This is incompatible with --recurse-submodules=[yes|on-demand] and takes precedence over the fetch.output config option.\n**--porcelain**: Write the list of remote refs fetched in the FETCH_HEAD file directly under $GIT_DIR. This is the default. Passing --no-write-fetch-head from the command line tells Git not to write the file. Under --dry-run option, the file is never written.\n**--[no-]write-fetch-head**: When git fetch is used with <src>:<dst> refspec, it may refuse to update the local branch as discussed in the <refspec> part below. This option overrides that check.\n**-f**: Keep downloaded pack.\n**--force**: Allow several <repository> and <group> arguments to be specified. No <refspec>s may be specified.\n**-k**: Run git maintenance run --auto at the end to perform automatic repository maintenance if needed. (--[no-]auto-gc is a synonym.) This is enabled by default.\n**--keep**: Write a commit-graph after fetching. This overrides the config setting fetch.writeCommitGraph.\n**--multiple**: Modify the configured refspec to place all refs into the refs/prefetch/ namespace. See the prefetch task in git-maintenance[1].\n**--[no-]auto-maintenance**: Before fetching, remove any remote-tracking references that no longer exist on the remote. Tags are not subject to pruning if they are fetched only because of the default tag auto-following or due to a --tags option. However, if tags are fetched due to an explicit refspec (either on the command line or in the remote configuration, for example if the remote was cloned with the --mirror option), then they are also subject to pruning. Supplying --prune-tags is a shorthand for providing the tag refspec. See the PRUNING section below for more details.\n**--[no-]auto-gc**: Before fetching, remove any local tags that no longer exist on the remote if --prune is enabled. This option should be used more carefully, unlike --prune it will remove any local references (local tags) that have been created. This option is a shorthand for providing the explicit tag refspec along with --prune, see the discussion about that in its documentation. See the PRUNING section below for more details.\n**--[no-]write-commit-graph**: By default, tags that point at objects that are downloaded from the remote repository are fetched and stored locally. This option disables this automatic tag following. The default behavior for a remote may be specified with the remote.<name>.tagOpt setting. See git-config[1].\n**--prefetch**: Instead of negotiating with the server to avoid transferring commits and associated objects that are already present locally, this option fetches all objects as a fresh clone would. Use this to reapply a partial clone filter from configuration or using --filter= when the filter definition has changed. Automatic post-fetch maintenance will perform object database pack consolidation to remove any duplicate objects.\n**-p**: When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of remote.*.fetch configuration variables for the remote repository. Providing an empty <refspec> to the --refmap option causes Git to ignore the configured refspecs and rely entirely on the refspecs supplied as command-line arguments. See section on \"Configured Remote-tracking Branches\" for details.\n**--prune**: Fetch all tags from the remote (i.e., fetch remote tags refs/tags/* into local tags with the same name), in addition to whatever else would otherwise be fetched. Using this option alone does not subject tags to pruning, even if --prune is used (though tags may be pruned anyway if they are also the destination of an explicit refspec; see --prune).\n**-P**: This option controls if and under what conditions new commits of submodules should be fetched too. When recursing through submodules, git fetch always attempts to fetch \"changed\" submodules, that is, a submodule that has commits that are referenced by a newly fetched superproject commit but are missing in the local submodule clone. A changed submodule can be fetched as long as it is present locally e.g. in $GIT_DIR/modules/ (see gitsubmodules[7]); if the upstream adds a new submodule, that submodule cannot be fetched until it is cloned e.g. by git submodule update. When set to on-demand, only changed submodules are fetched. When set to yes, all populated submodules are fetched and submodules that are both unpopulated and changed are fetched. When set to no, submodules are never fetched. When unspecified, this uses the value of fetch.recurseSubmodules if it is set (see git-config[1]), defaulting to on-demand if unset. When this option is used without any value, it defaults to yes.\n**--prune-tags**: Number of parallel children to be used for all forms of fetching. If the --multiple option was specified, the different remotes will be fetched in parallel. If multiple submodules are fetched, they will be fetched in parallel. To control them independently, use the config settings fetch.parallel and submodule.fetchJobs (see git-config[1]). Typically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel.\n**-n**: Disable recursive fetching of submodules (this has the same effect as using the --recurse-submodules=no option).\n**--no-tags**: If the remote is fetched successfully, add upstream (tracking) reference, used by argument-less git-pull[1] and other commands. For more information, see branch.<name>.merge and branch.<name>.remote in git-config[1].\n**--refetch**: Prepend <path> to paths printed in informative messages such as \"Fetching submodule foo\". This option is used internally when recursing over submodules.\n**--refmap=<refspec>**: This option is used internally to temporarily provide a non-negative default value for the --recurse-submodules option. All other methods of configuring fetch’s submodule recursion (such as settings in gitmodules[5] and git-config[1]) override this option, as does specifying --[no-]recurse-submodules directly.\n**-t**: By default git fetch refuses to update the head which corresponds to the current branch. This flag disables the check. This is purely for the internal use for git pull to communicate with git fetch, and unless you are implementing your own Porcelain you are not supposed to use it.\n**--tags**: When given, and the repository to fetch from is handled by git fetch-pack, --exec=<upload-pack> is passed to the command to specify non-default path for the command run on the other end.\n**--recurse-submodules[=(yes|on-demand|no)]**: Pass --quiet to git-fetch-pack and silence any other internally used git commands. Progress is not reported to the standard error stream.\n**-j**: Be verbose.\n**--jobs=<n>**: Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.\n**--no-recurse-submodules**: Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. The server’s handling of server options, including unknown ones, is server-specific. When multiple --server-option=<option> are given, they are all sent to the other side in the order listed on the command line. When no --server-option=<option> is given from the command line, the values of configuration variable remote.<name>.serverOption are used instead.\n**--set-upstream**: By default, git checks if a branch is force-updated during fetch. This can be disabled through fetch.showForcedUpdates, but the --show-forced-updates option guarantees this check occurs. See git-config[1].\n**--submodule-prefix=<path>**: By default, git checks if a branch is force-updated during fetch. Pass --no-show-forced-updates or set fetch.showForcedUpdates to false to skip this check for performance reasons. If used during git-pull the --ff-only option will still check for forced updates before attempting a fast-forward update. See git-config[1].\n**--recurse-submodules-default=[yes|on-demand]**: Use IPv4 addresses only, ignoring IPv6 addresses.\n**-u**: Use IPv6 addresses only, ignoring IPv4 addresses.\n**--update-head-ok**: The \"remote\" repository that is the source of a fetch or pull operation. This parameter can be either a URL (see the section GIT URLS below) or the name of a remote (see the section REMOTES below).\n**--upload-pack <upload-pack>**: A name referring to a list of repositories as the value of remotes.<group> in the configuration file. (See git-config[1]).\n**-q**: Specifies which refs to fetch and which local refs to update. When no <refspec>s appear on the command line, the refs to fetch are read from remote.<repository>.fetch variables instead (see CONFIGURED REMOTE-TRACKING BRANCHES below). The format of a <refspec> parameter is an optional plus +, followed by the source <src>, followed by a colon :, followed by the destination <dst>. The colon can be omitted when <dst> is empty. <src> is typically a ref, or a glob pattern with a single * that is used to match a set of refs, but it can also be a fully spelled hex object name. A <refspec> may contain a * in its <src> to indicate a simple pattern match. Such a refspec functions like a glob that matches any ref with the pattern. A pattern <refspec> must have one and only one * in both the <src> and <dst>. It will map refs to the destination by replacing the * with the contents matched from the source. If a refspec is prefixed by ^, it will be interpreted as a negative refspec. Rather than specifying which refs to fetch or which local refs to update, such a refspec will instead specify refs to exclude. A ref will be considered to match if it matches at least one positive refspec, and does not match any negative refspec. Negative refspecs can be useful to restrict the scope of a pattern refspec so that it will not include specific refs. Negative refspecs can themselves be pattern refspecs. However, they may only contain a <src> and do not specify a <dst>. Fully spelled out hex object names are also not supported. tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>; it requests fetching everything up to the given tag. The remote ref that matches <src> is fetched, and if <dst> is not an empty string, an attempt is made to update the local ref that matches it. Whether that update is allowed without --force depends on the ref namespace it’s being fetched to, the type of object being fetched, and whether the update is considered to be a fast-forward. Generally, the same rules apply for fetching as when pushing, see the <refspec>... section of git-push[1] for what those are. Exceptions to those rules particular to git fetch are noted below. Until Git version 2.20, and unlike when pushing with git-push[1], any updates to refs/tags/* would be accepted without + in the refspec (or --force). When fetching, we promiscuously considered all tag updates from a remote to be forced fetches. Since Git version 2.20, fetching to update refs/tags/* works the same way as when pushing. I.e. any updates will be rejected without + in the refspec (or --force). Unlike when pushing with git-push[1], any updates outside of refs/{tags,heads}/* will be accepted without + in the refspec (or --force), whether that’s swapping e.g. a tree object for a blob, or a commit for another commit that doesn’t have the previous commit as an ancestor etc. Unlike when pushing with git-push[1], there is no configuration which’ll amend these rules, and nothing like a pre-fetch hook analogous to the pre-receive hook. As with pushing with git-push[1], all of the rules described above about what’s not allowed as an update can be overridden by adding an optional leading + to a refspec (or using the --force command line option). The only exception to this is that no amount of forcing will make the refs/heads/* namespace accept a non-commit object. Note When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be a descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the + sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.\n**--quiet**: Read refspecs, one per line, from stdin in addition to those provided as arguments. The \"tag <name>\" format is not supported.\n\nNote | When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be a descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the + sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.\n\n[Note] Note When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be a descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the + sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 67,
          "content_length": 31620
        }
      },
      {
        "header": "GIT URLS",
        "content": "In general, URLs contain information about the transport protocol, the address of the remote server, and the path to the repository. Depending on the transport protocol, some of this information may be absent.\n\nGit supports ssh, git, http, and https protocols (in addition, ftp and ftps can be used for fetching, but this is inefficient and deprecated; do not use them).\n\nThe native transport (i.e. git:// URL) does no authentication and should be used with caution on unsecured networks.\n\nThe following syntaxes may be used with them:\n\nssh://[<user>@]<host>[:<port>]/<path-to-git-repo>\n\ngit://<host>[:<port>]/<path-to-git-repo>\n\nhttp[s]://<host>[:<port>]/<path-to-git-repo>\n\nftp[s]://<host>[:<port>]/<path-to-git-repo>\n\nAn alternative scp-like syntax may also be used with the ssh protocol:\n\n[<user>@]<host>:/<path-to-git-repo>\n\nThis syntax is only recognized if there are no slashes before the first colon. This helps differentiate a local path that contains a colon. For example the local path foo:bar could be specified as an absolute path or ./foo:bar to avoid being misinterpreted as an ssh url.\n\nThe ssh and git protocols additionally support ~<username> expansion:\n\nssh://[<user>@]<host>[:<port>]/~<user>/<path-to-git-repo>\n\ngit://<host>[:<port>]/~<user>/<path-to-git-repo>\n\n[<user>@]<host>:~<user>/<path-to-git-repo>\n\nFor local repositories, also supported by Git natively, the following syntaxes may be used:\n\nfile:///path/to/repo.git/\n\nThese two syntaxes are mostly equivalent, except when cloning, when the former implies --local option. See git-clone[1] for details.\n\ngit clone, git fetch and git pull, but not git push, will also accept a suitable bundle file. See git-bundle[1].\n\nWhen Git doesn’t know how to handle a certain transport protocol, it attempts to use the remote-<transport> remote helper, if one exists. To explicitly request a remote helper, the following syntax may be used:\n\n<transport>::<address>\n\nwhere <address> may be a path, a server and path, or an arbitrary URL-like string recognized by the specific remote helper being invoked. See gitremote-helpers[7] for details.\n\nIf there are a large number of similarly-named remote repositories and you want to use a different format for them (such that the URLs you use will be rewritten into URLs that work), you can create a configuration section of the form:\n\nFor example, with this:\n\na URL like \"work:repo.git\" or like \"host.xz:/path/to/repo.git\" will be rewritten in any context that takes a URL to be \"git://git.host.xz/repo.git\".\n\nIf you want to rewrite URLs for push only, you can create a configuration section of the form:\n\nFor example, with this:\n\na URL like \"git://example.org/path/to/repo.git\" will be rewritten to \"ssh://example.org/path/to/repo.git\" for pushes, but pulls will still use the original URL.\n\n• ssh://[<user>@]<host>[:<port>]/<path-to-git-repo>\n• git://<host>[:<port>]/<path-to-git-repo>\n• http[s]://<host>[:<port>]/<path-to-git-repo>\n• ftp[s]://<host>[:<port>]/<path-to-git-repo>\n\n• [<user>@]<host>:/<path-to-git-repo>\n\n• ssh://[<user>@]<host>[:<port>]/~<user>/<path-to-git-repo>\n• git://<host>[:<port>]/~<user>/<path-to-git-repo>\n• [<user>@]<host>:~<user>/<path-to-git-repo>\n\n• /path/to/repo.git/\n• file:///path/to/repo.git/\n\n• <transport>::<address>",
        "code_examples": [
          "```bash\n[url \"<actual-url-base>\"]\n\t\tinsteadOf =<other-url-base>\n```",
          "```bash\n[url \"<actual-url-base>\"]\n\t\tpushInsteadOf =<other-url-base>\n```"
        ],
        "usage_examples": [
          "```bash\n[url \"git://git.host.xz/\"]\n\t\tinsteadOf = host.xz:/path/to/\n\t\tinsteadOf = work:\n```",
          "```bash\n[url \"ssh://example.org/\"]\n\t\tpushInsteadOf = git://example.org/\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 28,
          "content_length": 3261
        }
      },
      {
        "header": "REMOTES",
        "content": "The name of one of the following can be used instead of a URL as <repository> argument:\n\na remote in the Git configuration file: $GIT_DIR/config,\n\na file in the $GIT_DIR/remotes directory, or\n\na file in the $GIT_DIR/branches directory.\n\nAll of these also allow you to omit the refspec from the command line because they each contain a refspec which git will use by default.\n\n• a remote in the Git configuration file: $GIT_DIR/config,\n• a file in the $GIT_DIR/remotes directory, or\n• a file in the $GIT_DIR/branches directory.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 525
        }
      },
      {
        "header": "Named remote in configuration file",
        "content": "You can choose to provide the name of a remote which you had previously configured using git-remote[1], git-config[1] or even by a manual edit to the $GIT_DIR/config file. The URL of this remote will be used to access the repository. The refspec of this remote will be used by default when you do not provide a refspec on the command line. The entry in the config file would appear like this:\n\nThe <pushurl> is used for pushes only. It is optional and defaults to <URL>. Pushing to a remote affects all defined pushurls or all defined urls if no pushurls are defined. Fetch, however, will only fetch from the first defined url if multiple urls are defined.",
        "code_examples": [
          "```bash\n[remote \"<name>\"]\n\t\turl = <URL>\n\t\tpushurl = <pushurl>\n\t\tpush =<refspec>fetch =<refspec>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 656
        }
      },
      {
        "header": "Named file in $GIT_DIR/remotes",
        "content": "You can choose to provide the name of a file in $GIT_DIR/remotes. The URL in this file will be used to access the repository. The refspec in this file will be used as default when you do not provide a refspec on the command line. This file should have the following format:\n\nPush: lines are used by git push and Pull: lines are used by git pull and git fetch. Multiple Push: and Pull: lines may be specified for additional branch mappings.",
        "code_examples": [
          "```bash\nURL: one of the above URL formats\n\tPush:<refspec>Pull:<refspec>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 439
        }
      },
      {
        "header": "Named file in $GIT_DIR/branches",
        "content": "You can choose to provide the name of a file in $GIT_DIR/branches. The URL in this file will be used to access the repository. This file should have the following format:\n\n<URL> is required; #<head> is optional.\n\nDepending on the operation, git will use one of the following refspecs, if you don’t provide one on the command line. <branch> is the name of this file in $GIT_DIR/branches and <head> defaults to master.",
        "code_examples": [
          "```bash\n<URL>#<head>\n```",
          "```bash\nrefs/heads/<head>:refs/heads/<branch>\n```",
          "```bash\nHEAD:refs/heads/<head>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 416
        }
      },
      {
        "header": "CONFIGURED REMOTE-TRACKING BRANCHES",
        "content": "You often interact with the same remote repository by regularly and repeatedly fetching from it. In order to keep track of the progress of such a remote repository, git fetch allows you to configure remote.<repository>.fetch configuration variables.\n\nTypically such a variable may look like this:\n\nThis configuration is used in two ways:\n\nWhen git fetch is run without specifying what branches and/or tags to fetch on the command line, e.g. git fetch origin or git fetch, remote.<repository>.fetch values are used as the refspecs—they specify which refs to fetch and which local refs to update. The example above will fetch all branches that exist in the origin (i.e. any ref that matches the left-hand side of the value, refs/heads/*) and update the corresponding remote-tracking branches in the refs/remotes/origin/* hierarchy.\n\nWhen git fetch is run with explicit branches and/or tags to fetch on the command line, e.g. git fetch origin master, the <refspec>s given on the command line determine what are to be fetched (e.g. master in the example, which is a short-hand for master:, which in turn means \"fetch the master branch but I do not explicitly say what remote-tracking branch to update with it from the command line\"), and the example command will fetch only the master branch. The remote.<repository>.fetch values determine which remote-tracking branch, if any, is updated. When used in this way, the remote.<repository>.fetch values do not have any effect in deciding what gets fetched (i.e. the values are not used as refspecs when the command-line lists refspecs); they are only used to decide where the refs that are fetched are stored by acting as a mapping.\n\nThe latter use of the remote.<repository>.fetch values can be overridden by giving the --refmap=<refspec> parameter(s) on the command line.\n\n• When git fetch is run without specifying what branches and/or tags to fetch on the command line, e.g. git fetch origin or git fetch, remote.<repository>.fetch values are used as the refspecs—they specify which refs to fetch and which local refs to update. The example above will fetch all branches that exist in the origin (i.e. any ref that matches the left-hand side of the value, refs/heads/*) and update the corresponding remote-tracking branches in the refs/remotes/origin/* hierarchy.\n• When git fetch is run with explicit branches and/or tags to fetch on the command line, e.g. git fetch origin master, the <refspec>s given on the command line determine what are to be fetched (e.g. master in the example, which is a short-hand for master:, which in turn means \"fetch the master branch but I do not explicitly say what remote-tracking branch to update with it from the command line\"), and the example command will fetch only the master branch. The remote.<repository>.fetch values determine which remote-tracking branch, if any, is updated. When used in this way, the remote.<repository>.fetch values do not have any effect in deciding what gets fetched (i.e. the values are not used as refspecs when the command-line lists refspecs); they are only used to decide where the refs that are fetched are stored by acting as a mapping.",
        "code_examples": [
          "```bash\n[remote \"origin\"]\n\tfetch = +refs/heads/*:refs/remotes/origin/*\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 3157
        }
      },
      {
        "header": "PRUNING",
        "content": "Git has a default disposition of keeping data unless it’s explicitly thrown away; this extends to holding onto local references to branches on remotes that have themselves deleted those branches.\n\nIf left to accumulate, these stale references might make performance worse on big and busy repos that have a lot of branch churn, and e.g. make the output of commands like git branch -a --contains <commit> needlessly verbose, as well as impacting anything else that’ll work with the complete set of known references.\n\nThese remote-tracking references can be deleted as a one-off with either of:\n\nTo prune references as part of your normal workflow without needing to remember to run that, set fetch.prune globally, or remote.<name>.prune per-remote in the config. See git-config[1].\n\nHere’s where things get tricky and more specific. The pruning feature doesn’t actually care about branches, instead it’ll prune local ←→ remote-references as a function of the refspec of the remote (see <refspec> and CONFIGURED REMOTE-TRACKING BRANCHES above).\n\nTherefore if the refspec for the remote includes e.g. refs/tags/*:refs/tags/*, or you manually run e.g. git fetch --prune <name> \"refs/tags/*:refs/tags/*\" it won’t be stale remote tracking branches that are deleted, but any local tag that doesn’t exist on the remote.\n\nThis might not be what you expect, i.e. you want to prune remote <name>, but also explicitly fetch tags from it, so when you fetch from it you delete all your local tags, most of which may not have come from the <name> remote in the first place.\n\nSo be careful when using this with a refspec like refs/tags/*:refs/tags/*, or any other refspec which might map references from multiple remotes to the same local namespace.\n\nSince keeping up-to-date with both branches and tags on the remote is a common use-case the --prune-tags option can be supplied along with --prune to prune local tags that don’t exist on the remote, and force-update those tags that differ. Tag pruning can also be enabled with fetch.pruneTags or remote.<name>.pruneTags in the config. See git-config[1].\n\nThe --prune-tags option is equivalent to having refs/tags/*:refs/tags/* declared in the refspecs of the remote. This can lead to some seemingly strange interactions:\n\nThe reason it doesn’t error out when provided without --prune or its config versions is for flexibility of the configured versions, and to maintain a 1=1 mapping between what the command line flags do, and what the configuration versions do.\n\nIt’s reasonable to e.g. configure fetch.pruneTags=true in ~/.gitconfig to have tags pruned whenever git fetch --prune is run, without making every invocation of git fetch without --prune an error.\n\nPruning tags with --prune-tags also works when fetching a URL instead of a named remote. These will all prune tags not found on origin:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n# While fetching\n$ git fetch --prune <name>\n\n# Only prune, don't fetch\n$ git remote prune <name>\n```",
          "```bash\n# These both fetch tags\n$ git fetch --no-tags origin 'refs/tags/*:refs/tags/*'\n$ git fetch --no-tags --prune-tags origin\n```",
          "```bash\n$ git fetch origin --prune --prune-tags\n$ git fetch origin --prune 'refs/tags/*:refs/tags/*'\n$ git fetch <url-of-origin> --prune --prune-tags\n$ git fetch <url-of-origin> --prune 'refs/tags/*:refs/tags/*'\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 13,
          "content_length": 2832
        }
      },
      {
        "header": "OUTPUT",
        "content": "The output of \"git fetch\" depends on the transport method used; this section describes the output when fetching over the Git protocol (either locally or via ssh) and Smart HTTP protocol.\n\nThe status of the fetch is output in tabular form, with each line representing the status of a single ref. Each line is of the form:\n\nWhen using --porcelain, the output format is intended to be machine-parseable. In contrast to the human-readable output formats it thus prints to standard output instead of standard error. Each line is of the form:\n\nThe status of up-to-date refs is shown only if the --verbose option is used.\n\nIn compact output mode, specified with configuration variable fetch.output, if either entire <from> or <to> is found in the other string, it will be substituted with * in the other string. For example, master -> origin/master becomes master -> origin/*.\n\nA single character indicating the status of the ref:\n\nfor a successfully fetched fast-forward;\n\nfor a successful forced update;\n\nfor a successfully pruned ref;\n\nfor a successful tag update;\n\nfor a successfully fetched new ref;\n\nfor a ref that was rejected or failed to update; and\n\nfor a ref that was up to date and did not need fetching.\n\nFor a successfully fetched ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to git log (this is <old>..<new> in most cases, and <old>...<new> for forced non-fast-forward updates).\n\nThe name of the remote ref being fetched from, minus its refs/<type>/ prefix. In the case of deletion, the name of the remote ref is \"(none)\".\n\nThe name of the local ref being updated, minus its refs/<type>/ prefix.\n\nA human-readable explanation. In the case of successfully fetched refs, no explanation is needed. For a failed ref, the reason for failure is described.\n\n**flag**: A single character indicating the status of the ref: (space) for a successfully fetched fast-forward; + for a successful forced update; - for a successfully pruned ref; t for a successful tag update; * for a successfully fetched new ref; ! for a ref that was rejected or failed to update; and = for a ref that was up to date and did not need fetching.\n**(space)**: for a successfully fetched fast-forward;\n**+**: for a successful forced update;\n**-**: for a successfully pruned ref;\n**t**: for a successful tag update;\n*****: for a successfully fetched new ref;\n**!**: for a ref that was rejected or failed to update; and\n**=**: for a ref that was up to date and did not need fetching.\n**summary**: For a successfully fetched ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to git log (this is <old>..<new> in most cases, and <old>...<new> for forced non-fast-forward updates).\n**from**: The name of the remote ref being fetched from, minus its refs/<type>/ prefix. In the case of deletion, the name of the remote ref is \"(none)\".\n**to**: The name of the local ref being updated, minus its refs/<type>/ prefix.\n**reason**: A human-readable explanation. In the case of successfully fetched refs, no explanation is needed. For a failed ref, the reason for failure is described.\n**(space)**: for a successfully fetched fast-forward;\n**+**: for a successful forced update;\n**-**: for a successfully pruned ref;\n**t**: for a successful tag update;\n*****: for a successfully fetched new ref;\n**!**: for a ref that was rejected or failed to update; and\n**=**: for a ref that was up to date and did not need fetching.",
        "code_examples": [
          "```bash\n<flag> <summary> <from> -> <to> [<reason>]\n```",
          "```bash\n<flag> <old-object-id> <new-object-id> <local-reference>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 17,
          "content_length": 3487
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Update the remote-tracking branches:\n\nThe above command copies all branches from the remote refs/heads/ namespace and stores them to the local refs/remotes/origin/ namespace, unless the remote.<repository>.fetch option is used to specify a non-default refspec.\n\nUsing refspecs explicitly:\n\nThis updates (or creates, as necessary) branches seen and tmp in the local repository by fetching from the branches (respectively) seen and maint from the remote repository.\n\nThe seen branch will be updated even if it does not fast-forward, because it is prefixed with a plus sign; tmp will not be.\n\nPeek at a remote’s branch, without configuring the remote in your local repository:\n\nThe first command fetches the maint branch from the repository at git://git.kernel.org/pub/scm/git/git.git and the second command uses FETCH_HEAD to examine the branch with git-log[1]. The fetched objects will eventually be removed by git’s built-in housekeeping (see git-gc[1]).\n\n• Update the remote-tracking branches: $ git fetch origin The above command copies all branches from the remote refs/heads/ namespace and stores them to the local refs/remotes/origin/ namespace, unless the remote.<repository>.fetch option is used to specify a non-default refspec.\n• Using refspecs explicitly: $ git fetch origin +seen:seen maint:tmp This updates (or creates, as necessary) branches seen and tmp in the local repository by fetching from the branches (respectively) seen and maint from the remote repository. The seen branch will be updated even if it does not fast-forward, because it is prefixed with a plus sign; tmp will not be.\n• Peek at a remote’s branch, without configuring the remote in your local repository: $ git fetch git://git.kernel.org/pub/scm/git/git.git maint $ git log FETCH_HEAD The first command fetches the maint branch from the repository at git://git.kernel.org/pub/scm/git/git.git and the second command uses FETCH_HEAD to examine the branch with git-log[1]. The fetched objects will eventually be removed by git’s built-in housekeeping (see git-gc[1]).",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git fetch origin\n```",
          "```bash\n$ git fetch origin +seen:seen maint:tmp\n```",
          "```bash\n$ git fetch git://git.kernel.org/pub/scm/git/git.git maint\n$ git log FETCH_HEAD\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 2049
        }
      },
      {
        "header": "SECURITY",
        "content": "The fetch and push protocols are not designed to prevent one side from stealing data from the other repository that was not intended to be shared. If you have private data that you need to protect from a malicious peer, your best option is to store it in another repository. This applies to both clients and servers. In particular, namespaces on a server are not effective for read access control; you should only grant read access to a namespace to clients that you would trust with read access to the entire repository.\n\nThe known attack vectors are as follows:\n\nThe victim sends \"have\" lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn’t required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to \"merge\" X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)\n\nAs in #1, the attacker chooses an object ID X to steal. The victim sends an object Y that the attacker already has, and the attacker falsely claims to have X and not Y, so the victim sends Y as a delta against X. The delta reveals regions of X that are similar to Y to the attacker.\n\n• The victim sends \"have\" lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn’t required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to \"merge\" X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)\n• As in #1, the attacker chooses an object ID X to steal. The victim sends an object Y that the attacker already has, and the attacker falsely claims to have X and not Y, so the victim sends Y as a delta against X. The delta reveals regions of X that are similar to Y to the attacker.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 2762
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Everything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there:\n\nThis option controls whether git fetch (and the underlying fetch in git pull) will recursively fetch into populated submodules. This option can be set either to a boolean value or to on-demand. Setting it to a boolean changes the behavior of fetch and pull to recurse unconditionally into submodules when set to true or to not recurse at all when set to false. When set to on-demand, fetch and pull will only recurse into a populated submodule when its superproject retrieves a commit that updates the submodule’s reference. Defaults to on-demand, or to the value of submodule.recurse if set.\n\nIf it is set to true, git-fetch-pack will check all fetched objects. See transfer.fsckObjects for what’s checked. Defaults to false. If not set, the value of transfer.fsckObjects is used instead.\n\nActs like fsck.<msg-id>, but is used by git-fetch-pack[1] instead of git-fsck[1]. See the fsck.<msg-id> documentation for details.\n\nActs like fsck.skipList, but is used by git-fetch-pack[1] instead of git-fsck[1]. See the fsck.skipList documentation for details.\n\nIf the number of objects fetched over the Git native transfer is below this limit, then the objects will be unpacked into loose object files. However if the number of received objects equals or exceeds this limit then the received pack will be stored as a pack, after adding any missing delta bases. Storing the pack from a push can make the push operation complete faster, especially on slow filesystems. If not set, the value of transfer.unpackLimit is used instead.\n\nIf true, fetch will automatically behave as if the --prune option was given on the command line. See also remote.<name>.prune and the PRUNING section of git-fetch[1].\n\nIf true, fetch will automatically behave as if the refs/tags/*:refs/tags/* refspec was provided when pruning, if not set already. This allows for setting both this option and fetch.prune to maintain a 1=1 mapping to upstream refs. See also remote.<name>.pruneTags and the PRUNING section of git-fetch[1].\n\nIf true, fetch will attempt to update all available remotes. This behavior can be overridden by passing --no-all or by explicitly specifying one or more remote(s) to fetch from. Defaults to false.\n\nControl how ref update status is printed. Valid values are full and compact. Default value is full. See the OUTPUT section in git-fetch[1] for details.\n\nControl how information about the commits in the local repository is sent when negotiating the contents of the packfile to be sent by the server. Set to \"consecutive\" to use an algorithm that walks over consecutive commits checking each one. Set to \"skipping\" to use an algorithm that skips commits in an effort to converge faster, but may result in a larger-than-necessary packfile; or set to \"noop\" to not send any information at all, which will almost certainly result in a larger-than-necessary packfile, but will skip the negotiation step. Set to \"default\" to override settings made previously and use the default behaviour. The default is normally \"consecutive\", but if feature.experimental is true, then the default is \"skipping\". Unknown values will cause git fetch to error out.\n\nSee also the --negotiate-only and --negotiation-tip options to git-fetch[1].\n\nSet to false to enable --no-show-forced-updates in git-fetch[1] and git-pull[1] commands. Defaults to true.\n\nSpecifies the maximal number of fetch operations to be run in parallel at a time (submodules, or remotes when the --multiple option of git-fetch[1] is in effect).\n\nA value of 0 will give some reasonable default. If unset, it defaults to 1.\n\nFor submodules, this setting can be overridden using the submodule.fetchJobs config setting.\n\nSet to true to write a commit-graph after every git fetch command that downloads a pack-file from a remote. Using the --split option, most executions will create a very small commit-graph file on top of the existing commit-graph file(s). Occasionally, these files will merge and the write may take longer. Having an updated commit-graph file helps performance of many Git commands, including git merge-base, git push -f, and git log --graph. Defaults to false.\n\nThis value stores a URI for downloading Git object data from a bundle URI before performing an incremental fetch from the origin Git server. This is similar to how the --bundle-uri option behaves in git-clone[1]. git clone --bundle-uri will set the fetch.bundleURI value if the supplied bundle URI contains a bundle list that is organized for incremental fetches.\n\nIf you modify this value and your repository has a fetch.bundleCreationToken value, then remove that fetch.bundleCreationToken value before fetching from the new bundle URI.\n\nWhen using fetch.bundleURI to fetch incrementally from a bundle list that uses the \"creationToken\" heuristic, this config value stores the maximum creationToken value of the downloaded bundles. This value is used to prevent downloading bundles in the future if the advertised creationToken is not strictly larger than this value.\n\nThe creation token values are chosen by the provider serving the specific bundle URI. If you modify the URI at fetch.bundleURI, then be sure to remove the value for the fetch.bundleCreationToken value before fetching.\n\n**fetch.recurseSubmodules**: This option controls whether git fetch (and the underlying fetch in git pull) will recursively fetch into populated submodules. This option can be set either to a boolean value or to on-demand. Setting it to a boolean changes the behavior of fetch and pull to recurse unconditionally into submodules when set to true or to not recurse at all when set to false. When set to on-demand, fetch and pull will only recurse into a populated submodule when its superproject retrieves a commit that updates the submodule’s reference. Defaults to on-demand, or to the value of submodule.recurse if set.\n**fetch.fsckObjects**: If it is set to true, git-fetch-pack will check all fetched objects. See transfer.fsckObjects for what’s checked. Defaults to false. If not set, the value of transfer.fsckObjects is used instead.\n**fetch.fsck.<msg-id>**: Acts like fsck.<msg-id>, but is used by git-fetch-pack[1] instead of git-fsck[1]. See the fsck.<msg-id> documentation for details.\n**fetch.fsck.skipList**: Acts like fsck.skipList, but is used by git-fetch-pack[1] instead of git-fsck[1]. See the fsck.skipList documentation for details.\n**fetch.unpackLimit**: If the number of objects fetched over the Git native transfer is below this limit, then the objects will be unpacked into loose object files. However if the number of received objects equals or exceeds this limit then the received pack will be stored as a pack, after adding any missing delta bases. Storing the pack from a push can make the push operation complete faster, especially on slow filesystems. If not set, the value of transfer.unpackLimit is used instead.\n**fetch.prune**: If true, fetch will automatically behave as if the --prune option was given on the command line. See also remote.<name>.prune and the PRUNING section of git-fetch[1].\n**fetch.pruneTags**: If true, fetch will automatically behave as if the refs/tags/*:refs/tags/* refspec was provided when pruning, if not set already. This allows for setting both this option and fetch.prune to maintain a 1=1 mapping to upstream refs. See also remote.<name>.pruneTags and the PRUNING section of git-fetch[1].\n**fetch.all**: If true, fetch will attempt to update all available remotes. This behavior can be overridden by passing --no-all or by explicitly specifying one or more remote(s) to fetch from. Defaults to false.\n**fetch.output**: Control how ref update status is printed. Valid values are full and compact. Default value is full. See the OUTPUT section in git-fetch[1] for details.\n**fetch.negotiationAlgorithm**: Control how information about the commits in the local repository is sent when negotiating the contents of the packfile to be sent by the server. Set to \"consecutive\" to use an algorithm that walks over consecutive commits checking each one. Set to \"skipping\" to use an algorithm that skips commits in an effort to converge faster, but may result in a larger-than-necessary packfile; or set to \"noop\" to not send any information at all, which will almost certainly result in a larger-than-necessary packfile, but will skip the negotiation step. Set to \"default\" to override settings made previously and use the default behaviour. The default is normally \"consecutive\", but if feature.experimental is true, then the default is \"skipping\". Unknown values will cause git fetch to error out. See also the --negotiate-only and --negotiation-tip options to git-fetch[1].\n**fetch.showForcedUpdates**: Set to false to enable --no-show-forced-updates in git-fetch[1] and git-pull[1] commands. Defaults to true.\n**fetch.parallel**: Specifies the maximal number of fetch operations to be run in parallel at a time (submodules, or remotes when the --multiple option of git-fetch[1] is in effect). A value of 0 will give some reasonable default. If unset, it defaults to 1. For submodules, this setting can be overridden using the submodule.fetchJobs config setting.\n**fetch.writeCommitGraph**: Set to true to write a commit-graph after every git fetch command that downloads a pack-file from a remote. Using the --split option, most executions will create a very small commit-graph file on top of the existing commit-graph file(s). Occasionally, these files will merge and the write may take longer. Having an updated commit-graph file helps performance of many Git commands, including git merge-base, git push -f, and git log --graph. Defaults to false.\n**fetch.bundleURI**: This value stores a URI for downloading Git object data from a bundle URI before performing an incremental fetch from the origin Git server. This is similar to how the --bundle-uri option behaves in git-clone[1]. git clone --bundle-uri will set the fetch.bundleURI value if the supplied bundle URI contains a bundle list that is organized for incremental fetches. If you modify this value and your repository has a fetch.bundleCreationToken value, then remove that fetch.bundleCreationToken value before fetching from the new bundle URI.\n**fetch.bundleCreationToken**: When using fetch.bundleURI to fetch incrementally from a bundle list that uses the \"creationToken\" heuristic, this config value stores the maximum creationToken value of the downloaded bundles. This value is used to prevent downloading bundles in the future if the advertised creationToken is not strictly larger than this value. The creation token values are chosen by the provider serving the specific bundle URI. If you modify the URI at fetch.bundleURI, then be sure to remove the value for the fetch.bundleCreationToken value before fetching.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 21,
          "content_length": 10915
        }
      },
      {
        "header": "BUGS",
        "content": "Using --recurse-submodules can only fetch new commits in submodules that are present locally e.g. in $GIT_DIR/modules/. If the upstream adds a new submodule, that submodule cannot be fetched until it is cloned e.g. by git submodule update. This is expected to be fixed in a future Git version.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 293
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-fetch",
    "doc_type": "git",
    "total_sections": 16
  },
  {
    "title": "Git",
    "summary": "NAME git-format-patch - Prepare patches for e-mail submission\n\ngit-format-patch - Prepare patches for e-mail submission",
    "sections": [
      {
        "header": "NAME",
        "content": "git-format-patch - Prepare patches for e-mail submission",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 56
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Prepare each non-merge commit with its \"patch\" in one \"message\" per commit, formatted to resemble a UNIX mailbox. The output of this command is convenient for e-mail submission or for use with git am.\n\nA \"message\" generated by the command consists of three parts:\n\nA brief metadata header that begins with From <commit> with a fixed Mon Sep 17 00:00:00 2001 datestamp to help programs like \"file(1)\" to recognize that the file is an output from this command, fields that record the author identity, the author date, and the title of the change (taken from the first paragraph of the commit log message).\n\nThe second and subsequent paragraphs of the commit log message.\n\nThe \"patch\", which is the \"diff -p --stat\" output (see git-diff[1]) between the commit and its parent.\n\nThe log message and the patch are separated by a line with a three-dash line.\n\nThere are two ways to specify which commits to operate on.\n\nA single commit, <since>, specifies that the commits leading to the tip of the current branch that are not in the history that leads to the <since> to be output.\n\nGeneric <revision-range> expression (see \"SPECIFYING REVISIONS\" section in gitrevisions[7]) means the commits in the specified range.\n\nThe first rule takes precedence in the case of a single <commit>. To apply the second rule, i.e., format everything since the beginning of history up until <commit>, use the --root option: git format-patch --root <commit>. If you want to format only <commit> itself, you can do this with git format-patch -1 <commit>.\n\nBy default, each output file is numbered sequentially from 1, and uses the first line of the commit message (massaged for pathname safety) as the filename. With the --numbered-files option, the output file names will only be numbers, without the first line of the commit appended. The names of the output files are printed to standard output, unless the --stdout option is specified.\n\nIf -o is specified, output files are created in <dir>. Otherwise they are created in the current working directory. The default path can be set with the format.outputDirectory configuration option. The -o option takes precedence over format.outputDirectory. To store patches in the current working directory even when format.outputDirectory points elsewhere, use -o .. All directory components will be created.\n\nBy default, the subject of a single patch is \"[PATCH] \" followed by the concatenation of lines from the commit message up to the first blank line (see the DISCUSSION section of git-commit[1]).\n\nWhen multiple patches are output, the subject prefix will instead be \"[PATCH n/m] \". To force 1/1 to be added for a single patch, use -n. To omit patch numbers from the subject, use -N.\n\nIf given --thread, git-format-patch will generate In-Reply-To and References headers to make the second and subsequent patch mails appear as replies to the first mail; this also generates a Message-ID header to reference.\n\n• A brief metadata header that begins with From <commit> with a fixed Mon Sep 17 00:00:00 2001 datestamp to help programs like \"file(1)\" to recognize that the file is an output from this command, fields that record the author identity, the author date, and the title of the change (taken from the first paragraph of the commit log message).\n• The second and subsequent paragraphs of the commit log message.\n• The \"patch\", which is the \"diff -p --stat\" output (see git-diff[1]) between the commit and its parent.\n\n• A single commit, <since>, specifies that the commits leading to the tip of the current branch that are not in the history that leads to the <since> to be output.\n• Generic <revision-range> expression (see \"SPECIFYING REVISIONS\" section in gitrevisions[7]) means the commits in the specified range.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 15,
          "content_length": 3743
        }
      },
      {
        "header": "OPTIONS",
        "content": "Generate plain patches without any diffstats.\n\nGenerate diffs with <n> lines of context instead of the usual three.\n\nOutput to a specific file instead of stdout.\n\nSpecify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively.\n\nEnable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.\n\nDisable the indent heuristic.\n\nSpend extra time to make sure the smallest possible diff is produced.\n\nGenerate a diff using the \"patience diff\" algorithm.\n\nGenerate a diff using the \"histogram diff\" algorithm.\n\nGenerate a diff using the \"anchored diff\" algorithm.\n\nThis option may be specified more than once.\n\nIf a line exists in both the source and destination, exists only once, and starts with <text>, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the \"patience diff\" algorithm internally.\n\nChoose a diff algorithm. The variants are as follows:\n\nThe basic greedy diff algorithm. Currently, this is the default.\n\nSpend extra time to make sure the smallest possible diff is produced.\n\nUse \"patience diff\" algorithm when generating patches.\n\nThis algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n\nFor instance, if you configured the diff.algorithm variable to a non-default value and want to use the default one, then you have to use --diff-algorithm=default option.\n\nGenerate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by <width>. The width of the filename part can be limited by giving another width <name-width> after a comma or by setting diff.statNameWidth=<name-width>. The width of the graph part can be limited by using --stat-graph-width=<graph-width> or by setting diff.statGraphWidth=<graph-width>. Using --stat or --stat-graph-width affects all commands generating a stat graph, while setting diff.statNameWidth or diff.statGraphWidth does not affect git format-patch. By giving a third parameter <count>, you can limit the output to the first <count> lines, followed by ... if there are more.\n\nThese parameters can also be set individually with --stat-width=<width>, --stat-name-width=<name-width> and --stat-count=<count>.\n\nOutput a condensed summary of extended header information such as file creations or deletions (\"new\" or \"gone\", optionally +l if it’s a symlink) and mode changes (+x or -x for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies --stat.\n\nSimilar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly. For binary files, outputs two - instead of saying 0 0.\n\nOutput only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines.\n\nOutput the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config[1]). The following parameters are available:\n\nCompute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n\nCompute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n\nCompute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n\nCount changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n\nAn integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n\nExample: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative.\n\nSynonym for --dirstat=cumulative.\n\nSynonym for --dirstat=files,<param>,....\n\nOutput a condensed summary of extended header information such as creations, renames and mode changes.\n\nTurn off rename detection, even when the configuration file gives the default to do so.\n\nWhether to use empty blobs as rename source.\n\nInstead of the first handful of characters, show the full pre- and post-image blob object names on the \"index\" line when generating patch format output.\n\nIn addition to --full-index, output a binary diff that can be applied with git-apply.\n\nInstead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. In diff-patch output format, --full-index takes higher precedence, i.e. if --full-index is specified, full blob names will be shown regardless of --abbrev. Non default number of digits can be specified with --abbrev=<n>.\n\nBreak complete rewrite changes into pairs of delete and create. This serves two purposes:\n\nIt affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number <m> controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).\n\nWhen used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number <n> controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file.\n\nDetect renames. If <n> is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed. Without a % sign, the number is to be read as a fraction, with a decimal point before it. I.e., -M5 becomes 0.5, and is thus the same as -M50%. Similarly, -M05 is the same as -M5%. To limit detection to exact renames, use -M100%. The default similarity index is 50%.\n\nDetect copies as well as renames. See also --find-copies-harder. If <n> is specified, it has the same meaning as for -M<n>.\n\nFor performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one -C option has the same effect.\n\nOmit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.\n\nWhen used together with -B, omit also the preimage in the deletion part of a delete/create pair.\n\nThe -M and -C options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources. (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.) For N sources and destinations, this exhaustive check is O(N^2). This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number. Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited.\n\nControl the order in which files appear in the output. This overrides the diff.orderFile configuration variable (see git-config[1]). To cancel diff.orderFile, use -O/dev/null.\n\nThe output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.\n\n<orderfile> is parsed as follows:\n\nBlank lines are ignored, so they can be used as separators for readability.\n\nLines starting with a hash (\"#\") are ignored, so they can be used for comments. Add a backslash (\"\\\") to the beginning of the pattern if it starts with a hash.\n\nEach other line contains a single pattern.\n\nPatterns have the same syntax and semantics as patterns used for fnmatch(3) without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern. For example, the pattern \"foo*bar\" matches \"fooasdfbar\" and \"foo/bar/baz/asdf\" but not \"foobarx\".\n\nDiscard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to). These options were invented primarily for the use of the git difftool command, and may not be very useful otherwise.\n\nWhen run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative.\n\nTreat all files as text.\n\nIgnore carriage-return at the end of line when doing a comparison.\n\nIgnore changes in whitespace at EOL.\n\nIgnore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n\nIgnore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n\nIgnore changes whose lines are all blank.\n\nIgnore changes whose all lines match <regex>. This option may be specified more than once.\n\nShow the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n\nShow whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see \"Defining a custom hunk-header\" in gitattributes[5]).\n\nAllow an external diff helper to be executed. If you set an external diff driver with gitattributes[5], you need to use this option with git-log[1] and friends.\n\nDisallow external diff drivers.\n\nAllow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes[5] for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff[1] and git-log[1], but not for git-format-patch[1] or diff plumbing commands.\n\nIgnore changes to submodules in the diff generation. all is the default. Using none will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config[1] or gitmodules[5]. When untracked is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using dirty ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using all hides all changes to submodules.\n\nShow the given source <prefix> instead of \"a/\".\n\nShow the given destination <prefix> instead of \"b/\".\n\nDo not show any source or destination prefix.\n\nUse the default source and destination prefixes (\"a/\" and \"b/\"). This overrides configuration variables such as diff.noprefix, diff.srcPrefix, diff.dstPrefix, and diff.mnemonicPrefix (see git-config[1]).\n\nPrepend an additional <prefix> to every line of output.\n\nBy default entries added by git add -N appear as an existing empty file in git diff and a new file in git diff --cached. This option makes the entry appear as a new file in git diff and non-existent in git diff --cached. This option could be reverted with --ita-visible-in-index. Both options are experimental and could be removed in future.\n\nFor more detailed explanation on these common options, see also gitdiffcore[7].\n\nPrepare patches from the topmost <n> commits.\n\nUse <dir> to store the resulting files, instead of the current working directory.\n\nName output in [PATCH n/m] format, even with a single patch.\n\nName output in [PATCH] format.\n\nStart numbering the patches at <n> instead of 1.\n\nOutput file names will be a simple number sequence without the default first line of the commit appended.\n\nDo not strip/add [PATCH] from the first line of the commit log message.\n\nAdd a Signed-off-by trailer to the commit message, using the committer identity of yourself. See the signoff option in git-commit[1] for more information.\n\nPrint all commits to the standard output in mbox format, instead of creating a file for each one.\n\nCreate multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with Content-Disposition: attachment.\n\nDisable the creation of an attachment, overriding the configuration setting.\n\nCreate multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with Content-Disposition: inline.\n\nControls addition of In-Reply-To and References headers to make the second and subsequent mails appear as replies to the first. Also controls generation of the Message-ID header to reference.\n\nThe optional <style> argument can be either shallow or deep. shallow threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the --in-reply-to, and the first patch mail, in this order. deep threading makes every mail a reply to the previous one.\n\nThe default is --no-thread, unless the format.thread configuration is set. --thread without an argument is equivalent to --thread=shallow.\n\nBeware that the default for git send-email is to thread emails itself. If you want git format-patch to take care of threading, you will want to ensure that threading is disabled for git send-email.\n\nMake the first mail (or all the mails with --no-thread) appear as a reply to the given <message-id>, which avoids breaking threads to provide a new patch series.\n\nDo not include a patch that matches a commit in <until>..<since>. This will examine all patches reachable from <since> but not from <until> and compare them with the patches being generated, and any patch that matches is ignored.\n\nInclude patches for commits that do not introduce any change, which are omitted by default.\n\nControls which parts of the cover letter will be automatically populated using the branch’s description.\n\nIf <mode> is message or default, the cover letter subject will be populated with placeholder text. The body of the cover letter will be populated with the branch’s description. This is the default mode when no configuration nor command line option is specified.\n\nIf <mode> is subject, the first paragraph of the branch description will populate the cover letter subject. The remainder of the description will populate the body of the cover letter.\n\nIf <mode> is auto, if the first paragraph of the branch description is greater than 100 bytes, then the mode will be message, otherwise subject will be used.\n\nIf <mode> is none, both the cover letter subject and body will be populated with placeholder text.\n\nUse the contents of <file> instead of the branch’s description for generating the cover letter.\n\nInstead of the standard [PATCH] prefix in the subject line, instead use [<subject-prefix>]. This can be used to name a patch series, and can be combined with the --numbered option.\n\nThe configuration variable format.subjectPrefix may also be used to configure a subject prefix to apply to a given repository for all patches. This is often useful on mailing lists which receive patches for several repositories and can be used to disambiguate the patches (with a value of e.g. \"PATCH my-project\").\n\nInstead of the standard 64 bytes, chomp the generated output filenames at around <n> bytes (too short a value will be silently raised to a reasonable length). Defaults to the value of the format.filenameMaxLength configuration variable, or 64 if unconfigured.\n\nPrepends the string <rfc> (defaults to \"RFC\") to the subject prefix. As the subject prefix defaults to \"PATCH\", you’ll get \"RFC PATCH\" by default.\n\nRFC means \"Request For Comments\"; use this when sending an experimental patch for discussion rather than application. \"--rfc=WIP\" may also be a useful way to indicate that a patch is not complete yet (\"WIP\" stands for \"Work In Progress\").\n\nIf the convention of the receiving community for a particular extra string is to have it after the subject prefix, the string <rfc> can be prefixed with a dash (\"-\") to signal that the rest of the <rfc> string should be appended to the subject prefix instead, e.g., --rfc='-(WIP) results in \"PATCH (WIP)\".\n\nMark the series as the <n>-th iteration of the topic. The output filenames have v<n> prepended to them, and the subject prefix (\"PATCH\" by default, but configurable via the --subject-prefix option) has ` v<n>` appended to it. E.g. --reroll-count=4 may produce v4-0001-add-makefile.patch file that has \"Subject: [PATCH v4 1/20] Add makefile\" in it. <n> does not have to be an integer (e.g. \"--reroll-count=4.4\", or \"--reroll-count=4rev2\" are allowed), but the downside of using such a reroll-count is that the range-diff/interdiff with the previous version does not state exactly which version the new iteration is compared against.\n\nAdd a To: header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form --no-to discards all To: headers added so far (from config or command line).\n\nAdd a Cc: header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form --no-cc discards all Cc: headers added so far (from config or command line).\n\nUse ident in the From: header of each commit email. If the author ident of the commit is not textually identical to the provided ident, place a From: header in the body of the message with the original author. If no ident is given, use the committer ident.\n\nNote that this option is only useful if you are actually sending the emails and want to identify yourself as the sender, but retain the original author (and git am will correctly pick up the in-body header). Note also that git send-email already handles this transformation for you, and this option should not be used if you are feeding the result to git send-email.\n\nWith the e-mail sender specified via the --from option, by default, an in-body \"From:\" to identify the real author of the commit is added at the top of the commit log message if the sender is different from the author. With this option, the in-body \"From:\" is added even when the sender and the author have the same name and address, which may help if the mailing list software mangles the sender’s identity. Defaults to the value of the format.forceInBodyFrom configuration variable.\n\nAdd an arbitrary header to the email headers. This is in addition to any configured headers, and may be used multiple times. For example, --add-header=\"Organization: git-foo\". The negated form --no-add-header discards all (To:, Cc:, and custom) headers added so far from config or command line.\n\nIn addition to the patches, generate a cover letter file containing the branch description, shortlog and the overall diffstat. You can fill in a description in the file before sending it out.\n\nEncode email headers that have non-ASCII characters with \"Q-encoding\" (described in RFC 2047), instead of outputting the headers verbatim. Defaults to the value of the format.encodeEmailHeaders configuration variable.\n\nAs a reviewer aid, insert an interdiff into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. previous is a single revision naming the tip of the previous series which shares a common base with the series being formatted (for example git format-patch --cover-letter --interdiff=feature/v1 -3 feature/v2).\n\nAs a reviewer aid, insert a range-diff (see git-range-diff[1]) into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. previous can be a single revision naming the tip of the previous series if it shares a common base with the series being formatted (for example git format-patch --cover-letter --range-diff=feature/v1 -3 feature/v2), or a revision range if the two versions of the series are disjoint (for example git format-patch --cover-letter --range-diff=feature/v1~3..feature/v1 -3 feature/v2).\n\nNote that diff options passed to the command affect how the primary product of format-patch is generated, and they are not passed to the underlying range-diff machinery used to generate the cover-letter material (this may change in the future).\n\nUsed with --range-diff, tweak the heuristic which matches up commits between the previous and current series of patches by adjusting the creation/deletion cost fudge factor. See git-range-diff[1]) for details.\n\nDefaults to 999 (the git-range-diff[1] uses 60), as the use case is to show comparison with an older iteration of the same topic and the tool should find more correspondence between the two sets of patches.\n\nAppend the notes (see git-notes[1]) for the commit after the three-dash line.\n\nThe expected use case of this is to write supporting explanation for the commit that does not belong to the commit log message proper, and include it with the patch submission. While one can simply write these explanations after format-patch has run but before sending, keeping them as Git notes allows them to be maintained between versions of the patch series (but see the discussion of the notes.rewrite configuration options in git-notes[1] to use this workflow).\n\nThe default is --no-notes, unless the format.notes configuration is set.\n\nAdd a signature to each message produced. Per RFC 3676 the signature is separated from the body by a line with '-- ' on it. If the signature option is omitted the signature defaults to the Git version number.\n\nWorks just like --signature except the signature is read from a file.\n\nInstead of using .patch as the suffix for generated filenames, use specified suffix. A common alternative is --suffix=.txt. Leaving this empty will remove the .patch suffix.\n\nNote that the leading character does not have to be a dot; for example, you can use --suffix=-patch to get 0001-description-of-my-change-patch.\n\nDo not print the names of the generated files to standard output.\n\nDo not output contents of changes in binary files, instead display a notice that those files changed. Patches generated using this option cannot be applied properly, but they are still useful for code review.\n\nOutput an all-zero hash in each patch’s From header instead of the hash of the commit.\n\nRecord the base tree information to identify the state the patch series applies to. See the BASE TREE INFORMATION section below for details. If <commit> is \"auto\", a base commit is automatically chosen. The --no-base option overrides a format.useAutoBase configuration.\n\nTreat the revision argument as a <revision-range>, even if it is just a single commit (that would normally be treated as a <since>). Note that root commits included in the specified range are always formatted as creation patches, independently of this flag.\n\nShow progress reports on stderr as patches are generated.\n\n• Blank lines are ignored, so they can be used as separators for readability.\n• Lines starting with a hash (\"#\") are ignored, so they can be used for comments. Add a backslash (\"\\\") to the beginning of the pattern if it starts with a hash.\n• Each other line contains a single pattern.\n\n**-p**: Generate plain patches without any diffstats.\n**--no-stat**: Generate diffs with <n> lines of context instead of the usual three.\n**-U<n>**: Output to a specific file instead of stdout.\n**--unified=<n>**: Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively.\n**--output=<file>**: Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.\n**--output-indicator-new=<char>**: Disable the indent heuristic.\n**--output-indicator-old=<char>**: Spend extra time to make sure the smallest possible diff is produced.\n**--output-indicator-context=<char>**: Generate a diff using the \"patience diff\" algorithm.\n**--indent-heuristic**: Generate a diff using the \"histogram diff\" algorithm.\n**--no-indent-heuristic**: Generate a diff using the \"anchored diff\" algorithm. This option may be specified more than once. If a line exists in both the source and destination, exists only once, and starts with <text>, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the \"patience diff\" algorithm internally.\n**--minimal**: Choose a diff algorithm. The variants are as follows: default myers The basic greedy diff algorithm. Currently, this is the default. minimal Spend extra time to make sure the smallest possible diff is produced. patience Use \"patience diff\" algorithm when generating patches. histogram This algorithm extends the patience algorithm to \"support low-occurrence common elements\". For instance, if you configured the diff.algorithm variable to a non-default value and want to use the default one, then you have to use --diff-algorithm=default option.\n**--patience**: The basic greedy diff algorithm. Currently, this is the default.\n**--histogram**: Spend extra time to make sure the smallest possible diff is produced.\n**--anchored=<text>**: Use \"patience diff\" algorithm when generating patches.\n**--diff-algorithm=(patience|minimal|histogram|myers)**: This algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n**default**: Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by <width>. The width of the filename part can be limited by giving another width <name-width> after a comma or by setting diff.statNameWidth=<name-width>. The width of the graph part can be limited by using --stat-graph-width=<graph-width> or by setting diff.statGraphWidth=<graph-width>. Using --stat or --stat-graph-width affects all commands generating a stat graph, while setting diff.statNameWidth or diff.statGraphWidth does not affect git format-patch. By giving a third parameter <count>, you can limit the output to the first <count> lines, followed by ... if there are more. These parameters can also be set individually with --stat-width=<width>, --stat-name-width=<name-width> and --stat-count=<count>.\n**myers**: Output a condensed summary of extended header information such as file creations or deletions (\"new\" or \"gone\", optionally +l if it’s a symlink) and mode changes (+x or -x for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies --stat.\n**minimal**: Similar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly. For binary files, outputs two - instead of saying 0 0.\n**patience**: Output only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines.\n**histogram**: Output the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config[1]). The following parameters are available: changes Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given. lines Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options. files Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all. cumulative Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter. <limit> An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output. Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative.\n**--stat[=<width>[,<name-width>[,<count>]]]**: Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n**--compact-summary**: Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n**--numstat**: Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n**--shortstat**: Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n**-X [<param>,...]**: An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n**--dirstat[=<param>,...]**: Synonym for --dirstat=cumulative.\n**changes**: Synonym for --dirstat=files,<param>,....\n**lines**: Output a condensed summary of extended header information such as creations, renames and mode changes.\n**files**: Turn off rename detection, even when the configuration file gives the default to do so.\n**cumulative**: Whether to use empty blobs as rename source.\n**<limit>**: Instead of the first handful of characters, show the full pre- and post-image blob object names on the \"index\" line when generating patch format output.\n**--cumulative**: In addition to --full-index, output a binary diff that can be applied with git-apply.\n**--dirstat-by-file[=<param>,...]**: Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. In diff-patch output format, --full-index takes higher precedence, i.e. if --full-index is specified, full blob names will be shown regardless of --abbrev. Non default number of digits can be specified with --abbrev=<n>.\n**--summary**: Break complete rewrite changes into pairs of delete and create. This serves two purposes: It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number <m> controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines). When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number <n> controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file.\n**--no-renames**: Detect renames. If <n> is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed. Without a % sign, the number is to be read as a fraction, with a decimal point before it. I.e., -M5 becomes 0.5, and is thus the same as -M50%. Similarly, -M05 is the same as -M5%. To limit detection to exact renames, use -M100%. The default similarity index is 50%.\n**--[no-]rename-empty**: Detect copies as well as renames. See also --find-copies-harder. If <n> is specified, it has the same meaning as for -M<n>.\n**--full-index**: For performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one -C option has the same effect.\n**--binary**: Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option. When used together with -B, omit also the preimage in the deletion part of a delete/create pair.\n**--abbrev[=<n>]**: The -M and -C options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources. (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.) For N sources and destinations, this exhaustive check is O(N^2). This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number. Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited.\n**-B[<n>][/<m>]**: Control the order in which files appear in the output. This overrides the diff.orderFile configuration variable (see git-config[1]). To cancel diff.orderFile, use -O/dev/null. The output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order. <orderfile> is parsed as follows: Blank lines are ignored, so they can be used as separators for readability. Lines starting with a hash (\"#\") are ignored, so they can be used for comments. Add a backslash (\"\\\") to the beginning of the pattern if it starts with a hash. Each other line contains a single pattern. Patterns have the same syntax and semantics as patterns used for fnmatch(3) without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern. For example, the pattern \"foo*bar\" matches \"fooasdfbar\" and \"foo/bar/baz/asdf\" but not \"foobarx\".\n**--break-rewrites[=[<n>][/<m>]]**: Discard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to). These options were invented primarily for the use of the git difftool command, and may not be very useful otherwise.\n**-M[<n>]**: When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative.\n**--find-renames[=<n>]**: Treat all files as text.\n**-C[<n>]**: Ignore carriage-return at the end of line when doing a comparison.\n**--find-copies[=<n>]**: Ignore changes in whitespace at EOL.\n**--find-copies-harder**: Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n**-D**: Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n**--irreversible-delete**: Ignore changes whose lines are all blank.\n**-l<num>**: Ignore changes whose all lines match <regex>. This option may be specified more than once.\n**-O<orderfile>**: Show the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n**--skip-to=<file>**: Show whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see \"Defining a custom hunk-header\" in gitattributes[5]).\n**--rotate-to=<file>**: Allow an external diff helper to be executed. If you set an external diff driver with gitattributes[5], you need to use this option with git-log[1] and friends.\n**--relative[=<path>]**: Disallow external diff drivers.\n**--no-relative**: Allow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes[5] for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff[1] and git-log[1], but not for git-format-patch[1] or diff plumbing commands.\n**-a**: Ignore changes to submodules in the diff generation. all is the default. Using none will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config[1] or gitmodules[5]. When untracked is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using dirty ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using all hides all changes to submodules.\n**--text**: Show the given source <prefix> instead of \"a/\".\n**--ignore-cr-at-eol**: Show the given destination <prefix> instead of \"b/\".\n**--ignore-space-at-eol**: Do not show any source or destination prefix.\n**-b**: Use the default source and destination prefixes (\"a/\" and \"b/\"). This overrides configuration variables such as diff.noprefix, diff.srcPrefix, diff.dstPrefix, and diff.mnemonicPrefix (see git-config[1]).\n**--ignore-space-change**: Prepend an additional <prefix> to every line of output.\n**-w**: By default entries added by git add -N appear as an existing empty file in git diff and a new file in git diff --cached. This option makes the entry appear as a new file in git diff and non-existent in git diff --cached. This option could be reverted with --ita-visible-in-index. Both options are experimental and could be removed in future.\n**default**: The basic greedy diff algorithm. Currently, this is the default.\n**myers**: Spend extra time to make sure the smallest possible diff is produced.\n**minimal**: Use \"patience diff\" algorithm when generating patches.\n**patience**: This algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n**changes**: Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n**lines**: Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n**files**: Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n**cumulative**: Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n**<limit>**: An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n**-<n>**: Prepare patches from the topmost <n> commits.\n**-o <dir>**: Use <dir> to store the resulting files, instead of the current working directory.\n**--output-directory <dir>**: Name output in [PATCH n/m] format, even with a single patch.\n**-n**: Name output in [PATCH] format.\n**--numbered**: Start numbering the patches at <n> instead of 1.\n**-N**: Output file names will be a simple number sequence without the default first line of the commit appended.\n**--no-numbered**: Do not strip/add [PATCH] from the first line of the commit log message.\n**--start-number <n>**: Add a Signed-off-by trailer to the commit message, using the committer identity of yourself. See the signoff option in git-commit[1] for more information.\n**--numbered-files**: Print all commits to the standard output in mbox format, instead of creating a file for each one.\n**-k**: Create multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with Content-Disposition: attachment.\n**--keep-subject**: Disable the creation of an attachment, overriding the configuration setting.\n**-s**: Create multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with Content-Disposition: inline.\n**--signoff**: Controls addition of In-Reply-To and References headers to make the second and subsequent mails appear as replies to the first. Also controls generation of the Message-ID header to reference. The optional <style> argument can be either shallow or deep. shallow threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the --in-reply-to, and the first patch mail, in this order. deep threading makes every mail a reply to the previous one. The default is --no-thread, unless the format.thread configuration is set. --thread without an argument is equivalent to --thread=shallow. Beware that the default for git send-email is to thread emails itself. If you want git format-patch to take care of threading, you will want to ensure that threading is disabled for git send-email.\n**--stdout**: Make the first mail (or all the mails with --no-thread) appear as a reply to the given <message-id>, which avoids breaking threads to provide a new patch series.\n**--attach[=<boundary>]**: Do not include a patch that matches a commit in <until>..<since>. This will examine all patches reachable from <since> but not from <until> and compare them with the patches being generated, and any patch that matches is ignored.\n**--no-attach**: Include patches for commits that do not introduce any change, which are omitted by default.\n**--inline[=<boundary>]**: Controls which parts of the cover letter will be automatically populated using the branch’s description. If <mode> is message or default, the cover letter subject will be populated with placeholder text. The body of the cover letter will be populated with the branch’s description. This is the default mode when no configuration nor command line option is specified. If <mode> is subject, the first paragraph of the branch description will populate the cover letter subject. The remainder of the description will populate the body of the cover letter. If <mode> is auto, if the first paragraph of the branch description is greater than 100 bytes, then the mode will be message, otherwise subject will be used. If <mode> is none, both the cover letter subject and body will be populated with placeholder text.\n**--thread[=<style>]**: Use the contents of <file> instead of the branch’s description for generating the cover letter.\n**--no-thread**: Instead of the standard [PATCH] prefix in the subject line, instead use [<subject-prefix>]. This can be used to name a patch series, and can be combined with the --numbered option. The configuration variable format.subjectPrefix may also be used to configure a subject prefix to apply to a given repository for all patches. This is often useful on mailing lists which receive patches for several repositories and can be used to disambiguate the patches (with a value of e.g. \"PATCH my-project\").\n**--in-reply-to=<message-id>**: Instead of the standard 64 bytes, chomp the generated output filenames at around <n> bytes (too short a value will be silently raised to a reasonable length). Defaults to the value of the format.filenameMaxLength configuration variable, or 64 if unconfigured.\n**--ignore-if-in-upstream**: Prepends the string <rfc> (defaults to \"RFC\") to the subject prefix. As the subject prefix defaults to \"PATCH\", you’ll get \"RFC PATCH\" by default. RFC means \"Request For Comments\"; use this when sending an experimental patch for discussion rather than application. \"--rfc=WIP\" may also be a useful way to indicate that a patch is not complete yet (\"WIP\" stands for \"Work In Progress\"). If the convention of the receiving community for a particular extra string is to have it after the subject prefix, the string <rfc> can be prefixed with a dash (\"-\") to signal that the rest of the <rfc> string should be appended to the subject prefix instead, e.g., --rfc='-(WIP) results in \"PATCH (WIP)\".\n**--always**: Mark the series as the <n>-th iteration of the topic. The output filenames have v<n> prepended to them, and the subject prefix (\"PATCH\" by default, but configurable via the --subject-prefix option) has ` v<n>` appended to it. E.g. --reroll-count=4 may produce v4-0001-add-makefile.patch file that has \"Subject: [PATCH v4 1/20] Add makefile\" in it. <n> does not have to be an integer (e.g. \"--reroll-count=4.4\", or \"--reroll-count=4rev2\" are allowed), but the downside of using such a reroll-count is that the range-diff/interdiff with the previous version does not state exactly which version the new iteration is compared against.\n**--cover-from-description=<mode>**: Add a To: header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form --no-to discards all To: headers added so far (from config or command line).\n**--description-file=<file>**: Add a Cc: header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form --no-cc discards all Cc: headers added so far (from config or command line).\n**--subject-prefix=<subject-prefix>**: Use ident in the From: header of each commit email. If the author ident of the commit is not textually identical to the provided ident, place a From: header in the body of the message with the original author. If no ident is given, use the committer ident. Note that this option is only useful if you are actually sending the emails and want to identify yourself as the sender, but retain the original author (and git am will correctly pick up the in-body header). Note also that git send-email already handles this transformation for you, and this option should not be used if you are feeding the result to git send-email.\n**--filename-max-length=<n>**: With the e-mail sender specified via the --from option, by default, an in-body \"From:\" to identify the real author of the commit is added at the top of the commit log message if the sender is different from the author. With this option, the in-body \"From:\" is added even when the sender and the author have the same name and address, which may help if the mailing list software mangles the sender’s identity. Defaults to the value of the format.forceInBodyFrom configuration variable.\n**--rfc[=<rfc>]**: Add an arbitrary header to the email headers. This is in addition to any configured headers, and may be used multiple times. For example, --add-header=\"Organization: git-foo\". The negated form --no-add-header discards all (To:, Cc:, and custom) headers added so far from config or command line.\n**-v <n>**: In addition to the patches, generate a cover letter file containing the branch description, shortlog and the overall diffstat. You can fill in a description in the file before sending it out.\n**--reroll-count=<n>**: Encode email headers that have non-ASCII characters with \"Q-encoding\" (described in RFC 2047), instead of outputting the headers verbatim. Defaults to the value of the format.encodeEmailHeaders configuration variable.\n**--to=<email>**: As a reviewer aid, insert an interdiff into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. previous is a single revision naming the tip of the previous series which shares a common base with the series being formatted (for example git format-patch --cover-letter --interdiff=feature/v1 -3 feature/v2).\n**--cc=<email>**: As a reviewer aid, insert a range-diff (see git-range-diff[1]) into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. previous can be a single revision naming the tip of the previous series if it shares a common base with the series being formatted (for example git format-patch --cover-letter --range-diff=feature/v1 -3 feature/v2), or a revision range if the two versions of the series are disjoint (for example git format-patch --cover-letter --range-diff=feature/v1~3..feature/v1 -3 feature/v2). Note that diff options passed to the command affect how the primary product of format-patch is generated, and they are not passed to the underlying range-diff machinery used to generate the cover-letter material (this may change in the future).\n**--from**: Used with --range-diff, tweak the heuristic which matches up commits between the previous and current series of patches by adjusting the creation/deletion cost fudge factor. See git-range-diff[1]) for details. Defaults to 999 (the git-range-diff[1] uses 60), as the use case is to show comparison with an older iteration of the same topic and the tool should find more correspondence between the two sets of patches.\n**--from=<ident>**: Append the notes (see git-notes[1]) for the commit after the three-dash line. The expected use case of this is to write supporting explanation for the commit that does not belong to the commit log message proper, and include it with the patch submission. While one can simply write these explanations after format-patch has run but before sending, keeping them as Git notes allows them to be maintained between versions of the patch series (but see the discussion of the notes.rewrite configuration options in git-notes[1] to use this workflow). The default is --no-notes, unless the format.notes configuration is set.\n**--[no-]force-in-body-from**: Add a signature to each message produced. Per RFC 3676 the signature is separated from the body by a line with '-- ' on it. If the signature option is omitted the signature defaults to the Git version number.\n**--add-header=<header>**: Works just like --signature except the signature is read from a file.\n**--[no-]cover-letter**: Instead of using .patch as the suffix for generated filenames, use specified suffix. A common alternative is --suffix=.txt. Leaving this empty will remove the .patch suffix. Note that the leading character does not have to be a dot; for example, you can use --suffix=-patch to get 0001-description-of-my-change-patch.\n**--encode-email-headers**: Do not print the names of the generated files to standard output.\n**--no-encode-email-headers**: Do not output contents of changes in binary files, instead display a notice that those files changed. Patches generated using this option cannot be applied properly, but they are still useful for code review.\n**--interdiff=<previous>**: Output an all-zero hash in each patch’s From header instead of the hash of the commit.\n**--range-diff=<previous>**: Record the base tree information to identify the state the patch series applies to. See the BASE TREE INFORMATION section below for details. If <commit> is \"auto\", a base commit is automatically chosen. The --no-base option overrides a format.useAutoBase configuration.\n**--creation-factor=<percent>**: Treat the revision argument as a <revision-range>, even if it is just a single commit (that would normally be treated as a <since>). Note that root commits included in the specified range are always formatted as creation patches, independently of this flag.\n**--notes[=<ref>]**: Show progress reports on stderr as patches are generated.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 134,
          "content_length": 57988
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "You can specify extra mail header lines to be added to each message, defaults for the subject prefix and file suffix, number patches when outputting more than one patch, add \"To:\" or \"Cc:\" headers, configure attachments, change the patch output directory, and sign off patches with configuration variables.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n[format]\n\theaders = \"Organization: git-foo\\n\"\n\tsubjectPrefix = CHANGE\n\tsuffix = .txt\n\tnumbered = auto\n\tto = <email>\n\tcc = <email>\n\tattach [ = mime-boundary-string ]\n\tsignOff = true\n\toutputDirectory =<directory>coverLetter = auto\n\tcoverFromDescription = auto\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 306
        }
      },
      {
        "header": "DISCUSSION",
        "content": "The patch produced by git format-patch is in UNIX mailbox format, with a fixed \"magic\" time stamp to indicate that the file is output from format-patch rather than a real mailbox, like so:\n\nTypically it will be placed in a MUA’s drafts folder, edited to add timely commentary that should not go in the changelog after the three dashes, and then sent as a message whose body, in our example, starts with \"arch/arm config files were…\". On the receiving end, readers can save interesting patches in a UNIX mailbox and apply them with git-am[1].\n\nWhen a patch is part of an ongoing discussion, the patch generated by git format-patch can be tweaked to take advantage of the git am --scissors feature. After your response to the discussion comes a line that consists solely of \"-- >8 --\" (scissors and perforation), followed by the patch with unnecessary header fields removed:\n\nWhen sending a patch this way, most often you are sending your own patch, so in addition to the \"From $SHA1 $magic_timestamp\" marker you should omit From: and Date: lines from the patch file. The patch title is likely to be different from the subject of the discussion the patch is in response to, so it is likely that you would want to keep the Subject: line, like the example above.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nFrom 8f72bad1baf19a53459661343e21d6491c3908d3 Mon Sep 17 00:00:00 2001\nFrom: Tony Luck <tony.luck@intel.com>\nDate: Tue, 13 Jul 2010 11:42:54 -0700\nSubject: [PATCH] =?UTF-8?q?[IA64]=20Put=20ia64=20config=20files=20on=20the=20?=\n =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig=20diet?=\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\narch/arm config files were slimmed down using a python script\n(See commit c2330e286f68f1c408b4aa6515ba49d57f05beae comment)\n\nDo the same for ia64 so we can have sleek & trim looking\n...\n```",
          "```bash\n...\n> So we should do such-and-such.\n\nMakes sense to me.  How about this patch?\n\n-- >8 --\nSubject: [IA64] Put ia64 config files on the Uwe Kleine-König diet\n\narch/arm config files were slimmed down using a python script\n...\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1258
        }
      },
      {
        "header": "Checking for patch corruption",
        "content": "Many mailers if not set up properly will corrupt whitespace. Here are two common types of corruption:\n\nEmpty context lines that do not have any whitespace.\n\nNon-empty context lines that have one extra whitespace at the beginning.\n\nOne way to test if your MUA is set up correctly is:\n\nSend the patch to yourself, exactly the way you would, except with To: and Cc: lines that do not contain the list and maintainer address.\n\nSave that patch to a file in UNIX mailbox format. Call it a.patch, say.\n\nIf it does not apply correctly, there can be various reasons.\n\nThe patch itself does not apply cleanly. That is bad but does not have much to do with your MUA. You might want to rebase the patch with git-rebase[1] before regenerating it in this case.\n\nThe MUA corrupted your patch; \"am\" would complain that the patch does not apply. Look in the .git/rebase-apply/ subdirectory and see what patch file contains and check for the common corruption patterns mentioned above.\n\nWhile at it, check the info and final-commit files as well. If what is in final-commit is not exactly what you would want to see in the commit log message, it is very likely that the receiver would end up hand editing the log message when applying your patch. Things like \"Hi, this is my first patch.\\n\" in the patch e-mail should come after the three-dash line that signals the end of the commit message.\n\n• Empty context lines that do not have any whitespace.\n• Non-empty context lines that have one extra whitespace at the beginning.\n\n• Send the patch to yourself, exactly the way you would, except with To: and Cc: lines that do not contain the list and maintainer address.\n• Save that patch to a file in UNIX mailbox format. Call it a.patch, say.\n• Apply it: $ git fetch <project> master:test-apply $ git switch test-apply $ git restore --source=HEAD --staged --worktree :/ $ git am a.patch\n\n• The patch itself does not apply cleanly. That is bad but does not have much to do with your MUA. You might want to rebase the patch with git-rebase[1] before regenerating it in this case.\n• The MUA corrupted your patch; \"am\" would complain that the patch does not apply. Look in the .git/rebase-apply/ subdirectory and see what patch file contains and check for the common corruption patterns mentioned above.\n• While at it, check the info and final-commit files as well. If what is in final-commit is not exactly what you would want to see in the commit log message, it is very likely that the receiver would end up hand editing the log message when applying your patch. Things like \"Hi, this is my first patch.\\n\" in the patch e-mail should come after the three-dash line that signals the end of the commit message.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git fetch <project> master:test-apply\n$ git switch test-apply\n$ git restore --source=HEAD --staged --worktree :/\n$ git am a.patch\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 2685
        }
      },
      {
        "header": "MUA-SPECIFIC HINTS",
        "content": "Here are some hints on how to successfully submit patches inline using various mailers.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 87
        }
      },
      {
        "header": "GMail",
        "content": "GMail does not have any way to turn off line wrapping in the web interface, so it will mangle any emails that you send. You can however use \"git send-email\" and send your patches through the GMail SMTP server, or use any IMAP email client to connect to the google IMAP server and forward the emails through that.\n\nFor hints on using git send-email to send your patches through the GMail SMTP server, see the EXAMPLE section of git-send-email[1].\n\nFor hints on submission using the IMAP interface, see the EXAMPLE section of git-imap-send[1].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 541
        }
      },
      {
        "header": "Thunderbird",
        "content": "By default, Thunderbird will both wrap emails as well as flag them as being format=flowed, both of which will make the resulting email unusable by Git.\n\nThere are three different approaches: use an add-on to turn off line wraps, configure Thunderbird to not mangle patches, or use an external editor to keep Thunderbird from mangling the patches.\n\nInstall the Toggle Line Wrap add-on that is available from https://addons.thunderbird.net/thunderbird/addon/toggle-line-wrap It adds a button \"Line Wrap\" to the composer’s toolbar that you can tick off. Now you can compose the message as you otherwise do (cut + paste, git format-patch | git imap-send, etc), but you have to insert line breaks manually in any text that you type.\n\nAs a bonus feature, the add-on can detect patch text in the composer and warns when line wrapping has not yet been turned off.\n\nThe add-on requires a few tweaks of the advanced configuration (about:config). These are listed on the download page.\n\nConfigure your mail server composition as plain text: Edit…Account Settings…Composition & Addressing, uncheck \"Compose Messages in HTML\".\n\nConfigure your general composition window to not wrap.\n\nIn Thunderbird 2: Edit..Preferences..Composition, wrap plain text messages at 0\n\nIn Thunderbird 3: Edit..Preferences..Advanced..Config Editor. Search for \"mail.wrap_long_lines\". Toggle it to make sure it is set to false. Also, search for \"mailnews.wraplength\" and set the value to 0.\n\nDisable the use of format=flowed: Edit..Preferences..Advanced..Config Editor. Search for \"mailnews.send_plaintext_flowed\". Toggle it to make sure it is set to false.\n\nAfter that is done, you should be able to compose email as you otherwise would (cut + paste, git format-patch | git imap-send, etc), and the patches will not be mangled.\n\nThe following Thunderbird extensions are needed: AboutConfig from https://mjg.github.io/AboutConfig/ and External Editor from https://globs.org/articles.php?lng=en&pg=8\n\nPrepare the patch as a text file using your method of choice.\n\nBefore opening a compose window, use Edit→Account Settings to uncheck the \"Compose messages in HTML format\" setting in the \"Composition & Addressing\" panel of the account to be used to send the patch.\n\nIn the main Thunderbird window, before you open the compose window for the patch, use Tools→about:config to set the following to the indicated values:\n\nOpen a compose window and click the external editor icon.\n\nIn the external editor window, read in the patch file and exit the editor normally.\n\nSide note: it may be possible to do step 2 with about:config and the following settings but no one’s tried yet.\n\nThere is a script in contrib/thunderbird-patch-inline which can help you include patches with Thunderbird in an easy way. To use it, do the steps above and then use the script as the external editor.\n\n• Configure your mail server composition as plain text: Edit…Account Settings…Composition & Addressing, uncheck \"Compose Messages in HTML\".\n• Configure your general composition window to not wrap. In Thunderbird 2: Edit..Preferences..Composition, wrap plain text messages at 0 In Thunderbird 3: Edit..Preferences..Advanced..Config Editor. Search for \"mail.wrap_long_lines\". Toggle it to make sure it is set to false. Also, search for \"mailnews.wraplength\" and set the value to 0.\n• Disable the use of format=flowed: Edit..Preferences..Advanced..Config Editor. Search for \"mailnews.send_plaintext_flowed\". Toggle it to make sure it is set to false.\n\n• Prepare the patch as a text file using your method of choice.\n• Before opening a compose window, use Edit→Account Settings to uncheck the \"Compose messages in HTML format\" setting in the \"Composition & Addressing\" panel of the account to be used to send the patch.\n• In the main Thunderbird window, before you open the compose window for the patch, use Tools→about:config to set the following to the indicated values: mailnews.send_plaintext_flowed => false mailnews.wraplength => 0\n• Open a compose window and click the external editor icon.\n• In the external editor window, read in the patch file and exit the editor normally.",
        "code_examples": [
          "```bash\nmailnews.send_plaintext_flowed  => false\n\tmailnews.wraplength             => 0\n```",
          "```bash\nmail.html_compose                       => false\n\tmail.identity.default.compose_html      => false\n\tmail.identity.id?.compose_html          => false\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 19,
          "content_length": 4118
        }
      },
      {
        "header": "KMail",
        "content": "This should help you to submit patches inline using KMail.\n\nPrepare the patch as a text file.\n\nGo under \"Options\" in the Composer window and be sure that \"Word wrap\" is not set.\n\nUse Message → Insert file… and insert the patch.\n\nBack in the compose window: add whatever other text you wish to the message, complete the addressing and subject fields, and press send.\n\n• Prepare the patch as a text file.\n• Click on New Mail.\n• Go under \"Options\" in the Composer window and be sure that \"Word wrap\" is not set.\n• Use Message → Insert file… and insert the patch.\n• Back in the compose window: add whatever other text you wish to the message, complete the addressing and subject fields, and press send.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 698
        }
      },
      {
        "header": "BASE TREE INFORMATION",
        "content": "The base tree information block is used for maintainers or third party testers to know the exact state the patch series applies to. It consists of the base commit, which is a well-known commit that is part of the stable part of the project history everybody else works off of, and zero or more prerequisite patches, which are well-known patches in flight that is not yet part of the base commit that need to be applied on top of base commit in topological order before the patches can be applied.\n\nThe base commit is shown as \"base-commit: \" followed by the 40-hex of the commit object name. A prerequisite patch is shown as \"prerequisite-patch-id: \" followed by the 40-hex patch id, which can be obtained by passing the patch through the git patch-id --stable command.\n\nImagine that on top of the public commit P, you applied well-known patches X, Y and Z from somebody else, and then built your three-patch series A, B, C, the history would be like:\n\nWith git format-patch --base=P -3 C (or variants thereof, e.g. with --cover-letter or using Z..C instead of -3 C to specify the range), the base tree information block is shown at the end of the first message the command outputs (either the first patch, or the cover letter), like this:\n\nFor non-linear topology, such as\n\nYou can also use git format-patch --base=P -3 C to generate patches for A, B and C, and the identifiers for P, X, Y, Z are appended at the end of the first message.\n\nIf set --base=auto in cmdline, it will automatically compute the base commit as the merge base of tip commit of the remote-tracking branch and revision-range specified in cmdline. For a local branch, you need to make it to track a remote branch by git branch --set-upstream-to before using this option.",
        "code_examples": [
          "```bash\n---P---X---Y---Z---A---B---C\n```",
          "```bash\nbase-commit: P\nprerequisite-patch-id: X\nprerequisite-patch-id: Y\nprerequisite-patch-id: Z\n```",
          "```bash\n---P---X---A---M---C\n    \\         /\n     Y---Z---B\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1743
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Extract commits between revisions R1 and R2, and apply them on top of the current branch using git am to cherry-pick them:\n\nExtract all commits which are in the current branch but not in the origin branch:\n\nFor each commit a separate file is created in the current directory.\n\nExtract all commits that lead to origin since the inception of the project:\n\nThe same as the previous one:\n\nAdditionally, it detects and handles renames and complete rewrites intelligently to produce a renaming patch. A renaming patch reduces the amount of text output, and generally makes it easier to review. Note that non-Git \"patch\" programs won’t understand renaming patches, so use it only when you know the recipient uses Git to apply your patch.\n\nExtract three topmost commits from the current branch and format them as e-mailable patches:\n\n• Extract commits between revisions R1 and R2, and apply them on top of the current branch using git am to cherry-pick them: $ git format-patch -k --stdout R1..R2 | git am -3 -k\n• Extract all commits which are in the current branch but not in the origin branch: $ git format-patch origin For each commit a separate file is created in the current directory.\n• Extract all commits that lead to origin since the inception of the project: $ git format-patch --root origin\n• The same as the previous one: $ git format-patch -M -B origin Additionally, it detects and handles renames and complete rewrites intelligently to produce a renaming patch. A renaming patch reduces the amount of text output, and generally makes it easier to review. Note that non-Git \"patch\" programs won’t understand renaming patches, so use it only when you know the recipient uses Git to apply your patch.\n• Extract three topmost commits from the current branch and format them as e-mailable patches: $ git format-patch -3",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git format-patch -k --stdout R1..R2 | git am -3 -k\n```",
          "```bash\n$ git format-patch origin\n```",
          "```bash\n$ git format-patch --root origin\n```",
          "```bash\n$ git format-patch -M -B origin\n```",
          "```bash\n$ git format-patch -3\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1820
        }
      },
      {
        "header": "CAVEATS",
        "content": "Note that format-patch will omit merge commits from the output, even if they are part of the requested range. A simple \"patch\" does not include enough information for the receiving end to reproduce the same merge commit.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 220
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-am[1], git-send-email[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 28
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-format-patch",
    "doc_type": "git",
    "total_sections": 15
  },
  {
    "title": "Git",
    "summary": "NAME git-gc - Cleanup unnecessary files and optimize the local repository\n\ngit-gc - Cleanup unnecessary files and optimize the local repository",
    "sections": [
      {
        "header": "NAME",
        "content": "git-gc - Cleanup unnecessary files and optimize the local repository",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 68
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Runs a number of housekeeping tasks within the current repository, such as compressing file revisions (to reduce disk space and increase performance), removing unreachable objects which may have been created from prior invocations of git add, packing refs, pruning reflog, rerere metadata or stale working trees. May also update ancillary indexes such as the commit-graph.\n\nWhen common porcelain operations that create objects are run, they will check whether the repository has grown substantially since the last maintenance, and if so run git gc automatically. See gc.auto below for how to disable this behavior.\n\nRunning git gc manually should only be needed when adding objects to a repository without regularly running such porcelain commands, to do a one-off repository optimization, or e.g. to clean up a suboptimal mass-import. See the \"PACKFILE OPTIMIZATION\" section in git-fast-import[1] for more details on the import case.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 934
        }
      },
      {
        "header": "OPTIONS",
        "content": "Usually git gc runs very quickly while providing good disk space utilization and performance. This option will cause git gc to more aggressively optimize the repository at the expense of taking much more time. The effects of this optimization are mostly persistent. See the \"AGGRESSIVE\" section below for details.\n\nWith this option, git gc checks whether any housekeeping is required; if not, it exits without performing any work.\n\nSee the gc.auto option in the \"CONFIGURATION\" section below for how this heuristic works.\n\nOnce housekeeping is triggered by exceeding the limits of configuration options such as gc.auto and gc.autoPackLimit, all other housekeeping tasks (e.g. rerere, working trees, reflog…) will be performed as well.\n\nRun in the background if the system supports it. This option overrides the gc.autoDetach config.\n\nWhen expiring unreachable objects, pack them separately into a cruft pack instead of storing them as loose objects. --cruft is on by default.\n\nWhen packing unreachable objects into a cruft pack, limit the size of new cruft packs to be at most <n> bytes. Overrides any value specified via the gc.maxCruftSize configuration. See the --max-cruft-size option of git-repack[1] for more.\n\nWhen packing unreachable objects into a cruft pack, write a cruft pack containing pruned objects (if any) to the directory <dir>. This option only has an effect when used together with --cruft. See the --expire-to option of git-repack[1] for more information.\n\nPrune loose objects older than date (default is 2 weeks ago, overridable by the config variable gc.pruneExpire). --prune=now prunes loose objects regardless of their age and increases the risk of corruption if another process is writing to the repository concurrently; see \"NOTES\" below. --prune is on by default.\n\nDo not prune any loose objects.\n\nSuppress all progress reports.\n\nForce git gc to run even if there may be another git gc instance running on this repository.\n\nAll packs except the largest non-cruft pack, any packs marked with a .keep file, and any cruft pack(s) are consolidated into a single pack. When this option is used, gc.bigPackThreshold is ignored.\n\n**--aggressive**: Usually git gc runs very quickly while providing good disk space utilization and performance. This option will cause git gc to more aggressively optimize the repository at the expense of taking much more time. The effects of this optimization are mostly persistent. See the \"AGGRESSIVE\" section below for details.\n**--auto**: With this option, git gc checks whether any housekeeping is required; if not, it exits without performing any work. See the gc.auto option in the \"CONFIGURATION\" section below for how this heuristic works. Once housekeeping is triggered by exceeding the limits of configuration options such as gc.auto and gc.autoPackLimit, all other housekeeping tasks (e.g. rerere, working trees, reflog…) will be performed as well.\n**--[no-]detach**: Run in the background if the system supports it. This option overrides the gc.autoDetach config.\n**--[no-]cruft**: When expiring unreachable objects, pack them separately into a cruft pack instead of storing them as loose objects. --cruft is on by default.\n**--max-cruft-size=<n>**: When packing unreachable objects into a cruft pack, limit the size of new cruft packs to be at most <n> bytes. Overrides any value specified via the gc.maxCruftSize configuration. See the --max-cruft-size option of git-repack[1] for more.\n**--expire-to=<dir>**: When packing unreachable objects into a cruft pack, write a cruft pack containing pruned objects (if any) to the directory <dir>. This option only has an effect when used together with --cruft. See the --expire-to option of git-repack[1] for more information.\n**--prune=<date>**: Prune loose objects older than date (default is 2 weeks ago, overridable by the config variable gc.pruneExpire). --prune=now prunes loose objects regardless of their age and increases the risk of corruption if another process is writing to the repository concurrently; see \"NOTES\" below. --prune is on by default.\n**--no-prune**: Do not prune any loose objects.\n**--quiet**: Suppress all progress reports.\n**--force**: Force git gc to run even if there may be another git gc instance running on this repository.\n**--keep-largest-pack**: All packs except the largest non-cruft pack, any packs marked with a .keep file, and any cruft pack(s) are consolidated into a single pack. When this option is used, gc.bigPackThreshold is ignored.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 13,
          "content_length": 4491
        }
      },
      {
        "header": "AGGRESSIVE",
        "content": "When the --aggressive option is supplied, git-repack[1] will be invoked with the -f flag, which in turn will pass --no-reuse-delta to git-pack-objects[1]. This will throw away any existing deltas and re-compute them, at the expense of spending much more time on the repacking.\n\nThe effects of this are mostly persistent, e.g. when packs and loose objects are coalesced into one another pack the existing deltas in that pack might get re-used, but there are also various cases where we might pick a sub-optimal delta from a newer pack instead.\n\nFurthermore, supplying --aggressive will tweak the --depth and --window options passed to git-repack[1]. See the gc.aggressiveDepth and gc.aggressiveWindow settings below. By using a larger window size we’re more likely to find more optimal deltas.\n\nIt’s probably not worth it to use this option on a given repository without running tailored performance benchmarks on it. It takes a lot more time, and the resulting space/delta optimization may or may not be worth it. Not using this at all is the right trade-off for most users and their repositories.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1097
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Everything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there:\n\nThe depth parameter used in the delta compression algorithm used by git gc --aggressive. This defaults to 50, which is the default for the --depth option when --aggressive isn’t in use.\n\nSee the documentation for the --depth option in git-repack[1] for more details.\n\nThe window size parameter used in the delta compression algorithm used by git gc --aggressive. This defaults to 250, which is a much more aggressive window size than the default --window of 10.\n\nSee the documentation for the --window option in git-repack[1] for more details.\n\nWhen there are approximately more than this many loose objects in the repository, git gc --auto will pack them. Some Porcelain commands use this command to perform a light-weight garbage collection from time to time. The default value is 6700.\n\nSetting this to 0 disables not only automatic packing based on the number of loose objects, but also any other heuristic git gc --auto will otherwise use to determine if there’s work to do, such as gc.autoPackLimit.\n\nWhen there are more than this many packs that are not marked with *.keep file in the repository, git gc --auto consolidates them into one larger pack. The default value is 50. Setting this to 0 disables it. Setting gc.auto to 0 will also disable this.\n\nSee the gc.bigPackThreshold configuration variable below. When in use, it’ll affect how the auto pack limit works.\n\nMake git gc --auto return immediately and run in the background if the system supports it. Default is true. This config variable acts as a fallback in case maintenance.autoDetach is not set.\n\nIf non-zero, all non-cruft packs larger than this limit are kept when git gc is run. This is very similar to --keep-largest-pack except that all non-cruft packs that meet the threshold are kept, not just the largest pack. Defaults to zero. Common unit suffixes of k, m, or g are supported.\n\nNote that if the number of kept packs is more than gc.autoPackLimit, this configuration variable is ignored, all packs except the base pack will be repacked. After this the number of packs should go below gc.autoPackLimit and gc.bigPackThreshold should be respected again.\n\nIf the amount of memory estimated for git repack to run smoothly is not available and gc.bigPackThreshold is not set, the largest pack will also be excluded (this is the equivalent of running git gc with --keep-largest-pack).\n\nIf true, then gc will rewrite the commit-graph file when git-gc[1] is run. When using git gc --auto the commit-graph will be updated if housekeeping is required. Default is true. See git-commit-graph[1] for details.\n\nIf the file gc.log exists, then git gc --auto will print its content and exit with status zero instead of running unless that file is more than gc.logExpiry old. Default is \"1.day\". See gc.pruneExpire for more ways to specify its value.\n\nRunning git pack-refs in a repository renders it unclonable by Git versions prior to 1.5.1.2 over dumb transports such as HTTP. This variable determines whether git gc runs git pack-refs. This can be set to notbare to enable it within all non-bare repos or it can be set to a boolean value. The default is true.\n\nStore unreachable objects in a cruft pack (see git-repack[1]) instead of as loose objects. The default is true.\n\nLimit the size of new cruft packs when repacking. When specified in addition to --max-cruft-size, the command line option takes priority. See the --max-cruft-size option of git-repack[1].\n\nWhen git gc is run, it will call prune --expire 2.weeks.ago (and repack --cruft --cruft-expiration 2.weeks.ago if using cruft packs via gc.cruftPacks or --cruft). Override the grace period with this config variable. The value \"now\" may be used to disable this grace period and always prune unreachable objects immediately, or \"never\" may be used to suppress pruning. This feature helps prevent corruption when git gc runs concurrently with another process writing to the repository; see the \"NOTES\" section of git-gc[1].\n\nWhen git gc is run, it calls git worktree prune --expire 3.months.ago. This config variable can be used to set a different grace period. The value \"now\" may be used to disable the grace period and prune $GIT_DIR/worktrees immediately, or \"never\" may be used to suppress pruning.\n\ngit reflog expire removes reflog entries older than this time; defaults to 90 days. The value \"now\" expires all entries immediately, and \"never\" suppresses expiration altogether. With \"<pattern>\" (e.g. \"refs/stash\") in the middle the setting applies only to the refs that match the <pattern>.\n\ngit reflog expire removes reflog entries older than this time and are not reachable from the current tip; defaults to 30 days. The value \"now\" expires all entries immediately, and \"never\" suppresses expiration altogether. With \"<pattern>\" (e.g. \"refs/stash\") in the middle, the setting applies only to the refs that match the <pattern>.\n\nThese types of entries are generally created as a result of using git commit --amend or git rebase and are the commits prior to the amend or rebase occurring. Since these changes are not part of the current project most users will want to expire them sooner, which is why the default is more aggressive than gc.reflogExpire.\n\nWhen considering whether or not to remove an object (either when generating a cruft pack or storing unreachable objects as loose), use the shell to execute the specified command(s). Interpret their output as object IDs which Git will consider as \"recent\", regardless of their age. By treating their mtimes as \"now\", any objects (and their descendants) mentioned in the output will be kept regardless of their true age.\n\nOutput must contain exactly one hex object ID per line, and nothing else. Objects which cannot be found in the repository are ignored. Multiple hooks are supported, but all must exit successfully, else the operation (either generating a cruft pack or unpacking unreachable objects) will be halted.\n\nWhen repacking, use the specified filter to move certain objects into a separate packfile. See the --filter=<filter-spec> option of git-repack[1].\n\nWhen repacking and using a filter, see gc.repackFilter, the specified location will be used to create the packfile containing the filtered out objects. WARNING: The specified location should be accessible, using for example the Git alternates mechanism, otherwise the repo could be considered corrupt by Git as it might not be able to access the objects in that packfile. See the --filter-to=<dir> option of git-repack[1] and the objects/info/alternates section of gitrepository-layout[5].\n\nRecords of conflicted merge you resolved earlier are kept for this many days when git rerere gc is run. You can also use more human-readable \"1.month.ago\", etc. The default is 60 days. See git-rerere[1].\n\nRecords of conflicted merge you have not resolved are kept for this many days when git rerere gc is run. You can also use more human-readable \"1.month.ago\", etc. The default is 15 days. See git-rerere[1].\n\n**gc.aggressiveDepth**: The depth parameter used in the delta compression algorithm used by git gc --aggressive. This defaults to 50, which is the default for the --depth option when --aggressive isn’t in use. See the documentation for the --depth option in git-repack[1] for more details.\n**gc.aggressiveWindow**: The window size parameter used in the delta compression algorithm used by git gc --aggressive. This defaults to 250, which is a much more aggressive window size than the default --window of 10. See the documentation for the --window option in git-repack[1] for more details.\n**gc.auto**: When there are approximately more than this many loose objects in the repository, git gc --auto will pack them. Some Porcelain commands use this command to perform a light-weight garbage collection from time to time. The default value is 6700. Setting this to 0 disables not only automatic packing based on the number of loose objects, but also any other heuristic git gc --auto will otherwise use to determine if there’s work to do, such as gc.autoPackLimit.\n**gc.autoPackLimit**: When there are more than this many packs that are not marked with *.keep file in the repository, git gc --auto consolidates them into one larger pack. The default value is 50. Setting this to 0 disables it. Setting gc.auto to 0 will also disable this. See the gc.bigPackThreshold configuration variable below. When in use, it’ll affect how the auto pack limit works.\n**gc.autoDetach**: Make git gc --auto return immediately and run in the background if the system supports it. Default is true. This config variable acts as a fallback in case maintenance.autoDetach is not set.\n**gc.bigPackThreshold**: If non-zero, all non-cruft packs larger than this limit are kept when git gc is run. This is very similar to --keep-largest-pack except that all non-cruft packs that meet the threshold are kept, not just the largest pack. Defaults to zero. Common unit suffixes of k, m, or g are supported. Note that if the number of kept packs is more than gc.autoPackLimit, this configuration variable is ignored, all packs except the base pack will be repacked. After this the number of packs should go below gc.autoPackLimit and gc.bigPackThreshold should be respected again. If the amount of memory estimated for git repack to run smoothly is not available and gc.bigPackThreshold is not set, the largest pack will also be excluded (this is the equivalent of running git gc with --keep-largest-pack).\n**gc.writeCommitGraph**: If true, then gc will rewrite the commit-graph file when git-gc[1] is run. When using git gc --auto the commit-graph will be updated if housekeeping is required. Default is true. See git-commit-graph[1] for details.\n**gc.logExpiry**: If the file gc.log exists, then git gc --auto will print its content and exit with status zero instead of running unless that file is more than gc.logExpiry old. Default is \"1.day\". See gc.pruneExpire for more ways to specify its value.\n**gc.packRefs**: Running git pack-refs in a repository renders it unclonable by Git versions prior to 1.5.1.2 over dumb transports such as HTTP. This variable determines whether git gc runs git pack-refs. This can be set to notbare to enable it within all non-bare repos or it can be set to a boolean value. The default is true.\n**gc.cruftPacks**: Store unreachable objects in a cruft pack (see git-repack[1]) instead of as loose objects. The default is true.\n**gc.maxCruftSize**: Limit the size of new cruft packs when repacking. When specified in addition to --max-cruft-size, the command line option takes priority. See the --max-cruft-size option of git-repack[1].\n**gc.pruneExpire**: When git gc is run, it will call prune --expire 2.weeks.ago (and repack --cruft --cruft-expiration 2.weeks.ago if using cruft packs via gc.cruftPacks or --cruft). Override the grace period with this config variable. The value \"now\" may be used to disable this grace period and always prune unreachable objects immediately, or \"never\" may be used to suppress pruning. This feature helps prevent corruption when git gc runs concurrently with another process writing to the repository; see the \"NOTES\" section of git-gc[1].\n**gc.worktreePruneExpire**: When git gc is run, it calls git worktree prune --expire 3.months.ago. This config variable can be used to set a different grace period. The value \"now\" may be used to disable the grace period and prune $GIT_DIR/worktrees immediately, or \"never\" may be used to suppress pruning.\n**gc.reflogExpire**: git reflog expire removes reflog entries older than this time; defaults to 90 days. The value \"now\" expires all entries immediately, and \"never\" suppresses expiration altogether. With \"<pattern>\" (e.g. \"refs/stash\") in the middle the setting applies only to the refs that match the <pattern>.\n**gc.<pattern>.reflogExpire**: git reflog expire removes reflog entries older than this time and are not reachable from the current tip; defaults to 30 days. The value \"now\" expires all entries immediately, and \"never\" suppresses expiration altogether. With \"<pattern>\" (e.g. \"refs/stash\") in the middle, the setting applies only to the refs that match the <pattern>. These types of entries are generally created as a result of using git commit --amend or git rebase and are the commits prior to the amend or rebase occurring. Since these changes are not part of the current project most users will want to expire them sooner, which is why the default is more aggressive than gc.reflogExpire.\n**gc.reflogExpireUnreachable**: When considering whether or not to remove an object (either when generating a cruft pack or storing unreachable objects as loose), use the shell to execute the specified command(s). Interpret their output as object IDs which Git will consider as \"recent\", regardless of their age. By treating their mtimes as \"now\", any objects (and their descendants) mentioned in the output will be kept regardless of their true age. Output must contain exactly one hex object ID per line, and nothing else. Objects which cannot be found in the repository are ignored. Multiple hooks are supported, but all must exit successfully, else the operation (either generating a cruft pack or unpacking unreachable objects) will be halted.\n**gc.<pattern>.reflogExpireUnreachable**: When repacking, use the specified filter to move certain objects into a separate packfile. See the --filter=<filter-spec> option of git-repack[1].\n**gc.recentObjectsHook**: When repacking and using a filter, see gc.repackFilter, the specified location will be used to create the packfile containing the filtered out objects. WARNING: The specified location should be accessible, using for example the Git alternates mechanism, otherwise the repo could be considered corrupt by Git as it might not be able to access the objects in that packfile. See the --filter-to=<dir> option of git-repack[1] and the objects/info/alternates section of gitrepository-layout[5].\n**gc.repackFilter**: Records of conflicted merge you resolved earlier are kept for this many days when git rerere gc is run. You can also use more human-readable \"1.month.ago\", etc. The default is 60 days. See git-rerere[1].\n**gc.repackFilterTo**: Records of conflicted merge you have not resolved are kept for this many days when git rerere gc is run. You can also use more human-readable \"1.month.ago\", etc. The default is 15 days. See git-rerere[1].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 29,
          "content_length": 14514
        }
      },
      {
        "header": "NOTES",
        "content": "git gc tries very hard not to delete objects that are referenced anywhere in your repository. In particular, it will keep not only objects referenced by your current set of branches and tags, but also objects referenced by the index, remote-tracking branches, reflogs (which may reference commits in branches that were later amended or rewound), and anything else in the refs/* namespace. Note that a note (of the kind created by git notes) attached to an object does not contribute in keeping the object alive. If you are expecting some objects to be deleted and they aren’t, check all of those locations and decide whether it makes sense in your case to remove those references.\n\nOn the other hand, when git gc runs concurrently with another process, there is a risk of it deleting an object that the other process is using but hasn’t created a reference to. This may just cause the other process to fail or may corrupt the repository if the other process later adds a reference to the deleted object. Git has two features that significantly mitigate this problem:\n\nAny object with modification time newer than the --prune date is kept, along with everything reachable from it.\n\nMost operations that add an object to the database update the modification time of the object if it is already present so that #1 applies.\n\nHowever, these features fall short of a complete solution, so users who run commands concurrently have to live with some risk of corruption (which seems to be low in practice).\n\n• Any object with modification time newer than the --prune date is kept, along with everything reachable from it.\n• Most operations that add an object to the database update the modification time of the object if it is already present so that #1 applies.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1753
        }
      },
      {
        "header": "HOOKS",
        "content": "The git gc --auto command will run the pre-auto-gc hook. See githooks[5] for more information.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 94
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-prune[1] git-reflog[1] git-repack[1] git-rerere[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 54
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-gc",
    "doc_type": "git",
    "total_sections": 9
  },
  {
    "title": "Git",
    "summary": "SYNOPSIS git grep [-a | --text] [-I] [--textconv] [-i | --ignore-case] [-w | --word-regexp] [-v | --invert-match] [-h|-H] [--full-name] [-E | --extended-regexp] [-G | --basic-regexp] [-P | --perl-regexp] [-F | --fixed-strings] [-n | --line-number] [--column] [-l | --files-with-matches] [-L | --files-without-match] [(-O | --open-files-in-pager) [<pager>]] [-z | --null] [ -o | --only-matching ] [-c | --count] [--all-match] [-q | --quiet] [--max-depth <depth>] [--[no-]recursive] [--color[=<when>] |",
    "sections": [
      {
        "header": "NAME",
        "content": "git-grep - Print lines matching a pattern",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 41
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Look for specified patterns in the tracked files in the work tree, blobs registered in the index file, or blobs in given tree objects. Patterns are lists of one or more search expressions separated by newline characters. An empty string as search expression matches all lines.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 276
        }
      },
      {
        "header": "OPTIONS",
        "content": "Instead of searching tracked files in the working tree, search blobs registered in the index file.\n\nIn addition to searching in the tracked files in the working tree, search also in untracked files.\n\nSearch files in the current directory that is not managed by Git, or by ignoring that the current directory is managed by Git. This is rather similar to running the regular grep(1) utility with its -r option specified, but with some additional benefits, such as using pathspec patterns to limit paths; see the pathspec entry in gitglossary[7] for more information.\n\nThis option cannot be used together with --cached or --untracked. See also grep.fallbackToNoIndex in CONFIGURATION below.\n\nAlso search in ignored files by not honoring the .gitignore mechanism. Only useful with --untracked.\n\nDo not pay attention to ignored files specified via the .gitignore mechanism. Only useful when searching files in the current directory with --no-index.\n\nRecursively search in each submodule that is active and checked out in the repository. When used in combination with the <tree> option the prefix of all submodule output will be the name of the parent project’s <tree> object. This option cannot be used together with --untracked, and it has no effect if --no-index is specified.\n\nProcess binary files as if they were text.\n\nHonor textconv filter settings.\n\nDo not honor textconv filter settings. This is the default.\n\nIgnore case differences between the patterns and the files.\n\nDon’t match the pattern in binary files.\n\nFor each <pathspec> given on command line, descend at most <depth> levels of directories. A value of -1 means no limit. This option is ignored if <pathspec> contains active wildcards. In other words if \"a*\" matches a directory named \"a*\", \"*\" is matched literally so --max-depth is still effective.\n\nSame as --max-depth=-1; this is the default.\n\nSame as --max-depth=0.\n\nMatch the pattern only at word boundary (either begin at the beginning of a line, or preceded by a non-word character; end at the end of a line or followed by a non-word character).\n\nSelect non-matching lines.\n\nBy default, the command shows the filename for each match. -h option is used to suppress this output. -H is there for completeness and does not do anything except it overrides -h given earlier on the command line.\n\nWhen run from a subdirectory, the command usually outputs paths relative to the current directory. This option forces paths to be output relative to the project top directory.\n\nUse POSIX extended/basic regexp for patterns. Default is to use basic regexp.\n\nUse Perl-compatible regular expressions for patterns.\n\nSupport for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die.\n\nUse fixed strings for patterns (don’t interpret pattern as a regex).\n\nPrefix the line number to matching lines.\n\nPrefix the 1-indexed byte-offset of the first match from the start of the matching line.\n\nInstead of showing every matched line, show only the names of files that contain (or do not contain) matches. For better compatibility with git diff, --name-only is a synonym for --files-with-matches.\n\nOpen the matching files in the pager (not the output of grep). If the pager happens to be \"less\" or \"vi\", and the user specified only one pattern, the first file is positioned at the first match automatically. The pager argument is optional; if specified, it must be stuck to the option without a space. If pager is unspecified, the default pager will be used (see core.pager in git-config[1]).\n\nUse \\0 as the delimiter for pathnames in the output, and print them verbatim. Without this option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n\nPrint only the matched (non-empty) parts of a matching line, with each such part on a separate output line.\n\nInstead of showing every matched line, show the number of lines that match.\n\nShow colored matches. The value must be always (the default), never, or auto.\n\nTurn off match highlighting, even when the configuration file gives the default to color output. Same as --color=never.\n\nPrint an empty line between matches from different files.\n\nShow the filename above the matches in that file instead of at the start of each shown line.\n\nShow the preceding line that contains the function name of the match, unless the matching line is a function name itself. The name is determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes[5]).\n\nShow <num> leading and trailing lines, and place a line containing -- between contiguous groups of matches.\n\nShow <num> trailing lines, and place a line containing -- between contiguous groups of matches.\n\nShow <num> leading lines, and place a line containing -- between contiguous groups of matches.\n\nShow the surrounding text from the previous line containing a function name up to the one before the next function name, effectively showing the whole function in which the match was found. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes[5]).\n\nLimit the amount of matches per file. When using the -v or --invert-match option, the search stops after the specified number of non-matches. A value of -1 will return unlimited results (the default). A value of 0 will exit immediately with a non-zero status.\n\nNumber of grep worker threads to use. See NOTES ON THREADS and grep.threads in CONFIGURATION for more information.\n\nRead patterns from <file>, one per line.\n\nPassing the pattern via <file> allows for providing a search pattern containing a \\0.\n\nNot all pattern types support patterns containing \\0. Git will error out if a given pattern type can’t support such a pattern. The --perl-regexp pattern type when compiled against the PCRE v2 backend has the widest support for these types of patterns.\n\nIn versions of Git before 2.23.0 patterns containing \\0 would be silently considered fixed. This was never documented, there were also odd and undocumented interactions between e.g. non-ASCII patterns containing \\0 and --ignore-case.\n\nIn future versions we may learn to support patterns containing \\0 for more search backends, until then we’ll die when the pattern type in question doesn’t support them.\n\nThe next parameter is the pattern. This option has to be used for patterns starting with - and should be used in scripts passing user input to grep. Multiple patterns are combined by or.\n\nSpecify how multiple patterns are combined using Boolean expressions. --or is the default operator. --and has higher precedence than --or. -e has to be used for all patterns.\n\nWhen giving multiple pattern expressions combined with --or, this flag is specified to limit the match to files that have lines to match all of them.\n\nDo not output matched lines; instead, exit with status 0 when there is a match and with non-zero status when there isn’t.\n\nInstead of searching tracked files in the working tree, search blobs in the given trees.\n\nSignals the end of options; the rest of the parameters are <pathspec> limiters.\n\nIf given, limit the search to paths matching at least one pattern. Both leading paths match and glob(7) patterns are supported.\n\nFor more details about the <pathspec> syntax, see the pathspec entry in gitglossary[7].\n\n**--cached**: Instead of searching tracked files in the working tree, search blobs registered in the index file.\n**--untracked**: In addition to searching in the tracked files in the working tree, search also in untracked files.\n**--no-index**: Search files in the current directory that is not managed by Git, or by ignoring that the current directory is managed by Git. This is rather similar to running the regular grep(1) utility with its -r option specified, but with some additional benefits, such as using pathspec patterns to limit paths; see the pathspec entry in gitglossary[7] for more information. This option cannot be used together with --cached or --untracked. See also grep.fallbackToNoIndex in CONFIGURATION below.\n**--no-exclude-standard**: Also search in ignored files by not honoring the .gitignore mechanism. Only useful with --untracked.\n**--exclude-standard**: Do not pay attention to ignored files specified via the .gitignore mechanism. Only useful when searching files in the current directory with --no-index.\n**--recurse-submodules**: Recursively search in each submodule that is active and checked out in the repository. When used in combination with the <tree> option the prefix of all submodule output will be the name of the parent project’s <tree> object. This option cannot be used together with --untracked, and it has no effect if --no-index is specified.\n**-a**: Process binary files as if they were text.\n**--text**: Honor textconv filter settings.\n**--textconv**: Do not honor textconv filter settings. This is the default.\n**--no-textconv**: Ignore case differences between the patterns and the files.\n**-i**: Don’t match the pattern in binary files.\n**--ignore-case**: For each <pathspec> given on command line, descend at most <depth> levels of directories. A value of -1 means no limit. This option is ignored if <pathspec> contains active wildcards. In other words if \"a*\" matches a directory named \"a*\", \"*\" is matched literally so --max-depth is still effective.\n**-I**: Same as --max-depth=-1; this is the default.\n**--max-depth <depth>**: Same as --max-depth=0.\n**-r**: Match the pattern only at word boundary (either begin at the beginning of a line, or preceded by a non-word character; end at the end of a line or followed by a non-word character).\n**--recursive**: Select non-matching lines.\n**--no-recursive**: By default, the command shows the filename for each match. -h option is used to suppress this output. -H is there for completeness and does not do anything except it overrides -h given earlier on the command line.\n**-w**: When run from a subdirectory, the command usually outputs paths relative to the current directory. This option forces paths to be output relative to the project top directory.\n**--word-regexp**: Use POSIX extended/basic regexp for patterns. Default is to use basic regexp.\n**-v**: Use Perl-compatible regular expressions for patterns. Support for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die.\n**--invert-match**: Use fixed strings for patterns (don’t interpret pattern as a regex).\n**-h**: Prefix the line number to matching lines.\n**-H**: Prefix the 1-indexed byte-offset of the first match from the start of the matching line.\n**--full-name**: Instead of showing every matched line, show only the names of files that contain (or do not contain) matches. For better compatibility with git diff, --name-only is a synonym for --files-with-matches.\n**-E**: Open the matching files in the pager (not the output of grep). If the pager happens to be \"less\" or \"vi\", and the user specified only one pattern, the first file is positioned at the first match automatically. The pager argument is optional; if specified, it must be stuck to the option without a space. If pager is unspecified, the default pager will be used (see core.pager in git-config[1]).\n**--extended-regexp**: Use \\0 as the delimiter for pathnames in the output, and print them verbatim. Without this option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n**-G**: Print only the matched (non-empty) parts of a matching line, with each such part on a separate output line.\n**--basic-regexp**: Instead of showing every matched line, show the number of lines that match.\n**-P**: Show colored matches. The value must be always (the default), never, or auto.\n**--perl-regexp**: Turn off match highlighting, even when the configuration file gives the default to color output. Same as --color=never.\n**-F**: Print an empty line between matches from different files.\n**--fixed-strings**: Show the filename above the matches in that file instead of at the start of each shown line.\n**-n**: Show the preceding line that contains the function name of the match, unless the matching line is a function name itself. The name is determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes[5]).\n**--line-number**: Show <num> leading and trailing lines, and place a line containing -- between contiguous groups of matches.\n**--column**: Show <num> trailing lines, and place a line containing -- between contiguous groups of matches.\n**-l**: Show <num> leading lines, and place a line containing -- between contiguous groups of matches.\n**--files-with-matches**: Show the surrounding text from the previous line containing a function name up to the one before the next function name, effectively showing the whole function in which the match was found. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes[5]).\n**--name-only**: Limit the amount of matches per file. When using the -v or --invert-match option, the search stops after the specified number of non-matches. A value of -1 will return unlimited results (the default). A value of 0 will exit immediately with a non-zero status.\n**-L**: Number of grep worker threads to use. See NOTES ON THREADS and grep.threads in CONFIGURATION for more information.\n**--files-without-match**: Read patterns from <file>, one per line. Passing the pattern via <file> allows for providing a search pattern containing a \\0. Not all pattern types support patterns containing \\0. Git will error out if a given pattern type can’t support such a pattern. The --perl-regexp pattern type when compiled against the PCRE v2 backend has the widest support for these types of patterns. In versions of Git before 2.23.0 patterns containing \\0 would be silently considered fixed. This was never documented, there were also odd and undocumented interactions between e.g. non-ASCII patterns containing \\0 and --ignore-case. In future versions we may learn to support patterns containing \\0 for more search backends, until then we’ll die when the pattern type in question doesn’t support them.\n**-O[<pager>]**: The next parameter is the pattern. This option has to be used for patterns starting with - and should be used in scripts passing user input to grep. Multiple patterns are combined by or.\n**--open-files-in-pager[=<pager>]**: Specify how multiple patterns are combined using Boolean expressions. --or is the default operator. --and has higher precedence than --or. -e has to be used for all patterns.\n**-z**: When giving multiple pattern expressions combined with --or, this flag is specified to limit the match to files that have lines to match all of them.\n**--null**: Do not output matched lines; instead, exit with status 0 when there is a match and with non-zero status when there isn’t.\n**-o**: Instead of searching tracked files in the working tree, search blobs in the given trees.\n**--only-matching**: Signals the end of options; the rest of the parameters are <pathspec> limiters.\n**-c**: If given, limit the search to paths matching at least one pattern. Both leading paths match and glob(7) patterns are supported. For more details about the <pathspec> syntax, see the pathspec entry in gitglossary[7].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 54,
          "content_length": 15588
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Looks for time_t in all tracked .c and .h files in the working directory and its subdirectories.\n\nLooks for a line that has #define and either MAX_PATH or PATH_MAX.\n\nLooks for a line that has NODE or Unexpected in files that have lines that match both.\n\nLooks for solution, excluding files in Documentation.\n\n**git grep time_t' -- *.[ch]**: Looks for time_t in all tracked .c and .h files in the working directory and its subdirectories.\n**git grep -e '#define' --and \\( -e MAX_PATH -e PATH_MAX \\)**: Looks for a line that has #define and either MAX_PATH or PATH_MAX.\n**git grep --all-match -e NODE -e Unexpected**: Looks for a line that has NODE or Unexpected in files that have lines that match both.\n**git grep solution -- :^Documentation**: Looks for solution, excluding files in Documentation.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 798
        }
      },
      {
        "header": "NOTES ON THREADS",
        "content": "The --threads option (and the grep.threads configuration) will be ignored when --open-files-in-pager is used, forcing a single-threaded execution.\n\nWhen grepping the object store (with --cached or giving tree objects), running with multiple threads might perform slower than single-threaded if --textconv is given and there are too many text conversions. Thus, if low performance is experienced in this case, it might be desirable to use --threads=1.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 450
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Everything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there:\n\nIf set to true, enable -n option by default.\n\nIf set to true, enable the --column option by default.\n\nSet the default matching behavior. Using a value of basic, extended, fixed, or perl will enable the --basic-regexp, --extended-regexp, --fixed-strings, or --perl-regexp option accordingly, while the value default will use the grep.extendedRegexp option to choose between basic and extended.\n\nIf set to true, enable --extended-regexp option by default. This option is ignored when the grep.patternType option is set to a value other than default.\n\nNumber of grep worker threads to use. If unset (or set to 0), Git will use as many threads as the number of logical cores available.\n\nIf set to true, enable --full-name option by default.\n\nIf set to true, fall back to git grep --no-index if git grep is executed outside of a git repository. Defaults to false.\n\n**grep.lineNumber**: If set to true, enable -n option by default.\n**grep.column**: If set to true, enable the --column option by default.\n**grep.patternType**: Set the default matching behavior. Using a value of basic, extended, fixed, or perl will enable the --basic-regexp, --extended-regexp, --fixed-strings, or --perl-regexp option accordingly, while the value default will use the grep.extendedRegexp option to choose between basic and extended.\n**grep.extendedRegexp**: If set to true, enable --extended-regexp option by default. This option is ignored when the grep.patternType option is set to a value other than default.\n**grep.threads**: Number of grep worker threads to use. If unset (or set to 0), Git will use as many threads as the number of logical cores available.\n**grep.fullName**: If set to true, enable --full-name option by default.\n**grep.fallbackToNoIndex**: If set to true, fall back to git grep --no-index if git grep is executed outside of a git repository. Defaults to false.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 2015
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-grep",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "Git",
    "summary": "NAME git-gui - A portable graphical interface to Git",
    "sections": [
      {
        "header": "NAME",
        "content": "git-gui - A portable graphical interface to Git",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 47
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "A Tcl/Tk based graphical user interface to Git. git gui focuses on allowing users to make changes to their repository by making new commits, amending existing ones, creating branches, performing local merges, and fetching/pushing to remote repositories.\n\nUnlike gitk, git gui focuses on commit generation and single file annotation and does not show project history. It does however supply menu actions to start a gitk session from within git gui.\n\ngit gui is known to work on all popular UNIX systems, Mac OS X, and Windows (under both Cygwin and MSYS). To the extent possible OS specific user interface guidelines are followed, making git gui a fairly native interface for users.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 681
        }
      },
      {
        "header": "COMMANDS",
        "content": "Start a blame viewer on the specified file on the given version (or working directory if not specified).\n\nStart a tree browser showing all files in the specified commit. Files selected through the browser are opened in the blame viewer.\n\nStart git gui and arrange to make exactly one commit before exiting and returning to the shell. The interface is limited to only commit actions, slightly reducing the application’s startup time and simplifying the menubar.\n\nDisplay the currently running version of git gui.\n\n**blame**: Start a blame viewer on the specified file on the given version (or working directory if not specified).\n**browser**: Start a tree browser showing all files in the specified commit. Files selected through the browser are opened in the blame viewer.\n**citool**: Start git gui and arrange to make exactly one commit before exiting and returning to the shell. The interface is limited to only commit actions, slightly reducing the application’s startup time and simplifying the menubar.\n**version**: Display the currently running version of git gui.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1070
        }
      },
      {
        "header": "Examples",
        "content": "Show the contents of the file Makefile in the current working directory, and provide annotations for both the original author of each line, and who moved the line to its current location. The uncommitted file is annotated, and uncommitted changes (if any) are explicitly attributed to Not Yet Committed.\n\nShow the contents of Makefile in revision v0.99.8 and provide annotations for each line. Unlike the above example the file is read from the object database and not the working directory.\n\nLoads annotations as described above and automatically scrolls the view to center on line 100.\n\nMake one commit and return to the shell when it is complete. This command returns a non-zero exit code if the window was closed in any way other than by making a commit.\n\nAutomatically enter the Amend Last Commit mode of the interface.\n\nBehave as normal citool, but instead of making a commit simply terminate with a zero exit code. It still checks that the index does not contain any unmerged entries, so you can use it as a GUI version of git-mergetool[1]\n\nSame as git gui citool (above).\n\nShow a browser for the tree of the maint branch. Files selected in the browser can be viewed with the internal blame viewer.\n\n**git gui blame Makefile**: Show the contents of the file Makefile in the current working directory, and provide annotations for both the original author of each line, and who moved the line to its current location. The uncommitted file is annotated, and uncommitted changes (if any) are explicitly attributed to Not Yet Committed.\n**git gui blame v0.99.8 Makefile**: Show the contents of Makefile in revision v0.99.8 and provide annotations for each line. Unlike the above example the file is read from the object database and not the working directory.\n**git gui blame --line=100 Makefile**: Loads annotations as described above and automatically scrolls the view to center on line 100.\n**git gui citool**: Make one commit and return to the shell when it is complete. This command returns a non-zero exit code if the window was closed in any way other than by making a commit.\n**git gui citool --amend**: Automatically enter the Amend Last Commit mode of the interface.\n**git gui citool --nocommit**: Behave as normal citool, but instead of making a commit simply terminate with a zero exit code. It still checks that the index does not contain any unmerged entries, so you can use it as a GUI version of git-mergetool[1]\n**git citool**: Same as git gui citool (above).\n**git gui browser maint**: Show a browser for the tree of the maint branch. Files selected in the browser can be viewed with the internal blame viewer.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 2630
        }
      },
      {
        "header": "SEE ALSO",
        "content": "The Git repository browser. Shows branches, commit history and file differences. gitk is the utility started by git gui's Repository Visualize actions.\n\n**gitk[1]**: The Git repository browser. Shows branches, commit history and file differences. gitk is the utility started by git gui's Repository Visualize actions.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 317
        }
      },
      {
        "header": "Other",
        "content": "git gui is actually maintained as an independent project, but stable versions are distributed as part of the Git suite for the convenience of end users.\n\nThe official repository of the git gui project can be found at:",
        "code_examples": [],
        "usage_examples": [
          "```bash\nhttps://github.com/j6t/git-gui\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 217
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-gui",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "Git",
    "summary": "NAME git-init - Create an empty Git repository or reinitialize an existing one\n\ngit-init - Create an empty Git repository or reinitialize an existing one",
    "sections": [
      {
        "header": "NAME",
        "content": "git-init - Create an empty Git repository or reinitialize an existing one",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 73
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "This command creates an empty Git repository - basically a .git directory with subdirectories for objects, refs/heads, refs/tags, and template files. An initial branch without any commits will be created (see the --initial-branch option below for its name).\n\nIf the GIT_DIR environment variable is set then it specifies a path to use instead of ./.git for the base of the repository.\n\nIf the object storage directory is specified via the GIT_OBJECT_DIRECTORY environment variable then the sha1 directories are created underneath; otherwise, the default $GIT_DIR/objects directory is used.\n\nRunning git init in an existing repository is safe. It will not overwrite things that are already there. The primary reason for rerunning git init is to pick up newly added templates (or to move the repository to another place if --separate-git-dir is given).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 849
        }
      },
      {
        "header": "OPTIONS",
        "content": "Only print error and warning messages; all other output will be suppressed.\n\nCreate a bare repository. If GIT_DIR environment is not set, it is set to the current working directory.\n\nSpecify the given object <format> (hash algorithm) for the repository. The valid values are sha1 and (if enabled) sha256. sha1 is the default.\n\nNote: At present, there is no interoperability between SHA-256 repositories and SHA-1 repositories.\n\nHistorically, we warned that SHA-256 repositories may later need backward incompatible changes when we introduce such interoperability features. Today, we only expect compatible changes. Furthermore, if such changes prove to be necessary, it can be expected that SHA-256 repositories created with today’s Git will be usable by future versions of Git without data loss.\n\nSpecify the given ref storage <format> for the repository. The valid values are:\n\nfiles for loose files with packed-refs. This is the default.\n\nreftable for the reftable format. This format is experimental and its internals are subject to change.\n\nSpecify the directory from which templates will be used. (See the \"TEMPLATE DIRECTORY\" section below.)\n\nInstead of initializing the repository as a directory to either $GIT_DIR or ./.git/, create a text file there containing the path to the actual repository. This file acts as a filesystem-agnostic Git symbolic link to the repository.\n\nIf this is a reinitialization, the repository will be moved to the specified path.\n\nUse <branch-name> for the initial branch in the newly created repository. If not specified, fall back to the default name (currently master, but this is subject to change in the future; the name can be customized via the init.defaultBranch configuration variable).\n\nSpecify that the Git repository is to be shared amongst several users. This allows users belonging to the same group to push into that repository. When specified, the config variable core.sharedRepository is set so that files and directories under $GIT_DIR are created with the requested permissions. When not specified, Git will use permissions reported by umask(2).\n\nThe option can have the following values, defaulting to group if no value is given:\n\nUse permissions reported by umask(2). The default, when --shared is not specified.\n\nMake the repository group-writable, (and g+sx, since the git group may not be the primary group of all users). This is used to loosen the permissions of an otherwise safe umask(2) value. Note that the umask still applies to the other permission bits (e.g. if umask is 0022, using group will not remove read privileges from other (non-group) users). See 0xxx for how to exactly specify the repository permissions.\n\nSame as group, but make the repository readable by all users.\n\n<perm> is a 3-digit octal number prefixed with 0 and each file will have mode <perm>. <perm> will override users' umask(2) value (and not only loosen permissions as group and all do). 0640 will create a repository which is group-readable, but not group-writable or accessible to others. 0660 will create a repo that is readable and writable to the current user and group, but inaccessible to others (directories and executable files get their x bit from the r bit for corresponding classes of users).\n\nBy default, the configuration flag receive.denyNonFastForwards is enabled in shared repositories, so that you cannot force a non fast-forwarding push into it.\n\nIf you provide a <directory>, the command is run inside it. If this directory does not exist, it will be created.\n\n• files for loose files with packed-refs. This is the default.\n• reftable for the reftable format. This format is experimental and its internals are subject to change.\n\n**-q**: Only print error and warning messages; all other output will be suppressed.\n**--quiet**: Create a bare repository. If GIT_DIR environment is not set, it is set to the current working directory.\n**--bare**: Specify the given object <format> (hash algorithm) for the repository. The valid values are sha1 and (if enabled) sha256. sha1 is the default. Note: At present, there is no interoperability between SHA-256 repositories and SHA-1 repositories.\n**--ref-format=<format>**: Specify the given ref storage <format> for the repository. The valid values are: files for loose files with packed-refs. This is the default. reftable for the reftable format. This format is experimental and its internals are subject to change.\n**--template=<template-directory>**: Specify the directory from which templates will be used. (See the \"TEMPLATE DIRECTORY\" section below.)\n**--separate-git-dir=<git-dir>**: Instead of initializing the repository as a directory to either $GIT_DIR or ./.git/, create a text file there containing the path to the actual repository. This file acts as a filesystem-agnostic Git symbolic link to the repository. If this is a reinitialization, the repository will be moved to the specified path.\n**-b <branch-name>**: Use <branch-name> for the initial branch in the newly created repository. If not specified, fall back to the default name (currently master, but this is subject to change in the future; the name can be customized via the init.defaultBranch configuration variable).\n**--initial-branch=<branch-name>**: Specify that the Git repository is to be shared amongst several users. This allows users belonging to the same group to push into that repository. When specified, the config variable core.sharedRepository is set so that files and directories under $GIT_DIR are created with the requested permissions. When not specified, Git will use permissions reported by umask(2). The option can have the following values, defaulting to group if no value is given: umask false Use permissions reported by umask(2). The default, when --shared is not specified. group true Make the repository group-writable, (and g+sx, since the git group may not be the primary group of all users). This is used to loosen the permissions of an otherwise safe umask(2) value. Note that the umask still applies to the other permission bits (e.g. if umask is 0022, using group will not remove read privileges from other (non-group) users). See 0xxx for how to exactly specify the repository permissions. all world everybody Same as group, but make the repository readable by all users. <perm> <perm> is a 3-digit octal number prefixed with 0 and each file will have mode <perm>. <perm> will override users' umask(2) value (and not only loosen permissions as group and all do). 0640 will create a repository which is group-readable, but not group-writable or accessible to others. 0660 will create a repo that is readable and writable to the current user and group, but inaccessible to others (directories and executable files get their x bit from the r bit for corresponding classes of users).\n**--shared[=(false|true|umask|group|all|world|everybody|<perm>)]**: Use permissions reported by umask(2). The default, when --shared is not specified.\n**umask**: Make the repository group-writable, (and g+sx, since the git group may not be the primary group of all users). This is used to loosen the permissions of an otherwise safe umask(2) value. Note that the umask still applies to the other permission bits (e.g. if umask is 0022, using group will not remove read privileges from other (non-group) users). See 0xxx for how to exactly specify the repository permissions.\n**false**: Same as group, but make the repository readable by all users.\n**group**: <perm> is a 3-digit octal number prefixed with 0 and each file will have mode <perm>. <perm> will override users' umask(2) value (and not only loosen permissions as group and all do). 0640 will create a repository which is group-readable, but not group-writable or accessible to others. 0660 will create a repo that is readable and writable to the current user and group, but inaccessible to others (directories and executable files get their x bit from the r bit for corresponding classes of users).\n**umask**: Use permissions reported by umask(2). The default, when --shared is not specified.\n**false**: Make the repository group-writable, (and g+sx, since the git group may not be the primary group of all users). This is used to loosen the permissions of an otherwise safe umask(2) value. Note that the umask still applies to the other permission bits (e.g. if umask is 0022, using group will not remove read privileges from other (non-group) users). See 0xxx for how to exactly specify the repository permissions.\n**group**: Same as group, but make the repository readable by all users.\n**true**: <perm> is a 3-digit octal number prefixed with 0 and each file will have mode <perm>. <perm> will override users' umask(2) value (and not only loosen permissions as group and all do). 0640 will create a repository which is group-readable, but not group-writable or accessible to others. 0660 will create a repo that is readable and writable to the current user and group, but inaccessible to others (directories and executable files get their x bit from the r bit for corresponding classes of users).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 20,
          "content_length": 9059
        }
      },
      {
        "header": "TEMPLATE DIRECTORY",
        "content": "Files and directories in the template directory whose name do not start with a dot will be copied to the $GIT_DIR after it is created.\n\nThe template directory will be one of the following (in order):\n\nthe argument given with the --template option;\n\nthe contents of the $GIT_TEMPLATE_DIR environment variable;\n\nthe init.templateDir configuration variable; or\n\nthe default template directory: /usr/share/git-core/templates.\n\nThe default template directory includes some directory structure, suggested \"exclude patterns\" (see gitignore[5]), and sample hook files.\n\nThe sample hooks are all disabled by default. To enable one of the sample hooks rename it by removing its .sample suffix.\n\nSee githooks[5] for more general info on hook execution.\n\n• the argument given with the --template option;\n• the contents of the $GIT_TEMPLATE_DIR environment variable;\n• the init.templateDir configuration variable; or\n• the default template directory: /usr/share/git-core/templates.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 968
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Create a /path/to/my/codebase/.git directory.\n\nAdd all existing files to the index.\n\nRecord the pristine state as the first commit in the history.\n\n• Create a /path/to/my/codebase/.git directory.\n• Add all existing files to the index.\n• Record the pristine state as the first commit in the history.\n\n**Start a new Git repository for an existing code base**: $ cd /path/to/my/codebase $ git init (1) $ git add . (2) $ git commit (3) Create a /path/to/my/codebase/.git directory. Add all existing files to the index. Record the pristine state as the first commit in the history.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ cd /path/to/my/codebase\n$ git init(1)$ git add .(2)$ git commit(3)\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 576
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Everything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there:\n\nSpecify the directory from which templates will be copied.\n\nAllows overriding the default branch name e.g. when initializing a new repository.\n\nAllows overriding the default object format for new repositories. See --object-format= in git-init[1]. Both the command line option and the GIT_DEFAULT_HASH environment variable take precedence over this config.\n\nAllows overriding the default ref storage format for new repositories. See --ref-format= in git-init[1]. Both the command line option and the GIT_DEFAULT_REF_FORMAT environment variable take precedence over this config.\n\n**init.templateDir**: Specify the directory from which templates will be copied.\n**init.defaultBranch**: Allows overriding the default branch name e.g. when initializing a new repository.\n**init.defaultObjectFormat**: Allows overriding the default object format for new repositories. See --object-format= in git-init[1]. Both the command line option and the GIT_DEFAULT_HASH environment variable take precedence over this config.\n**init.defaultRefFormat**: Allows overriding the default ref storage format for new repositories. See --ref-format= in git-init[1]. Both the command line option and the GIT_DEFAULT_REF_FORMAT environment variable take precedence over this config.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1407
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-init",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "Git",
    "summary": "SYNOPSIS git log [<options>] [<revision-range>] [[--] <path>…]",
    "sections": [
      {
        "header": "NAME",
        "content": "git-log - Show commit logs",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 26
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Shows the commit logs.\n\nList commits that are reachable by following the parent links from the given commit(s), but exclude commits that are reachable from the one(s) given with a ^ in front of them. The output is given in reverse chronological order by default.\n\nYou can think of this as a set operation. Commits reachable from any of the commits given on the command line form a set, and then commits reachable from any of the ones given with ^ in front are subtracted from that set. The remaining commits are what comes out in the command’s output. Various other options and paths parameters can be used to further limit the result.\n\nThus, the following command:\n\nmeans \"list all the commits which are reachable from foo or bar, but not from baz\".\n\nA special notation \"<commit1>..<commit2>\" can be used as a short-hand for \"^<commit1> <commit2>\". For example, either of the following may be used interchangeably:\n\nAnother special notation is \"<commit1>...<commit2>\" which is useful for merges. The resulting set of commits is the symmetric difference between the two operands. The following two commands are equivalent:\n\nThe command takes options applicable to the git-rev-list[1] command to control what is shown and how, and options applicable to the git-diff[1] command to control how the changes each commit introduces are shown.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git log foo bar ^baz\n```",
          "```bash\n$ git log origin..HEAD\n$ git log HEAD ^origin\n```",
          "```bash\n$ git log A B --not $(git merge-base --all A B)\n$ git log A...B\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1336
        }
      },
      {
        "header": "OPTIONS",
        "content": "Continue listing the history of a file beyond renames (works only for a single file).\n\nPrint out the ref names of any commits that are shown. Possible values are:\n\nThe option --decorate is short-hand for --decorate=short. Default to configuration value of log.decorate if configured, otherwise, auto.\n\nFor each candidate reference, do not use it for decoration if it matches any of the <pattern> parameters given to --decorate-refs-exclude or if it doesn’t match any of the <pattern> parameters given to --decorate-refs. The log.excludeDecoration config option allows excluding refs from the decorations, but an explicit --decorate-refs pattern will override a match in log.excludeDecoration.\n\nIf none of these options or config settings are given, then references are used as decoration if they match HEAD, refs/heads/, refs/remotes/, refs/stash/, or refs/tags/.\n\nWhen specified, this option clears all previous --decorate-refs or --decorate-refs-exclude options and relaxes the default decoration filter to include all references. This option is assumed if the config value log.initialDecorationSet is set to all.\n\nPrint out the ref name given on the command line by which each commit was reached.\n\nUse mailmap file to map author and committer names and email addresses to canonical real names and email addresses. See git-shortlog[1].\n\nWithout this flag, git log -p <path>... shows commits that touch the specified paths, and diffs about the same specified paths. With this, the full diff is shown for commits that touch the specified paths; this means that \"<path>...\" limits only commits, and doesn’t limit diff for those commits.\n\nNote that this affects all diff-based output types, e.g. those produced by --stat, etc.\n\nInclude a line log size <number> in the output for each commit, where <number> is the length of that commit’s message in bytes. Intended to speed up tools that read log messages from git log output by allowing them to allocate space in advance.\n\nTrace the evolution of the line range given by <start>,<end>, or by the function name regex <funcname>, within the <file>. You may not give any pathspec limiters. This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and <start> and <end> (or <funcname>) must exist in the starting revision. You can specify this option more than once. Implies --patch. Patch output can be suppressed using --no-patch, but other diff formats (namely --raw, --numstat, --shortstat, --dirstat, --summary, --name-only, --name-status, --check) are not currently implemented.\n\n<start> and <end> can take one of these forms:\n\nIf <start> or <end> is a number, it specifies an absolute line number (lines count from 1).\n\nThis form will use the first line matching the given POSIX <regex>. If <start> is a regex, it will search from the end of the previous -L range, if any, otherwise from the start of file. If <start> is ^/<regex>/, it will search from the start of file. If <end> is a regex, it will search starting at the line given by <start>.\n\n+<offset> or -<offset>\n\nThis is only valid for <end> and will specify a number of lines before or after the line given by <start>.\n\nIf :<funcname> is given in place of <start> and <end>, it is a regular expression that denotes the range from the first funcname line that matches <funcname>, up to the next funcname line. :<funcname> searches from the end of the previous -L range, if any, otherwise from the start of file. ^:<funcname> searches from the start of file. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes[5]).\n\nShow only commits in the specified revision range. When no <revision-range> is specified, it defaults to HEAD (i.e. the whole history leading to the current commit). origin..HEAD specifies all the commits reachable from the current commit (i.e. HEAD), but not from origin. For a complete list of ways to spell <revision-range>, see the Specifying Ranges section of gitrevisions[7].\n\nShow only commits that are enough to explain how the files that match the specified paths came to be. See History Simplification below for details and other simplification modes.\n\nPaths may need to be prefixed with -- to separate them from options or the revision range, when confusion arises.\n\n• <number> If <start> or <end> is a number, it specifies an absolute line number (lines count from 1).\n• /<regex>/ This form will use the first line matching the given POSIX <regex>. If <start> is a regex, it will search from the end of the previous -L range, if any, otherwise from the start of file. If <start> is ^/<regex>/, it will search from the start of file. If <end> is a regex, it will search starting at the line given by <start>.\n• +<offset> or -<offset> This is only valid for <end> and will specify a number of lines before or after the line given by <start>.\n\n**--follow**: Continue listing the history of a file beyond renames (works only for a single file).\n**--no-decorate**: Print out the ref names of any commits that are shown. Possible values are: `short`;; the ref name prefixes `refs/heads/`, `refs/tags/` and `refs/remotes/` are not printed. `full`;; the full ref name (including prefix) is printed. `auto`:: if the output is going to a terminal, the ref names are shown as if `short` were given, otherwise no ref names are shown. The option --decorate is short-hand for --decorate=short. Default to configuration value of log.decorate if configured, otherwise, auto.\n**--decorate[=(short|full|auto|no)]**: For each candidate reference, do not use it for decoration if it matches any of the <pattern> parameters given to --decorate-refs-exclude or if it doesn’t match any of the <pattern> parameters given to --decorate-refs. The log.excludeDecoration config option allows excluding refs from the decorations, but an explicit --decorate-refs pattern will override a match in log.excludeDecoration. If none of these options or config settings are given, then references are used as decoration if they match HEAD, refs/heads/, refs/remotes/, refs/stash/, or refs/tags/.\n**--decorate-refs=<pattern>**: When specified, this option clears all previous --decorate-refs or --decorate-refs-exclude options and relaxes the default decoration filter to include all references. This option is assumed if the config value log.initialDecorationSet is set to all.\n**--decorate-refs-exclude=<pattern>**: Print out the ref name given on the command line by which each commit was reached.\n**--clear-decorations**: Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses. See git-shortlog[1].\n**--source**: Without this flag, git log -p <path>... shows commits that touch the specified paths, and diffs about the same specified paths. With this, the full diff is shown for commits that touch the specified paths; this means that \"<path>...\" limits only commits, and doesn’t limit diff for those commits. Note that this affects all diff-based output types, e.g. those produced by --stat, etc.\n**--[no-]mailmap**: Include a line log size <number> in the output for each commit, where <number> is the length of that commit’s message in bytes. Intended to speed up tools that read log messages from git log output by allowing them to allocate space in advance.\n**--[no-]use-mailmap**: Trace the evolution of the line range given by <start>,<end>, or by the function name regex <funcname>, within the <file>. You may not give any pathspec limiters. This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and <start> and <end> (or <funcname>) must exist in the starting revision. You can specify this option more than once. Implies --patch. Patch output can be suppressed using --no-patch, but other diff formats (namely --raw, --numstat, --shortstat, --dirstat, --summary, --name-only, --name-status, --check) are not currently implemented. <start> and <end> can take one of these forms: <number> If <start> or <end> is a number, it specifies an absolute line number (lines count from 1). /<regex>/ This form will use the first line matching the given POSIX <regex>. If <start> is a regex, it will search from the end of the previous -L range, if any, otherwise from the start of file. If <start> is ^/<regex>/, it will search from the start of file. If <end> is a regex, it will search starting at the line given by <start>. +<offset> or -<offset> This is only valid for <end> and will specify a number of lines before or after the line given by <start>. If :<funcname> is given in place of <start> and <end>, it is a regular expression that denotes the range from the first funcname line that matches <funcname>, up to the next funcname line. :<funcname> searches from the end of the previous -L range, if any, otherwise from the start of file. ^:<funcname> searches from the start of file. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes[5]).\n**--full-diff**: Show only commits in the specified revision range. When no <revision-range> is specified, it defaults to HEAD (i.e. the whole history leading to the current commit). origin..HEAD specifies all the commits reachable from the current commit (i.e. HEAD), but not from origin. For a complete list of ways to spell <revision-range>, see the Specifying Ranges section of gitrevisions[7].\n**--log-size**: Show only commits that are enough to explain how the files that match the specified paths came to be. See History Simplification below for details and other simplification modes. Paths may need to be prefixed with -- to separate them from options or the revision range, when confusion arises.",
        "code_examples": [
          "```bash\n`short`;; the ref name prefixes `refs/heads/`, `refs/tags/` and\n\t`refs/remotes/` are not printed.\n`full`;; the full ref name (including prefix) is printed.\n`auto`:: if the output is going to a terminal, the ref names\n\tare shown as if `short` were given, otherwise no ref names are\n\tshown.\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 21,
          "content_length": 9860
        }
      },
      {
        "header": "Commit Limiting",
        "content": "Besides specifying a range of commits that should be listed using the special notations explained in the description, additional commit limiting may be applied.\n\nUsing more options generally further limits the output (e.g. --since=<date1> limits to commits newer than <date1>, and using it with --grep=<pattern> further limits to commits whose log message has a line that matches <pattern>), unless otherwise noted.\n\nNote that these are applied before commit ordering and formatting options, such as --reverse.\n\nLimit the output to <number> commits.\n\nSkip <number> commits before starting to show the commit output.\n\nShow commits more recent than <date>.\n\nShow all commits more recent than <date>. This visits all commits in the range, rather than stopping at the first commit which is older than <date>.\n\nShow commits older than <date>.\n\nLimit the commits output to ones with author/committer header lines that match the <pattern> regular expression. With more than one --author=<pattern>, commits whose author matches any of the <pattern> are chosen (similarly for multiple --committer=<pattern>).\n\nLimit the commits output to ones with reflog entries that match the <pattern> regular expression. With more than one --grep-reflog, commits whose reflog message matches any of the given patterns are chosen. It is an error to use this option unless --walk-reflogs is in use.\n\nLimit the commits output to ones with a log message that matches the <pattern> regular expression. With more than one --grep=<pattern>, commits whose message matches any of the <pattern> are chosen (but see --all-match).\n\nWhen --notes is in effect, the message from the notes is matched as if it were part of the log message.\n\nLimit the commits output to ones that match all given --grep, instead of ones that match at least one.\n\nLimit the commits output to ones with a log message that do not match the <pattern> specified with --grep=<pattern>.\n\nMatch the regular expression limiting patterns without regard to letter case.\n\nConsider the limiting patterns to be basic regular expressions; this is the default.\n\nConsider the limiting patterns to be extended regular expressions instead of the default basic regular expressions.\n\nConsider the limiting patterns to be fixed strings (don’t interpret pattern as a regular expression).\n\nConsider the limiting patterns to be Perl-compatible regular expressions.\n\nSupport for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die.\n\nStop when a given path disappears from the tree.\n\nPrint only merge commits. This is exactly the same as --min-parents=2.\n\nDo not print commits with more than one parent. This is exactly the same as --max-parents=1.\n\nShow only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges. --max-parents=0 gives all root commits and --min-parents=3 all octopus merges.\n\n--no-min-parents and --no-max-parents reset these limits (to no limit) again. Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit).\n\nWhen finding commits to include, follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge.\n\nThis option also changes default diff format for merge commits to first-parent, see --diff-merges=first-parent for details.\n\nWhen finding commits to exclude (with a ^), follow only the first parent commit upon seeing a merge commit. This can be used to find the set of changes in a topic branch from the point where it diverged from the remote branch, given that arbitrary merges can be valid topic branch changes.\n\nReverses the meaning of the ^ prefix (or lack thereof) for all following revision specifiers, up to the next --not. When used on the command line before --stdin, the revisions passed through stdin will not be affected by it. Conversely, when passed via standard input, the revisions passed on the command line will not be affected by it.\n\nPretend as if all the refs in refs/, along with HEAD, are listed on the command line as <commit>.\n\nPretend as if all the refs in refs/heads are listed on the command line as <commit>. If <pattern> is given, limit branches to ones matching given shell glob. If <pattern> lacks ?, *, or [, /* at the end is implied.\n\nPretend as if all the refs in refs/tags are listed on the command line as <commit>. If <pattern> is given, limit tags to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied.\n\nPretend as if all the refs in refs/remotes are listed on the command line as <commit>. If <pattern> is given, limit remote-tracking branches to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied.\n\nPretend as if all the refs matching shell glob <glob-pattern> are listed on the command line as <commit>. Leading refs/, is automatically prepended if missing. If pattern lacks ?, *, or [, /* at the end is implied.\n\nDo not include refs matching <glob-pattern> that the next --all, --branches, --tags, --remotes, or --glob would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next --all, --branches, --tags, --remotes, or --glob option (other options or arguments do not clear accumulated patterns).\n\nThe patterns given should not begin with refs/heads, refs/tags, or refs/remotes when applied to --branches, --tags, or --remotes, respectively, and they must begin with refs/ when applied to --glob or --all. If a trailing /* is intended, it must be given explicitly.\n\nDo not include refs that would be hidden by git-fetch, git-receive-pack or git-upload-pack by consulting the appropriate fetch.hideRefs, receive.hideRefs or uploadpack.hideRefs configuration along with transfer.hideRefs (see git-config[1]). This option affects the next pseudo-ref option --all or --glob and is cleared after processing them.\n\nPretend as if all objects mentioned by reflogs are listed on the command line as <commit>.\n\nPretend as if all objects mentioned as ref tips of alternate repositories were listed on the command line. An alternate repository is any repository whose object directory is specified in objects/info/alternates. The set of included objects may be modified by core.alternateRefsCommand, etc. See git-config[1].\n\nBy default, all working trees will be examined by the following options when there are more than one (see git-worktree[1]): --all, --reflog and --indexed-objects. This option forces them to examine the current working tree only.\n\nUpon seeing an invalid object name in the input, pretend as if the bad input was not given.\n\nPretend as if the bad bisection ref refs/bisect/bad was listed and as if it was followed by --not and the good bisection refs refs/bisect/good-* on the command line.\n\nIn addition to getting arguments from the command line, read them from standard input as well. This accepts commits and pseudo-options like --all and --glob=. When a -- separator is seen, the following input is treated as paths and used to limit the result. Flags like --not which are read via standard input are only respected for arguments passed in the same way and will not influence any subsequent command line arguments.\n\nLike --cherry-pick (see below) but mark equivalent commits with = rather than omitting them, and inequivalent ones with +.\n\nOmit any commit that introduces the same change as another commit on the “other side” when the set of commits are limited with symmetric difference.\n\nFor example, if you have two branches, A and B, a usual way to list all commits on only one side of them is with --left-right (see the example below in the description of the --left-right option). However, it shows the commits that were cherry-picked from the other branch (for example, “3rd on b” may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output.\n\nList only commits on the respective side of a symmetric difference, i.e. only those which would be marked < resp. > by --left-right.\n\nFor example, --cherry-pick --right-only A...B omits those commits from B which are in A or are patch-equivalent to a commit in A. In other words, this lists the + commits from git cherry A B. More precisely, --cherry-pick --right-only --no-merges gives the exact list.\n\nA synonym for --right-only --cherry-mark --no-merges; useful to limit the output to the commits on our side and mark those that have been applied to the other side of a forked history with git log --cherry upstream...mybranch, similar to git cherry upstream mybranch.\n\nInstead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, ^<commit>, <commit1>..<commit2>, and <commit1>...<commit2> notations cannot be used).\n\nWith --pretty format other than oneline and reference (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as ref@{<Nth>} (where <Nth> is the reverse-chronological index in the reflog) or as ref@{<timestamp>} (with the <timestamp> for that entry), depending on a few rules:\n\nIf the starting point is specified as ref@{<Nth>}, show the index format.\n\nIf the starting point was specified as ref@{now}, show the timestamp format.\n\nIf neither was used, but --date was given on the command line, show the timestamp in the format requested by --date.\n\nOtherwise, show the index format.\n\nUnder --pretty=oneline, the commit message is prefixed with this information on the same line. This option cannot be combined with --reverse. See also git-reflog[1].\n\nUnder --pretty=reference, this information will not be shown at all.\n\nShow commits touching conflicted paths in the range HEAD...<other>, where <other> is the first existing pseudoref in MERGE_HEAD, CHERRY_PICK_HEAD, REVERT_HEAD or REBASE_HEAD. Only works when the index has unmerged entries. This option can be used to show relevant commits when resolving conflicts from a 3-way merge.\n\nOutput excluded boundary commits. Boundary commits are prefixed with -.\n\n• If the starting point is specified as ref@{<Nth>}, show the index format.\n• If the starting point was specified as ref@{now}, show the timestamp format.\n• If neither was used, but --date was given on the command line, show the timestamp in the format requested by --date.\n• Otherwise, show the index format.\n\n**-<number>**: Limit the output to <number> commits.\n**-n <number>**: Skip <number> commits before starting to show the commit output.\n**--max-count=<number>**: Show commits more recent than <date>.\n**--skip=<number>**: Show all commits more recent than <date>. This visits all commits in the range, rather than stopping at the first commit which is older than <date>.\n**--since=<date>**: Show commits older than <date>.\n**--after=<date>**: Limit the commits output to ones with author/committer header lines that match the <pattern> regular expression. With more than one --author=<pattern>, commits whose author matches any of the <pattern> are chosen (similarly for multiple --committer=<pattern>).\n**--since-as-filter=<date>**: Limit the commits output to ones with reflog entries that match the <pattern> regular expression. With more than one --grep-reflog, commits whose reflog message matches any of the given patterns are chosen. It is an error to use this option unless --walk-reflogs is in use.\n**--until=<date>**: Limit the commits output to ones with a log message that matches the <pattern> regular expression. With more than one --grep=<pattern>, commits whose message matches any of the <pattern> are chosen (but see --all-match). When --notes is in effect, the message from the notes is matched as if it were part of the log message.\n**--before=<date>**: Limit the commits output to ones that match all given --grep, instead of ones that match at least one.\n**--author=<pattern>**: Limit the commits output to ones with a log message that do not match the <pattern> specified with --grep=<pattern>.\n**--committer=<pattern>**: Match the regular expression limiting patterns without regard to letter case.\n**--grep-reflog=<pattern>**: Consider the limiting patterns to be basic regular expressions; this is the default.\n**--grep=<pattern>**: Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions.\n**--all-match**: Consider the limiting patterns to be fixed strings (don’t interpret pattern as a regular expression).\n**--invert-grep**: Consider the limiting patterns to be Perl-compatible regular expressions. Support for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die.\n**-i**: Stop when a given path disappears from the tree.\n**--regexp-ignore-case**: Print only merge commits. This is exactly the same as --min-parents=2.\n**--basic-regexp**: Do not print commits with more than one parent. This is exactly the same as --max-parents=1.\n**-E**: Show only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges. --max-parents=0 gives all root commits and --min-parents=3 all octopus merges. --no-min-parents and --no-max-parents reset these limits (to no limit) again. Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit).\n**--extended-regexp**: When finding commits to include, follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge. This option also changes default diff format for merge commits to first-parent, see --diff-merges=first-parent for details.\n**-F**: When finding commits to exclude (with a ^), follow only the first parent commit upon seeing a merge commit. This can be used to find the set of changes in a topic branch from the point where it diverged from the remote branch, given that arbitrary merges can be valid topic branch changes.\n**--fixed-strings**: Reverses the meaning of the ^ prefix (or lack thereof) for all following revision specifiers, up to the next --not. When used on the command line before --stdin, the revisions passed through stdin will not be affected by it. Conversely, when passed via standard input, the revisions passed on the command line will not be affected by it.\n**-P**: Pretend as if all the refs in refs/, along with HEAD, are listed on the command line as <commit>.\n**--perl-regexp**: Pretend as if all the refs in refs/heads are listed on the command line as <commit>. If <pattern> is given, limit branches to ones matching given shell glob. If <pattern> lacks ?, *, or [, /* at the end is implied.\n**--remove-empty**: Pretend as if all the refs in refs/tags are listed on the command line as <commit>. If <pattern> is given, limit tags to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied.\n**--merges**: Pretend as if all the refs in refs/remotes are listed on the command line as <commit>. If <pattern> is given, limit remote-tracking branches to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied.\n**--no-merges**: Pretend as if all the refs matching shell glob <glob-pattern> are listed on the command line as <commit>. Leading refs/, is automatically prepended if missing. If pattern lacks ?, *, or [, /* at the end is implied.\n**--min-parents=<number>**: Do not include refs matching <glob-pattern> that the next --all, --branches, --tags, --remotes, or --glob would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next --all, --branches, --tags, --remotes, or --glob option (other options or arguments do not clear accumulated patterns). The patterns given should not begin with refs/heads, refs/tags, or refs/remotes when applied to --branches, --tags, or --remotes, respectively, and they must begin with refs/ when applied to --glob or --all. If a trailing /* is intended, it must be given explicitly.\n**--max-parents=<number>**: Do not include refs that would be hidden by git-fetch, git-receive-pack or git-upload-pack by consulting the appropriate fetch.hideRefs, receive.hideRefs or uploadpack.hideRefs configuration along with transfer.hideRefs (see git-config[1]). This option affects the next pseudo-ref option --all or --glob and is cleared after processing them.\n**--no-min-parents**: Pretend as if all objects mentioned by reflogs are listed on the command line as <commit>.\n**--no-max-parents**: Pretend as if all objects mentioned as ref tips of alternate repositories were listed on the command line. An alternate repository is any repository whose object directory is specified in objects/info/alternates. The set of included objects may be modified by core.alternateRefsCommand, etc. See git-config[1].\n**--first-parent**: By default, all working trees will be examined by the following options when there are more than one (see git-worktree[1]): --all, --reflog and --indexed-objects. This option forces them to examine the current working tree only.\n**--exclude-first-parent-only**: Upon seeing an invalid object name in the input, pretend as if the bad input was not given.\n**--not**: Pretend as if the bad bisection ref refs/bisect/bad was listed and as if it was followed by --not and the good bisection refs refs/bisect/good-* on the command line.\n**--all**: In addition to getting arguments from the command line, read them from standard input as well. This accepts commits and pseudo-options like --all and --glob=. When a -- separator is seen, the following input is treated as paths and used to limit the result. Flags like --not which are read via standard input are only respected for arguments passed in the same way and will not influence any subsequent command line arguments.\n**--branches[=<pattern>]**: Like --cherry-pick (see below) but mark equivalent commits with = rather than omitting them, and inequivalent ones with +.\n**--tags[=<pattern>]**: Omit any commit that introduces the same change as another commit on the “other side” when the set of commits are limited with symmetric difference. For example, if you have two branches, A and B, a usual way to list all commits on only one side of them is with --left-right (see the example below in the description of the --left-right option). However, it shows the commits that were cherry-picked from the other branch (for example, “3rd on b” may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output.\n**--remotes[=<pattern>]**: List only commits on the respective side of a symmetric difference, i.e. only those which would be marked < resp. > by --left-right. For example, --cherry-pick --right-only A...B omits those commits from B which are in A or are patch-equivalent to a commit in A. In other words, this lists the + commits from git cherry A B. More precisely, --cherry-pick --right-only --no-merges gives the exact list.\n**--glob=<glob-pattern>**: A synonym for --right-only --cherry-mark --no-merges; useful to limit the output to the commits on our side and mark those that have been applied to the other side of a forked history with git log --cherry upstream...mybranch, similar to git cherry upstream mybranch.\n**--exclude=<glob-pattern>**: Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, ^<commit>, <commit1>..<commit2>, and <commit1>...<commit2> notations cannot be used). With --pretty format other than oneline and reference (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as ref@{<Nth>} (where <Nth> is the reverse-chronological index in the reflog) or as ref@{<timestamp>} (with the <timestamp> for that entry), depending on a few rules: If the starting point is specified as ref@{<Nth>}, show the index format. If the starting point was specified as ref@{now}, show the timestamp format. If neither was used, but --date was given on the command line, show the timestamp in the format requested by --date. Otherwise, show the index format. Under --pretty=oneline, the commit message is prefixed with this information on the same line. This option cannot be combined with --reverse. See also git-reflog[1]. Under --pretty=reference, this information will not be shown at all.\n**--exclude-hidden=(fetch|receive|uploadpack)**: Show commits touching conflicted paths in the range HEAD...<other>, where <other> is the first existing pseudoref in MERGE_HEAD, CHERRY_PICK_HEAD, REVERT_HEAD or REBASE_HEAD. Only works when the index has unmerged entries. This option can be used to show relevant commits when resolving conflicts from a 3-way merge.\n**--reflog**: Output excluded boundary commits. Boundary commits are prefixed with -.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 59,
          "content_length": 21774
        }
      },
      {
        "header": "History Simplification",
        "content": "Sometimes you are only interested in parts of the history, for example the commits modifying a particular <path>. But there are two parts of History Simplification, one part is selecting the commits and the other is how to do it, as there are various strategies to simplify the history.\n\nThe following options select the commits to be shown:\n\nCommits modifying the given <paths> are selected.\n\nCommits that are referred by some branch or tag are selected.\n\nNote that extra commits can be shown to give a meaningful history.\n\nThe following options affect the way the simplification is performed:\n\nSimplifies the history to the simplest history explaining the final state of the tree. Simplest because it prunes some side branches if the end result is the same (i.e. merging branches with the same content)\n\nInclude all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent. This mode is helpful for showing the merge commits that \"first introduced\" a change to a branch.\n\nSame as the default mode, but does not prune some history.\n\nOnly the selected commits are shown, plus some to have a meaningful history.\n\nAll commits in the simplified history are shown.\n\nAdditional option to --full-history to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge.\n\nWhen given a range of commits to display (e.g. <commit1>..<commit2> or <commit2> ^<commit1>), and a commit <commit> in that range, only display commits in that range that are ancestors of <commit>, descendants of <commit>, or <commit> itself. If no commit is specified, use <commit1> (the excluded part of the range) as <commit>. Can be passed multiple times; if so, a commit is included if it is any of the commits given or if it is an ancestor or descendant of one of them.\n\nA more detailed explanation follows.\n\nSuppose you specified foo as the <paths>. We shall call commits that modify foo !TREESAME, and the rest TREESAME. (In a diff filtered for foo, they look different and equal, respectively.)\n\nIn the following, we will always refer to the same example history to illustrate the differences between simplification settings. We assume that you are filtering for a file foo in this commit graph:\n\nThe horizontal line of history A---Q is taken to be the first parent of each merge. The commits are:\n\nI is the initial commit, in which foo exists with contents asdf, and a file quux exists with contents quux. Initial commits are compared to an empty tree, so I is !TREESAME.\n\nIn A, foo contains just foo.\n\nB contains the same change as A. Its merge M is trivial and hence TREESAME to all parents.\n\nC does not change foo, but its merge N changes it to foobar, so it is not TREESAME to any parent.\n\nD sets foo to baz. Its merge O combines the strings from N and D to foobarbaz; i.e., it is not TREESAME to any parent.\n\nE changes quux to xyzzy, and its merge P combines the strings to quux xyzzy. P is TREESAME to O, but not to E.\n\nX is an independent root commit that added a new file side, and Y modified it. Y is TREESAME to X. Its merge Q added side to P, and Q is TREESAME to P, but not to Y.\n\nrev-list walks backwards through history, including or excluding commits based on whether --full-history and/or parent rewriting (via --parents or --children) are used. The following settings are available.\n\nCommits are included if they are not TREESAME to any parent (though this can be changed, see --sparse below). If the commit was a merge, and it was TREESAME to one parent, follow only that parent. (Even if there are several TREESAME parents, follow only one of them.) Otherwise, follow all parents.\n\nNote how the rule to only follow the TREESAME parent, if one is available, removed B from consideration entirely. C was considered via N, but is TREESAME. Root commits are compared to an empty tree, so I is !TREESAME.\n\nParent/child relations are only visible with --parents, but that does not affect the commits selected in default mode, so we have shown the parent lines.\n\nThis mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is! In the example, we get\n\nM was excluded because it is TREESAME to both parents. E, C and B were all walked, but only B was !TREESAME, so the others do not appear.\n\nNote that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected.\n\nOrdinary commits are only included if they are !TREESAME (though this can be changed, see --sparse below).\n\nMerges are always included. However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves. This results in\n\nCompare to --full-history without rewriting above. Note that E was pruned away because it is TREESAME, but the parent list of P was rewritten to contain E's parent I. The same happened for C and N, and X, Y and Q.\n\nIn addition to the above settings, you can change whether TREESAME affects inclusion:\n\nCommits that are walked are included if they are not TREESAME to any parent.\n\nAll commits that are walked are included.\n\nNote that without --full-history, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked.\n\nFirst, build a history graph in the same way that --full-history with parent rewriting does (see above).\n\nThen simplify each commit C to its replacement C' in the final history according to the following rules:\n\nReplace each parent P of C' with its simplification P'. In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to.\n\nIf after this parent rewriting, C' is a root or merge commit (has zero or >1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent.\n\nThe effect of this is best shown by way of comparing to --full-history with parent rewriting. The example turns into:\n\nNote the major differences in N, P, and Q over --full-history:\n\nN's parent list had I removed, because it is an ancestor of the other parent M. Still, N remained because it is !TREESAME.\n\nP's parent list similarly had I removed. P was then removed completely, because it had one parent and is TREESAME.\n\nQ's parent list had Y simplified to X. X was then removed, because it was a TREESAME root. Q was then removed completely, because it had one parent and is TREESAME.\n\nThere is another simplification mode available:\n\nLimit the displayed commits to those which are an ancestor of <commit>, or which are a descendant of <commit>, or are <commit> itself.\n\nAs an example use case, consider the following commit history:\n\nA regular D..M computes the set of commits that are ancestors of M, but excludes the ones that are ancestors of D. This is useful to see what happened to the history leading to M since D, in the sense that \"what does M have that did not exist in D\". The result in this example would be all the commits, except A and B (and D itself, of course).\n\nWhen we want to find out what commits in M are contaminated with the bug introduced by D and need fixing, however, we might want to view only the subset of D..M that are actually descendants of D, i.e. excluding C and K. This is exactly what the --ancestry-path option does. Applied to the D..M range, it results in:\n\nWe can also use --ancestry-path=D instead of --ancestry-path which means the same thing when applied to the D..M range but is just more explicit.\n\nIf we instead are interested in a given topic within this range, and all commits affected by that topic, we may only want to view the subset of D..M which contain that topic in their ancestry path. So, using --ancestry-path=H D..M for example would result in:\n\nWhereas --ancestry-path=K D..M would result in\n\nBefore discussing another option, --show-pulls, we need to create a new example history.\n\nA common problem users face when looking at simplified history is that a commit they know changed a file somehow does not appear in the file’s simplified history. Let’s demonstrate a new example and show how options such as --full-history and --simplify-merges works in that case:\n\nFor this example, suppose I created file.txt which was modified by A, B, and X in different ways. The single-parent commits C, Z, and Y do not change file.txt. The merge commit M was created by resolving the merge conflict to include both changes from A and B and hence is not TREESAME to either. The merge commit R, however, was created by ignoring the contents of file.txt at M and taking only the contents of file.txt at X. Hence, R is TREESAME to X but not M. Finally, the natural merge resolution to create N is to take the contents of file.txt at R, so N is TREESAME to R but not C. The merge commits O and P are TREESAME to their first parents, but not to their second parents, Z and Y respectively.\n\nWhen using the default mode, N and R both have a TREESAME parent, so those edges are walked and the others are ignored. The resulting history graph is:\n\nWhen using --full-history, Git walks every edge. This will discover the commits A and B and the merge M, but also will reveal the merge commits O and P. With parent rewriting, the resulting graph is:\n\nHere, the merge commits O and P contribute extra noise, as they did not actually contribute a change to file.txt. They only merged a topic that was based on an older version of file.txt. This is a common issue in repositories using a workflow where many contributors work in parallel and merge their topic branches along a single trunk: many unrelated merges appear in the --full-history results.\n\nWhen using the --simplify-merges option, the commits O and P disappear from the results. This is because the rewritten second parents of O and P are reachable from their first parents. Those edges are removed and then the commits look like single-parent commits that are TREESAME to their parent. This also happens to the commit N, resulting in a history view as follows:\n\nIn this view, we see all of the important single-parent changes from A, B, and X. We also see the carefully-resolved merge M and the not-so-carefully-resolved merge R. This is usually enough information to determine why the commits A and B \"disappeared\" from history in the default view. However, there are a few issues with this approach.\n\nThe first issue is performance. Unlike any previous option, the --simplify-merges option requires walking the entire commit history before returning a single result. This can make the option difficult to use for very large repositories.\n\nThe second issue is one of auditing. When many contributors are working on the same repository, it is important which merge commits introduced a change into an important branch. The problematic merge R above is not likely to be the merge commit that was used to merge into an important branch. Instead, the merge N was used to merge R and X into the important branch. This commit may have information about why the change X came to override the changes from A and B in its commit message.\n\nIn addition to the commits shown in the default history, show each merge commit that is not TREESAME to its first parent but is TREESAME to a later parent.\n\nWhen a merge commit is included by --show-pulls, the merge is treated as if it \"pulled\" the change from another branch. When using --show-pulls on this example (and no other options) the resulting graph is:\n\nHere, the merge commits R and N are included because they pulled the commits X and R into the base branch, respectively. These merges are the reason the commits A and B do not appear in the default history.\n\nWhen --show-pulls is paired with --simplify-merges, the graph includes all of the necessary information:\n\nNotice that since M is reachable from R, the edge from N to M was simplified away. However, N still appears in the history as an important commit because it \"pulled\" the change R into the main branch.\n\nThe --simplify-by-decoration option allows you to view only the big picture of the topology of the history, by omitting commits that are not referenced by tags. Commits are marked as !TREESAME (in other words, kept after history simplification rules described above) if (1) they are referenced by tags, or (2) they change the contents of the paths given on the command line. All other commits are marked as TREESAME (subject to be simplified away).\n\n• I is the initial commit, in which foo exists with contents asdf, and a file quux exists with contents quux. Initial commits are compared to an empty tree, so I is !TREESAME.\n• In A, foo contains just foo.\n• B contains the same change as A. Its merge M is trivial and hence TREESAME to all parents.\n• C does not change foo, but its merge N changes it to foobar, so it is not TREESAME to any parent.\n• D sets foo to baz. Its merge O combines the strings from N and D to foobarbaz; i.e., it is not TREESAME to any parent.\n• E changes quux to xyzzy, and its merge P combines the strings to quux xyzzy. P is TREESAME to O, but not to E.\n• X is an independent root commit that added a new file side, and Y modified it. Y is TREESAME to X. Its merge Q added side to P, and Q is TREESAME to P, but not to Y.\n\n• Set C' to C.\n• Replace each parent P of C' with its simplification P'. In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to.\n• If after this parent rewriting, C' is a root or merge commit (has zero or >1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent.\n\n• N's parent list had I removed, because it is an ancestor of the other parent M. Still, N remained because it is !TREESAME.\n• P's parent list similarly had I removed. P was then removed completely, because it had one parent and is TREESAME.\n• Q's parent list had Y simplified to X. X was then removed, because it was a TREESAME root. Q was then removed completely, because it had one parent and is TREESAME.\n\n**<paths>**: Commits modifying the given <paths> are selected.\n**--simplify-by-decoration**: Commits that are referred by some branch or tag are selected.\n**Default mode**: Simplifies the history to the simplest history explaining the final state of the tree. Simplest because it prunes some side branches if the end result is the same (i.e. merging branches with the same content)\n**--show-pulls**: Include all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent. This mode is helpful for showing the merge commits that \"first introduced\" a change to a branch.\n**--full-history**: Same as the default mode, but does not prune some history.\n**--dense**: Only the selected commits are shown, plus some to have a meaningful history.\n**--sparse**: All commits in the simplified history are shown.\n**--simplify-merges**: Additional option to --full-history to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge.\n**--ancestry-path[=<commit>]**: When given a range of commits to display (e.g. <commit1>..<commit2> or <commit2> ^<commit1>), and a commit <commit> in that range, only display commits in that range that are ancestors of <commit>, descendants of <commit>, or <commit> itself. If no commit is specified, use <commit1> (the excluded part of the range) as <commit>. Can be passed multiple times; if so, a commit is included if it is any of the commits given or if it is an ancestor or descendant of one of them.\n**Default mode**: Commits are included if they are not TREESAME to any parent (though this can be changed, see --sparse below). If the commit was a merge, and it was TREESAME to one parent, follow only that parent. (Even if there are several TREESAME parents, follow only one of them.) Otherwise, follow all parents. This results in: .-A---N---O / / / I---------D Note how the rule to only follow the TREESAME parent, if one is available, removed B from consideration entirely. C was considered via N, but is TREESAME. Root commits are compared to an empty tree, so I is !TREESAME. Parent/child relations are only visible with --parents, but that does not affect the commits selected in default mode, so we have shown the parent lines.\n**--full-history without parent rewriting**: This mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is! In the example, we get I A B N D O P Q M was excluded because it is TREESAME to both parents. E, C and B were all walked, but only B was !TREESAME, so the others do not appear. Note that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected.\n**--full-history with parent rewriting**: Ordinary commits are only included if they are !TREESAME (though this can be changed, see --sparse below). Merges are always included. However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves. This results in .-A---M---N---O---P---Q / / / / / I B / D / \\ / / / / `-------------' Compare to --full-history without rewriting above. Note that E was pruned away because it is TREESAME, but the parent list of P was rewritten to contain E's parent I. The same happened for C and N, and X, Y and Q.\n**--dense**: Commits that are walked are included if they are not TREESAME to any parent.\n**--sparse**: All commits that are walked are included. Note that without --full-history, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked.\n**--simplify-merges**: First, build a history graph in the same way that --full-history with parent rewriting does (see above). Then simplify each commit C to its replacement C' in the final history according to the following rules: Set C' to C. Replace each parent P of C' with its simplification P'. In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to. If after this parent rewriting, C' is a root or merge commit (has zero or >1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent. The effect of this is best shown by way of comparing to --full-history with parent rewriting. The example turns into: .-A---M---N---O / / / I B D \\ / / `---------' Note the major differences in N, P, and Q over --full-history: N's parent list had I removed, because it is an ancestor of the other parent M. Still, N remained because it is !TREESAME. P's parent list similarly had I removed. P was then removed completely, because it had one parent and is TREESAME. Q's parent list had Y simplified to X. X was then removed, because it was a TREESAME root. Q was then removed completely, because it had one parent and is TREESAME.\n**--ancestry-path[=<commit>]**: Limit the displayed commits to those which are an ancestor of <commit>, or which are a descendant of <commit>, or are <commit> itself. As an example use case, consider the following commit history: D---E-------F / \\ \\ B---C---G---H---I---J / \\ A-------K---------------L--M A regular D..M computes the set of commits that are ancestors of M, but excludes the ones that are ancestors of D. This is useful to see what happened to the history leading to M since D, in the sense that \"what does M have that did not exist in D\". The result in this example would be all the commits, except A and B (and D itself, of course). When we want to find out what commits in M are contaminated with the bug introduced by D and need fixing, however, we might want to view only the subset of D..M that are actually descendants of D, i.e. excluding C and K. This is exactly what the --ancestry-path option does. Applied to the D..M range, it results in: E-------F \\ \\ G---H---I---J \\ L--M We can also use --ancestry-path=D instead of --ancestry-path which means the same thing when applied to the D..M range but is just more explicit. If we instead are interested in a given topic within this range, and all commits affected by that topic, we may only want to view the subset of D..M which contain that topic in their ancestry path. So, using --ancestry-path=H D..M for example would result in: E \\ C---G---H---I---J \\ L--M Whereas --ancestry-path=K D..M would result in K---------------L--M\n**--show-pulls**: In addition to the commits shown in the default history, show each merge commit that is not TREESAME to its first parent but is TREESAME to a later parent. When a merge commit is included by --show-pulls, the merge is treated as if it \"pulled\" the change from another branch. When using --show-pulls on this example (and no other options) the resulting graph is: I---X---R---N Here, the merge commits R and N are included because they pulled the commits X and R into the base branch, respectively. These merges are the reason the commits A and B do not appear in the default history. When --show-pulls is paired with --simplify-merges, the graph includes all of the necessary information: .-A---M--. N / / \\ / I B R \\ / / \\ / / `---X--' Notice that since M is reachable from R, the edge from N to M was simplified away. However, N still appears in the history as an important commit because it \"pulled\" the change R into the main branch.",
        "code_examples": [
          "```bash\n.-A---M---N---O---P---Q\n\t /     /   /   /   /   /\n\tI     B   C   D   E   Y\n\t \\   /   /   /   /   /\n\t  `-------------'   X\n```",
          "```bash\n.-A---N---O\n\t /     /   /\n\tI---------D\n```",
          "```bash\nI  A  B  N  D  O  P  Q\n```",
          "```bash\n.-A---M---N---O---P---Q\n\t /     /   /   /   /\n\tI     B   /   D   /\n\t \\   /   /   /   /\n\t  `-------------'\n```",
          "```bash\n.-A---M---N---O\n\t /     /       /\n\tI     B       D\n\t \\   /       /\n\t  `---------'\n```",
          "```bash\nD---E-------F\n\t   /     \\       \\\n\t  B---C---G---H---I---J\n\t /                     \\\n\tA-------K---------------L--M\n```",
          "```bash\nE-------F\n\t\t \\       \\\n\t\t  G---H---I---J\n\t\t\t       \\\n\t\t\t\tL--M\n```",
          "```bash\nE\n\t\t \\\n\t      C---G---H---I---J\n\t\t\t       \\\n\t\t\t\tL--M\n```",
          "```bash\nK---------------L--M\n```",
          "```bash\n.-A---M-----C--N---O---P\n\t /     / \\  \\  \\/   /   /\n\tI     B   \\  R-'`-Z'   /\n\t \\   /     \\/         /\n\t  \\ /      /\\        /\n\t   `---X--'  `---Y--'\n```",
          "```bash\n.-A---M--------N---O---P\n\t /     / \\  \\  \\/   /   /\n\tI     B   \\  R-'`--'   /\n\t \\   /     \\/         /\n\t  \\ /      /\\        /\n\t   `---X--'  `------'\n```",
          "```bash\n.-A---M--.\n\t /     /    \\\n\tI     B      R\n\t \\   /      /\n\t  \\ /      /\n\t   `---X--'\n```",
          "```bash\nI---X---R---N\n```",
          "```bash\n.-A---M--.   N\n\t /     /    \\ /\n\tI     B      R\n\t \\   /      /\n\t  \\ /      /\n\t   `---X--'\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 71,
          "content_length": 22013
        }
      },
      {
        "header": "Commit Ordering",
        "content": "By default, the commits are shown in reverse chronological order.\n\nShow no parents before all of its children are shown, but otherwise show commits in the commit timestamp order.\n\nShow no parents before all of its children are shown, but otherwise show commits in the author timestamp order.\n\nShow no parents before all of its children are shown, and avoid showing commits on multiple lines of history intermixed.\n\nFor example, in a commit history like this:\n\nwhere the numbers denote the order of commit timestamps, git rev-list and friends with --date-order show the commits in the timestamp order: 8 7 6 5 4 3 2 1.\n\nWith --topo-order, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown before newer ones in order to avoid showing the commits from two parallel development track mixed together.\n\nOutput the commits chosen to be shown (see Commit Limiting section above) in reverse order. Cannot be combined with --walk-reflogs.\n\n**--date-order**: Show no parents before all of its children are shown, but otherwise show commits in the commit timestamp order.\n**--author-date-order**: Show no parents before all of its children are shown, but otherwise show commits in the author timestamp order.\n**--topo-order**: Show no parents before all of its children are shown, and avoid showing commits on multiple lines of history intermixed. For example, in a commit history like this: ---1----2----4----7 \\ \\ 3----5----6----8--- where the numbers denote the order of commit timestamps, git rev-list and friends with --date-order show the commits in the timestamp order: 8 7 6 5 4 3 2 1. With --topo-order, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown before newer ones in order to avoid showing the commits from two parallel development track mixed together.\n**--reverse**: Output the commits chosen to be shown (see Commit Limiting section above) in reverse order. Cannot be combined with --walk-reflogs.",
        "code_examples": [
          "```bash\n---1----2----4----7\n\t\\\t       \\\n\t 3----5----6----8---\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1971
        }
      },
      {
        "header": "Object Traversal",
        "content": "These options are mostly targeted for packing of Git repositories.\n\nOnly show the given commits, but do not traverse their ancestors. This has no effect if a range is specified. If the argument unsorted is given, the commits are shown in the order they were given on the command line. Otherwise (if sorted or no argument was given), the commits are shown in reverse chronological order by commit time. Cannot be combined with --graph.\n\nOverrides a previous --no-walk.\n\n**--no-walk[=(sorted|unsorted)]**: Only show the given commits, but do not traverse their ancestors. This has no effect if a range is specified. If the argument unsorted is given, the commits are shown in the order they were given on the command line. Otherwise (if sorted or no argument was given), the commits are shown in reverse chronological order by commit time. Cannot be combined with --graph.\n**--do-walk**: Overrides a previous --no-walk.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 917
        }
      },
      {
        "header": "Commit Formatting",
        "content": "Pretty-print the contents of the commit logs in a given format, where <format> can be one of oneline, short, medium, full, fuller, reference, email, raw, format:<string> and tformat:<string>. When <format> is none of the above, and has %<placeholder> in it, it acts as if --pretty=tformat:<format> were given.\n\nSee the \"PRETTY FORMATS\" section for some additional details for each format. When =<format> part is omitted, it defaults to medium.\n\nInstead of showing the full 40-byte hexadecimal commit object name, show a prefix that names the object uniquely. --abbrev=<n> (which also modifies diff output, if it is displayed) option can be used to specify the minimum length of the prefix.\n\nThis should make --pretty=oneline a whole lot more readable for people using 80-column terminals.\n\nShow the full 40-byte hexadecimal commit object name. This negates --abbrev-commit, either explicit or implied by other options such as --oneline. It also overrides the log.abbrevCommit variable.\n\nThis is a shorthand for --pretty=oneline --abbrev-commit used together.\n\nCommit objects record the character encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user. For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in X and we are outputting in X, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output. Likewise, if iconv(3) fails to convert the commit, we will quietly output the original object verbatim.\n\nPerform a tab expansion (replace each tab with enough spaces to fill to the next display column that is a multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion.\n\nBy default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e. medium, which is the default, full, and fuller).\n\nShow the notes (see git-notes[1]) that annotate the commit, when showing the commit log message. This is the default for git log, git show and git whatchanged commands when there is no --pretty, --format, or --oneline option given on the command line.\n\nBy default, the notes shown are from the notes refs listed in the core.notesRef and notes.displayRef variables (or corresponding environment overrides). See git-config[1] for more details.\n\nWith an optional <ref> argument, use the ref to find the notes to display. The ref can specify the full refname when it begins with refs/notes/; when it begins with notes/, refs/ and otherwise refs/notes/ is prefixed to form the full name of the ref.\n\nMultiple --notes options can be combined to control which notes are being displayed. Examples: \"--notes=foo\" will show only notes from refs/notes/foo; \"--notes=foo --notes\" will show both notes from \"refs/notes/foo\" and from the default notes ref(s).\n\nDo not show notes. This negates the above --notes option, by resetting the list of notes refs from which notes are shown. Options are parsed in the order given on the command line, so e.g. \"--notes --notes=foo --no-notes --notes=bar\" will only show notes from refs/notes/bar.\n\nShow the default notes unless options for displaying specific notes are given.\n\nThese options are deprecated. Use the above --notes/--no-notes options instead.\n\nCheck the validity of a signed commit object by passing the signature to gpg --verify and show the output.\n\nSynonym for --date=relative.\n\nOnly takes effect for dates shown in human-readable format, such as when using --pretty. log.date config variable sets a default value for the log command’s --date option. By default, dates are shown in the original time zone (either committer’s or author’s). If -local is appended to the format (e.g., iso-local), the user’s local time zone is used instead.\n\n--date=relative shows dates relative to the current time, e.g. “2 hours ago”. The -local option has no effect for --date=relative.\n\n--date=local is an alias for --date=default-local.\n\n--date=iso (or --date=iso8601) shows timestamps in a ISO 8601-like format. The differences to the strict ISO 8601 format are:\n\na space instead of the T date/time delimiter\n\na space between time and time zone\n\nno colon between hours and minutes of the time zone\n\n--date=iso-strict (or --date=iso8601-strict) shows timestamps in strict ISO 8601 format.\n\n--date=rfc (or --date=rfc2822) shows timestamps in RFC 2822 format, often found in email messages.\n\n--date=short shows only the date, but not the time, in YYYY-MM-DD format.\n\n--date=raw shows the date as seconds since the epoch (1970-01-01 00:00:00 UTC), followed by a space, and then the timezone as an offset from UTC (a + or - with four digits; the first two are hours, and the second two are minutes). I.e., as if the timestamp were formatted with strftime(\"%s %z\")). Note that the -local option does not affect the seconds-since-epoch value (which is always measured in UTC), but does switch the accompanying timezone value.\n\n--date=human shows the timezone if the timezone does not match the current time-zone, and doesn’t print the whole date if that matches (ie skip printing year for dates that are \"this year\", but also skip the whole date itself if it’s in the last few days and we can just say what weekday it was). For older dates the hour and minute is also omitted.\n\n--date=unix shows the date as a Unix epoch timestamp (seconds since 1970). As with --raw, this is always in UTC and therefore -local has no effect.\n\n--date=format:<format> feeds the <format> to your system strftime, except for %s, %z, and %Z, which are handled internally. Use --date=format:%c to show the date in your system locale’s preferred format. See the strftime(3) manual for a complete list of format placeholders. When using -local, the correct syntax is --date=format-local:<format>.\n\n--date=default is the default format, and is based on ctime(3) output. It shows a single line with three-letter day of the week, three-letter month, day-of-month, hour-minute-seconds in \"HH:MM:SS\" format, followed by 4-digit year, plus timezone information, unless the local time zone is used, e.g. Thu Jan 1 00:00:00 1970 +0000.\n\nPrint also the parents of the commit (in the form \"commit parent…\"). Also enables parent rewriting, see History Simplification above.\n\nPrint also the children of the commit (in the form \"commit child…\"). Also enables parent rewriting, see History Simplification above.\n\nMark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with < and those from the right with >. If combined with --boundary, those commits are prefixed with -.\n\nFor example, if you have this topology:\n\nyou would get an output like this:\n\nDraw a text-based graphical representation of the commit history on the left hand side of the output. This may cause extra lines to be printed in between commits, in order for the graph history to be drawn properly. Cannot be combined with --no-walk.\n\nThis enables parent rewriting, see History Simplification above.\n\nThis implies the --topo-order option by default, but the --date-order option may also be specified.\n\nWhen --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If <barrier> is specified, it is the string that will be shown instead of the default one.\n\n• a space instead of the T date/time delimiter\n• a space between time and time zone\n• no colon between hours and minutes of the time zone\n\n**--pretty[=<format>]**: Pretty-print the contents of the commit logs in a given format, where <format> can be one of oneline, short, medium, full, fuller, reference, email, raw, format:<string> and tformat:<string>. When <format> is none of the above, and has %<placeholder> in it, it acts as if --pretty=tformat:<format> were given. See the \"PRETTY FORMATS\" section for some additional details for each format. When =<format> part is omitted, it defaults to medium. Note you can specify the default pretty format in the repository configuration (see git-config[1]).\n**--format=<format>**: Instead of showing the full 40-byte hexadecimal commit object name, show a prefix that names the object uniquely. --abbrev=<n> (which also modifies diff output, if it is displayed) option can be used to specify the minimum length of the prefix. This should make --pretty=oneline a whole lot more readable for people using 80-column terminals.\n**--abbrev-commit**: Show the full 40-byte hexadecimal commit object name. This negates --abbrev-commit, either explicit or implied by other options such as --oneline. It also overrides the log.abbrevCommit variable.\n**--no-abbrev-commit**: This is a shorthand for --pretty=oneline --abbrev-commit used together.\n**--oneline**: Commit objects record the character encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user. For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in X and we are outputting in X, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output. Likewise, if iconv(3) fails to convert the commit, we will quietly output the original object verbatim.\n**--encoding=<encoding>**: Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is a multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion. By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e. medium, which is the default, full, and fuller).\n**--expand-tabs=<n>**: Show the notes (see git-notes[1]) that annotate the commit, when showing the commit log message. This is the default for git log, git show and git whatchanged commands when there is no --pretty, --format, or --oneline option given on the command line. By default, the notes shown are from the notes refs listed in the core.notesRef and notes.displayRef variables (or corresponding environment overrides). See git-config[1] for more details. With an optional <ref> argument, use the ref to find the notes to display. The ref can specify the full refname when it begins with refs/notes/; when it begins with notes/, refs/ and otherwise refs/notes/ is prefixed to form the full name of the ref. Multiple --notes options can be combined to control which notes are being displayed. Examples: \"--notes=foo\" will show only notes from refs/notes/foo; \"--notes=foo --notes\" will show both notes from \"refs/notes/foo\" and from the default notes ref(s).\n**--expand-tabs**: Do not show notes. This negates the above --notes option, by resetting the list of notes refs from which notes are shown. Options are parsed in the order given on the command line, so e.g. \"--notes --notes=foo --no-notes --notes=bar\" will only show notes from refs/notes/bar.\n**--no-expand-tabs**: Show the default notes unless options for displaying specific notes are given.\n**--notes[=<ref>]**: These options are deprecated. Use the above --notes/--no-notes options instead.\n**--no-notes**: Check the validity of a signed commit object by passing the signature to gpg --verify and show the output.\n**--show-notes-by-default**: Synonym for --date=relative.\n**--show-notes[=<ref>]**: Only takes effect for dates shown in human-readable format, such as when using --pretty. log.date config variable sets a default value for the log command’s --date option. By default, dates are shown in the original time zone (either committer’s or author’s). If -local is appended to the format (e.g., iso-local), the user’s local time zone is used instead. --date=relative shows dates relative to the current time, e.g. “2 hours ago”. The -local option has no effect for --date=relative. --date=local is an alias for --date=default-local. --date=iso (or --date=iso8601) shows timestamps in a ISO 8601-like format. The differences to the strict ISO 8601 format are: a space instead of the T date/time delimiter a space between time and time zone no colon between hours and minutes of the time zone --date=iso-strict (or --date=iso8601-strict) shows timestamps in strict ISO 8601 format. --date=rfc (or --date=rfc2822) shows timestamps in RFC 2822 format, often found in email messages. --date=short shows only the date, but not the time, in YYYY-MM-DD format. --date=raw shows the date as seconds since the epoch (1970-01-01 00:00:00 UTC), followed by a space, and then the timezone as an offset from UTC (a + or - with four digits; the first two are hours, and the second two are minutes). I.e., as if the timestamp were formatted with strftime(\"%s %z\")). Note that the -local option does not affect the seconds-since-epoch value (which is always measured in UTC), but does switch the accompanying timezone value. --date=human shows the timezone if the timezone does not match the current time-zone, and doesn’t print the whole date if that matches (ie skip printing year for dates that are \"this year\", but also skip the whole date itself if it’s in the last few days and we can just say what weekday it was). For older dates the hour and minute is also omitted. --date=unix shows the date as a Unix epoch timestamp (seconds since 1970). As with --raw, this is always in UTC and therefore -local has no effect. --date=format:<format> feeds the <format> to your system strftime, except for %s, %z, and %Z, which are handled internally. Use --date=format:%c to show the date in your system locale’s preferred format. See the strftime(3) manual for a complete list of format placeholders. When using -local, the correct syntax is --date=format-local:<format>. --date=default is the default format, and is based on ctime(3) output. It shows a single line with three-letter day of the week, three-letter month, day-of-month, hour-minute-seconds in \"HH:MM:SS\" format, followed by 4-digit year, plus timezone information, unless the local time zone is used, e.g. Thu Jan 1 00:00:00 1970 +0000.\n**--standard-notes**: Print also the parents of the commit (in the form \"commit parent…\"). Also enables parent rewriting, see History Simplification above.\n**--no-standard-notes**: Print also the children of the commit (in the form \"commit child…\"). Also enables parent rewriting, see History Simplification above.\n**--show-signature**: Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with < and those from the right with >. If combined with --boundary, those commits are prefixed with -. For example, if you have this topology: y---b---b branch B / \\ / / . / / \\ o---x---a---a branch A you would get an output like this: $ git rev-list --left-right --boundary --pretty=oneline A...B >bbbbbbb... 3rd on b >bbbbbbb... 2nd on b <aaaaaaa... 3rd on a <aaaaaaa... 2nd on a -yyyyyyy... 1st on b -xxxxxxx... 1st on a\n**--relative-date**: Draw a text-based graphical representation of the commit history on the left hand side of the output. This may cause extra lines to be printed in between commits, in order for the graph history to be drawn properly. Cannot be combined with --no-walk. This enables parent rewriting, see History Simplification above. This implies the --topo-order option by default, but the --date-order option may also be specified.\n**--date=<format>**: When --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If <barrier> is specified, it is the string that will be shown instead of the default one.\n\nNote | you can specify the default pretty format in the repository configuration (see git-config[1]).\n\n[Note] Note you can specify the default pretty format in the repository configuration (see git-config[1]).",
        "code_examples": [
          "```bash\ny---b---b  branch B\n\t    / \\ /\n\t   /   .\n\t  /   / \\\n\t o---x---a---a  branch A\n```"
        ],
        "usage_examples": [
          "```bash\n$ git rev-list --left-right --boundary --pretty=oneline A...B\n\n\t>bbbbbbb... 3rd on b\n\t>bbbbbbb... 2nd on b\n\t<aaaaaaa... 3rd on a\n\t<aaaaaaa... 2nd on a\n\t-yyyyyyy... 1st on b\n\t-xxxxxxx... 1st on a\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 42,
          "content_length": 16259
        }
      },
      {
        "header": "PRETTY FORMATS",
        "content": "If the commit is a merge, and if the pretty-format is not oneline, email or raw, an additional line is inserted before the Author: line. This line begins with \"Merge: \" and the hashes of ancestral commits are printed, separated by spaces. Note that the listed commits may not necessarily be the list of the direct parent commits if you have limited your view of history: for example, if you are only interested in changes related to a certain directory or file.\n\nThere are several built-in formats, and you can define additional formats by setting a pretty.<name> config option to either another format name, or a format: string, as described below (see git-config[1]). Here are the details of the built-in formats:\n\nThis is designed to be as compact as possible.\n\nThis format is used to refer to another commit in a commit message and is the same as --pretty='format:%C(auto)%h (%s, %ad). By default, the date is formatted with --date=short unless another --date option is explicitly specified. As with any format: with format placeholders, its output is not affected by other options like --decorate and --walk-reflogs.\n\nLike email, but lines in the commit message starting with \"From \" (preceded by zero or more \">\") are quoted with \">\" so they aren’t confused as starting a new commit.\n\nThe raw format shows the entire commit exactly as stored in the commit object. Notably, the hashes are displayed in full, regardless of whether --abbrev or --no-abbrev are used, and parents information show the true parent commits, without taking grafts or history simplification into account. Note that this format affects the way commits are displayed, but not the way the diff is shown e.g. with git log --raw. To get full object names in a raw diff format, use --no-abbrev.\n\nformat:<format-string>\n\nThe format:<format-string> format allows you to specify which information you want to show. It works a little bit like printf format, with the notable exception that you get a newline with %n instead of \\n.\n\nE.g, format:\"The author of %h was %an, %ar%nThe title was >>%s<<%n\" would show something like this:\n\nThe placeholders are:\n\nPlaceholders that expand to a single literal character:\n\n%x followed by two hexadecimal digits is replaced with a byte with the hexadecimal digits' value (we will call this \"literal formatting code\" in the rest of this document).\n\nPlaceholders that affect formatting of later placeholders:\n\nswitch color to green\n\nswitch color to blue\n\ncolor specification, as described under Values in the \"CONFIGURATION FILE\" section of git-config[1]. By default, colors are shown only when enabled for log output (by color.diff, color.ui, or --color, and respecting the auto settings of the former if we are going to a terminal). %C(auto,<spec>) is accepted as a historical synonym for the default (e.g., %C(auto,red)). Specifying %C(always,<spec>) will show the colors even when color is not otherwise enabled (though consider just using --color=always to enable color for the whole output, including this format and anything else git might color). auto alone (i.e. %C(auto)) will turn on auto coloring on the next placeholders until the color is switched again.\n\nleft (<), right (>) or boundary (-) mark\n\nswitch line wrapping, like the -w option of git-shortlog[1].\n\nmake the next placeholder take at least N column widths, padding spaces on the right if necessary. Optionally truncate (with ellipsis ..) at the left (ltrunc) ..ft, the middle (mtrunc) mi..le, or the end (trunc) rig.., if the output is longer than <n> columns. Note 1: that truncating only works correctly with <n> >= 2. Note 2: spaces around the <n> and <m> (see below) values are optional. Note 3: Emojis and other wide characters will take two display columns, which may over-run column boundaries. Note 4: decomposed character combining marks may be misplaced at padding boundaries.\n\nmake the next placeholder take at least until <m> th display column, padding spaces on the right if necessary. Use negative <m> values for column positions measured from the right hand edge of the terminal window.\n\nsimilar to %<(<n>), %<|(<m>) respectively, but padding spaces on the left\n\nsimilar to %>(<n>), %>|(<m>) respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces\n\nsimilar to %<(<n>), %<|(<m>) respectively, but padding both sides (i.e. the text is centered)\n\nPlaceholders that expand to information extracted from the commit:\n\nabbreviated commit hash\n\nabbreviated tree hash\n\nabbreviated parent hashes\n\nauthor name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\nauthor email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\nauthor email local-part (the part before the @ sign)\n\nauthor local-part (see %al) respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\nauthor date (format respects --date= option)\n\nauthor date, RFC2822 style\n\nauthor date, relative\n\nauthor date, UNIX timestamp\n\nauthor date, ISO 8601-like format\n\nauthor date, strict ISO 8601 format\n\nauthor date, short format (YYYY-MM-DD)\n\nauthor date, human style (like the --date=human option of git-rev-list[1])\n\ncommitter name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\ncommitter email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\ncommitter email local-part (the part before the @ sign)\n\ncommitter local-part (see %cl) respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\ncommitter date (format respects --date= option)\n\ncommitter date, RFC2822 style\n\ncommitter date, relative\n\ncommitter date, UNIX timestamp\n\ncommitter date, ISO 8601-like format\n\ncommitter date, strict ISO 8601 format\n\ncommitter date, short format (YYYY-MM-DD)\n\ncommitter date, human style (like the --date=human option of git-rev-list[1])\n\nref names, like the --decorate option of git-log[1]\n\nref names without the \" (\", \")\" wrapping.\n\nref names with custom decorations. The decorate string may be followed by a colon and zero or more comma-separated options. Option values may contain literal formatting codes. These must be used for commas (%x2C) and closing parentheses (%x29), due to their role in the option syntax.\n\nprefix=<value>: Shown before the list of ref names. Defaults to \" (\".\n\nsuffix=<value>: Shown after the list of ref names. Defaults to \")\".\n\nseparator=<value>: Shown between ref names. Defaults to \", \".\n\npointer=<value>: Shown between HEAD and the branch it points to, if any. Defaults to \" → \".\n\ntag=<value>: Shown before tag names. Defaults to \"tag: \".\n\nFor example, to produce decorations with no wrapping or tag annotations, and spaces as separators:\n\n%(decorate:prefix=,suffix=,tag=,separator= )\n\nhuman-readable name, like git-describe[1]; empty string for undescribable commits. The describe string may be followed by a colon and zero or more comma-separated options. Descriptions can be inconsistent when tags are added or removed at the same time.\n\ntags[=<bool-value>]: Instead of only considering annotated tags, consider lightweight tags as well.\n\nabbrev=<number>: Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <number> digits, or as many digits as needed to form a unique object name.\n\nmatch=<pattern>: Only consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix.\n\nexclude=<pattern>: Do not consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix.\n\nref name given on the command line by which the commit was reached (like git log --source), only works with git log\n\nsanitized subject line, suitable for a filename\n\nraw body (unwrapped subject and body)\n\nraw verification message from GPG for a signed commit\n\nshow \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key) and \"N\" for no signature\n\nshow the name of the signer for a signed commit\n\nshow the key used to sign a signed commit\n\nshow the fingerprint of the key used to sign a signed commit\n\nshow the fingerprint of the primary key whose subkey was used to sign a signed commit\n\nshow the trust level for the key used to sign a signed commit\n\nreflog selector, e.g., refs/stash@{1} or refs/stash@{2 minutes ago}; the format follows the rules described for the -g option. The portion before the @ is the refname as given on the command line (so git log -g refs/heads/master would yield refs/heads/master@{0}).\n\nshortened reflog selector; same as %gD, but the refname portion is shortened for human readability (so refs/heads/master becomes just master).\n\nreflog identity name\n\nreflog identity name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\nreflog identity email\n\nreflog identity email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\ndisplay the trailers of the body as interpreted by git-interpret-trailers[1]. The trailers string may be followed by a colon and zero or more comma-separated options. If any option is provided multiple times, the last occurrence wins.\n\nkey=<key>: only show trailers with specified <key>. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the only option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with only=false. E.g., %(trailers:key=Reviewed-by) shows trailer lines with key Reviewed-by.\n\nonly[=<bool>]: select whether non-trailer lines from the trailer block should be included.\n\nseparator=<sep>: specify the separator inserted between trailer lines. Defaults to a line feed character. The string <sep> may contain the literal formatting codes described above. To use comma as separator one must use %x2C as it would otherwise be parsed as next option. E.g., %(trailers:key=Ticket,separator=%x2C ) shows all trailer lines whose key is \"Ticket\" separated by a comma and a space.\n\nunfold[=<bool>]: make it behave as if interpret-trailer’s --unfold option was given. E.g., %(trailers:only,unfold=true) unfolds and shows all trailer lines.\n\nkeyonly[=<bool>]: only show the key part of the trailer.\n\nvalueonly[=<bool>]: only show the value part of the trailer.\n\nkey_value_separator=<sep>: specify the separator inserted between the key and value of each trailer. Defaults to \": \". Otherwise it shares the same semantics as separator=<sep> above.\n\nThe boolean options accept an optional value [=<bool-value>]. The values taken by --type=bool git-config[1], like yes and off, are all accepted. Giving a boolean option without =<value> is equivalent to giving it with =true.\n\nIf you add a + (plus sign) after % of a placeholder, a line-feed is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.\n\nIf you add a - (minus sign) after % of a placeholder, all consecutive line-feeds immediately preceding the expansion are deleted if and only if the placeholder expands to an empty string.\n\nIf you add a (space) after % of a placeholder, a space is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.\n\nThe tformat: format works exactly like format:, except that it provides \"terminator\" semantics instead of \"separator\" semantics. In other words, each commit has the message terminator character (usually a newline) appended, rather than a separator placed between entries. This means that the final entry of a single-line format will be properly terminated with a new line, just as the \"oneline\" format does. For example:\n\nIn addition, any unrecognized string that has a % in it is interpreted as if it has tformat: in front of it. For example, these two are equivalent:\n\n• oneline <hash> <title-line> This is designed to be as compact as possible.\n• short commit <hash> Author: <author> <title-line>\n• medium commit <hash> Author: <author> Date: <author-date> <title-line> <full-commit-message>\n• full commit <hash> Author: <author> Commit: <committer> <title-line> <full-commit-message>\n• fuller commit <hash> Author: <author> AuthorDate: <author-date> Commit: <committer> CommitDate: <committer-date> <title-line> <full-commit-message>\n• reference <abbrev-hash> (<title-line>, <short-author-date>) This format is used to refer to another commit in a commit message and is the same as --pretty='format:%C(auto)%h (%s, %ad). By default, the date is formatted with --date=short unless another --date option is explicitly specified. As with any format: with format placeholders, its output is not affected by other options like --decorate and --walk-reflogs.\n• email From <hash> <date> From: <author> Date: <author-date> Subject: [PATCH] <title-line> <full-commit-message>\n• mboxrd Like email, but lines in the commit message starting with \"From \" (preceded by zero or more \">\") are quoted with \">\" so they aren’t confused as starting a new commit.\n• raw The raw format shows the entire commit exactly as stored in the commit object. Notably, the hashes are displayed in full, regardless of whether --abbrev or --no-abbrev are used, and parents information show the true parent commits, without taking grafts or history simplification into account. Note that this format affects the way commits are displayed, but not the way the diff is shown e.g. with git log --raw. To get full object names in a raw diff format, use --no-abbrev.\n• format:<format-string> The format:<format-string> format allows you to specify which information you want to show. It works a little bit like printf format, with the notable exception that you get a newline with %n instead of \\n. E.g, format:\"The author of %h was %an, %ar%nThe title was >>%s<<%n\" would show something like this: The author of fe6e0ee was Junio C Hamano, 23 hours ago The title was >>t4119: test autocomputing -p<n> for traditional diff input.<< The placeholders are: Placeholders that expand to a single literal character: %n newline %% a raw % %x00 %x followed by two hexadecimal digits is replaced with a byte with the hexadecimal digits' value (we will call this \"literal formatting code\" in the rest of this document). Placeholders that affect formatting of later placeholders: %Cred switch color to red %Cgreen switch color to green %Cblue switch color to blue %Creset reset color %C(<spec>) color specification, as described under Values in the \"CONFIGURATION FILE\" section of git-config[1]. By default, colors are shown only when enabled for log output (by color.diff, color.ui, or --color, and respecting the auto settings of the former if we are going to a terminal). %C(auto,<spec>) is accepted as a historical synonym for the default (e.g., %C(auto,red)). Specifying %C(always,<spec>) will show the colors even when color is not otherwise enabled (though consider just using --color=always to enable color for the whole output, including this format and anything else git might color). auto alone (i.e. %C(auto)) will turn on auto coloring on the next placeholders until the color is switched again. %m left (<), right (>) or boundary (-) mark %w([<w>[,<i1>[,<i2>]]]) switch line wrapping, like the -w option of git-shortlog[1]. %<(<n>[,(trunc|ltrunc|mtrunc)]) make the next placeholder take at least N column widths, padding spaces on the right if necessary. Optionally truncate (with ellipsis ..) at the left (ltrunc) ..ft, the middle (mtrunc) mi..le, or the end (trunc) rig.., if the output is longer than <n> columns. Note 1: that truncating only works correctly with <n> >= 2. Note 2: spaces around the <n> and <m> (see below) values are optional. Note 3: Emojis and other wide characters will take two display columns, which may over-run column boundaries. Note 4: decomposed character combining marks may be misplaced at padding boundaries. %<|(<m> ) make the next placeholder take at least until <m> th display column, padding spaces on the right if necessary. Use negative <m> values for column positions measured from the right hand edge of the terminal window. %>(<n>) %>|(<m>) similar to %<(<n>), %<|(<m>) respectively, but padding spaces on the left %>>(<n>) %>>|(<m>) similar to %>(<n>), %>|(<m>) respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces %><(<n>) %><|(<m>) similar to %<(<n>), %<|(<m>) respectively, but padding both sides (i.e. the text is centered) Placeholders that expand to information extracted from the commit: %H commit hash %h abbreviated commit hash %T tree hash %t abbreviated tree hash %P parent hashes %p abbreviated parent hashes %an author name %aN author name (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ae author email %aE author email (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %al author email local-part (the part before the @ sign) %aL author local-part (see %al) respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ad author date (format respects --date= option) %aD author date, RFC2822 style %ar author date, relative %at author date, UNIX timestamp %ai author date, ISO 8601-like format %aI author date, strict ISO 8601 format %as author date, short format (YYYY-MM-DD) %ah author date, human style (like the --date=human option of git-rev-list[1]) %cn committer name %cN committer name (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ce committer email %cE committer email (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %cl committer email local-part (the part before the @ sign) %cL committer local-part (see %cl) respecting .mailmap, see git-shortlog[1] or git-blame[1]) %cd committer date (format respects --date= option) %cD committer date, RFC2822 style %cr committer date, relative %ct committer date, UNIX timestamp %ci committer date, ISO 8601-like format %cI committer date, strict ISO 8601 format %cs committer date, short format (YYYY-MM-DD) %ch committer date, human style (like the --date=human option of git-rev-list[1]) %d ref names, like the --decorate option of git-log[1] %D ref names without the \" (\", \")\" wrapping. %(decorate[:<option>,...]) ref names with custom decorations. The decorate string may be followed by a colon and zero or more comma-separated options. Option values may contain literal formatting codes. These must be used for commas (%x2C) and closing parentheses (%x29), due to their role in the option syntax. prefix=<value>: Shown before the list of ref names. Defaults to \" (\". suffix=<value>: Shown after the list of ref names. Defaults to \")\". separator=<value>: Shown between ref names. Defaults to \", \". pointer=<value>: Shown between HEAD and the branch it points to, if any. Defaults to \" → \". tag=<value>: Shown before tag names. Defaults to \"tag: \". For example, to produce decorations with no wrapping or tag annotations, and spaces as separators: %(decorate:prefix=,suffix=,tag=,separator= ) %(describe[:<option>,...]) human-readable name, like git-describe[1]; empty string for undescribable commits. The describe string may be followed by a colon and zero or more comma-separated options. Descriptions can be inconsistent when tags are added or removed at the same time. tags[=<bool-value>]: Instead of only considering annotated tags, consider lightweight tags as well. abbrev=<number>: Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <number> digits, or as many digits as needed to form a unique object name. match=<pattern>: Only consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix. exclude=<pattern>: Do not consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix. %S ref name given on the command line by which the commit was reached (like git log --source), only works with git log %e encoding %s subject %f sanitized subject line, suitable for a filename %b body %B raw body (unwrapped subject and body) %N commit notes %GG raw verification message from GPG for a signed commit %G? show \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key) and \"N\" for no signature %GS show the name of the signer for a signed commit %GK show the key used to sign a signed commit %GF show the fingerprint of the key used to sign a signed commit %GP show the fingerprint of the primary key whose subkey was used to sign a signed commit %GT show the trust level for the key used to sign a signed commit %gD reflog selector, e.g., refs/stash@{1} or refs/stash@{2 minutes ago}; the format follows the rules described for the -g option. The portion before the @ is the refname as given on the command line (so git log -g refs/heads/master would yield refs/heads/master@{0}). %gd shortened reflog selector; same as %gD, but the refname portion is shortened for human readability (so refs/heads/master becomes just master). %gn reflog identity name %gN reflog identity name (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ge reflog identity email %gE reflog identity email (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %gs reflog subject %(trailers[:<option>,...]) display the trailers of the body as interpreted by git-interpret-trailers[1]. The trailers string may be followed by a colon and zero or more comma-separated options. If any option is provided multiple times, the last occurrence wins. key=<key>: only show trailers with specified <key>. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the only option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with only=false. E.g., %(trailers:key=Reviewed-by) shows trailer lines with key Reviewed-by. only[=<bool>]: select whether non-trailer lines from the trailer block should be included. separator=<sep>: specify the separator inserted between trailer lines. Defaults to a line feed character. The string <sep> may contain the literal formatting codes described above. To use comma as separator one must use %x2C as it would otherwise be parsed as next option. E.g., %(trailers:key=Ticket,separator=%x2C ) shows all trailer lines whose key is \"Ticket\" separated by a comma and a space. unfold[=<bool>]: make it behave as if interpret-trailer’s --unfold option was given. E.g., %(trailers:only,unfold=true) unfolds and shows all trailer lines. keyonly[=<bool>]: only show the key part of the trailer. valueonly[=<bool>]: only show the value part of the trailer. key_value_separator=<sep>: specify the separator inserted between the key and value of each trailer. Defaults to \": \". Otherwise it shares the same semantics as separator=<sep> above.\n\n• Placeholders that expand to a single literal character: %n newline %% a raw % %x00 %x followed by two hexadecimal digits is replaced with a byte with the hexadecimal digits' value (we will call this \"literal formatting code\" in the rest of this document).\n• Placeholders that affect formatting of later placeholders: %Cred switch color to red %Cgreen switch color to green %Cblue switch color to blue %Creset reset color %C(<spec>) color specification, as described under Values in the \"CONFIGURATION FILE\" section of git-config[1]. By default, colors are shown only when enabled for log output (by color.diff, color.ui, or --color, and respecting the auto settings of the former if we are going to a terminal). %C(auto,<spec>) is accepted as a historical synonym for the default (e.g., %C(auto,red)). Specifying %C(always,<spec>) will show the colors even when color is not otherwise enabled (though consider just using --color=always to enable color for the whole output, including this format and anything else git might color). auto alone (i.e. %C(auto)) will turn on auto coloring on the next placeholders until the color is switched again. %m left (<), right (>) or boundary (-) mark %w([<w>[,<i1>[,<i2>]]]) switch line wrapping, like the -w option of git-shortlog[1]. %<(<n>[,(trunc|ltrunc|mtrunc)]) make the next placeholder take at least N column widths, padding spaces on the right if necessary. Optionally truncate (with ellipsis ..) at the left (ltrunc) ..ft, the middle (mtrunc) mi..le, or the end (trunc) rig.., if the output is longer than <n> columns. Note 1: that truncating only works correctly with <n> >= 2. Note 2: spaces around the <n> and <m> (see below) values are optional. Note 3: Emojis and other wide characters will take two display columns, which may over-run column boundaries. Note 4: decomposed character combining marks may be misplaced at padding boundaries. %<|(<m> ) make the next placeholder take at least until <m> th display column, padding spaces on the right if necessary. Use negative <m> values for column positions measured from the right hand edge of the terminal window. %>(<n>) %>|(<m>) similar to %<(<n>), %<|(<m>) respectively, but padding spaces on the left %>>(<n>) %>>|(<m>) similar to %>(<n>), %>|(<m>) respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces %><(<n>) %><|(<m>) similar to %<(<n>), %<|(<m>) respectively, but padding both sides (i.e. the text is centered)\n• Placeholders that expand to information extracted from the commit: %H commit hash %h abbreviated commit hash %T tree hash %t abbreviated tree hash %P parent hashes %p abbreviated parent hashes %an author name %aN author name (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ae author email %aE author email (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %al author email local-part (the part before the @ sign) %aL author local-part (see %al) respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ad author date (format respects --date= option) %aD author date, RFC2822 style %ar author date, relative %at author date, UNIX timestamp %ai author date, ISO 8601-like format %aI author date, strict ISO 8601 format %as author date, short format (YYYY-MM-DD) %ah author date, human style (like the --date=human option of git-rev-list[1]) %cn committer name %cN committer name (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ce committer email %cE committer email (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %cl committer email local-part (the part before the @ sign) %cL committer local-part (see %cl) respecting .mailmap, see git-shortlog[1] or git-blame[1]) %cd committer date (format respects --date= option) %cD committer date, RFC2822 style %cr committer date, relative %ct committer date, UNIX timestamp %ci committer date, ISO 8601-like format %cI committer date, strict ISO 8601 format %cs committer date, short format (YYYY-MM-DD) %ch committer date, human style (like the --date=human option of git-rev-list[1]) %d ref names, like the --decorate option of git-log[1] %D ref names without the \" (\", \")\" wrapping. %(decorate[:<option>,...]) ref names with custom decorations. The decorate string may be followed by a colon and zero or more comma-separated options. Option values may contain literal formatting codes. These must be used for commas (%x2C) and closing parentheses (%x29), due to their role in the option syntax. prefix=<value>: Shown before the list of ref names. Defaults to \" (\". suffix=<value>: Shown after the list of ref names. Defaults to \")\". separator=<value>: Shown between ref names. Defaults to \", \". pointer=<value>: Shown between HEAD and the branch it points to, if any. Defaults to \" → \". tag=<value>: Shown before tag names. Defaults to \"tag: \".\n\n• prefix=<value>: Shown before the list of ref names. Defaults to \" (\".\n• suffix=<value>: Shown after the list of ref names. Defaults to \")\".\n• separator=<value>: Shown between ref names. Defaults to \", \".\n• pointer=<value>: Shown between HEAD and the branch it points to, if any. Defaults to \" → \".\n• tag=<value>: Shown before tag names. Defaults to \"tag: \".\n\n• tags[=<bool-value>]: Instead of only considering annotated tags, consider lightweight tags as well.\n• abbrev=<number>: Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <number> digits, or as many digits as needed to form a unique object name.\n• match=<pattern>: Only consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix.\n• exclude=<pattern>: Do not consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix.\n\n• key=<key>: only show trailers with specified <key>. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the only option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with only=false. E.g., %(trailers:key=Reviewed-by) shows trailer lines with key Reviewed-by.\n• only[=<bool>]: select whether non-trailer lines from the trailer block should be included.\n• separator=<sep>: specify the separator inserted between trailer lines. Defaults to a line feed character. The string <sep> may contain the literal formatting codes described above. To use comma as separator one must use %x2C as it would otherwise be parsed as next option. E.g., %(trailers:key=Ticket,separator=%x2C ) shows all trailer lines whose key is \"Ticket\" separated by a comma and a space.\n• unfold[=<bool>]: make it behave as if interpret-trailer’s --unfold option was given. E.g., %(trailers:only,unfold=true) unfolds and shows all trailer lines.\n• keyonly[=<bool>]: only show the key part of the trailer.\n• valueonly[=<bool>]: only show the value part of the trailer.\n• key_value_separator=<sep>: specify the separator inserted between the key and value of each trailer. Defaults to \": \". Otherwise it shares the same semantics as separator=<sep> above.\n\n• tformat: The tformat: format works exactly like format:, except that it provides \"terminator\" semantics instead of \"separator\" semantics. In other words, each commit has the message terminator character (usually a newline) appended, rather than a separator placed between entries. This means that the final entry of a single-line format will be properly terminated with a new line, just as the \"oneline\" format does. For example: $ git log -2 --pretty=format:%h 4da45bef \\ | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/' 4da45be 7134973 -- NO NEWLINE $ git log -2 --pretty=tformat:%h 4da45bef \\ | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/' 4da45be 7134973 In addition, any unrecognized string that has a % in it is interpreted as if it has tformat: in front of it. For example, these two are equivalent: $ git log -2 --pretty=tformat:%h 4da45bef $ git log -2 --pretty=%h 4da45bef\n\n**%n**: newline\n**%%**: a raw %\n**%x00**: %x followed by two hexadecimal digits is replaced with a byte with the hexadecimal digits' value (we will call this \"literal formatting code\" in the rest of this document).\n**%Cred**: switch color to red\n**%Cgreen**: switch color to green\n**%Cblue**: switch color to blue\n**%Creset**: reset color\n**%C(<spec>)**: color specification, as described under Values in the \"CONFIGURATION FILE\" section of git-config[1]. By default, colors are shown only when enabled for log output (by color.diff, color.ui, or --color, and respecting the auto settings of the former if we are going to a terminal). %C(auto,<spec>) is accepted as a historical synonym for the default (e.g., %C(auto,red)). Specifying %C(always,<spec>) will show the colors even when color is not otherwise enabled (though consider just using --color=always to enable color for the whole output, including this format and anything else git might color). auto alone (i.e. %C(auto)) will turn on auto coloring on the next placeholders until the color is switched again.\n**%m**: left (<), right (>) or boundary (-) mark\n**%w([<w>[,<i1>[,<i2>]]])**: switch line wrapping, like the -w option of git-shortlog[1].\n**%<(<n>[,(trunc|ltrunc|mtrunc)])**: make the next placeholder take at least N column widths, padding spaces on the right if necessary. Optionally truncate (with ellipsis ..) at the left (ltrunc) ..ft, the middle (mtrunc) mi..le, or the end (trunc) rig.., if the output is longer than <n> columns. Note 1: that truncating only works correctly with <n> >= 2. Note 2: spaces around the <n> and <m> (see below) values are optional. Note 3: Emojis and other wide characters will take two display columns, which may over-run column boundaries. Note 4: decomposed character combining marks may be misplaced at padding boundaries.\n**%<|(<m> )**: make the next placeholder take at least until <m> th display column, padding spaces on the right if necessary. Use negative <m> values for column positions measured from the right hand edge of the terminal window.\n**%>(<n>)**: similar to %<(<n>), %<|(<m>) respectively, but padding spaces on the left\n**%>|(<m>)**: similar to %>(<n>), %>|(<m>) respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces\n**%>>(<n>)**: similar to %<(<n>), %<|(<m>) respectively, but padding both sides (i.e. the text is centered)\n**%H**: commit hash\n**%h**: abbreviated commit hash\n**%T**: tree hash\n**%t**: abbreviated tree hash\n**%P**: parent hashes\n**%p**: abbreviated parent hashes\n**%an**: author name\n**%aN**: author name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%ae**: author email\n**%aE**: author email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%al**: author email local-part (the part before the @ sign)\n**%aL**: author local-part (see %al) respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%ad**: author date (format respects --date= option)\n**%aD**: author date, RFC2822 style\n**%ar**: author date, relative\n**%at**: author date, UNIX timestamp\n**%ai**: author date, ISO 8601-like format\n**%aI**: author date, strict ISO 8601 format\n**%as**: author date, short format (YYYY-MM-DD)\n**%ah**: author date, human style (like the --date=human option of git-rev-list[1])\n**%cn**: committer name\n**%cN**: committer name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%ce**: committer email\n**%cE**: committer email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%cl**: committer email local-part (the part before the @ sign)\n**%cL**: committer local-part (see %cl) respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%cd**: committer date (format respects --date= option)\n**%cD**: committer date, RFC2822 style\n**%cr**: committer date, relative\n**%ct**: committer date, UNIX timestamp\n**%ci**: committer date, ISO 8601-like format\n**%cI**: committer date, strict ISO 8601 format\n**%cs**: committer date, short format (YYYY-MM-DD)\n**%ch**: committer date, human style (like the --date=human option of git-rev-list[1])\n**%d**: ref names, like the --decorate option of git-log[1]\n**%D**: ref names without the \" (\", \")\" wrapping.\n**%(decorate[:<option>,...])**: ref names with custom decorations. The decorate string may be followed by a colon and zero or more comma-separated options. Option values may contain literal formatting codes. These must be used for commas (%x2C) and closing parentheses (%x29), due to their role in the option syntax. prefix=<value>: Shown before the list of ref names. Defaults to \" (\". suffix=<value>: Shown after the list of ref names. Defaults to \")\". separator=<value>: Shown between ref names. Defaults to \", \". pointer=<value>: Shown between HEAD and the branch it points to, if any. Defaults to \" → \". tag=<value>: Shown before tag names. Defaults to \"tag: \".\n**%(describe[:<option>,...])**: human-readable name, like git-describe[1]; empty string for undescribable commits. The describe string may be followed by a colon and zero or more comma-separated options. Descriptions can be inconsistent when tags are added or removed at the same time. tags[=<bool-value>]: Instead of only considering annotated tags, consider lightweight tags as well. abbrev=<number>: Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <number> digits, or as many digits as needed to form a unique object name. match=<pattern>: Only consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix. exclude=<pattern>: Do not consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix.\n**%S**: ref name given on the command line by which the commit was reached (like git log --source), only works with git log\n**%e**: encoding\n**%s**: subject\n**%f**: sanitized subject line, suitable for a filename\n**%b**: body\n**%B**: raw body (unwrapped subject and body)\n**%N**: commit notes\n**%GG**: raw verification message from GPG for a signed commit\n**%G?**: show \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key) and \"N\" for no signature\n**%GS**: show the name of the signer for a signed commit\n**%GK**: show the key used to sign a signed commit\n**%GF**: show the fingerprint of the key used to sign a signed commit\n**%GP**: show the fingerprint of the primary key whose subkey was used to sign a signed commit\n**%GT**: show the trust level for the key used to sign a signed commit\n**%gD**: reflog selector, e.g., refs/stash@{1} or refs/stash@{2 minutes ago}; the format follows the rules described for the -g option. The portion before the @ is the refname as given on the command line (so git log -g refs/heads/master would yield refs/heads/master@{0}).\n**%gd**: shortened reflog selector; same as %gD, but the refname portion is shortened for human readability (so refs/heads/master becomes just master).\n**%gn**: reflog identity name\n**%gN**: reflog identity name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%ge**: reflog identity email\n**%gE**: reflog identity email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%gs**: reflog subject\n**%(trailers[:<option>,...])**: display the trailers of the body as interpreted by git-interpret-trailers[1]. The trailers string may be followed by a colon and zero or more comma-separated options. If any option is provided multiple times, the last occurrence wins. key=<key>: only show trailers with specified <key>. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the only option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with only=false. E.g., %(trailers:key=Reviewed-by) shows trailer lines with key Reviewed-by. only[=<bool>]: select whether non-trailer lines from the trailer block should be included. separator=<sep>: specify the separator inserted between trailer lines. Defaults to a line feed character. The string <sep> may contain the literal formatting codes described above. To use comma as separator one must use %x2C as it would otherwise be parsed as next option. E.g., %(trailers:key=Ticket,separator=%x2C ) shows all trailer lines whose key is \"Ticket\" separated by a comma and a space. unfold[=<bool>]: make it behave as if interpret-trailer’s --unfold option was given. E.g., %(trailers:only,unfold=true) unfolds and shows all trailer lines. keyonly[=<bool>]: only show the key part of the trailer. valueonly[=<bool>]: only show the value part of the trailer. key_value_separator=<sep>: specify the separator inserted between the key and value of each trailer. Defaults to \": \". Otherwise it shares the same semantics as separator=<sep> above.\n\nNote | Some placeholders may depend on other options given to the revision traversal engine. For example, the %g* reflog options will insert an empty string unless we are traversing reflog entries (e.g., by git log -g). The %d and %D placeholders will use the \"short\" decoration format if --decorate was not already provided on the command line.\n\n[Note] Note Some placeholders may depend on other options given to the revision traversal engine. For example, the %g* reflog options will insert an empty string unless we are traversing reflog entries (e.g., by git log -g). The %d and %D placeholders will use the \"short\" decoration format if --decorate was not already provided on the command line.",
        "code_examples": [
          "```bash\n<hash><title-line>\n```",
          "```bash\ncommit<hash>Author: <author>\n```",
          "```bash\n<title-line>\n```",
          "```bash\ncommit<hash>Author: <author>\nDate:   <author-date>\n```",
          "```bash\n<title-line>\n```",
          "```bash\n<full-commit-message>\n```",
          "```bash\ncommit<hash>Author: <author>\nCommit: <committer>\n```",
          "```bash\n<title-line>\n```",
          "```bash\n<full-commit-message>\n```",
          "```bash\ncommit<hash>Author:     <author>\nAuthorDate: <author-date>\nCommit:     <committer>\nCommitDate: <committer-date>\n```",
          "```bash\n<title-line>\n```",
          "```bash\n<full-commit-message>\n```",
          "```bash\n<abbrev-hash> (<title-line>, <short-author-date>)\n```",
          "```bash\nFrom<hash><date>\nFrom: <author>\nDate: <author-date>\nSubject: [PATCH] <title-line>\n```",
          "```bash\n<full-commit-message>\n```",
          "```bash\nThe author of fe6e0ee was Junio C Hamano, 23 hours ago\nThe title was >>t4119: test autocomputing -p<n> for traditional diff input.<<\n```"
        ],
        "usage_examples": [
          "```bash\n$ git log -2 --pretty=format:%h 4da45bef \\\n  | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/'\n4da45be\n7134973 -- NO NEWLINE\n\n$ git log -2 --pretty=tformat:%h 4da45bef \\\n  | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/'\n4da45be\n7134973\n```",
          "```bash\n$ git log -2 --pretty=tformat:%h 4da45bef\n$ git log -2 --pretty=%h 4da45bef\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 96,
          "content_length": 41261
        }
      },
      {
        "header": "DIFF FORMATTING",
        "content": "By default, git log does not generate any diff output. The options below can be used to show the changes made by each commit.\n\nNote that unless one of --diff-merges variants (including short -m, -c, --cc, and --dd options) is explicitly given, merge commits will not show a diff, even if a diff format like --patch is selected, nor will they match search options like -S. The exception is when --first-parent is in use, in which case first-parent is the default format for merge commits.\n\nGenerate patch (see Generating patch text with -p).\n\nSuppress all output from the diff machinery. Useful for commands like git show that show the patch by default to squelch their output, or to cancel the effect of options like --patch, --stat earlier on the command line in an alias.\n\nShow diffs for merge commits in the default format. This is similar to --diff-merges=on, except -m will produce no output unless -p is given as well.\n\nProduce combined diff output for merge commits. Shortcut for --diff-merges=combined -p.\n\nProduce dense combined diff output for merge commits. Shortcut for --diff-merges=dense-combined -p.\n\nProduce diff with respect to first parent for both merge and regular commits. Shortcut for --diff-merges=first-parent -p.\n\nProduce remerge-diff output for merge commits. Shortcut for --diff-merges=remerge -p.\n\nSynonym for --diff-merges=off.\n\nSpecify diff format to be used for merge commits. Default is `off` unless --first-parent is in use, in which case first-parent is the default.\n\nThe following formats are supported:\n\nDisable output of diffs for merge commits. Useful to override implied value.\n\nMake diff output for merge commits to be shown in the default format. The default format can be changed using log.diffMerges configuration variable, whose default value is separate.\n\nShow full diff with respect to first parent. This is the same format as --patch produces for non-merge commits.\n\nShow full diff with respect to each of parents. Separate log entry and diff is generated for each parent.\n\nShow differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents.\n\nFurther compress output produced by --diff-merges=combined by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification.\n\nRemerge two-parent merge commits to create a temporary tree object—potentially containing files with conflict markers and such. A diff is then shown between that temporary tree and the actual merge commit.\n\nThe output emitted when this option is used is subject to change, and so is its interaction with other options (unless explicitly documented).\n\nCause combined diffs (used for merge commits) to list the name of the file from all parents. It thus only has effect when --diff-merges=[dense-]combined is in use, and is likely only useful if filename changes are detected (i.e. when either rename or copy detection have been requested).\n\nGenerate diffs with <n> lines of context instead of the usual three. Implies --patch.\n\nOutput to a specific file instead of stdout.\n\nSpecify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively.\n\nFor each commit, show a summary of changes using the raw diff format. See the \"RAW OUTPUT FORMAT\" section of git-diff[1]. This is different from showing the log itself in raw format, which you can achieve with --format=raw.\n\nSynonym for -p --raw.\n\nShow the tree objects in the diff output.\n\nEnable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.\n\nDisable the indent heuristic.\n\nSpend extra time to make sure the smallest possible diff is produced.\n\nGenerate a diff using the \"patience diff\" algorithm.\n\nGenerate a diff using the \"histogram diff\" algorithm.\n\nGenerate a diff using the \"anchored diff\" algorithm.\n\nThis option may be specified more than once.\n\nIf a line exists in both the source and destination, exists only once, and starts with <text>, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the \"patience diff\" algorithm internally.\n\nChoose a diff algorithm. The variants are as follows:\n\nThe basic greedy diff algorithm. Currently, this is the default.\n\nSpend extra time to make sure the smallest possible diff is produced.\n\nUse \"patience diff\" algorithm when generating patches.\n\nThis algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n\nFor instance, if you configured the diff.algorithm variable to a non-default value and want to use the default one, then you have to use --diff-algorithm=default option.\n\nGenerate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by <width>. The width of the filename part can be limited by giving another width <name-width> after a comma or by setting diff.statNameWidth=<name-width>. The width of the graph part can be limited by using --stat-graph-width=<graph-width> or by setting diff.statGraphWidth=<graph-width>. Using --stat or --stat-graph-width affects all commands generating a stat graph, while setting diff.statNameWidth or diff.statGraphWidth does not affect git format-patch. By giving a third parameter <count>, you can limit the output to the first <count> lines, followed by ... if there are more.\n\nThese parameters can also be set individually with --stat-width=<width>, --stat-name-width=<name-width> and --stat-count=<count>.\n\nOutput a condensed summary of extended header information such as file creations or deletions (\"new\" or \"gone\", optionally +l if it’s a symlink) and mode changes (+x or -x for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies --stat.\n\nSimilar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly. For binary files, outputs two - instead of saying 0 0.\n\nOutput only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines.\n\nOutput the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config[1]). The following parameters are available:\n\nCompute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n\nCompute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n\nCompute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n\nCount changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n\nAn integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n\nExample: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative.\n\nSynonym for --dirstat=cumulative.\n\nSynonym for --dirstat=files,<param>,....\n\nOutput a condensed summary of extended header information such as creations, renames and mode changes.\n\nSynonym for -p --stat.\n\nSeparate the commits with NULs instead of newlines.\n\nAlso, when --raw or --numstat has been given, do not munge pathnames and use NULs as output field terminators.\n\nWithout this option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n\nShow only the name of each changed file in the post-image tree. The file names are often encoded in UTF-8. For more information see the discussion about encoding in the git-log[1] manual page.\n\nShow only the name(s) and status of each changed file. See the description of the --diff-filter option on what the status letters mean. Just like --name-only the file names are often encoded in UTF-8.\n\nSpecify how differences in submodules are shown. When specifying --submodule=short the short format is used. This format just shows the names of the commits at the beginning and end of the range. When --submodule or --submodule=log is specified, the log format is used. This format lists the commits in the range like git-submodule[1] summary does. When --submodule=diff is specified, the diff format is used. This format shows an inline diff of the changes in the submodule contents between the commit range. Defaults to diff.submodule or the short format if the config option is unset.\n\nShow colored diff. --color (i.e. without =<when>) is the same as --color=always. <when> can be one of always, never, or auto.\n\nTurn off colored diff. It is the same as --color=never.\n\nMoved lines of code are colored differently. The <mode> defaults to no if the option is not given and to zebra if the option with no mode is given. The mode must be one of:\n\nMoved lines are not highlighted.\n\nIs a synonym for zebra. This may change to a more sensible mode in the future.\n\nAny line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.\n\nBlocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart.\n\nBlocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected.\n\nSimilar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n\nTurn off move detection. This can be used to override configuration settings. It is the same as --color-moved=no.\n\nThis configures how whitespace is ignored when performing the move detection for --color-moved. These modes can be given as a comma separated list:\n\nDo not ignore whitespace when performing move detection.\n\nIgnore changes in whitespace at EOL.\n\nIgnore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n\nIgnore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n\nInitially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n\nDo not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as --color-moved-ws=no.\n\nBy default, words are delimited by whitespace; see --word-diff-regex below. The <mode> defaults to plain, and must be one of:\n\nHighlight changed words using only colors. Implies --color.\n\nShow words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.\n\nUse a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own.\n\nDisable word diff again.\n\nNote that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled.\n\nUse <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies --word-diff unless it was already enabled.\n\nEvery non-overlapping match of the <regex> is considered a word. Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences. You may want to append |[^[:space:]] to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline.\n\nFor example, --word-diff-regex=. will treat each character as a word and, correspondingly, show differences character by character.\n\nThe regex can also be set via a diff driver or configuration option, see gitattributes[5] or git-config[1]. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.\n\nEquivalent to --word-diff=color plus (if a regex was specified) --word-diff-regex=<regex>.\n\nTurn off rename detection, even when the configuration file gives the default to do so.\n\nWhether to use empty blobs as rename source.\n\nWarn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by core.whitespace configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.\n\nHighlight whitespace errors in the context, old or new lines of the diff. Multiple values are separated by comma, none resets previous values, default reset the list to new and all is a shorthand for old,new,context. When this option is not given, and the configuration variable diff.wsErrorHighlight is not set, only whitespace errors in new lines are highlighted. The whitespace errors are colored with color.diff.whitespace.\n\nInstead of the first handful of characters, show the full pre- and post-image blob object names on the \"index\" line when generating patch format output.\n\nIn addition to --full-index, output a binary diff that can be applied with git-apply. Implies --patch.\n\nInstead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. In diff-patch output format, --full-index takes higher precedence, i.e. if --full-index is specified, full blob names will be shown regardless of --abbrev. Non default number of digits can be specified with --abbrev=<n>.\n\nBreak complete rewrite changes into pairs of delete and create. This serves two purposes:\n\nIt affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number <m> controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).\n\nWhen used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number <n> controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file.\n\nIf generating diffs, detect and report renames for each commit. For following files across renames while traversing history, see --follow. If <n> is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed. Without a % sign, the number is to be read as a fraction, with a decimal point before it. I.e., -M5 becomes 0.5, and is thus the same as -M50%. Similarly, -M05 is the same as -M5%. To limit detection to exact renames, use -M100%. The default similarity index is 50%.\n\nDetect copies as well as renames. See also --find-copies-harder. If <n> is specified, it has the same meaning as for -M<n>.\n\nFor performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one -C option has the same effect.\n\nOmit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.\n\nWhen used together with -B, omit also the preimage in the deletion part of a delete/create pair.\n\nThe -M and -C options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources. (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.) For N sources and destinations, this exhaustive check is O(N^2). This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number. Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited.\n\nSelect only files that are Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have their type (i.e. regular file, symlink, submodule, …) changed (T), are Unmerged (U), are Unknown (X), or have had their pairing Broken (B). Any combination of the filter characters (including none) can be used. When * (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected.\n\nAlso, these upper-case letters can be downcased to exclude. E.g. --diff-filter=ad excludes added and deleted paths.\n\nNote that not all diffs can feature all types. For instance, copied and renamed entries cannot appear if detection for those types is disabled.\n\nLook for differences that change the number of occurrences of the specified <string> (i.e. addition/deletion) in a file. Intended for the scripter’s use.\n\nIt is useful when you’re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into -S, and keep going until you get the very first version of the block.\n\nBinary files are searched as well.\n\nLook for differences whose patch text contains added/removed lines that match <regex>.\n\nTo illustrate the difference between -S<regex> --pickaxe-regex and -G<regex>, consider a commit with the following diff in the same file:\n\nWhile git log -G\"frotz\\(nitfol\" will show this commit, git log -S\"frotz\\(nitfol\" --pickaxe-regex will not (because the number of occurrences of that string did not change).\n\nUnless --text is supplied patches of binary files without a textconv filter will be ignored.\n\nSee the pickaxe entry in gitdiffcore[7] for more information.\n\nLook for differences that change the number of occurrences of the specified object. Similar to -S, just the argument is different in that it doesn’t search for a specific string but for a specific object id.\n\nThe object can be a blob or a submodule commit. It implies the -t option in git-log to also find trees.\n\nWhen -S or -G finds a change, show all the changes in that changeset, not just the files that contain the change in <string>.\n\nTreat the <string> given to -S as an extended POSIX regular expression to match.\n\nControl the order in which files appear in the output. This overrides the diff.orderFile configuration variable (see git-config[1]). To cancel diff.orderFile, use -O/dev/null.\n\nThe output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.\n\n<orderfile> is parsed as follows:\n\nBlank lines are ignored, so they can be used as separators for readability.\n\nLines starting with a hash (\"#\") are ignored, so they can be used for comments. Add a backslash (\"\\\") to the beginning of the pattern if it starts with a hash.\n\nEach other line contains a single pattern.\n\nPatterns have the same syntax and semantics as patterns used for fnmatch(3) without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern. For example, the pattern \"foo*bar\" matches \"fooasdfbar\" and \"foo/bar/baz/asdf\" but not \"foobarx\".\n\nDiscard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to). These options were invented primarily for the use of the git difftool command, and may not be very useful otherwise.\n\nSwap two inputs; that is, show differences from index or on-disk file to tree contents.\n\nWhen run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative.\n\nTreat all files as text.\n\nIgnore carriage-return at the end of line when doing a comparison.\n\nIgnore changes in whitespace at EOL.\n\nIgnore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n\nIgnore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n\nIgnore changes whose lines are all blank.\n\nIgnore changes whose all lines match <regex>. This option may be specified more than once.\n\nShow the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n\nShow whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see \"Defining a custom hunk-header\" in gitattributes[5]).\n\nAllow an external diff helper to be executed. If you set an external diff driver with gitattributes[5], you need to use this option with git-log[1] and friends.\n\nDisallow external diff drivers.\n\nAllow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes[5] for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff[1] and git-log[1], but not for git-format-patch[1] or diff plumbing commands.\n\nIgnore changes to submodules in the diff generation. all is the default. Using none will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config[1] or gitmodules[5]. When untracked is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using dirty ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using all hides all changes to submodules.\n\nShow the given source <prefix> instead of \"a/\".\n\nShow the given destination <prefix> instead of \"b/\".\n\nDo not show any source or destination prefix.\n\nUse the default source and destination prefixes (\"a/\" and \"b/\"). This overrides configuration variables such as diff.noprefix, diff.srcPrefix, diff.dstPrefix, and diff.mnemonicPrefix (see git-config[1]).\n\nPrepend an additional <prefix> to every line of output.\n\nBy default entries added by git add -N appear as an existing empty file in git diff and a new file in git diff --cached. This option makes the entry appear as a new file in git diff and non-existent in git diff --cached. This option could be reverted with --ita-visible-in-index. Both options are experimental and could be removed in future.\n\nFor more detailed explanation on these common options, see also gitdiffcore[7].\n\n• Blank lines are ignored, so they can be used as separators for readability.\n• Lines starting with a hash (\"#\") are ignored, so they can be used for comments. Add a backslash (\"\\\") to the beginning of the pattern if it starts with a hash.\n• Each other line contains a single pattern.\n\n**-p**: Generate patch (see Generating patch text with -p).\n**-u**: Suppress all output from the diff machinery. Useful for commands like git show that show the patch by default to squelch their output, or to cancel the effect of options like --patch, --stat earlier on the command line in an alias.\n**--patch**: Show diffs for merge commits in the default format. This is similar to --diff-merges=on, except -m will produce no output unless -p is given as well.\n**-s**: Produce combined diff output for merge commits. Shortcut for --diff-merges=combined -p.\n**--no-patch**: Produce dense combined diff output for merge commits. Shortcut for --diff-merges=dense-combined -p.\n**-m**: Produce diff with respect to first parent for both merge and regular commits. Shortcut for --diff-merges=first-parent -p.\n**-c**: Produce remerge-diff output for merge commits. Shortcut for --diff-merges=remerge -p.\n**--cc**: Synonym for --diff-merges=off.\n**--dd**: Specify diff format to be used for merge commits. Default is `off` unless --first-parent is in use, in which case first-parent is the default. The following formats are supported: off none Disable output of diffs for merge commits. Useful to override implied value. on m Make diff output for merge commits to be shown in the default format. The default format can be changed using log.diffMerges configuration variable, whose default value is separate. first-parent 1 Show full diff with respect to first parent. This is the same format as --patch produces for non-merge commits. separate Show full diff with respect to each of parents. Separate log entry and diff is generated for each parent. combined c Show differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents. dense-combined cc Further compress output produced by --diff-merges=combined by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification. remerge r Remerge two-parent merge commits to create a temporary tree object—potentially containing files with conflict markers and such. A diff is then shown between that temporary tree and the actual merge commit. The output emitted when this option is used is subject to change, and so is its interaction with other options (unless explicitly documented).\n**--remerge-diff**: Disable output of diffs for merge commits. Useful to override implied value.\n**--no-diff-merges**: Make diff output for merge commits to be shown in the default format. The default format can be changed using log.diffMerges configuration variable, whose default value is separate.\n**--diff-merges=<format>**: Show full diff with respect to first parent. This is the same format as --patch produces for non-merge commits.\n**off**: Show full diff with respect to each of parents. Separate log entry and diff is generated for each parent.\n**none**: Show differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents.\n**on**: Further compress output produced by --diff-merges=combined by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification.\n**m**: Remerge two-parent merge commits to create a temporary tree object—potentially containing files with conflict markers and such. A diff is then shown between that temporary tree and the actual merge commit.\n**first-parent**: Cause combined diffs (used for merge commits) to list the name of the file from all parents. It thus only has effect when --diff-merges=[dense-]combined is in use, and is likely only useful if filename changes are detected (i.e. when either rename or copy detection have been requested).\n**1**: Generate diffs with <n> lines of context instead of the usual three. Implies --patch.\n**separate**: Output to a specific file instead of stdout.\n**combined**: Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively.\n**c**: For each commit, show a summary of changes using the raw diff format. See the \"RAW OUTPUT FORMAT\" section of git-diff[1]. This is different from showing the log itself in raw format, which you can achieve with --format=raw.\n**dense-combined**: Synonym for -p --raw.\n**cc**: Show the tree objects in the diff output.\n**remerge**: Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.\n**r**: Disable the indent heuristic.\n**--combined-all-paths**: Spend extra time to make sure the smallest possible diff is produced.\n**-U<n>**: Generate a diff using the \"patience diff\" algorithm.\n**--unified=<n>**: Generate a diff using the \"histogram diff\" algorithm.\n**--output=<file>**: Generate a diff using the \"anchored diff\" algorithm. This option may be specified more than once. If a line exists in both the source and destination, exists only once, and starts with <text>, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the \"patience diff\" algorithm internally.\n**--output-indicator-new=<char>**: Choose a diff algorithm. The variants are as follows: default myers The basic greedy diff algorithm. Currently, this is the default. minimal Spend extra time to make sure the smallest possible diff is produced. patience Use \"patience diff\" algorithm when generating patches. histogram This algorithm extends the patience algorithm to \"support low-occurrence common elements\". For instance, if you configured the diff.algorithm variable to a non-default value and want to use the default one, then you have to use --diff-algorithm=default option.\n**--output-indicator-old=<char>**: The basic greedy diff algorithm. Currently, this is the default.\n**--output-indicator-context=<char>**: Spend extra time to make sure the smallest possible diff is produced.\n**--raw**: Use \"patience diff\" algorithm when generating patches.\n**--patch-with-raw**: This algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n**-t**: Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by <width>. The width of the filename part can be limited by giving another width <name-width> after a comma or by setting diff.statNameWidth=<name-width>. The width of the graph part can be limited by using --stat-graph-width=<graph-width> or by setting diff.statGraphWidth=<graph-width>. Using --stat or --stat-graph-width affects all commands generating a stat graph, while setting diff.statNameWidth or diff.statGraphWidth does not affect git format-patch. By giving a third parameter <count>, you can limit the output to the first <count> lines, followed by ... if there are more. These parameters can also be set individually with --stat-width=<width>, --stat-name-width=<name-width> and --stat-count=<count>.\n**--indent-heuristic**: Output a condensed summary of extended header information such as file creations or deletions (\"new\" or \"gone\", optionally +l if it’s a symlink) and mode changes (+x or -x for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies --stat.\n**--no-indent-heuristic**: Similar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly. For binary files, outputs two - instead of saying 0 0.\n**--minimal**: Output only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines.\n**--patience**: Output the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config[1]). The following parameters are available: changes Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given. lines Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options. files Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all. cumulative Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter. <limit> An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output. Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative.\n**--histogram**: Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n**--anchored=<text>**: Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n**--diff-algorithm=(patience|minimal|histogram|myers)**: Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n**default**: Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n**myers**: An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n**minimal**: Synonym for --dirstat=cumulative.\n**patience**: Synonym for --dirstat=files,<param>,....\n**histogram**: Output a condensed summary of extended header information such as creations, renames and mode changes.\n**--stat[=<width>[,<name-width>[,<count>]]]**: Synonym for -p --stat.\n**--compact-summary**: Separate the commits with NULs instead of newlines. Also, when --raw or --numstat has been given, do not munge pathnames and use NULs as output field terminators. Without this option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n**--numstat**: Show only the name of each changed file in the post-image tree. The file names are often encoded in UTF-8. For more information see the discussion about encoding in the git-log[1] manual page.\n**--shortstat**: Show only the name(s) and status of each changed file. See the description of the --diff-filter option on what the status letters mean. Just like --name-only the file names are often encoded in UTF-8.\n**-X [<param>,...]**: Specify how differences in submodules are shown. When specifying --submodule=short the short format is used. This format just shows the names of the commits at the beginning and end of the range. When --submodule or --submodule=log is specified, the log format is used. This format lists the commits in the range like git-submodule[1] summary does. When --submodule=diff is specified, the diff format is used. This format shows an inline diff of the changes in the submodule contents between the commit range. Defaults to diff.submodule or the short format if the config option is unset.\n**--dirstat[=<param>,...]**: Show colored diff. --color (i.e. without =<when>) is the same as --color=always. <when> can be one of always, never, or auto.\n**changes**: Turn off colored diff. It is the same as --color=never.\n**lines**: Moved lines of code are colored differently. The <mode> defaults to no if the option is not given and to zebra if the option with no mode is given. The mode must be one of: no Moved lines are not highlighted. default Is a synonym for zebra. This may change to a more sensible mode in the future. plain Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation. blocks Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart. zebra Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected. dimmed-zebra Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n**files**: Moved lines are not highlighted.\n**cumulative**: Is a synonym for zebra. This may change to a more sensible mode in the future.\n**<limit>**: Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.\n**--cumulative**: Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart.\n**--dirstat-by-file[=<param>,...]**: Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected.\n**--summary**: Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n**--patch-with-stat**: Turn off move detection. This can be used to override configuration settings. It is the same as --color-moved=no.\n**-z**: This configures how whitespace is ignored when performing the move detection for --color-moved. These modes can be given as a comma separated list: no Do not ignore whitespace when performing move detection. ignore-space-at-eol Ignore changes in whitespace at EOL. ignore-space-change Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent. ignore-all-space Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none. allow-indentation-change Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n**--name-only**: Do not ignore whitespace when performing move detection.\n**--name-status**: Ignore changes in whitespace at EOL.\n**--submodule[=<format>]**: Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n**--color[=<when>]**: Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n**--no-color**: Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n**--color-moved[=<mode>]**: Do not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as --color-moved-ws=no.\n**no**: By default, words are delimited by whitespace; see --word-diff-regex below. The <mode> defaults to plain, and must be one of: color Highlight changed words using only colors. Implies --color. plain Show words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous. porcelain Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own. none Disable word diff again. Note that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled.\n**default**: Highlight changed words using only colors. Implies --color.\n**plain**: Show words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.\n**blocks**: Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own.\n**zebra**: Disable word diff again.\n**dimmed-zebra**: Use <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies --word-diff unless it was already enabled. Every non-overlapping match of the <regex> is considered a word. Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences. You may want to append |[^[:space:]] to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline. For example, --word-diff-regex=. will treat each character as a word and, correspondingly, show differences character by character. The regex can also be set via a diff driver or configuration option, see gitattributes[5] or git-config[1]. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.\n**--no-color-moved**: Equivalent to --word-diff=color plus (if a regex was specified) --word-diff-regex=<regex>.\n**--color-moved-ws=<mode>,...**: Turn off rename detection, even when the configuration file gives the default to do so.\n**no**: Whether to use empty blobs as rename source.\n**ignore-space-at-eol**: Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by core.whitespace configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.\n**ignore-space-change**: Highlight whitespace errors in the context, old or new lines of the diff. Multiple values are separated by comma, none resets previous values, default reset the list to new and all is a shorthand for old,new,context. When this option is not given, and the configuration variable diff.wsErrorHighlight is not set, only whitespace errors in new lines are highlighted. The whitespace errors are colored with color.diff.whitespace.\n**ignore-all-space**: Instead of the first handful of characters, show the full pre- and post-image blob object names on the \"index\" line when generating patch format output.\n**allow-indentation-change**: In addition to --full-index, output a binary diff that can be applied with git-apply. Implies --patch.\n**--no-color-moved-ws**: Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. In diff-patch output format, --full-index takes higher precedence, i.e. if --full-index is specified, full blob names will be shown regardless of --abbrev. Non default number of digits can be specified with --abbrev=<n>.\n**--word-diff[=<mode>]**: Break complete rewrite changes into pairs of delete and create. This serves two purposes: It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number <m> controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines). When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number <n> controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file.\n**color**: If generating diffs, detect and report renames for each commit. For following files across renames while traversing history, see --follow. If <n> is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed. Without a % sign, the number is to be read as a fraction, with a decimal point before it. I.e., -M5 becomes 0.5, and is thus the same as -M50%. Similarly, -M05 is the same as -M5%. To limit detection to exact renames, use -M100%. The default similarity index is 50%.\n**plain**: Detect copies as well as renames. See also --find-copies-harder. If <n> is specified, it has the same meaning as for -M<n>.\n**porcelain**: For performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one -C option has the same effect.\n**none**: Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option. When used together with -B, omit also the preimage in the deletion part of a delete/create pair.\n**--word-diff-regex=<regex>**: The -M and -C options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources. (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.) For N sources and destinations, this exhaustive check is O(N^2). This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number. Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited.\n**--color-words[=<regex>]**: Select only files that are Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have their type (i.e. regular file, symlink, submodule, …) changed (T), are Unmerged (U), are Unknown (X), or have had their pairing Broken (B). Any combination of the filter characters (including none) can be used. When * (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected. Also, these upper-case letters can be downcased to exclude. E.g. --diff-filter=ad excludes added and deleted paths. Note that not all diffs can feature all types. For instance, copied and renamed entries cannot appear if detection for those types is disabled.\n**--no-renames**: Look for differences that change the number of occurrences of the specified <string> (i.e. addition/deletion) in a file. Intended for the scripter’s use. It is useful when you’re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into -S, and keep going until you get the very first version of the block. Binary files are searched as well.\n**--[no-]rename-empty**: Look for differences whose patch text contains added/removed lines that match <regex>. To illustrate the difference between -S<regex> --pickaxe-regex and -G<regex>, consider a commit with the following diff in the same file: + return frotz(nitfol, two->ptr, 1, 0); ... - hit = frotz(nitfol, mf2.ptr, 1, 0); While git log -G\"frotz\\(nitfol\" will show this commit, git log -S\"frotz\\(nitfol\" --pickaxe-regex will not (because the number of occurrences of that string did not change). Unless --text is supplied patches of binary files without a textconv filter will be ignored. See the pickaxe entry in gitdiffcore[7] for more information.\n**--check**: Look for differences that change the number of occurrences of the specified object. Similar to -S, just the argument is different in that it doesn’t search for a specific string but for a specific object id. The object can be a blob or a submodule commit. It implies the -t option in git-log to also find trees.\n**--ws-error-highlight=<kind>**: When -S or -G finds a change, show all the changes in that changeset, not just the files that contain the change in <string>.\n**--full-index**: Treat the <string> given to -S as an extended POSIX regular expression to match.\n**--binary**: Control the order in which files appear in the output. This overrides the diff.orderFile configuration variable (see git-config[1]). To cancel diff.orderFile, use -O/dev/null. The output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order. <orderfile> is parsed as follows: Blank lines are ignored, so they can be used as separators for readability. Lines starting with a hash (\"#\") are ignored, so they can be used for comments. Add a backslash (\"\\\") to the beginning of the pattern if it starts with a hash. Each other line contains a single pattern. Patterns have the same syntax and semantics as patterns used for fnmatch(3) without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern. For example, the pattern \"foo*bar\" matches \"fooasdfbar\" and \"foo/bar/baz/asdf\" but not \"foobarx\".\n**--abbrev[=<n>]**: Discard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to). These options were invented primarily for the use of the git difftool command, and may not be very useful otherwise.\n**-B[<n>][/<m>]**: Swap two inputs; that is, show differences from index or on-disk file to tree contents.\n**--break-rewrites[=[<n>][/<m>]]**: When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative.\n**-M[<n>]**: Treat all files as text.\n**--find-renames[=<n>]**: Ignore carriage-return at the end of line when doing a comparison.\n**-C[<n>]**: Ignore changes in whitespace at EOL.\n**--find-copies[=<n>]**: Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n**--find-copies-harder**: Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n**-D**: Ignore changes whose lines are all blank.\n**--irreversible-delete**: Ignore changes whose all lines match <regex>. This option may be specified more than once.\n**-l<num>**: Show the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n**--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]**: Show whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see \"Defining a custom hunk-header\" in gitattributes[5]).\n**-S<string>**: Allow an external diff helper to be executed. If you set an external diff driver with gitattributes[5], you need to use this option with git-log[1] and friends.\n**-G<regex>**: Disallow external diff drivers.\n**--find-object=<object-id>**: Allow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes[5] for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff[1] and git-log[1], but not for git-format-patch[1] or diff plumbing commands.\n**--pickaxe-all**: Ignore changes to submodules in the diff generation. all is the default. Using none will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config[1] or gitmodules[5]. When untracked is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using dirty ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using all hides all changes to submodules.\n**--pickaxe-regex**: Show the given source <prefix> instead of \"a/\".\n**-O<orderfile>**: Show the given destination <prefix> instead of \"b/\".\n**--skip-to=<file>**: Do not show any source or destination prefix.\n**--rotate-to=<file>**: Use the default source and destination prefixes (\"a/\" and \"b/\"). This overrides configuration variables such as diff.noprefix, diff.srcPrefix, diff.dstPrefix, and diff.mnemonicPrefix (see git-config[1]).\n**-R**: Prepend an additional <prefix> to every line of output.\n**--relative[=<path>]**: By default entries added by git add -N appear as an existing empty file in git diff and a new file in git diff --cached. This option makes the entry appear as a new file in git diff and non-existent in git diff --cached. This option could be reverted with --ita-visible-in-index. Both options are experimental and could be removed in future.\n**off**: Disable output of diffs for merge commits. Useful to override implied value.\n**none**: Make diff output for merge commits to be shown in the default format. The default format can be changed using log.diffMerges configuration variable, whose default value is separate.\n**on**: Show full diff with respect to first parent. This is the same format as --patch produces for non-merge commits.\n**m**: Show full diff with respect to each of parents. Separate log entry and diff is generated for each parent.\n**first-parent**: Show differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents.\n**1**: Further compress output produced by --diff-merges=combined by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification.\n**separate**: Remerge two-parent merge commits to create a temporary tree object—potentially containing files with conflict markers and such. A diff is then shown between that temporary tree and the actual merge commit.\n**default**: The basic greedy diff algorithm. Currently, this is the default.\n**myers**: Spend extra time to make sure the smallest possible diff is produced.\n**minimal**: Use \"patience diff\" algorithm when generating patches.\n**patience**: This algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n**changes**: Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n**lines**: Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n**files**: Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n**cumulative**: Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n**<limit>**: An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n**no**: Moved lines are not highlighted.\n**default**: Is a synonym for zebra. This may change to a more sensible mode in the future.\n**plain**: Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.\n**blocks**: Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart.\n**zebra**: Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected.\n**dimmed-zebra**: Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n**no**: Do not ignore whitespace when performing move detection.\n**ignore-space-at-eol**: Ignore changes in whitespace at EOL.\n**ignore-space-change**: Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n**ignore-all-space**: Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n**allow-indentation-change**: Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n**color**: Highlight changed words using only colors. Implies --color.\n**plain**: Show words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.\n**porcelain**: Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own.\n**none**: Disable word diff again.",
        "code_examples": [
          "```bash\n+    return frotz(nitfol, two->ptr, 1, 0);\n...\n-    hit = frotz(nitfol, mf2.ptr, 1, 0);\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 152,
          "content_length": 66623
        }
      },
      {
        "header": "Generating patch text with -p",
        "content": "Running git-diff[1], git-log[1], git-show[1], git-diff-index[1], git-diff-tree[1], or git-diff-files[1] with the -p option produces patch text. You can customize the creation of patch text via the GIT_EXTERNAL_DIFF and the GIT_DIFF_OPTS environment variables (see git[1]), and the diff attribute (see gitattributes[5]).\n\nWhat the -p option produces is slightly different from the traditional diff format:\n\nIt is preceded by a \"git diff\" header that looks like this:\n\nThe a/ and b/ filenames are the same unless rename/copy is involved. Especially, even for a creation or a deletion, /dev/null is not used in place of the a/ or b/ filenames.\n\nWhen a rename/copy is involved, file1 and file2 show the name of the source file of the rename/copy and the name of the file that the rename/copy produces, respectively.\n\nIt is followed by one or more extended header lines:\n\nFile modes <mode> are printed as 6-digit octal numbers including the file type and file permission bits.\n\nPath names in extended headers do not include the a/ and b/ prefixes.\n\nThe similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one.\n\nThe index line includes the blob object names before and after the change. The <mode> is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.\n\nPathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n\nAll the file1 files in the output refer to files before the commit, and all the file2 files refer to files after the commit. It is incorrect to apply each change to each file sequentially. For example, this patch will swap a and b:\n\nHunk headers mention the name of the function to which the hunk applies. See \"Defining a custom hunk-header\" in gitattributes[5] for details of how to tailor this to specific languages.\n\n• It is preceded by a \"git diff\" header that looks like this: diff --git a/file1 b/file2 The a/ and b/ filenames are the same unless rename/copy is involved. Especially, even for a creation or a deletion, /dev/null is not used in place of the a/ or b/ filenames. When a rename/copy is involved, file1 and file2 show the name of the source file of the rename/copy and the name of the file that the rename/copy produces, respectively.\n• It is followed by one or more extended header lines: old mode <mode> new mode <mode> deleted file mode <mode> new file mode <mode> copy from <path> copy to <path> rename from <path> rename to <path> similarity index <number> dissimilarity index <number> index <hash>..<hash> <mode> File modes <mode> are printed as 6-digit octal numbers including the file type and file permission bits. Path names in extended headers do not include the a/ and b/ prefixes. The similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one. The index line includes the blob object names before and after the change. The <mode> is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.\n• Pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n• All the file1 files in the output refer to files before the commit, and all the file2 files refer to files after the commit. It is incorrect to apply each change to each file sequentially. For example, this patch will swap a and b: diff --git a/a b/b rename from a rename to b diff --git a/b b/a rename from b rename to a\n• Hunk headers mention the name of the function to which the hunk applies. See \"Defining a custom hunk-header\" in gitattributes[5] for details of how to tailor this to specific languages.",
        "code_examples": [
          "```bash\noldmode<mode>newmode<mode>deletedfilemode<mode>newfilemode<mode>copyfrom<path>copyto<path>renamefrom<path>renameto<path>similarityindex<number>dissimilarityindex<number>index<hash>..<hash><mode>\n```"
        ],
        "usage_examples": [
          "```bash\ndiff --git a/file1 b/file2\n```",
          "```bash\ndiff --git a/a b/b\nrename from a\nrename to b\ndiff --git a/b b/a\nrename from b\nrename to a\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 13,
          "content_length": 4196
        }
      },
      {
        "header": "Combined diff format",
        "content": "Any diff-generating command can take the -c or --cc option to produce a combined diff when showing a merge. This is the default format when showing merges with git-diff[1] or git-show[1]. Note also that you can give suitable --diff-merges option to any of these commands to force generation of diffs in a specific format.\n\nA \"combined diff\" format looks like this:\n\nIt is preceded by a \"git diff\" header, that looks like this (when the -c option is used):\n\nor like this (when the --cc option is used):\n\nIt is followed by one or more extended header lines (this example shows a merge with two parents):\n\nThe mode <mode>,<mode>..<mode> line appears only if at least one of the <mode> is different from the rest. Extended headers with information about detected content movement (renames and copying detection) are designed to work with the diff of two <tree-ish> and are not used by combined diff format.\n\nIt is followed by a two-line from-file/to-file header:\n\nSimilar to the two-line header for the traditional unified diff format, /dev/null is used to signal created or deleted files.\n\nHowever, if the --combined-all-paths option is provided, instead of a two-line from-file/to-file, you get an N+1 line from-file/to-file header, where N is the number of parents in the merge commit:\n\nThis extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents.\n\nChunk header format is modified to prevent people from accidentally feeding it to patch -p1. Combined diff format was created for review of merge commit changes, and was not meant to be applied. The change is similar to the change in the extended index header:\n\nThere are (number of parents + 1) @ characters in the chunk header for combined diff format.\n\nUnlike the traditional unified diff format, which shows two files A and B with a single column that has - (minus — appears in A but removed in B), + (plus — missing in A but added to B), or \" \" (space — unchanged) prefix, this format compares two or more files file1, file2,… with one file X, and shows how X differs from each of fileN. One column for each of fileN is prepended to the output line to note how X’s line is different from it.\n\nA - character in the column N means that the line appears in fileN but it does not appear in the result. A + character in the column N means that the line appears in the result, and fileN does not have that line (in other words, the line was added, from the point of view of that parent).\n\nIn the above example output, the function signature was changed from both files (hence two - removals from both file1 and file2, plus ++ to mean one line that was added does not appear in either file1 or file2). Also, eight other lines are the same from file1 but do not appear in file2 (hence prefixed with +).\n\nWhen shown by git diff-tree -c, it compares the parents of a merge commit with the merge result (i.e. file1..fileN are the parents). When shown by git diff-files -c, it compares the two unresolved merge parents with the working tree file (i.e. file1 is stage 2 aka \"our version\", file2 is stage 3 aka \"their version\").\n\n• It is preceded by a \"git diff\" header, that looks like this (when the -c option is used): diff --combined file or like this (when the --cc option is used): diff --cc file\n• It is followed by one or more extended header lines (this example shows a merge with two parents): index <hash>,<hash>..<hash> mode <mode>,<mode>..<mode> new file mode <mode> deleted file mode <mode>,<mode> The mode <mode>,<mode>..<mode> line appears only if at least one of the <mode> is different from the rest. Extended headers with information about detected content movement (renames and copying detection) are designed to work with the diff of two <tree-ish> and are not used by combined diff format.\n• It is followed by a two-line from-file/to-file header: --- a/file +++ b/file Similar to the two-line header for the traditional unified diff format, /dev/null is used to signal created or deleted files. However, if the --combined-all-paths option is provided, instead of a two-line from-file/to-file, you get an N+1 line from-file/to-file header, where N is the number of parents in the merge commit: --- a/file --- a/file --- a/file +++ b/file This extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents.\n• Chunk header format is modified to prevent people from accidentally feeding it to patch -p1. Combined diff format was created for review of merge commit changes, and was not meant to be applied. The change is similar to the change in the extended index header: @@@ <from-file-range> <from-file-range> <to-file-range> @@@ There are (number of parents + 1) @ characters in the chunk header for combined diff format.",
        "code_examples": [
          "```bash\ndiff --combined describe.c\nindex fabadb8,cc95eb0..4866510\n--- a/describe.c\n+++ b/describe.c\n@@@ -98,20 -98,12 +98,20 @@@\n\treturn (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;\n  }\n\n- static void describe(char *arg)\n -static void describe(struct commit *cmit, int last_one)\n++static void describe(char *arg, int last_one)\n  {\n +\tunsigned char sha1[20];\n +\tstruct commit *cmit;\n\tstruct commit_list *list;\n\tstatic int initialized = 0;\n\tstruct commit_name *n;\n\n +\tif (get_sha1(arg, sha1) < 0)\n +\t\tusage(describe_usage);\n +\tcmit = lookup_commit_reference(sha1);\n +\tif (!cmit)\n +\t\tusage(describe_usage);\n +\n\tif (!initialized) {\n\t\tinitialized = 1;\n\t\tfor_each_ref(get_name);\n```",
          "```bash\ndiff --combined file\n```",
          "```bash\ndiff --cc file\n```",
          "```bash\nindex<hash>,<hash>..<hash>mode<mode>,<mode>..<mode>newfilemode<mode>deletedfilemode<mode>,<mode>\n```",
          "```bash\n--- a/file\n+++ b/file\n```",
          "```bash\n--- a/file\n--- a/file\n--- a/file\n+++ b/file\n```",
          "```bash\n@@@ <from-file-range> <from-file-range> <to-file-range> @@@\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 16,
          "content_length": 4844
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Show the whole commit history, but skip any merges\n\nShow all commits since version v2.6.12 that changed any file in the include/scsi or drivers/scsi subdirectories\n\nShow the changes during the last two weeks to the file gitk. The -- is necessary to avoid confusion with the branch named gitk\n\nShow the commits that are in the \"test\" branch but not yet in the \"release\" branch, along with the list of paths each commit modifies.\n\nShows the commits that changed builtin/rev-list.c, including those commits that occurred before the file was given its present name.\n\nShows all commits that are in any of local branches but not in any of remote-tracking branches for origin (what you have that origin doesn’t).\n\nShows all commits that are in local master but not in any remote repository master branches.\n\nShows the history including change diffs, but only from the “main branch” perspective, skipping commits that come from merged branches, and showing full diffs of changes introduced by the merges. This makes sense only when following a strict policy of merging all topic branches when staying on a single integration branch.\n\nShows how the function main() in the file main.c evolved over time.\n\nLimits the number of commits to show to 3.\n\n**git log --no-merges**: Show the whole commit history, but skip any merges\n**git log v2.6.12.. include/scsi drivers/scsi**: Show all commits since version v2.6.12 that changed any file in the include/scsi or drivers/scsi subdirectories\n**git log --since=\"2 weeks ago\" -- gitk**: Show the changes during the last two weeks to the file gitk. The -- is necessary to avoid confusion with the branch named gitk\n**git log --name-status release..test**: Show the commits that are in the \"test\" branch but not yet in the \"release\" branch, along with the list of paths each commit modifies.\n**git log --follow builtin/rev-list.c**: Shows the commits that changed builtin/rev-list.c, including those commits that occurred before the file was given its present name.\n**git log --branches --not --remotes=origin**: Shows all commits that are in any of local branches but not in any of remote-tracking branches for origin (what you have that origin doesn’t).\n**git log master --not --remotes=*/master**: Shows all commits that are in local master but not in any remote repository master branches.\n**git log -p -m --first-parent**: Shows the history including change diffs, but only from the “main branch” perspective, skipping commits that come from merged branches, and showing full diffs of changes introduced by the merges. This makes sense only when following a strict policy of merging all topic branches when staying on a single integration branch.\n**git log -L /int main/',/^}/:main.c**: Shows how the function main() in the file main.c evolved over time.\n**git log -3**: Limits the number of commits to show to 3.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 2848
        }
      },
      {
        "header": "DISCUSSION",
        "content": "Git is to some extent character encoding agnostic.\n\nThe contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the core level.\n\nPath names are encoded in UTF-8 normalization form C. This applies to tree objects, the index file, ref names, as well as path names in command line arguments, environment variables and config files (.git/config (see git-config[1]), gitignore[5], gitattributes[5] and gitmodules[5]).\n\nNote that Git at the core level treats path names simply as sequences of non-NUL bytes, there are no path name encoding conversions (except on Mac and Windows). Therefore, using non-ASCII path names will mostly work even on platforms and file systems that use legacy extended ASCII encodings. However, repositories created on such systems will not work properly on UTF-8-based systems (e.g. Linux, Mac, Windows) and vice versa. Additionally, many Git-based tools simply assume path names to be UTF-8 and will fail to display other encodings correctly.\n\nCommit log messages are typically encoded in UTF-8, but other extended ASCII encodings are also supported. This includes ISO-8859-x, CP125x and many others, but not UTF-16/32, EBCDIC and CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.).\n\nAlthough we encourage that the commit log messages are encoded in UTF-8, both the core and Git Porcelain are designed not to force UTF-8 on projects. If all participants of a particular project find it more convenient to use legacy encodings, Git does not forbid it. However, there are a few things to keep in mind.\n\ngit commit and git commit-tree issue a warning if the commit log message given to it does not look like a valid UTF-8 string, unless you explicitly say your project uses a legacy encoding. The way to say this is to have i18n.commitEncoding in .git/config file, like this:\n\nCommit objects created with the above setting record the value of i18n.commitEncoding in their encoding header. This is to help other people who look at them later. Lack of this header implies that the commit log message is encoded in UTF-8.\n\ngit log, git show, git blame and friends look at the encoding header of a commit object, and try to re-code the log message into UTF-8 unless otherwise specified. You can specify the desired output encoding with i18n.logOutputEncoding in .git/config file, like this:\n\nIf you do not have this configuration variable, the value of i18n.commitEncoding is used instead.\n\nNote that we deliberately chose not to re-code the commit log message when a commit is made to force UTF-8 at the commit object level, because re-coding to UTF-8 is not necessarily a reversible operation.\n\n• The contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the core level.\n• Path names are encoded in UTF-8 normalization form C. This applies to tree objects, the index file, ref names, as well as path names in command line arguments, environment variables and config files (.git/config (see git-config[1]), gitignore[5], gitattributes[5] and gitmodules[5]). Note that Git at the core level treats path names simply as sequences of non-NUL bytes, there are no path name encoding conversions (except on Mac and Windows). Therefore, using non-ASCII path names will mostly work even on platforms and file systems that use legacy extended ASCII encodings. However, repositories created on such systems will not work properly on UTF-8-based systems (e.g. Linux, Mac, Windows) and vice versa. Additionally, many Git-based tools simply assume path names to be UTF-8 and will fail to display other encodings correctly.\n• Commit log messages are typically encoded in UTF-8, but other extended ASCII encodings are also supported. This includes ISO-8859-x, CP125x and many others, but not UTF-16/32, EBCDIC and CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.).\n\n• git commit and git commit-tree issue a warning if the commit log message given to it does not look like a valid UTF-8 string, unless you explicitly say your project uses a legacy encoding. The way to say this is to have i18n.commitEncoding in .git/config file, like this: [i18n] commitEncoding = ISO-8859-1 Commit objects created with the above setting record the value of i18n.commitEncoding in their encoding header. This is to help other people who look at them later. Lack of this header implies that the commit log message is encoded in UTF-8.\n• git log, git show, git blame and friends look at the encoding header of a commit object, and try to re-code the log message into UTF-8 unless otherwise specified. You can specify the desired output encoding with i18n.logOutputEncoding in .git/config file, like this: [i18n] logOutputEncoding = ISO-8859-1 If you do not have this configuration variable, the value of i18n.commitEncoding is used instead.",
        "code_examples": [
          "```bash\n[i18n]\n\tcommitEncoding = ISO-8859-1\n```",
          "```bash\n[i18n]\n\tlogOutputEncoding = ISO-8859-1\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 11,
          "content_length": 4852
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "See git-config[1] for core variables and git-diff[1] for settings related to diff generation.\n\nDefault for the --format option. (See Pretty Formats above.) Defaults to medium.\n\nEncoding to use when displaying logs. (See Discussion above.) Defaults to the value of i18n.commitEncoding if set, and UTF-8 otherwise.\n\nEverything above this line in this section isn’t included from the git-config[1] documentation. The content that follows is the same as what’s found there:\n\nIf true, make git-log[1], git-show[1], and git-whatchanged[1] assume --abbrev-commit. You may override this option with --no-abbrev-commit.\n\nSet the default date-time mode for the log command. Setting a value for log.date is similar to using git log's --date option. See git-log[1] for details.\n\nIf the format is set to \"auto:foo\" and the pager is in use, format \"foo\" will be used for the date format. Otherwise, \"default\" will be used.\n\nPrint out the ref names of any commits that are shown by the log command. Possible values are:\n\nthe ref name prefixes refs/heads/, refs/tags/ and refs/remotes/ are not printed.\n\nthe full ref name (including prefix) are printed.\n\nif the output is going to a terminal, the ref names are shown as if short were given, otherwise no ref names are shown.\n\nThis is the same as the --decorate option of the git log.\n\nBy default, git log only shows decorations for certain known ref namespaces. If all is specified, then show all refs as decorations.\n\nExclude the specified patterns from the log decorations. This is similar to the --decorate-refs-exclude command-line option, but the config option can be overridden by the --decorate-refs option.\n\nSet diff format to be used when --diff-merges=on is specified, see --diff-merges in git-log[1] for details. Defaults to separate.\n\nIf true, git log will act as if the --follow option was used when a single <path> is given. This has the same limitations as --follow, i.e. it cannot be used to follow multiple files and does not work well on non-linear history.\n\nA list of colors, separated by commas, that can be used to draw history lines in git log --graph.\n\nIf true, the initial commit will be shown as a big creation event. This is equivalent to a diff against an empty tree. Tools like git-log[1] or git-whatchanged[1], which normally hide the root commit will now show it. True by default.\n\nIf true, makes git-log[1], git-show[1], and git-whatchanged[1] assume --show-signature.\n\nIf true, makes git-log[1], git-show[1], and git-whatchanged[1] assume --use-mailmap, otherwise assume --no-use-mailmap. True by default.\n\nWhich merge strategy to choose by default when resolving notes conflicts. Must be one of manual, ours, theirs, union, or cat_sort_uniq. Defaults to manual. See the \"NOTES MERGE STRATEGIES\" section of git-notes[1] for more information on each strategy.\n\nThis setting can be overridden by passing the --strategy option to git-notes[1].\n\nWhich merge strategy to choose when doing a notes merge into refs/notes/<name>. This overrides the more general notes.mergeStrategy. See the \"NOTES MERGE STRATEGIES\" section in git-notes[1] for more information on the available strategies.\n\nWhich ref (or refs, if a glob or specified more than once), in addition to the default set by core.notesRef or GIT_NOTES_REF, to read notes from when showing commit messages with the git log family of commands.\n\nThis setting can be overridden with the GIT_NOTES_DISPLAY_REF environment variable, which must be a colon separated list of refs or globs.\n\nA warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.\n\nThis setting can be disabled by the --no-notes option to the git-log[1] family of commands, or by the --notes=<ref> option accepted by those commands.\n\nThe effective value of core.notesRef (possibly overridden by GIT_NOTES_REF) is also implicitly added to the list of refs to be displayed.\n\nWhen rewriting commits with <command> (currently amend or rebase), if this variable is false, git will not copy notes from the original to the rewritten commit. Defaults to true. See also notes.rewriteRef below.\n\nThis setting can be overridden with the GIT_NOTES_REWRITE_REF environment variable, which must be a colon separated list of refs or globs.\n\nWhen copying notes during a rewrite (see the notes.rewrite.<command> option), determines what to do if the target commit already has a note. Must be one of overwrite, concatenate, cat_sort_uniq, or ignore. Defaults to concatenate.\n\nThis setting can be overridden with the GIT_NOTES_REWRITE_MODE environment variable.\n\nWhen copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. May be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.\n\nDoes not have a default value; you must configure this variable to enable note rewriting. Set it to refs/notes/commits to enable rewriting for the default commit notes.\n\nCan be overridden with the GIT_NOTES_REWRITE_REF environment variable. See notes.rewrite.<command> above for a further description of its format.\n\n**format.pretty**: Default for the --format option. (See Pretty Formats above.) Defaults to medium.\n**i18n.logOutputEncoding**: Encoding to use when displaying logs. (See Discussion above.) Defaults to the value of i18n.commitEncoding if set, and UTF-8 otherwise.\n**log.abbrevCommit**: If true, make git-log[1], git-show[1], and git-whatchanged[1] assume --abbrev-commit. You may override this option with --no-abbrev-commit.\n**log.date**: Set the default date-time mode for the log command. Setting a value for log.date is similar to using git log's --date option. See git-log[1] for details. If the format is set to \"auto:foo\" and the pager is in use, format \"foo\" will be used for the date format. Otherwise, \"default\" will be used.\n**log.decorate**: Print out the ref names of any commits that are shown by the log command. Possible values are: short the ref name prefixes refs/heads/, refs/tags/ and refs/remotes/ are not printed. full the full ref name (including prefix) are printed. auto if the output is going to a terminal, the ref names are shown as if short were given, otherwise no ref names are shown. This is the same as the --decorate option of the git log.\n**short**: the ref name prefixes refs/heads/, refs/tags/ and refs/remotes/ are not printed.\n**full**: the full ref name (including prefix) are printed.\n**auto**: if the output is going to a terminal, the ref names are shown as if short were given, otherwise no ref names are shown.\n**log.initialDecorationSet**: By default, git log only shows decorations for certain known ref namespaces. If all is specified, then show all refs as decorations.\n**log.excludeDecoration**: Exclude the specified patterns from the log decorations. This is similar to the --decorate-refs-exclude command-line option, but the config option can be overridden by the --decorate-refs option.\n**log.diffMerges**: Set diff format to be used when --diff-merges=on is specified, see --diff-merges in git-log[1] for details. Defaults to separate.\n**log.follow**: If true, git log will act as if the --follow option was used when a single <path> is given. This has the same limitations as --follow, i.e. it cannot be used to follow multiple files and does not work well on non-linear history.\n**log.graphColors**: A list of colors, separated by commas, that can be used to draw history lines in git log --graph.\n**log.showRoot**: If true, the initial commit will be shown as a big creation event. This is equivalent to a diff against an empty tree. Tools like git-log[1] or git-whatchanged[1], which normally hide the root commit will now show it. True by default.\n**log.showSignature**: If true, makes git-log[1], git-show[1], and git-whatchanged[1] assume --show-signature.\n**log.mailmap**: If true, makes git-log[1], git-show[1], and git-whatchanged[1] assume --use-mailmap, otherwise assume --no-use-mailmap. True by default.\n**notes.mergeStrategy**: Which merge strategy to choose by default when resolving notes conflicts. Must be one of manual, ours, theirs, union, or cat_sort_uniq. Defaults to manual. See the \"NOTES MERGE STRATEGIES\" section of git-notes[1] for more information on each strategy. This setting can be overridden by passing the --strategy option to git-notes[1].\n**notes.<name>.mergeStrategy**: Which merge strategy to choose when doing a notes merge into refs/notes/<name>. This overrides the more general notes.mergeStrategy. See the \"NOTES MERGE STRATEGIES\" section in git-notes[1] for more information on the available strategies.\n**notes.displayRef**: Which ref (or refs, if a glob or specified more than once), in addition to the default set by core.notesRef or GIT_NOTES_REF, to read notes from when showing commit messages with the git log family of commands. This setting can be overridden with the GIT_NOTES_DISPLAY_REF environment variable, which must be a colon separated list of refs or globs. A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored. This setting can be disabled by the --no-notes option to the git-log[1] family of commands, or by the --notes=<ref> option accepted by those commands. The effective value of core.notesRef (possibly overridden by GIT_NOTES_REF) is also implicitly added to the list of refs to be displayed.\n**notes.rewrite.<command>**: When rewriting commits with <command> (currently amend or rebase), if this variable is false, git will not copy notes from the original to the rewritten commit. Defaults to true. See also notes.rewriteRef below. This setting can be overridden with the GIT_NOTES_REWRITE_REF environment variable, which must be a colon separated list of refs or globs.\n**notes.rewriteMode**: When copying notes during a rewrite (see the notes.rewrite.<command> option), determines what to do if the target commit already has a note. Must be one of overwrite, concatenate, cat_sort_uniq, or ignore. Defaults to concatenate. This setting can be overridden with the GIT_NOTES_REWRITE_MODE environment variable.\n**notes.rewriteRef**: When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. May be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times. Does not have a default value; you must configure this variable to enable note rewriting. Set it to refs/notes/commits to enable rewriting for the default commit notes. Can be overridden with the GIT_NOTES_REWRITE_REF environment variable. See notes.rewrite.<command> above for a further description of its format.\n**short**: the ref name prefixes refs/heads/, refs/tags/ and refs/remotes/ are not printed.\n**full**: the full ref name (including prefix) are printed.\n**auto**: if the output is going to a terminal, the ref names are shown as if short were given, otherwise no ref names are shown.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 35,
          "content_length": 10972
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-log",
    "doc_type": "git",
    "total_sections": 16
  },
  {
    "title": "Git",
    "summary": "NAME git-merge - Join two or more development histories together\n\ngit-merge - Join two or more development histories together",
    "sections": [
      {
        "header": "NAME",
        "content": "git-merge - Join two or more development histories together",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 59
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Incorporates changes from the named commits (since the time their histories diverged from the current branch) into the current branch. This command is used by git pull to incorporate changes from another repository and can be used by hand to merge changes from one branch into another.\n\nAssume the following history exists and the current branch is master:\n\nThen git merge topic will replay the changes made on the topic branch since it diverged from master (i.e., E) until its current commit (C) on top of master, and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes. Before the operation, ORIG_HEAD is set to the tip of the current branch (G).\n\nA merge stops if there’s a conflict that cannot be resolved automatically or if --no-commit was provided when initiating the merge. At that point you can run git merge --abort or git merge --continue.\n\ngit merge --abort will abort the merge process and try to reconstruct the pre-merge state. However, if there were uncommitted changes when the merge started (and especially if those changes were further modified after the merge was started), git merge --abort will in some cases be unable to reconstruct the original (pre-merge) changes. Therefore:\n\nWarning | Running git merge with non-trivial uncommitted changes is discouraged: while possible, it may leave you in a state that is hard to back out of in the case of a conflict.\n\n[Warning] Warning Running git merge with non-trivial uncommitted changes is discouraged: while possible, it may leave you in a state that is hard to back out of in the case of a conflict.",
        "code_examples": [
          "```bash\nA---B---C topic\n         /\n    D---E---F---G master\n```",
          "```bash\nA---B---C topic\n         /         \\\n    D---E---F---G---H master\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 5,
          "content_length": 1654
        }
      },
      {
        "header": "OPTIONS",
        "content": "Perform the merge and commit the result. This option can be used to override --no-commit.\n\nWith --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing.\n\nNote that fast-forward updates do not create a merge commit and therefore there is no way to stop those merges with --no-commit. Thus, if you want to ensure your branch is not changed or updated by the merge command, use --no-ff with --no-commit.\n\nInvoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The --no-edit option can be used to accept the auto-generated message (this is generally discouraged). The --edit (or -e) option is still useful if you are giving a draft message with the -m option from the command line and want to edit it in the editor.\n\nOlder scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run git merge. To make it easier to adjust such scripts to the updated behaviour, the environment variable GIT_MERGE_AUTOEDIT can be set to no at the beginning of them.\n\nThis option determines how the merge message will be cleaned up before committing. See git-commit[1] for more details. In addition, if the <mode> is given a value of scissors, scissors will be appended to MERGE_MSG before being passed on to the commit machinery in the case of a merge conflict.\n\nSpecifies how a merge is handled when the merged-in history is already a descendant of the current history. --ff is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the refs/tags/ hierarchy, in which case --no-ff is assumed.\n\nWith --ff, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit). When not possible (when the merged-in history is not a descendant of the current history), create a merge commit.\n\nWith --no-ff, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward.\n\nWith --ff-only, resolve the merge as a fast-forward when possible. When not possible, refuse to merge and exit with a non-zero status.\n\nGPG-sign the resulting merge commit. The <key-id> argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign.\n\nIn addition to branch names, populate the log message with one-line descriptions from at most <n> actual commits that are being merged. See also git-fmt-merge-msg[1].\n\nWith --no-log do not list one-line descriptions from the actual commits being merged.\n\nAdd a Signed-off-by trailer by the committer at the end of the commit log message. The meaning of a signoff depends on the project to which you’re committing. For example, it may certify that the committer has the rights to submit the work under the project’s license or agrees to some contributor representation, such as a Developer Certificate of Origin. (See https://developercertificate.org for the one used by the Linux kernel and Git projects.) Consult the documentation or leadership of the project to which you’re contributing to understand how the signoffs are used in that project.\n\nThe --no-signoff option can be used to countermand an earlier --signoff option on the command line.\n\nShow a diffstat at the end of the merge. The diffstat is also controlled by the configuration option merge.stat.\n\nWith -n or --no-stat do not show a diffstat at the end of the merge.\n\nShow a compact-summary at the end of the merge.\n\nProduce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the HEAD, or record $GIT_DIR/MERGE_HEAD (to cause the next git commit command to create a merge commit). This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus).\n\nWith --no-squash perform the merge and commit the result. This option can be used to override --squash.\n\nWith --squash, --commit is not allowed, and will fail.\n\nBy default, the pre-merge and commit-msg hooks are run. When --no-verify is given, these are bypassed. See also githooks[5].\n\nUse the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no -s option, a built-in list of strategies is used instead (ort when merging a single head, octopus otherwise).\n\nPass merge strategy specific option through to the merge strategy.\n\nVerify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key. If the tip commit of the side branch is not signed with a valid key, the merge is aborted.\n\nSynonyms to --stat and --no-stat; these are deprecated and will be removed in the future.\n\nOperate quietly. Implies --no-progress.\n\nTurn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal. Note that not all merge strategies may support progress reporting.\n\nAutomatically create a temporary stash entry before the operation begins, record it in the ref MERGE_AUTOSTASH and apply it after the operation ends. This means that you can run the operation on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts.\n\nBy default, git merge command refuses to merge histories that do not share a common ancestor. This option can be used to override this safety when merging histories of two projects that started their lives independently. As that is a very rare occasion, no configuration variable to enable this by default exists or will be added.\n\nSet the commit message to be used for the merge commit (in case one is created).\n\nIf --log is specified, a shortlog of the commits being merged will be appended to the specified message.\n\nThe git fmt-merge-msg command can be used to give a good default for automated git merge invocations. The automated message can include the branch description.\n\nPrepare the default merge message as if merging to the branch <branch>, instead of the name of the real branch to which the merge is made.\n\nRead the commit message to be used for the merge commit (in case one is created).\n\nIf --log is specified, a shortlog of the commits being merged will be appended to the specified message.\n\nAfter the rerere mechanism reuses a recorded resolution on the current conflict to update the files in the working tree, allow it to also update the index with the result of resolution. --no-rerere-autoupdate is a good way to double-check what rerere did and catch potential mismerges, before committing the result to the index with a separate git add.\n\nSilently overwrite ignored files from the merge result. This is the default behavior. Use --no-overwrite-ignore to abort.\n\nAbort the current conflict resolution process, and try to reconstruct the pre-merge state. If an autostash entry is present, apply it to the worktree.\n\nIf there were uncommitted worktree changes present when the merge started, git merge --abort will in some cases be unable to reconstruct these changes. It is therefore recommended to always commit or stash your changes before running git merge.\n\ngit merge --abort is equivalent to git reset --merge when MERGE_HEAD is present unless MERGE_AUTOSTASH is also present in which case git merge --abort applies the stash entry to the worktree whereas git reset --merge will save the stashed changes in the stash list.\n\nForget about the current merge in progress. Leave the index and the working tree as-is. If MERGE_AUTOSTASH is present, the stash entry will be saved to the stash list.\n\nAfter a git merge stops due to conflicts you can conclude the merge by running git merge --continue (see \"HOW TO RESOLVE CONFLICTS\" section below).\n\nCommits, usually other branch heads, to merge into our branch. Specifying more than one commit will create a merge with more than two parents (affectionately called an Octopus merge).\n\nIf no commit is given from the command line, merge the remote-tracking branches that the current branch is configured to use as its upstream. See also the configuration section of this manual page.\n\nWhen FETCH_HEAD (and no other commit) is specified, the branches recorded in the .git/FETCH_HEAD file by the previous invocation of git fetch for merging are merged to the current branch.\n\n**--commit**: Perform the merge and commit the result. This option can be used to override --no-commit. With --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing. Note that fast-forward updates do not create a merge commit and therefore there is no way to stop those merges with --no-commit. Thus, if you want to ensure your branch is not changed or updated by the merge command, use --no-ff with --no-commit.\n**--no-commit**: Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The --no-edit option can be used to accept the auto-generated message (this is generally discouraged). The --edit (or -e) option is still useful if you are giving a draft message with the -m option from the command line and want to edit it in the editor. Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run git merge. To make it easier to adjust such scripts to the updated behaviour, the environment variable GIT_MERGE_AUTOEDIT can be set to no at the beginning of them.\n**--edit**: This option determines how the merge message will be cleaned up before committing. See git-commit[1] for more details. In addition, if the <mode> is given a value of scissors, scissors will be appended to MERGE_MSG before being passed on to the commit machinery in the case of a merge conflict.\n**-e**: Specifies how a merge is handled when the merged-in history is already a descendant of the current history. --ff is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the refs/tags/ hierarchy, in which case --no-ff is assumed. With --ff, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit). When not possible (when the merged-in history is not a descendant of the current history), create a merge commit. With --no-ff, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward. With --ff-only, resolve the merge as a fast-forward when possible. When not possible, refuse to merge and exit with a non-zero status.\n**--no-edit**: GPG-sign the resulting merge commit. The <key-id> argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign.\n**--cleanup=<mode>**: In addition to branch names, populate the log message with one-line descriptions from at most <n> actual commits that are being merged. See also git-fmt-merge-msg[1]. With --no-log do not list one-line descriptions from the actual commits being merged.\n**--ff**: Add a Signed-off-by trailer by the committer at the end of the commit log message. The meaning of a signoff depends on the project to which you’re committing. For example, it may certify that the committer has the rights to submit the work under the project’s license or agrees to some contributor representation, such as a Developer Certificate of Origin. (See https://developercertificate.org for the one used by the Linux kernel and Git projects.) Consult the documentation or leadership of the project to which you’re contributing to understand how the signoffs are used in that project. The --no-signoff option can be used to countermand an earlier --signoff option on the command line.\n**--no-ff**: Show a diffstat at the end of the merge. The diffstat is also controlled by the configuration option merge.stat. With -n or --no-stat do not show a diffstat at the end of the merge.\n**--ff-only**: Show a compact-summary at the end of the merge.\n**-S[<key-id>]**: Produce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the HEAD, or record $GIT_DIR/MERGE_HEAD (to cause the next git commit command to create a merge commit). This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus). With --no-squash perform the merge and commit the result. This option can be used to override --squash. With --squash, --commit is not allowed, and will fail.\n**--gpg-sign[=<key-id>]**: By default, the pre-merge and commit-msg hooks are run. When --no-verify is given, these are bypassed. See also githooks[5].\n**--no-gpg-sign**: Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no -s option, a built-in list of strategies is used instead (ort when merging a single head, octopus otherwise).\n**--log[=<n>]**: Pass merge strategy specific option through to the merge strategy.\n**--no-log**: Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key. If the tip commit of the side branch is not signed with a valid key, the merge is aborted.\n**--signoff**: Synonyms to --stat and --no-stat; these are deprecated and will be removed in the future.\n**--no-signoff**: Operate quietly. Implies --no-progress.\n**--stat**: Be verbose.\n**-n**: Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal. Note that not all merge strategies may support progress reporting.\n**--no-stat**: Automatically create a temporary stash entry before the operation begins, record it in the ref MERGE_AUTOSTASH and apply it after the operation ends. This means that you can run the operation on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts.\n**--compact-summary**: By default, git merge command refuses to merge histories that do not share a common ancestor. This option can be used to override this safety when merging histories of two projects that started their lives independently. As that is a very rare occasion, no configuration variable to enable this by default exists or will be added.\n**--squash**: Set the commit message to be used for the merge commit (in case one is created). If --log is specified, a shortlog of the commits being merged will be appended to the specified message. The git fmt-merge-msg command can be used to give a good default for automated git merge invocations. The automated message can include the branch description.\n**--no-squash**: Prepare the default merge message as if merging to the branch <branch>, instead of the name of the real branch to which the merge is made.\n**--[no-]verify**: Read the commit message to be used for the merge commit (in case one is created). If --log is specified, a shortlog of the commits being merged will be appended to the specified message.\n**-s <strategy>**: After the rerere mechanism reuses a recorded resolution on the current conflict to update the files in the working tree, allow it to also update the index with the result of resolution. --no-rerere-autoupdate is a good way to double-check what rerere did and catch potential mismerges, before committing the result to the index with a separate git add.\n**--strategy=<strategy>**: Silently overwrite ignored files from the merge result. This is the default behavior. Use --no-overwrite-ignore to abort.\n**-X <option>**: Abort the current conflict resolution process, and try to reconstruct the pre-merge state. If an autostash entry is present, apply it to the worktree. If there were uncommitted worktree changes present when the merge started, git merge --abort will in some cases be unable to reconstruct these changes. It is therefore recommended to always commit or stash your changes before running git merge. git merge --abort is equivalent to git reset --merge when MERGE_HEAD is present unless MERGE_AUTOSTASH is also present in which case git merge --abort applies the stash entry to the worktree whereas git reset --merge will save the stashed changes in the stash list.\n**--strategy-option=<option>**: Forget about the current merge in progress. Leave the index and the working tree as-is. If MERGE_AUTOSTASH is present, the stash entry will be saved to the stash list.\n**--verify-signatures**: After a git merge stops due to conflicts you can conclude the merge by running git merge --continue (see \"HOW TO RESOLVE CONFLICTS\" section below).\n**--no-verify-signatures**: Commits, usually other branch heads, to merge into our branch. Specifying more than one commit will create a merge with more than two parents (affectionately called an Octopus merge). If no commit is given from the command line, merge the remote-tracking branches that the current branch is configured to use as its upstream. See also the configuration section of this manual page. When FETCH_HEAD (and no other commit) is specified, the branches recorded in the .git/FETCH_HEAD file by the previous invocation of git fetch for merging are merged to the current branch.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 46,
          "content_length": 18099
        }
      },
      {
        "header": "PRE-MERGE CHECKS",
        "content": "Before applying outside changes, you should get your own work in good shape and committed locally, so it will not be clobbered if there are conflicts. See also git-stash[1]. git pull and git merge will stop without doing anything when local uncommitted changes overlap with files that git pull/git merge may need to update.\n\nTo avoid recording unrelated changes in the merge commit, git pull and git merge will also abort if there are any changes registered in the index relative to the HEAD commit. (Special narrow exceptions to this rule may exist depending on which merge strategy is in use, but generally, the index must match HEAD.)\n\nIf all named commits are already ancestors of HEAD, git merge will exit early with the message \"Already up to date.\"",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 755
        }
      },
      {
        "header": "FAST-FORWARD MERGE",
        "content": "Often the current branch head is an ancestor of the named commit. This is the most common case especially when invoked from git pull: you are tracking an upstream repository, you have committed no local changes, and now you want to update to a newer upstream revision. In this case, a new commit is not needed to store the combined history; instead, the HEAD (along with the index) is updated to point at the named commit, without creating an extra merge commit.\n\nThis behavior can be suppressed with the --no-ff option.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 520
        }
      },
      {
        "header": "TRUE MERGE",
        "content": "Except in a fast-forward merge (see above), the branches to be merged must be tied together by a merge commit that has both of them as its parents.\n\nA merged version reconciling the changes from all branches to be merged is committed, and your HEAD, index, and working tree are updated to it. It is possible to have modifications in the working tree as long as they do not overlap; the update will preserve them.\n\nWhen it is not obvious how to reconcile the changes, the following happens:\n\nThe HEAD pointer stays the same.\n\nThe MERGE_HEAD ref is set to point to the other branch head.\n\nPaths that merged cleanly are updated both in the index file and in your working tree.\n\nFor conflicting paths, the index file records up to three versions: stage 1 stores the version from the common ancestor, stage 2 from HEAD, and stage 3 from MERGE_HEAD (you can inspect the stages with git ls-files -u). The working tree files contain the result of the merge operation; i.e. 3-way merge results with familiar conflict markers <<< === >>>.\n\nA ref named AUTO_MERGE is written, pointing to a tree corresponding to the current content of the working tree (including conflict markers for textual conflicts). Note that this ref is only written when the ort merge strategy is used (the default).\n\nNo other changes are made. In particular, the local modifications you had before you started merge will stay the same and the index entries for them stay as they were, i.e. matching HEAD.\n\nIf you tried a merge which resulted in complex conflicts and want to start over, you can recover with git merge --abort.\n\n• The HEAD pointer stays the same.\n• The MERGE_HEAD ref is set to point to the other branch head.\n• Paths that merged cleanly are updated both in the index file and in your working tree.\n• For conflicting paths, the index file records up to three versions: stage 1 stores the version from the common ancestor, stage 2 from HEAD, and stage 3 from MERGE_HEAD (you can inspect the stages with git ls-files -u). The working tree files contain the result of the merge operation; i.e. 3-way merge results with familiar conflict markers <<< === >>>.\n• A ref named AUTO_MERGE is written, pointing to a tree corresponding to the current content of the working tree (including conflict markers for textual conflicts). Note that this ref is only written when the ort merge strategy is used (the default).\n• No other changes are made. In particular, the local modifications you had before you started merge will stay the same and the index entries for them stay as they were, i.e. matching HEAD.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 2574
        }
      },
      {
        "header": "MERGING TAG",
        "content": "When merging an annotated (and possibly signed) tag, Git always creates a merge commit even if a fast-forward merge is possible, and the commit message template is prepared with the tag message. Additionally, if the tag is signed, the signature check is reported as a comment in the message template. See also git-tag[1].\n\nWhen you want to just integrate with the work leading to the commit that happens to be tagged, e.g. synchronizing with an upstream release point, you may not want to make an unnecessary merge commit.\n\nIn such a case, you can \"unwrap\" the tag yourself before feeding it to git merge, or pass --ff-only when you do not have any work on your own. e.g.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit fetch origin\ngit merge v1.2.3^0\ngit merge --ff-only v1.2.3\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 671
        }
      },
      {
        "header": "HOW CONFLICTS ARE PRESENTED",
        "content": "During a merge, the working tree files are updated to reflect the result of the merge. Among the changes made to the common ancestor’s version, non-overlapping ones (that is, you changed an area of the file while the other side left that area intact, or vice versa) are incorporated in the final result verbatim. When both sides made changes to the same area, however, Git cannot randomly pick one side over the other, and asks you to resolve it by leaving what both sides did to that area.\n\nBy default, Git uses the same style as the one used by the \"merge\" program from the RCS suite to present such a conflicted hunk, like this:\n\nThe area where a pair of conflicting changes happened is marked with markers <<<<<<<, =======, and >>>>>>>. The part before the ======= is typically your side, and the part afterwards is typically their side.\n\nThe default format does not show what the original said in the conflicting area. You cannot tell how many lines are deleted and replaced with Barbie’s remark on your side. The only thing you can tell is that your side wants to say it is hard and you’d prefer to go shopping, while the other side wants to claim it is easy.\n\nAn alternative style can be used by setting the merge.conflictStyle configuration variable to either diff3 or zdiff3. In diff3 style, the above conflict may look like this:\n\nwhile in zdiff3 style, it may look like this:\n\nIn addition to the <<<<<<<, =======, and >>>>>>> markers, it uses another ||||||| marker that is followed by the original text. You can tell that the original just stated a fact, and your side simply gave in to that statement and gave up, while the other side tried to have a more positive attitude. You can sometimes come up with a better resolution by viewing the original.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nHere are lines that are either unchanged from the common\nancestor, or cleanly resolved because only one side changed,\nor cleanly resolved because both sides changed the same way.\n<<<<<<< yours:sample.txt\nConflict resolution is hard;\nlet's go shopping.\n=======\nGit makes conflict resolution easy.\n>>>>>>> theirs:sample.txt\nAnd here is another line that is cleanly resolved or unmodified.\n```",
          "```bash\nHere are lines that are either unchanged from the common\nancestor, or cleanly resolved because only one side changed,\n<<<<<<< yours:sample.txt\nor cleanly resolved because both sides changed the same way.\nConflict resolution is hard;\nlet's go shopping.\n||||||| base:sample.txt\nor cleanly resolved because both sides changed identically.\nConflict resolution is hard.\n=======\nor cleanly resolved because both sides changed the same way.\nGit makes conflict resolution easy.\n>>>>>>> theirs:sample.txt\nAnd here is another line that is cleanly resolved or unmodified.\n```",
          "```bash\nHere are lines that are either unchanged from the common\nancestor, or cleanly resolved because only one side changed,\nor cleanly resolved because both sides changed the same way.\n<<<<<<< yours:sample.txt\nConflict resolution is hard;\nlet's go shopping.\n||||||| base:sample.txt\nor cleanly resolved because both sides changed identically.\nConflict resolution is hard.\n=======\nGit makes conflict resolution easy.\n>>>>>>> theirs:sample.txt\nAnd here is another line that is cleanly resolved or unmodified.\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1763
        }
      },
      {
        "header": "HOW TO RESOLVE CONFLICTS",
        "content": "After seeing a conflict, you can do two things:\n\nDecide not to merge. The only clean-ups you need are to reset the index file to the HEAD commit to reverse 2. and to clean up working tree changes made by 2. and 3.; git merge --abort can be used for this.\n\nResolve the conflicts. Git will mark the conflicts in the working tree. Edit the files into shape and git add them to the index. Use git commit or git merge --continue to seal the deal. The latter command checks whether there is a (interrupted) merge in progress before calling git commit.\n\nYou can work through the conflict with a number of tools:\n\nUse a mergetool. git mergetool to launch a graphical mergetool which will work through the merge with you.\n\nLook at the diffs. git diff will show a three-way diff, highlighting changes from both the HEAD and MERGE_HEAD versions. git diff AUTO_MERGE will show what changes you’ve made so far to resolve textual conflicts.\n\nLook at the diffs from each branch. git log --merge -p <path> will show diffs first for the HEAD version and then the MERGE_HEAD version.\n\nLook at the originals. git show :1:filename shows the common ancestor, git show :2:filename shows the HEAD version, and git show :3:filename shows the MERGE_HEAD version.\n\n• Decide not to merge. The only clean-ups you need are to reset the index file to the HEAD commit to reverse 2. and to clean up working tree changes made by 2. and 3.; git merge --abort can be used for this.\n• Resolve the conflicts. Git will mark the conflicts in the working tree. Edit the files into shape and git add them to the index. Use git commit or git merge --continue to seal the deal. The latter command checks whether there is a (interrupted) merge in progress before calling git commit.\n\n• Use a mergetool. git mergetool to launch a graphical mergetool which will work through the merge with you.\n• Look at the diffs. git diff will show a three-way diff, highlighting changes from both the HEAD and MERGE_HEAD versions. git diff AUTO_MERGE will show what changes you’ve made so far to resolve textual conflicts.\n• Look at the diffs from each branch. git log --merge -p <path> will show diffs first for the HEAD version and then the MERGE_HEAD version.\n• Look at the originals. git show :1:filename shows the common ancestor, git show :2:filename shows the HEAD version, and git show :3:filename shows the MERGE_HEAD version.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 2376
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Merge branches fixes and enhancements on top of the current branch, making an octopus merge:\n\nMerge branch obsolete into the current branch, using ours merge strategy:\n\nMerge branch maint into the current branch, but do not make a new commit automatically:\n\nThis can be used when you want to include further changes to the merge, or want to write your own merge commit message.\n\nYou should refrain from abusing this option to sneak substantial changes into a merge commit. Small fixups like bumping release/version name would be acceptable.\n\n• Merge branches fixes and enhancements on top of the current branch, making an octopus merge: $ git merge fixes enhancements\n• Merge branch obsolete into the current branch, using ours merge strategy: $ git merge -s ours obsolete\n• Merge branch maint into the current branch, but do not make a new commit automatically: $ git merge --no-commit maint This can be used when you want to include further changes to the merge, or want to write your own merge commit message. You should refrain from abusing this option to sneak substantial changes into a merge commit. Small fixups like bumping release/version name would be acceptable.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git merge fixes enhancements\n```",
          "```bash\n$ git merge -s ours obsolete\n```",
          "```bash\n$ git merge --no-commit maint\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1174
        }
      },
      {
        "header": "MERGE STRATEGIES",
        "content": "The merge mechanism (git merge and git pull commands) allows the backend merge strategies to be chosen with -s option. Some strategies can also take their own options, which can be passed by giving -X<option> arguments to git merge and/or git pull.\n\nThis is the default merge strategy when pulling or merging one branch. This strategy can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this strategy can detect and handle merges involving renames. It does not make use of detected copies. The name for this algorithm is an acronym (\"Ostensibly Recursive’s Twin\") and came from the fact that it was written as a replacement for the previous default algorithm, recursive.\n\nIn the case where the path is a submodule, if the submodule commit used on one side of the merge is a descendant of the submodule commit used on the other side of the merge, Git attempts to fast-forward to the descendant. Otherwise, Git will treat this case as a conflict, suggesting as a resolution a submodule commit that is descendant of the conflicting ones, if one exists.\n\nThe ort strategy can take the following options:\n\nThis option forces conflicting hunks to be auto-resolved cleanly by favoring our version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side.\n\nThis should not be confused with the ours merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring our history contains all that happened in it.\n\nThis is the opposite of ours; note that, unlike ours, there is no theirs merge strategy to confuse this merge option with.\n\nTreats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also git-diff[1] -b, -w, --ignore-space-at-eol, and --ignore-cr-at-eol.\n\nIf their version only introduces whitespace changes to a line, our version is used;\n\nIf our version introduces whitespace changes but their version includes a substantial change, their version is used;\n\nOtherwise, the merge proceeds in the usual way.\n\nThis runs a virtual check-out and check-in of all three stages of any file which needs a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See \"Merging branches with differing checkin/checkout attributes\" in gitattributes[5] for details.\n\nDisables the renormalize option. This overrides the merge.renormalize configuration variable.\n\nTurn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the merge.renames configuration variable. See also git-diff[1] --find-renames.\n\nDeprecated synonym for find-renames=<n>.\n\nTurn off rename detection. This overrides the merge.renames configuration variable. See also git-diff[1] --no-renames.\n\nDeprecated synonym for diff-algorithm=histogram.\n\nDeprecated synonym for diff-algorithm=patience.\n\nUse a different diff algorithm while merging, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also git-diff[1] --diff-algorithm. Note that ort defaults to diff-algorithm=histogram, while regular diffs currently default to the diff.algorithm config setting.\n\nThis option is a more advanced form of subtree strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.\n\nThis is now a synonym for ort. It was an alternative implementation until v2.49.0, but was redirected to mean ort in v2.50.0. The previous recursive strategy was the default strategy for resolving two heads from Git v0.99.9k until v2.33.0.\n\nThis can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm. It tries to carefully detect criss-cross merge ambiguities. It does not handle renames.\n\nThis resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branch.\n\nThis resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the ort merge strategy.\n\nThis is a modified ort strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree.\n\nWith the strategies that use 3-way merge (including the default, ort), if a change is made on both branches, but later reverted on one of the branches, that change will be present in the merged result; some people find this behavior confusing. It occurs because only the heads and the merge base are considered when performing a merge, not the individual commits. The merge algorithm therefore considers the reverted change as no change at all, and substitutes the changed version instead.\n\n• If their version only introduces whitespace changes to a line, our version is used;\n• If our version introduces whitespace changes but their version includes a substantial change, their version is used;\n• Otherwise, the merge proceeds in the usual way.\n\n**ort**: This is the default merge strategy when pulling or merging one branch. This strategy can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this strategy can detect and handle merges involving renames. It does not make use of detected copies. The name for this algorithm is an acronym (\"Ostensibly Recursive’s Twin\") and came from the fact that it was written as a replacement for the previous default algorithm, recursive. In the case where the path is a submodule, if the submodule commit used on one side of the merge is a descendant of the submodule commit used on the other side of the merge, Git attempts to fast-forward to the descendant. Otherwise, Git will treat this case as a conflict, suggesting as a resolution a submodule commit that is descendant of the conflicting ones, if one exists. The ort strategy can take the following options: ours This option forces conflicting hunks to be auto-resolved cleanly by favoring our version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side. This should not be confused with the ours merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring our history contains all that happened in it. theirs This is the opposite of ours; note that, unlike ours, there is no theirs merge strategy to confuse this merge option with. ignore-space-change ignore-all-space ignore-space-at-eol ignore-cr-at-eol Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also git-diff[1] -b, -w, --ignore-space-at-eol, and --ignore-cr-at-eol. If their version only introduces whitespace changes to a line, our version is used; If our version introduces whitespace changes but their version includes a substantial change, their version is used; Otherwise, the merge proceeds in the usual way. renormalize This runs a virtual check-out and check-in of all three stages of any file which needs a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See \"Merging branches with differing checkin/checkout attributes\" in gitattributes[5] for details. no-renormalize Disables the renormalize option. This overrides the merge.renormalize configuration variable. find-renames[=<n>] Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the merge.renames configuration variable. See also git-diff[1] --find-renames. rename-threshold=<n> Deprecated synonym for find-renames=<n>. no-renames Turn off rename detection. This overrides the merge.renames configuration variable. See also git-diff[1] --no-renames. histogram Deprecated synonym for diff-algorithm=histogram. patience Deprecated synonym for diff-algorithm=patience. diff-algorithm=(histogram|minimal|myers|patience) Use a different diff algorithm while merging, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also git-diff[1] --diff-algorithm. Note that ort defaults to diff-algorithm=histogram, while regular diffs currently default to the diff.algorithm config setting. subtree[=<path>] This option is a more advanced form of subtree strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.\n**ours**: This option forces conflicting hunks to be auto-resolved cleanly by favoring our version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side. This should not be confused with the ours merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring our history contains all that happened in it.\n**theirs**: This is the opposite of ours; note that, unlike ours, there is no theirs merge strategy to confuse this merge option with.\n**ignore-space-change**: Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also git-diff[1] -b, -w, --ignore-space-at-eol, and --ignore-cr-at-eol. If their version only introduces whitespace changes to a line, our version is used; If our version introduces whitespace changes but their version includes a substantial change, their version is used; Otherwise, the merge proceeds in the usual way.\n**ignore-all-space**: This runs a virtual check-out and check-in of all three stages of any file which needs a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See \"Merging branches with differing checkin/checkout attributes\" in gitattributes[5] for details.\n**ignore-space-at-eol**: Disables the renormalize option. This overrides the merge.renormalize configuration variable.\n**ignore-cr-at-eol**: Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the merge.renames configuration variable. See also git-diff[1] --find-renames.\n**renormalize**: Deprecated synonym for find-renames=<n>.\n**no-renormalize**: Turn off rename detection. This overrides the merge.renames configuration variable. See also git-diff[1] --no-renames.\n**find-renames[=<n>]**: Deprecated synonym for diff-algorithm=histogram.\n**rename-threshold=<n>**: Deprecated synonym for diff-algorithm=patience.\n**no-renames**: Use a different diff algorithm while merging, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also git-diff[1] --diff-algorithm. Note that ort defaults to diff-algorithm=histogram, while regular diffs currently default to the diff.algorithm config setting.\n**histogram**: This option is a more advanced form of subtree strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.\n**patience**: This is now a synonym for ort. It was an alternative implementation until v2.49.0, but was redirected to mean ort in v2.50.0. The previous recursive strategy was the default strategy for resolving two heads from Git v0.99.9k until v2.33.0.\n**diff-algorithm=(histogram|minimal|myers|patience)**: This can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm. It tries to carefully detect criss-cross merge ambiguities. It does not handle renames.\n**subtree[=<path>]**: This resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branch.\n**recursive**: This resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the ort merge strategy.\n**resolve**: This is a modified ort strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree.\n**ours**: This option forces conflicting hunks to be auto-resolved cleanly by favoring our version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side. This should not be confused with the ours merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring our history contains all that happened in it.\n**theirs**: This is the opposite of ours; note that, unlike ours, there is no theirs merge strategy to confuse this merge option with.\n**ignore-space-change**: Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also git-diff[1] -b, -w, --ignore-space-at-eol, and --ignore-cr-at-eol. If their version only introduces whitespace changes to a line, our version is used; If our version introduces whitespace changes but their version includes a substantial change, their version is used; Otherwise, the merge proceeds in the usual way.\n**ignore-all-space**: This runs a virtual check-out and check-in of all three stages of any file which needs a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See \"Merging branches with differing checkin/checkout attributes\" in gitattributes[5] for details.\n**ignore-space-at-eol**: Disables the renormalize option. This overrides the merge.renormalize configuration variable.\n**ignore-cr-at-eol**: Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the merge.renames configuration variable. See also git-diff[1] --find-renames.\n**renormalize**: Deprecated synonym for find-renames=<n>.\n**no-renormalize**: Turn off rename detection. This overrides the merge.renames configuration variable. See also git-diff[1] --no-renames.\n**find-renames[=<n>]**: Deprecated synonym for diff-algorithm=histogram.\n**rename-threshold=<n>**: Deprecated synonym for diff-algorithm=patience.\n**no-renames**: Use a different diff algorithm while merging, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also git-diff[1] --diff-algorithm. Note that ort defaults to diff-algorithm=histogram, while regular diffs currently default to the diff.algorithm config setting.\n**histogram**: This option is a more advanced form of subtree strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 26,
          "content_length": 17184
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Sets default options for merging into branch <name>. The syntax and supported options are the same as those of git merge, but option values containing whitespace characters are currently not supported.\n\nEverything above this line in this section isn’t included from the git-config[1] documentation. The content that follows is the same as what’s found there:\n\nSpecify the style in which conflicted hunks are written out to working tree files upon merge. The default is \"merge\", which shows a <<<<<<< conflict marker, changes made by one side, a ======= marker, changes made by the other side, and then a >>>>>>> marker. An alternate style, \"diff3\", adds a ||||||| marker and the original text before the ======= marker. The \"merge\" style tends to produce smaller conflict regions than diff3, both because of the exclusion of the original text, and because when a subset of lines match on the two sides, they are just pulled out of the conflict region. Another alternate style, \"zdiff3\", is similar to diff3 but removes matching lines on the two sides from the conflict region when those matching lines appear near either the beginning or end of a conflict region.\n\nIf merge is called without any commit argument, merge the upstream branches configured for the current branch by using their last observed values stored in their remote-tracking branches. The values of the branch.<current branch>.merge that name the branches at the remote named by branch.<current-branch>.remote are consulted, and then they are mapped via remote.<remote>.fetch to their corresponding remote-tracking branches, and the tips of these tracking branches are merged. Defaults to true.\n\nBy default, Git does not create an extra merge commit when merging a commit that is a descendant of the current commit. Instead, the tip of the current branch is fast-forwarded. When set to false, this variable tells Git to create an extra merge commit in such a case (equivalent to giving the --no-ff option from the command line). When set to only, only such fast-forward merges are allowed (equivalent to giving the --ff-only option from the command line).\n\nIf true, this is equivalent to the --verify-signatures command line option. See git-merge[1] for details.\n\nIn addition to branch names, populate the log message with the branch description text associated with them. Defaults to false.\n\nIn addition to branch names, populate the log message with at most the specified number of one-line descriptions from the actual commits that are being merged. Defaults to false, and true is a synonym for 20.\n\nBy adding a glob that matches the names of integration branches to this multi-valued configuration variable, the default merge message computed for merges into these integration branches will omit \"into <branch-name>\" from its title.\n\nAn element with an empty value can be used to clear the list of globs accumulated from previous configuration entries. When there is no merge.suppressDest variable defined, the default value of master is used for backward compatibility.\n\nThe number of files to consider in the exhaustive portion of rename detection during a merge. If not specified, defaults to the value of diff.renameLimit. If neither merge.renameLimit nor diff.renameLimit are specified, currently defaults to 7000. This setting has no effect if rename detection is turned off.\n\nWhether Git detects renames. If set to false, rename detection is disabled. If set to true, basic rename detection is enabled. Defaults to the value of diff.renames.\n\nWhether Git detects directory renames, affecting what happens at merge time to new files added to a directory on one side of history when that directory was renamed on the other side of history. Possible values are:\n\nDirectory rename detection is disabled, meaning that such new files will be left behind in the old directory.\n\nDirectory rename detection is enabled, meaning that such new files will be moved into the new directory.\n\nA conflict will be reported for such paths.\n\nIf merge.renames is false, merge.directoryRenames is ignored and treated as false. Defaults to conflict.\n\nTell Git that canonical representation of files in the repository has changed over time (e.g. earlier commits record text files with CRLF line endings, but recent ones use LF line endings). In such a repository, for each file where a three-way content merge is needed, Git can convert the data recorded in commits to a canonical form before performing a merge to reduce unnecessary conflicts. For more information, see section \"Merging branches with differing checkin/checkout attributes\" in gitattributes[5].\n\nWhat, if anything, to print between ORIG_HEAD and the merge result at the end of the merge. Possible values are:\n\nShow git diff --diffstat --summary ORIG_HEAD.\n\nShow git diff --compact-summary ORIG_HEAD.\n\nbut any unrecognised value (e.g., a value added by a future version of Git) is taken as true instead of triggering an error. Defaults to true.\n\nWhen set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run merge on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts. This option can be overridden by the --no-autostash and --autostash options of git-merge[1]. Defaults to false.\n\nControls which merge tool is used by git-mergetool[1]. The list below shows the valid built-in values. Any other value is treated as a custom merge tool and requires that a corresponding mergetool.<tool>.cmd variable is defined.\n\nControls which merge tool is used by git-mergetool[1] when the -g/--gui flag is specified. The list below shows the valid built-in values. Any other value is treated as a custom merge tool and requires that a corresponding mergetool.<guitool>.cmd variable is defined.\n\nControls the amount of output shown by the recursive merge strategy. Level 0 outputs nothing except a final error message if conflicts were detected. Level 1 outputs only conflicts, 2 outputs conflicts and file changes. Level 5 and above outputs debugging information. The default is level 2. Can be overridden by the GIT_MERGE_VERBOSITY environment variable.\n\nDefines a human-readable name for a custom low-level merge driver. See gitattributes[5] for details.\n\nDefines the command that implements a custom low-level merge driver. See gitattributes[5] for details.\n\nNames a low-level merge driver to be used when performing an internal merge between common ancestors. See gitattributes[5] for details.\n\n• codecompare\n• deltawalker\n• tortoisemerge\n\n**branch.<name>.mergeOptions**: Sets default options for merging into branch <name>. The syntax and supported options are the same as those of git merge, but option values containing whitespace characters are currently not supported.\n**merge.conflictStyle**: Specify the style in which conflicted hunks are written out to working tree files upon merge. The default is \"merge\", which shows a <<<<<<< conflict marker, changes made by one side, a ======= marker, changes made by the other side, and then a >>>>>>> marker. An alternate style, \"diff3\", adds a ||||||| marker and the original text before the ======= marker. The \"merge\" style tends to produce smaller conflict regions than diff3, both because of the exclusion of the original text, and because when a subset of lines match on the two sides, they are just pulled out of the conflict region. Another alternate style, \"zdiff3\", is similar to diff3 but removes matching lines on the two sides from the conflict region when those matching lines appear near either the beginning or end of a conflict region.\n**merge.defaultToUpstream**: If merge is called without any commit argument, merge the upstream branches configured for the current branch by using their last observed values stored in their remote-tracking branches. The values of the branch.<current branch>.merge that name the branches at the remote named by branch.<current-branch>.remote are consulted, and then they are mapped via remote.<remote>.fetch to their corresponding remote-tracking branches, and the tips of these tracking branches are merged. Defaults to true.\n**merge.ff**: By default, Git does not create an extra merge commit when merging a commit that is a descendant of the current commit. Instead, the tip of the current branch is fast-forwarded. When set to false, this variable tells Git to create an extra merge commit in such a case (equivalent to giving the --no-ff option from the command line). When set to only, only such fast-forward merges are allowed (equivalent to giving the --ff-only option from the command line).\n**merge.verifySignatures**: If true, this is equivalent to the --verify-signatures command line option. See git-merge[1] for details.\n**merge.branchdesc**: In addition to branch names, populate the log message with the branch description text associated with them. Defaults to false.\n**merge.log**: In addition to branch names, populate the log message with at most the specified number of one-line descriptions from the actual commits that are being merged. Defaults to false, and true is a synonym for 20.\n**merge.suppressDest**: By adding a glob that matches the names of integration branches to this multi-valued configuration variable, the default merge message computed for merges into these integration branches will omit \"into <branch-name>\" from its title. An element with an empty value can be used to clear the list of globs accumulated from previous configuration entries. When there is no merge.suppressDest variable defined, the default value of master is used for backward compatibility.\n**merge.renameLimit**: The number of files to consider in the exhaustive portion of rename detection during a merge. If not specified, defaults to the value of diff.renameLimit. If neither merge.renameLimit nor diff.renameLimit are specified, currently defaults to 7000. This setting has no effect if rename detection is turned off.\n**merge.renames**: Whether Git detects renames. If set to false, rename detection is disabled. If set to true, basic rename detection is enabled. Defaults to the value of diff.renames.\n**merge.directoryRenames**: Whether Git detects directory renames, affecting what happens at merge time to new files added to a directory on one side of history when that directory was renamed on the other side of history. Possible values are: false Directory rename detection is disabled, meaning that such new files will be left behind in the old directory. true Directory rename detection is enabled, meaning that such new files will be moved into the new directory. conflict A conflict will be reported for such paths. If merge.renames is false, merge.directoryRenames is ignored and treated as false. Defaults to conflict.\n**false**: Directory rename detection is disabled, meaning that such new files will be left behind in the old directory.\n**true**: Directory rename detection is enabled, meaning that such new files will be moved into the new directory.\n**conflict**: A conflict will be reported for such paths.\n**merge.renormalize**: Tell Git that canonical representation of files in the repository has changed over time (e.g. earlier commits record text files with CRLF line endings, but recent ones use LF line endings). In such a repository, for each file where a three-way content merge is needed, Git can convert the data recorded in commits to a canonical form before performing a merge to reduce unnecessary conflicts. For more information, see section \"Merging branches with differing checkin/checkout attributes\" in gitattributes[5].\n**merge.stat**: What, if anything, to print between ORIG_HEAD and the merge result at the end of the merge. Possible values are: false Show nothing. true Show git diff --diffstat --summary ORIG_HEAD. compact Show git diff --compact-summary ORIG_HEAD. but any unrecognised value (e.g., a value added by a future version of Git) is taken as true instead of triggering an error. Defaults to true.\n**false**: Show nothing.\n**true**: Show git diff --diffstat --summary ORIG_HEAD.\n**compact**: Show git diff --compact-summary ORIG_HEAD.\n**merge.autoStash**: When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run merge on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts. This option can be overridden by the --no-autostash and --autostash options of git-merge[1]. Defaults to false.\n**merge.tool**: Controls which merge tool is used by git-mergetool[1]. The list below shows the valid built-in values. Any other value is treated as a custom merge tool and requires that a corresponding mergetool.<tool>.cmd variable is defined.\n**merge.guitool**: Controls which merge tool is used by git-mergetool[1] when the -g/--gui flag is specified. The list below shows the valid built-in values. Any other value is treated as a custom merge tool and requires that a corresponding mergetool.<guitool>.cmd variable is defined. araxis bc codecompare deltawalker diffmerge diffuse ecmerge emerge examdiff guiffy gvimdiff kdiff3 meld nvimdiff opendiff p4merge smerge tkdiff tortoisemerge vimdiff vscode winmerge xxdiff\n**merge.verbosity**: Controls the amount of output shown by the recursive merge strategy. Level 0 outputs nothing except a final error message if conflicts were detected. Level 1 outputs only conflicts, 2 outputs conflicts and file changes. Level 5 and above outputs debugging information. The default is level 2. Can be overridden by the GIT_MERGE_VERBOSITY environment variable.\n**merge.<driver>.name**: Defines a human-readable name for a custom low-level merge driver. See gitattributes[5] for details.\n**merge.<driver>.driver**: Defines the command that implements a custom low-level merge driver. See gitattributes[5] for details.\n**merge.<driver>.recursive**: Names a low-level merge driver to be used when performing an internal merge between common ancestors. See gitattributes[5] for details.\n**false**: Directory rename detection is disabled, meaning that such new files will be left behind in the old directory.\n**true**: Directory rename detection is enabled, meaning that such new files will be moved into the new directory.\n**conflict**: A conflict will be reported for such paths.\n**false**: Show nothing.\n**true**: Show git diff --diffstat --summary ORIG_HEAD.\n**compact**: Show git diff --compact-summary ORIG_HEAD.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 29,
          "content_length": 14590
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-fmt-merge-msg[1], git-pull[1], gitattributes[5], git-reset[1], git-diff[1], git-ls-files[1], git-add[1], git-rm[1], git-mergetool[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 136
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-merge",
    "doc_type": "git",
    "total_sections": 14
  },
  {
    "title": "Git",
    "summary": "NAME git-mv - Move or rename a file, a directory, or a symlink\n\ngit-mv - Move or rename a file, a directory, or a symlink",
    "sections": [
      {
        "header": "NAME",
        "content": "git-mv - Move or rename a file, a directory, or a symlink",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 57
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Move or rename a file, directory, or symlink.\n\nIn the first form, it renames <source>, which must exist and be either a file, symlink or directory, to <destination>. In the second form, <destination-directory> has to be an existing directory; the given sources will be moved into this directory.\n\nThe index is updated after successful completion, but the change must still be committed.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 386
        }
      },
      {
        "header": "OPTIONS",
        "content": "Force renaming or moving of a file even if the <destination> exists.\n\nSkip move or rename actions which would lead to an error condition. An error happens when a source is neither existing nor controlled by Git, or when it would overwrite an existing file unless -f is given.\n\nDo nothing; only show what would happen\n\nReport the names of files as they are moved.\n\n**-f**: Force renaming or moving of a file even if the <destination> exists.\n**--force**: Skip move or rename actions which would lead to an error condition. An error happens when a source is neither existing nor controlled by Git, or when it would overwrite an existing file unless -f is given.\n**-k**: Do nothing; only show what would happen\n**-n**: Report the names of files as they are moved.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 760
        }
      },
      {
        "header": "SUBMODULES",
        "content": "Moving a submodule using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will update the gitfile and core.worktree setting to make the submodule work in the new location. It also will attempt to update the submodule.<name>.path setting in the gitmodules[5] file and stage that file (unless -n is used).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 329
        }
      },
      {
        "header": "BUGS",
        "content": "Each time a superproject update moves a populated submodule (e.g. when switching between commits before and after the move) a stale submodule checkout will remain in the old location and an empty directory will appear in the new location. To populate the submodule again in the new location the user will have to run \"git submodule update\" afterwards. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. Both steps will be obsolete when recursive submodule update has been implemented.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 560
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-mv",
    "doc_type": "git",
    "total_sections": 6
  },
  {
    "title": "Git",
    "summary": "SYNOPSIS git notes [list [<object>]] git notes add [-f] [--allow-empty] [--[no-]separator | --separator=<paragraph-break>] [--[no-]stripspace] [-F <file> | -m <msg> | (-c | -C) <object>] [-e] [<object>] git notes copy [-f] ( --stdin | <from-object> [<to-object>] ) git notes append [--allow-empty] [--[no-]separator | --separator=<paragraph-break>] [--[no-]stripspace] [-F <file> | -m <msg> | (-c | -C) <object>] [-e] [<object>] git notes edit [--allow-empty] [<object>] [--[no-]stripspace] git notes",
    "sections": [
      {
        "header": "NAME",
        "content": "git-notes - Add or inspect object notes",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 39
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Adds, removes, or reads notes attached to objects, without touching the objects themselves.\n\nBy default, notes are saved to and read from refs/notes/commits, but this default can be overridden. See the OPTIONS, CONFIGURATION, and ENVIRONMENT sections below. If this ref does not exist, it will be quietly created when it is first needed to store a note.\n\nA typical use of notes is to supplement a commit message without changing the commit itself. Notes can be shown by git log along with the original commit message. To distinguish these notes from the message stored in the commit object, the notes are indented like the message, after an unindented line saying \"Notes (<refname>):\" (or \"Notes:\" for refs/notes/commits).\n\nNotes can also be added to patches prepared with git format-patch by using the --notes option. Such notes are added as a patch commentary after a three dash separator line.\n\nTo change which notes are shown by git log, see the notes.displayRef discussion in CONFIGURATION.\n\nSee the notes.rewrite.<command> configuration for a way to carry notes across commands that rewrite commits.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1105
        }
      },
      {
        "header": "SUBCOMMANDS",
        "content": "List the notes object for a given object. If no object is given, show a list of all note objects and the objects they annotate (in the format \"<note-object> <annotated-object>\"). This is the default subcommand if no subcommand is given.\n\nAdd notes for a given object (defaults to HEAD). Abort if the object already has notes (use -f to overwrite existing notes). However, if you’re using add interactively (using an editor to supply the notes contents), then - instead of aborting - the existing notes will be opened in the editor (like the edit subcommand). If you specify multiple -m and -F, a blank line will be inserted between the messages. Use the --separator option to insert other delimiters. You can use -e to edit and fine-tune the message(s) supplied from -m and -F options interactively (using an editor) before adding the note.\n\nCopy the notes for the first object onto the second object (defaults to HEAD). Abort if the second object already has notes, or if the first object has none (use -f to overwrite existing notes to the second object). This subcommand is equivalent to: git notes add [-f] -C $(git notes list <from-object>) <to-object>\n\nIn --stdin mode, take lines in the format\n\non standard input, and copy the notes from each <from-object> to its corresponding <to-object>. (The optional <rest> is ignored so that the command can read the input given to the post-rewrite hook.)\n\n--stdin cannot be combined with object names given on the command line.\n\nAppend new message(s) given by -m or -F options to an existing note, or add them as a new note if one does not exist, for the object (defaults to HEAD). When appending to an existing note, a blank line is added before each new message as an inter-paragraph separator. The separator can be customized with the --separator option. Edit the notes to be appended given by -m and -F options with -e interactively (using an editor) before appending the note.\n\nEdit the notes for a given object (defaults to HEAD).\n\nShow the notes for a given object (defaults to HEAD).\n\nMerge the given notes ref into the current notes ref. This will try to merge the changes made by the given notes ref (called \"remote\") since the merge-base (if any) into the current notes ref (called \"local\").\n\nIf conflicts arise and a strategy for automatically resolving conflicting notes (see the \"NOTES MERGE STRATEGIES\" section) is not given, the manual resolver is used. This resolver checks out the conflicting notes in a special worktree (.git/NOTES_MERGE_WORKTREE), and instructs the user to manually resolve the conflicts there. When done, the user can either finalize the merge with git notes merge --commit, or abort the merge with git notes merge --abort.\n\nRemove the notes for given objects (defaults to HEAD). When giving zero or one object from the command line, this is equivalent to specifying an empty note message to the edit subcommand.\n\nIn --stdin mode, also remove the object names given on standard input. In other words, --stdin can be combined with object names from the command line.\n\nRemove all notes for non-existing/unreachable objects.\n\nPrint the current notes ref. This provides an easy way to retrieve the current notes ref (e.g. from scripts).\n\n**list**: List the notes object for a given object. If no object is given, show a list of all note objects and the objects they annotate (in the format \"<note-object> <annotated-object>\"). This is the default subcommand if no subcommand is given.\n**add**: Add notes for a given object (defaults to HEAD). Abort if the object already has notes (use -f to overwrite existing notes). However, if you’re using add interactively (using an editor to supply the notes contents), then - instead of aborting - the existing notes will be opened in the editor (like the edit subcommand). If you specify multiple -m and -F, a blank line will be inserted between the messages. Use the --separator option to insert other delimiters. You can use -e to edit and fine-tune the message(s) supplied from -m and -F options interactively (using an editor) before adding the note.\n**copy**: Copy the notes for the first object onto the second object (defaults to HEAD). Abort if the second object already has notes, or if the first object has none (use -f to overwrite existing notes to the second object). This subcommand is equivalent to: git notes add [-f] -C $(git notes list <from-object>) <to-object> In --stdin mode, take lines in the format <from-object> SP <to-object> [ SP <rest> ] LF on standard input, and copy the notes from each <from-object> to its corresponding <to-object>. (The optional <rest> is ignored so that the command can read the input given to the post-rewrite hook.) --stdin cannot be combined with object names given on the command line.\n**append**: Append new message(s) given by -m or -F options to an existing note, or add them as a new note if one does not exist, for the object (defaults to HEAD). When appending to an existing note, a blank line is added before each new message as an inter-paragraph separator. The separator can be customized with the --separator option. Edit the notes to be appended given by -m and -F options with -e interactively (using an editor) before appending the note.\n**edit**: Edit the notes for a given object (defaults to HEAD).\n**show**: Show the notes for a given object (defaults to HEAD).\n**merge**: Merge the given notes ref into the current notes ref. This will try to merge the changes made by the given notes ref (called \"remote\") since the merge-base (if any) into the current notes ref (called \"local\"). If conflicts arise and a strategy for automatically resolving conflicting notes (see the \"NOTES MERGE STRATEGIES\" section) is not given, the manual resolver is used. This resolver checks out the conflicting notes in a special worktree (.git/NOTES_MERGE_WORKTREE), and instructs the user to manually resolve the conflicts there. When done, the user can either finalize the merge with git notes merge --commit, or abort the merge with git notes merge --abort.\n**remove**: Remove the notes for given objects (defaults to HEAD). When giving zero or one object from the command line, this is equivalent to specifying an empty note message to the edit subcommand. In --stdin mode, also remove the object names given on standard input. In other words, --stdin can be combined with object names from the command line.\n**prune**: Remove all notes for non-existing/unreachable objects.\n**get-ref**: Print the current notes ref. This provides an easy way to retrieve the current notes ref (e.g. from scripts).",
        "code_examples": [
          "```bash\n<from-object> SP <to-object> [ SP <rest> ] LF\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 15,
          "content_length": 6576
        }
      },
      {
        "header": "OPTIONS",
        "content": "When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting).\n\nUse the given note message (instead of prompting). If multiple -m options are given, their values are concatenated as separate paragraphs.\n\nTake the note message from the given file. Use - to read the note message from the standard input.\n\nTake the given blob object (for example, another note) as the note message. (Use git notes copy <object> instead to copy notes between objects.) Implies --no-stripspace since the default behavior is to copy the message verbatim.\n\nLike -C, but with -c the editor is invoked, so that the user can further edit the note message.\n\nAllow an empty note object to be stored. The default behavior is to automatically remove empty notes.\n\nSpecify a string used as a custom inter-paragraph separator (a newline is added at the end as needed). If --no-separator, no separators will be added between paragraphs. Defaults to a blank line.\n\nClean up whitespace. Specifically (see git-stripspace[1]):\n\nremove trailing whitespace from all lines\n\ncollapse multiple consecutive empty lines into one empty line\n\nremove empty lines from the beginning and end of the input\n\nadd a missing \\n to the last line if necessary.\n\n--stripspace is the default except for -C/--reuse-message. However, keep in mind that this depends on the order of similar options. For example, for -C <object> -m<message>, --stripspace will be used because the default for -m overrides the previous -C. This is a known limitation that may be fixed in the future.\n\nManipulate the notes tree in <ref>. This overrides GIT_NOTES_REF and the core.notesRef configuration. The ref specifies the full refname when it begins with refs/notes/; when it begins with notes/, refs/ and otherwise refs/notes/ is prefixed to form a full name of the ref.\n\nDo not consider it an error to request removing notes from an object that does not have notes attached to it.\n\nOnly valid for remove and copy. See the respective subcommands.\n\nDo not remove anything; just report the object names whose notes would be removed.\n\nWhen merging notes, resolve notes conflicts using the given strategy. The following strategies are recognized: manual (default), ours, theirs, union and cat_sort_uniq. This option overrides the notes.mergeStrategy configuration setting. See the \"NOTES MERGE STRATEGIES\" section below for more information on each notes merge strategy.\n\nFinalize an in-progress git notes merge. Use this option when you have resolved the conflicts that git notes merge stored in .git/NOTES_MERGE_WORKTREE. This amends the partial merge commit created by git notes merge (stored in .git/NOTES_MERGE_PARTIAL) by adding the notes in .git/NOTES_MERGE_WORKTREE. The notes ref stored in the .git/NOTES_MERGE_REF symref is updated to the resulting commit.\n\nAbort/reset an in-progress git notes merge, i.e. a notes merge with conflicts. This simply removes all files related to the notes merge.\n\nWhen merging notes, operate quietly.\n\nWhen merging notes, be more verbose. When pruning notes, report all object names whose notes are removed.\n\n• remove trailing whitespace from all lines\n• collapse multiple consecutive empty lines into one empty line\n• remove empty lines from the beginning and end of the input\n• add a missing \\n to the last line if necessary.\n\n**-f**: When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting).\n**--force**: Use the given note message (instead of prompting). If multiple -m options are given, their values are concatenated as separate paragraphs.\n**-m <msg>**: Take the note message from the given file. Use - to read the note message from the standard input.\n**--message=<msg>**: Take the given blob object (for example, another note) as the note message. (Use git notes copy <object> instead to copy notes between objects.) Implies --no-stripspace since the default behavior is to copy the message verbatim.\n**-F <file>**: Like -C, but with -c the editor is invoked, so that the user can further edit the note message.\n**--file=<file>**: Allow an empty note object to be stored. The default behavior is to automatically remove empty notes.\n**-C <object>**: Specify a string used as a custom inter-paragraph separator (a newline is added at the end as needed). If --no-separator, no separators will be added between paragraphs. Defaults to a blank line.\n**--reuse-message=<object>**: Clean up whitespace. Specifically (see git-stripspace[1]): remove trailing whitespace from all lines collapse multiple consecutive empty lines into one empty line remove empty lines from the beginning and end of the input add a missing \\n to the last line if necessary. --stripspace is the default except for -C/--reuse-message. However, keep in mind that this depends on the order of similar options. For example, for -C <object> -m<message>, --stripspace will be used because the default for -m overrides the previous -C. This is a known limitation that may be fixed in the future.\n**-c <object>**: Manipulate the notes tree in <ref>. This overrides GIT_NOTES_REF and the core.notesRef configuration. The ref specifies the full refname when it begins with refs/notes/; when it begins with notes/, refs/ and otherwise refs/notes/ is prefixed to form a full name of the ref.\n**--reedit-message=<object>**: Do not consider it an error to request removing notes from an object that does not have notes attached to it.\n**--allow-empty**: Only valid for remove and copy. See the respective subcommands.\n**--separator=<paragraph-break>**: Do not remove anything; just report the object names whose notes would be removed.\n**--separator**: When merging notes, resolve notes conflicts using the given strategy. The following strategies are recognized: manual (default), ours, theirs, union and cat_sort_uniq. This option overrides the notes.mergeStrategy configuration setting. See the \"NOTES MERGE STRATEGIES\" section below for more information on each notes merge strategy.\n**--no-separator**: Finalize an in-progress git notes merge. Use this option when you have resolved the conflicts that git notes merge stored in .git/NOTES_MERGE_WORKTREE. This amends the partial merge commit created by git notes merge (stored in .git/NOTES_MERGE_PARTIAL) by adding the notes in .git/NOTES_MERGE_WORKTREE. The notes ref stored in the .git/NOTES_MERGE_REF symref is updated to the resulting commit.\n**--stripspace**: Abort/reset an in-progress git notes merge, i.e. a notes merge with conflicts. This simply removes all files related to the notes merge.\n**--no-stripspace**: When merging notes, operate quietly.\n**--ref=<ref>**: When merging notes, be more verbose. When pruning notes, report all object names whose notes are removed.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 22,
          "content_length": 6759
        }
      },
      {
        "header": "DISCUSSION",
        "content": "Commit notes are blobs containing extra information about an object (usually information to supplement a commit’s message). These blobs are taken from notes refs. A notes ref is usually a branch which contains \"files\" whose paths are the object names for the objects they describe, with some directory separators included for performance reasons [1].\n\nEvery notes change creates a new commit at the specified notes ref. You can therefore inspect the history of the notes by invoking, e.g., git log -p notes/commits. Currently the commit message only records which operation triggered the update, and the commit authorship is determined according to the usual rules (see git-commit[1]). These details may change in the future.\n\nIt is also permitted for a notes ref to point directly to a tree object, in which case the history of the notes can be read with git log -p -g <refname>.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 880
        }
      },
      {
        "header": "NOTES MERGE STRATEGIES",
        "content": "The default notes merge strategy is manual, which checks out conflicting notes in a special work tree for resolving notes conflicts (.git/NOTES_MERGE_WORKTREE), and instructs the user to resolve the conflicts in that work tree. When done, the user can either finalize the merge with git notes merge --commit, or abort the merge with git notes merge --abort.\n\nUsers may select an automated merge strategy from among the following using either -s/--strategy option or configuring notes.mergeStrategy accordingly:\n\nours automatically resolves conflicting notes in favor of the local version (i.e. the current notes ref).\n\ntheirs automatically resolves notes conflicts in favor of the remote version (i.e. the given notes ref being merged into the current notes ref).\n\nunion automatically resolves notes conflicts by concatenating the local and remote versions.\n\ncat_sort_uniq is similar to union, but in addition to concatenating the local and remote versions, this strategy also sorts the resulting lines, and removes duplicate lines from the result. This is equivalent to applying the \"cat | sort | uniq\" shell pipeline to the local and remote versions. This strategy is useful if the notes follow a line-based format where one wants to avoid duplicated lines in the merge result. Note that if either the local or remote version contain duplicate lines prior to the merge, these will also be removed by this notes merge strategy.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1428
        }
      },
      {
        "header": "EXAMPLES",
        "content": "You can use notes to add annotations with information that was not available at the time a commit was written.\n\nIn principle, a note is a regular Git blob, and any kind of (non-)format is accepted. You can binary-safely create notes from arbitrary files using git hash-object:\n\n(You cannot simply use git notes --ref=built add -F a.out HEAD because that is not binary-safe.) Of course, it doesn’t make much sense to display non-text-format notes with git log, so if you use such notes, you’ll probably need to write some special-purpose tools to do something useful with them.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git notes add -m 'Tested-by: Johannes Sixt <j6t@kdbg.org>' 72a144e2\n$ git show -s 72a144e\n[...]\n    Signed-off-by: Junio C Hamano <gitster@pobox.com>\n\nNotes:\n    Tested-by: Johannes Sixt <j6t@kdbg.org>\n```",
          "```bash\n$ cc *.c\n$ blob=$(git hash-object -w a.out)\n$ git notes --ref=built add --allow-empty -C \"$blob\" HEAD\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 576
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Notes ref to read and manipulate instead of refs/notes/commits. Must be an unabbreviated ref name. This setting can be overridden through the environment and command line.\n\nEverything above this line in this section isn’t included from the git-config[1] documentation. The content that follows is the same as what’s found there:\n\nWhich merge strategy to choose by default when resolving notes conflicts. Must be one of manual, ours, theirs, union, or cat_sort_uniq. Defaults to manual. See the \"NOTES MERGE STRATEGIES\" section of git-notes[1] for more information on each strategy.\n\nThis setting can be overridden by passing the --strategy option to git-notes[1].\n\nWhich merge strategy to choose when doing a notes merge into refs/notes/<name>. This overrides the more general notes.mergeStrategy. See the \"NOTES MERGE STRATEGIES\" section in git-notes[1] for more information on the available strategies.\n\nWhich ref (or refs, if a glob or specified more than once), in addition to the default set by core.notesRef or GIT_NOTES_REF, to read notes from when showing commit messages with the git log family of commands.\n\nThis setting can be overridden with the GIT_NOTES_DISPLAY_REF environment variable, which must be a colon separated list of refs or globs.\n\nA warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.\n\nThis setting can be disabled by the --no-notes option to the git-log[1] family of commands, or by the --notes=<ref> option accepted by those commands.\n\nThe effective value of core.notesRef (possibly overridden by GIT_NOTES_REF) is also implicitly added to the list of refs to be displayed.\n\nWhen rewriting commits with <command> (currently amend or rebase), if this variable is false, git will not copy notes from the original to the rewritten commit. Defaults to true. See also notes.rewriteRef below.\n\nThis setting can be overridden with the GIT_NOTES_REWRITE_REF environment variable, which must be a colon separated list of refs or globs.\n\nWhen copying notes during a rewrite (see the notes.rewrite.<command> option), determines what to do if the target commit already has a note. Must be one of overwrite, concatenate, cat_sort_uniq, or ignore. Defaults to concatenate.\n\nThis setting can be overridden with the GIT_NOTES_REWRITE_MODE environment variable.\n\nWhen copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. May be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.\n\nDoes not have a default value; you must configure this variable to enable note rewriting. Set it to refs/notes/commits to enable rewriting for the default commit notes.\n\nCan be overridden with the GIT_NOTES_REWRITE_REF environment variable. See notes.rewrite.<command> above for a further description of its format.\n\n**core.notesRef**: Notes ref to read and manipulate instead of refs/notes/commits. Must be an unabbreviated ref name. This setting can be overridden through the environment and command line.\n**notes.mergeStrategy**: Which merge strategy to choose by default when resolving notes conflicts. Must be one of manual, ours, theirs, union, or cat_sort_uniq. Defaults to manual. See the \"NOTES MERGE STRATEGIES\" section of git-notes[1] for more information on each strategy. This setting can be overridden by passing the --strategy option to git-notes[1].\n**notes.<name>.mergeStrategy**: Which merge strategy to choose when doing a notes merge into refs/notes/<name>. This overrides the more general notes.mergeStrategy. See the \"NOTES MERGE STRATEGIES\" section in git-notes[1] for more information on the available strategies.\n**notes.displayRef**: Which ref (or refs, if a glob or specified more than once), in addition to the default set by core.notesRef or GIT_NOTES_REF, to read notes from when showing commit messages with the git log family of commands. This setting can be overridden with the GIT_NOTES_DISPLAY_REF environment variable, which must be a colon separated list of refs or globs. A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored. This setting can be disabled by the --no-notes option to the git-log[1] family of commands, or by the --notes=<ref> option accepted by those commands. The effective value of core.notesRef (possibly overridden by GIT_NOTES_REF) is also implicitly added to the list of refs to be displayed.\n**notes.rewrite.<command>**: When rewriting commits with <command> (currently amend or rebase), if this variable is false, git will not copy notes from the original to the rewritten commit. Defaults to true. See also notes.rewriteRef below. This setting can be overridden with the GIT_NOTES_REWRITE_REF environment variable, which must be a colon separated list of refs or globs.\n**notes.rewriteMode**: When copying notes during a rewrite (see the notes.rewrite.<command> option), determines what to do if the target commit already has a note. Must be one of overwrite, concatenate, cat_sort_uniq, or ignore. Defaults to concatenate. This setting can be overridden with the GIT_NOTES_REWRITE_MODE environment variable.\n**notes.rewriteRef**: When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. May be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times. Does not have a default value; you must configure this variable to enable note rewriting. Set it to refs/notes/commits to enable rewriting for the default commit notes. Can be overridden with the GIT_NOTES_REWRITE_REF environment variable. See notes.rewrite.<command> above for a further description of its format.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 17,
          "content_length": 5764
        }
      },
      {
        "header": "ENVIRONMENT",
        "content": "Which ref to manipulate notes from, instead of refs/notes/commits. This overrides the core.notesRef setting.\n\nColon-delimited list of refs or globs indicating which refs, in addition to the default from core.notesRef or GIT_NOTES_REF, to read notes from when showing commit messages. This overrides the notes.displayRef setting.\n\nA warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.\n\nWhen copying notes during a rewrite, what to do if the target commit already has a note. Must be one of overwrite, concatenate, cat_sort_uniq, or ignore. This overrides the core.rewriteMode setting.\n\nWhen rewriting commits, which notes to copy from the original to the rewritten commit. Must be a colon-delimited list of refs or globs.\n\nIf not set in the environment, the list of notes to copy depends on the notes.rewrite.<command> and notes.rewriteRef settings.\n\n**GIT_NOTES_REF**: Which ref to manipulate notes from, instead of refs/notes/commits. This overrides the core.notesRef setting.\n**GIT_NOTES_DISPLAY_REF**: Colon-delimited list of refs or globs indicating which refs, in addition to the default from core.notesRef or GIT_NOTES_REF, to read notes from when showing commit messages. This overrides the notes.displayRef setting. A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.\n**GIT_NOTES_REWRITE_MODE**: When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of overwrite, concatenate, cat_sort_uniq, or ignore. This overrides the core.rewriteMode setting.\n**GIT_NOTES_REWRITE_REF**: When rewriting commits, which notes to copy from the original to the rewritten commit. Must be a colon-delimited list of refs or globs. If not set in the environment, the list of notes to copy depends on the notes.rewrite.<command> and notes.rewriteRef settings.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1914
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite\n\n[Note] 1. Permitted pathnames have the form bf/fe/30/…/680d5a…: a sequence of directory names of two hexadecimal digits each followed by a filename with the rest of the object ID.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 205
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-notes",
    "doc_type": "git",
    "total_sections": 10
  },
  {
    "title": "Git",
    "summary": "NAME git-pull - Fetch from and integrate with another repository or a local branch\n\ngit-pull - Fetch from and integrate with another repository or a local branch",
    "sections": [
      {
        "header": "NAME",
        "content": "git-pull - Fetch from and integrate with another repository or a local branch",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 77
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Incorporates changes from a remote repository into the current branch. If the current branch is behind the remote, then by default it will fast-forward the current branch to match the remote. If the current branch and the remote have diverged, the user needs to specify how to reconcile the divergent branches with --rebase or --no-rebase (or the corresponding configuration option in pull.rebase).\n\nMore precisely, git pull runs git fetch with the given parameters and then depending on configuration options or command line flags, will call either git rebase or git merge to reconcile diverging branches.\n\n<repository> should be the name of a remote repository as passed to git-fetch[1]. <refspec> can name an arbitrary remote ref (for example, the name of a tag) or even a collection of refs with corresponding remote-tracking branches (e.g., refs/heads/*:refs/remotes/origin/*), but usually it is the name of a branch in the remote repository.\n\nDefault values for <repository> and <branch> are read from the \"remote\" and \"merge\" configuration for the current branch as set by git-branch[1] --track.\n\nAssume the following history exists and the current branch is \"master\":\n\nThen \"git pull\" will fetch and replay the changes from the remote master branch since it diverged from the local master (i.e., E) until its current commit (C) on top of master and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes.\n\nSee git-merge[1] for details, including how conflicts are presented and handled.\n\nIn Git 1.7.0 or later, to cancel a conflicting merge, use git reset --merge. Warning: In older versions of Git, running git pull with uncommitted changes is discouraged: while possible, it leaves you in a state that may be hard to back out of in the case of a conflict.\n\nIf any of the remote changes overlap with local uncommitted changes, the merge will be automatically canceled and the work tree untouched. It is generally best to get any local changes in working order before pulling or stash them away with git-stash[1].",
        "code_examples": [
          "```bash\nA---B---C master on origin\n\t /\n    D---E---F---G master\n\t^\n\torigin/master in your repository\n```",
          "```bash\nA---B---C origin/master\n\t /         \\\n    D---E---F---G---H master\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 2102
        }
      },
      {
        "header": "OPTIONS",
        "content": "This is passed to both underlying git-fetch to squelch reporting of during transfer, and underlying git-merge to squelch output during merging.\n\nPass --verbose to git-fetch and git-merge.\n\nThis option controls if new commits of populated submodules should be fetched, and if the working trees of active submodules should be updated, too (see git-fetch[1], git-config[1] and gitmodules[5]).\n\nIf the checkout is done via rebase, local submodule commits are rebased as well.\n\nIf the update is done via merge, the submodule conflicts are resolved and checked out.\n\n**-q**: This is passed to both underlying git-fetch to squelch reporting of during transfer, and underlying git-merge to squelch output during merging.\n**--quiet**: Pass --verbose to git-fetch and git-merge.\n**-v**: This option controls if new commits of populated submodules should be fetched, and if the working trees of active submodules should be updated, too (see git-fetch[1], git-config[1] and gitmodules[5]). If the checkout is done via rebase, local submodule commits are rebased as well. If the update is done via merge, the submodule conflicts are resolved and checked out.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1145
        }
      },
      {
        "header": "Options related to merging",
        "content": "Perform the merge and commit the result. This option can be used to override --no-commit. Only useful when merging.\n\nWith --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing.\n\nNote that fast-forward updates do not create a merge commit and therefore there is no way to stop those merges with --no-commit. Thus, if you want to ensure your branch is not changed or updated by the merge command, use --no-ff with --no-commit.\n\nInvoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The --no-edit option can be used to accept the auto-generated message (this is generally discouraged).\n\nOlder scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run git merge. To make it easier to adjust such scripts to the updated behaviour, the environment variable GIT_MERGE_AUTOEDIT can be set to no at the beginning of them.\n\nThis option determines how the merge message will be cleaned up before committing. See git-commit[1] for more details. In addition, if the <mode> is given a value of scissors, scissors will be appended to MERGE_MSG before being passed on to the commit machinery in the case of a merge conflict.\n\nOnly update to the new history if there is no divergent local history. This is the default when no method for reconciling divergent histories is provided (via the --rebase=* flags).\n\nWhen merging rather than rebasing, specifies how a merge is handled when the merged-in history is already a descendant of the current history. If merging is requested, --ff is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the refs/tags/ hierarchy, in which case --no-ff is assumed.\n\nWith --ff, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit). When not possible (when the merged-in history is not a descendant of the current history), create a merge commit.\n\nWith --no-ff, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward.\n\nGPG-sign the resulting merge commit. The <key-id> argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign.\n\nIn addition to branch names, populate the log message with one-line descriptions from at most <n> actual commits that are being merged. See also git-fmt-merge-msg[1]. Only useful when merging.\n\nWith --no-log do not list one-line descriptions from the actual commits being merged.\n\nAdd a Signed-off-by trailer by the committer at the end of the commit log message. The meaning of a signoff depends on the project to which you’re committing. For example, it may certify that the committer has the rights to submit the work under the project’s license or agrees to some contributor representation, such as a Developer Certificate of Origin. (See https://developercertificate.org for the one used by the Linux kernel and Git projects.) Consult the documentation or leadership of the project to which you’re contributing to understand how the signoffs are used in that project.\n\nThe --no-signoff option can be used to countermand an earlier --signoff option on the command line.\n\nShow a diffstat at the end of the merge. The diffstat is also controlled by the configuration option merge.stat.\n\nWith -n or --no-stat do not show a diffstat at the end of the merge.\n\nShow a compact-summary at the end of the merge.\n\nProduce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the HEAD, or record $GIT_DIR/MERGE_HEAD (to cause the next git commit command to create a merge commit). This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus).\n\nWith --no-squash perform the merge and commit the result. This option can be used to override --squash.\n\nWith --squash, --commit is not allowed, and will fail.\n\nOnly useful when merging.\n\nBy default, the pre-merge and commit-msg hooks are run. When --no-verify is given, these are bypassed. See also githooks[5]. Only useful when merging.\n\nUse the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no -s option, a built-in list of strategies is used instead (ort when merging a single head, octopus otherwise).\n\nPass merge strategy specific option through to the merge strategy.\n\nVerify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key. If the tip commit of the side branch is not signed with a valid key, the merge is aborted.\n\nOnly useful when merging.\n\nSynonyms to --stat and --no-stat; these are deprecated and will be removed in the future.\n\nAutomatically create a temporary stash entry before the operation begins, record it in the ref MERGE_AUTOSTASH and apply it after the operation ends. This means that you can run the operation on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts.\n\nBy default, git merge command refuses to merge histories that do not share a common ancestor. This option can be used to override this safety when merging histories of two projects that started their lives independently. As that is a very rare occasion, no configuration variable to enable this by default exists or will be added.\n\nOnly useful when merging.\n\nWhen true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.\n\nWhen set to merges, rebase using git rebase --rebase-merges so that the local merge commits are included in the rebase (see git-rebase[1] for details).\n\nWhen false, merge the upstream branch into the current branch.\n\nWhen interactive, enable the interactive mode of rebase.\n\nSee pull.rebase, branch.<name>.rebase and branch.autoSetupRebase in git-config[1] if you want to make git pull always use --rebase instead of merging.\n\nThis is shorthand for --rebase=false.\n\n**--commit**: Perform the merge and commit the result. This option can be used to override --no-commit. Only useful when merging. With --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing. Note that fast-forward updates do not create a merge commit and therefore there is no way to stop those merges with --no-commit. Thus, if you want to ensure your branch is not changed or updated by the merge command, use --no-ff with --no-commit.\n**--no-commit**: Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The --no-edit option can be used to accept the auto-generated message (this is generally discouraged). Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run git merge. To make it easier to adjust such scripts to the updated behaviour, the environment variable GIT_MERGE_AUTOEDIT can be set to no at the beginning of them.\n**--edit**: This option determines how the merge message will be cleaned up before committing. See git-commit[1] for more details. In addition, if the <mode> is given a value of scissors, scissors will be appended to MERGE_MSG before being passed on to the commit machinery in the case of a merge conflict.\n**-e**: Only update to the new history if there is no divergent local history. This is the default when no method for reconciling divergent histories is provided (via the --rebase=* flags).\n**--no-edit**: When merging rather than rebasing, specifies how a merge is handled when the merged-in history is already a descendant of the current history. If merging is requested, --ff is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the refs/tags/ hierarchy, in which case --no-ff is assumed. With --ff, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit). When not possible (when the merged-in history is not a descendant of the current history), create a merge commit. With --no-ff, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward.\n**--cleanup=<mode>**: GPG-sign the resulting merge commit. The <key-id> argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign.\n**--ff-only**: In addition to branch names, populate the log message with one-line descriptions from at most <n> actual commits that are being merged. See also git-fmt-merge-msg[1]. Only useful when merging. With --no-log do not list one-line descriptions from the actual commits being merged.\n**--ff**: Add a Signed-off-by trailer by the committer at the end of the commit log message. The meaning of a signoff depends on the project to which you’re committing. For example, it may certify that the committer has the rights to submit the work under the project’s license or agrees to some contributor representation, such as a Developer Certificate of Origin. (See https://developercertificate.org for the one used by the Linux kernel and Git projects.) Consult the documentation or leadership of the project to which you’re contributing to understand how the signoffs are used in that project. The --no-signoff option can be used to countermand an earlier --signoff option on the command line.\n**--no-ff**: Show a diffstat at the end of the merge. The diffstat is also controlled by the configuration option merge.stat. With -n or --no-stat do not show a diffstat at the end of the merge.\n**-S[<key-id>]**: Show a compact-summary at the end of the merge.\n**--gpg-sign[=<key-id>]**: Produce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the HEAD, or record $GIT_DIR/MERGE_HEAD (to cause the next git commit command to create a merge commit). This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus). With --no-squash perform the merge and commit the result. This option can be used to override --squash. With --squash, --commit is not allowed, and will fail. Only useful when merging.\n**--no-gpg-sign**: By default, the pre-merge and commit-msg hooks are run. When --no-verify is given, these are bypassed. See also githooks[5]. Only useful when merging.\n**--log[=<n>]**: Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no -s option, a built-in list of strategies is used instead (ort when merging a single head, octopus otherwise).\n**--no-log**: Pass merge strategy specific option through to the merge strategy.\n**--signoff**: Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key. If the tip commit of the side branch is not signed with a valid key, the merge is aborted. Only useful when merging.\n**--no-signoff**: Synonyms to --stat and --no-stat; these are deprecated and will be removed in the future.\n**--stat**: Automatically create a temporary stash entry before the operation begins, record it in the ref MERGE_AUTOSTASH and apply it after the operation ends. This means that you can run the operation on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts.\n**-n**: By default, git merge command refuses to merge histories that do not share a common ancestor. This option can be used to override this safety when merging histories of two projects that started their lives independently. As that is a very rare occasion, no configuration variable to enable this by default exists or will be added. Only useful when merging.\n**--no-stat**: When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes. When set to merges, rebase using git rebase --rebase-merges so that the local merge commits are included in the rebase (see git-rebase[1] for details). When false, merge the upstream branch into the current branch. When interactive, enable the interactive mode of rebase. See pull.rebase, branch.<name>.rebase and branch.autoSetupRebase in git-config[1] if you want to make git pull always use --rebase instead of merging. Note This is a potentially dangerous mode of operation. It rewrites history, which does not bode well when you published that history already. Do not use this option unless you have read git-rebase[1] carefully.\n**--compact-summary**: This is shorthand for --rebase=false.\n\nNote | This is a potentially dangerous mode of operation. It rewrites history, which does not bode well when you published that history already. Do not use this option unless you have read git-rebase[1] carefully.\n\n[Note] Note This is a potentially dangerous mode of operation. It rewrites history, which does not bode well when you published that history already. Do not use this option unless you have read git-rebase[1] carefully.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 37,
          "content_length": 14389
        }
      },
      {
        "header": "Options related to fetching",
        "content": "Fetch all remotes, except for the ones that has the remote.<name>.skipFetchAll configuration variable set. This overrides the configuration variable fetch.all.\n\nAppend ref names and object names of fetched refs to the existing contents of .git/FETCH_HEAD. Without this option old data in .git/FETCH_HEAD will be overwritten.\n\nUse an atomic transaction to update local refs. Either all refs are updated, or on error, no refs are updated.\n\nLimit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a shallow repository created by git clone with --depth=<depth> option (see git-clone[1]), deepen or shorten the history to the specified number of commits. Tags for the deepened commits are not fetched.\n\nSimilar to --depth, except it specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history.\n\nDeepen or shorten the history of a shallow repository to include all reachable commits after <date>.\n\nDeepen or shorten the history of a shallow repository to exclude commits reachable from a specified remote branch or tag. This option can be specified multiple times.\n\nIf the source repository is complete, convert a shallow repository to a complete one, removing all the limitations imposed by shallow repositories.\n\nIf the source repository is shallow, fetch as much as possible so that the current repository has the same history as the source repository.\n\nBy default when fetching from a shallow repository, git fetch refuses refs that require updating .git/shallow. This option updates .git/shallow and accepts such refs.\n\nBy default, Git will report, to the server, commits reachable from all local refs to find common commits in an attempt to reduce the size of the to-be-received packfile. If specified, Git will only report commits reachable from the given tips. This is useful to speed up fetches when the user knows which local ref is likely to have commits in common with the upstream ref being fetched.\n\nThis option may be specified more than once; if so, Git will report commits reachable from any of the given commits.\n\nThe argument to this option may be a glob on ref names, a ref, or the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is equivalent to specifying this option multiple times, one for each matching ref name.\n\nSee also the fetch.negotiationAlgorithm and push.negotiate configuration variables documented in git-config[1], and the --negotiate-only option below.\n\nDo not fetch anything from the server, and instead print the ancestors of the provided --negotiation-tip=* arguments, which we have in common with the server.\n\nThis is incompatible with --recurse-submodules=[yes|on-demand]. Internally this is used to implement the push.negotiate option, see git-config[1].\n\nShow what would be done, without making any changes.\n\nPrint the output to standard output in an easy-to-parse format for scripts. See section OUTPUT in git-fetch[1] for details.\n\nThis is incompatible with --recurse-submodules=[yes|on-demand] and takes precedence over the fetch.output config option.\n\nWhen git fetch is used with <src>:<dst> refspec, it may refuse to update the local branch as discussed in the <refspec> part of the git-fetch[1] documentation. This option overrides that check.\n\nKeep downloaded pack.\n\nModify the configured refspec to place all refs into the refs/prefetch/ namespace. See the prefetch task in git-maintenance[1].\n\nBefore fetching, remove any remote-tracking references that no longer exist on the remote. Tags are not subject to pruning if they are fetched only because of the default tag auto-following or due to a --tags option. However, if tags are fetched due to an explicit refspec (either on the command line or in the remote configuration, for example if the remote was cloned with the --mirror option), then they are also subject to pruning. Supplying --prune-tags is a shorthand for providing the tag refspec.\n\nBy default, tags that point at objects that are downloaded from the remote repository are fetched and stored locally. This option disables this automatic tag following. The default behavior for a remote may be specified with the remote.<name>.tagOpt setting. See git-config[1].\n\nWhen fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of remote.*.fetch configuration variables for the remote repository. Providing an empty <refspec> to the --refmap option causes Git to ignore the configured refspecs and rely entirely on the refspecs supplied as command-line arguments. See section on \"Configured Remote-tracking Branches\" for details.\n\nFetch all tags from the remote (i.e., fetch remote tags refs/tags/* into local tags with the same name), in addition to whatever else would otherwise be fetched. Using this option alone does not subject tags to pruning, even if --prune is used (though tags may be pruned anyway if they are also the destination of an explicit refspec; see --prune).\n\nNumber of parallel children to be used for all forms of fetching.\n\nIf the --multiple option was specified, the different remotes will be fetched in parallel. If multiple submodules are fetched, they will be fetched in parallel. To control them independently, use the config settings fetch.parallel and submodule.fetchJobs (see git-config[1]).\n\nTypically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel.\n\nIf the remote is fetched successfully, add upstream (tracking) reference, used by argument-less git-pull[1] and other commands. For more information, see branch.<name>.merge and branch.<name>.remote in git-config[1].\n\nWhen given, and the repository to fetch from is handled by git fetch-pack, --exec=<upload-pack> is passed to the command to specify non-default path for the command run on the other end.\n\nProgress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.\n\nTransmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. The server’s handling of server options, including unknown ones, is server-specific. When multiple --server-option=<option> are given, they are all sent to the other side in the order listed on the command line. When no --server-option=<option> is given from the command line, the values of configuration variable remote.<name>.serverOption are used instead.\n\nBy default, git checks if a branch is force-updated during fetch. This can be disabled through fetch.showForcedUpdates, but the --show-forced-updates option guarantees this check occurs. See git-config[1].\n\nBy default, git checks if a branch is force-updated during fetch. Pass --no-show-forced-updates or set fetch.showForcedUpdates to false to skip this check for performance reasons. If used during git-pull the --ff-only option will still check for forced updates before attempting a fast-forward update. See git-config[1].\n\nUse IPv4 addresses only, ignoring IPv6 addresses.\n\nUse IPv6 addresses only, ignoring IPv4 addresses.\n\nThe \"remote\" repository that is the source of a fetch or pull operation. This parameter can be either a URL (see the section GIT URLS below) or the name of a remote (see the section REMOTES below).\n\nSpecifies which refs to fetch and which local refs to update. When no <refspec>s appear on the command line, the refs to fetch are read from remote.<repository>.fetch variables instead (see the section \"CONFIGURED REMOTE-TRACKING BRANCHES\" in git-fetch[1]).\n\nThe format of a <refspec> parameter is an optional plus +, followed by the source <src>, followed by a colon :, followed by the destination <dst>. The colon can be omitted when <dst> is empty. <src> is typically a ref, or a glob pattern with a single * that is used to match a set of refs, but it can also be a fully spelled hex object name.\n\nA <refspec> may contain a * in its <src> to indicate a simple pattern match. Such a refspec functions like a glob that matches any ref with the pattern. A pattern <refspec> must have one and only one * in both the <src> and <dst>. It will map refs to the destination by replacing the * with the contents matched from the source.\n\nIf a refspec is prefixed by ^, it will be interpreted as a negative refspec. Rather than specifying which refs to fetch or which local refs to update, such a refspec will instead specify refs to exclude. A ref will be considered to match if it matches at least one positive refspec, and does not match any negative refspec. Negative refspecs can be useful to restrict the scope of a pattern refspec so that it will not include specific refs. Negative refspecs can themselves be pattern refspecs. However, they may only contain a <src> and do not specify a <dst>. Fully spelled out hex object names are also not supported.\n\ntag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>; it requests fetching everything up to the given tag.\n\nThe remote ref that matches <src> is fetched, and if <dst> is not an empty string, an attempt is made to update the local ref that matches it.\n\nWhether that update is allowed without --force depends on the ref namespace it’s being fetched to, the type of object being fetched, and whether the update is considered to be a fast-forward. Generally, the same rules apply for fetching as when pushing, see the <refspec>... section of git-push[1] for what those are. Exceptions to those rules particular to git fetch are noted below.\n\nUntil Git version 2.20, and unlike when pushing with git-push[1], any updates to refs/tags/* would be accepted without + in the refspec (or --force). When fetching, we promiscuously considered all tag updates from a remote to be forced fetches. Since Git version 2.20, fetching to update refs/tags/* works the same way as when pushing. I.e. any updates will be rejected without + in the refspec (or --force).\n\nUnlike when pushing with git-push[1], any updates outside of refs/{tags,heads}/* will be accepted without + in the refspec (or --force), whether that’s swapping e.g. a tree object for a blob, or a commit for another commit that doesn’t have the previous commit as an ancestor etc.\n\nUnlike when pushing with git-push[1], there is no configuration which’ll amend these rules, and nothing like a pre-fetch hook analogous to the pre-receive hook.\n\nAs with pushing with git-push[1], all of the rules described above about what’s not allowed as an update can be overridden by adding an optional leading + to a refspec (or using the --force command line option). The only exception to this is that no amount of forcing will make the refs/heads/* namespace accept a non-commit object.\n\n**--[no-]all**: Fetch all remotes, except for the ones that has the remote.<name>.skipFetchAll configuration variable set. This overrides the configuration variable fetch.all.\n**-a**: Append ref names and object names of fetched refs to the existing contents of .git/FETCH_HEAD. Without this option old data in .git/FETCH_HEAD will be overwritten.\n**--append**: Use an atomic transaction to update local refs. Either all refs are updated, or on error, no refs are updated.\n**--atomic**: Limit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a shallow repository created by git clone with --depth=<depth> option (see git-clone[1]), deepen or shorten the history to the specified number of commits. Tags for the deepened commits are not fetched.\n**--depth=<depth>**: Similar to --depth, except it specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history.\n**--deepen=<depth>**: Deepen or shorten the history of a shallow repository to include all reachable commits after <date>.\n**--shallow-since=<date>**: Deepen or shorten the history of a shallow repository to exclude commits reachable from a specified remote branch or tag. This option can be specified multiple times.\n**--shallow-exclude=<ref>**: If the source repository is complete, convert a shallow repository to a complete one, removing all the limitations imposed by shallow repositories. If the source repository is shallow, fetch as much as possible so that the current repository has the same history as the source repository.\n**--unshallow**: By default when fetching from a shallow repository, git fetch refuses refs that require updating .git/shallow. This option updates .git/shallow and accepts such refs.\n**--update-shallow**: By default, Git will report, to the server, commits reachable from all local refs to find common commits in an attempt to reduce the size of the to-be-received packfile. If specified, Git will only report commits reachable from the given tips. This is useful to speed up fetches when the user knows which local ref is likely to have commits in common with the upstream ref being fetched. This option may be specified more than once; if so, Git will report commits reachable from any of the given commits. The argument to this option may be a glob on ref names, a ref, or the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is equivalent to specifying this option multiple times, one for each matching ref name. See also the fetch.negotiationAlgorithm and push.negotiate configuration variables documented in git-config[1], and the --negotiate-only option below.\n**--negotiation-tip=<commit|glob>**: Do not fetch anything from the server, and instead print the ancestors of the provided --negotiation-tip=* arguments, which we have in common with the server. This is incompatible with --recurse-submodules=[yes|on-demand]. Internally this is used to implement the push.negotiate option, see git-config[1].\n**--negotiate-only**: Show what would be done, without making any changes.\n**--dry-run**: Print the output to standard output in an easy-to-parse format for scripts. See section OUTPUT in git-fetch[1] for details. This is incompatible with --recurse-submodules=[yes|on-demand] and takes precedence over the fetch.output config option.\n**--porcelain**: When git fetch is used with <src>:<dst> refspec, it may refuse to update the local branch as discussed in the <refspec> part of the git-fetch[1] documentation. This option overrides that check.\n**-f**: Keep downloaded pack.\n**--force**: Modify the configured refspec to place all refs into the refs/prefetch/ namespace. See the prefetch task in git-maintenance[1].\n**-k**: Before fetching, remove any remote-tracking references that no longer exist on the remote. Tags are not subject to pruning if they are fetched only because of the default tag auto-following or due to a --tags option. However, if tags are fetched due to an explicit refspec (either on the command line or in the remote configuration, for example if the remote was cloned with the --mirror option), then they are also subject to pruning. Supplying --prune-tags is a shorthand for providing the tag refspec.\n**--keep**: By default, tags that point at objects that are downloaded from the remote repository are fetched and stored locally. This option disables this automatic tag following. The default behavior for a remote may be specified with the remote.<name>.tagOpt setting. See git-config[1].\n**--prefetch**: When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of remote.*.fetch configuration variables for the remote repository. Providing an empty <refspec> to the --refmap option causes Git to ignore the configured refspecs and rely entirely on the refspecs supplied as command-line arguments. See section on \"Configured Remote-tracking Branches\" for details.\n**-p**: Fetch all tags from the remote (i.e., fetch remote tags refs/tags/* into local tags with the same name), in addition to whatever else would otherwise be fetched. Using this option alone does not subject tags to pruning, even if --prune is used (though tags may be pruned anyway if they are also the destination of an explicit refspec; see --prune).\n**--prune**: Number of parallel children to be used for all forms of fetching. If the --multiple option was specified, the different remotes will be fetched in parallel. If multiple submodules are fetched, they will be fetched in parallel. To control them independently, use the config settings fetch.parallel and submodule.fetchJobs (see git-config[1]). Typically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel.\n**--no-tags**: If the remote is fetched successfully, add upstream (tracking) reference, used by argument-less git-pull[1] and other commands. For more information, see branch.<name>.merge and branch.<name>.remote in git-config[1].\n**--refmap=<refspec>**: When given, and the repository to fetch from is handled by git fetch-pack, --exec=<upload-pack> is passed to the command to specify non-default path for the command run on the other end.\n**-t**: Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.\n**--tags**: Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. The server’s handling of server options, including unknown ones, is server-specific. When multiple --server-option=<option> are given, they are all sent to the other side in the order listed on the command line. When no --server-option=<option> is given from the command line, the values of configuration variable remote.<name>.serverOption are used instead.\n**-j**: By default, git checks if a branch is force-updated during fetch. This can be disabled through fetch.showForcedUpdates, but the --show-forced-updates option guarantees this check occurs. See git-config[1].\n**--jobs=<n>**: By default, git checks if a branch is force-updated during fetch. Pass --no-show-forced-updates or set fetch.showForcedUpdates to false to skip this check for performance reasons. If used during git-pull the --ff-only option will still check for forced updates before attempting a fast-forward update. See git-config[1].\n**--set-upstream**: Use IPv4 addresses only, ignoring IPv6 addresses.\n**--upload-pack <upload-pack>**: Use IPv6 addresses only, ignoring IPv4 addresses.\n**--progress**: The \"remote\" repository that is the source of a fetch or pull operation. This parameter can be either a URL (see the section GIT URLS below) or the name of a remote (see the section REMOTES below).\n**-o <option>**: Specifies which refs to fetch and which local refs to update. When no <refspec>s appear on the command line, the refs to fetch are read from remote.<repository>.fetch variables instead (see the section \"CONFIGURED REMOTE-TRACKING BRANCHES\" in git-fetch[1]). The format of a <refspec> parameter is an optional plus +, followed by the source <src>, followed by a colon :, followed by the destination <dst>. The colon can be omitted when <dst> is empty. <src> is typically a ref, or a glob pattern with a single * that is used to match a set of refs, but it can also be a fully spelled hex object name. A <refspec> may contain a * in its <src> to indicate a simple pattern match. Such a refspec functions like a glob that matches any ref with the pattern. A pattern <refspec> must have one and only one * in both the <src> and <dst>. It will map refs to the destination by replacing the * with the contents matched from the source. If a refspec is prefixed by ^, it will be interpreted as a negative refspec. Rather than specifying which refs to fetch or which local refs to update, such a refspec will instead specify refs to exclude. A ref will be considered to match if it matches at least one positive refspec, and does not match any negative refspec. Negative refspecs can be useful to restrict the scope of a pattern refspec so that it will not include specific refs. Negative refspecs can themselves be pattern refspecs. However, they may only contain a <src> and do not specify a <dst>. Fully spelled out hex object names are also not supported. tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>; it requests fetching everything up to the given tag. The remote ref that matches <src> is fetched, and if <dst> is not an empty string, an attempt is made to update the local ref that matches it. Whether that update is allowed without --force depends on the ref namespace it’s being fetched to, the type of object being fetched, and whether the update is considered to be a fast-forward. Generally, the same rules apply for fetching as when pushing, see the <refspec>... section of git-push[1] for what those are. Exceptions to those rules particular to git fetch are noted below. Until Git version 2.20, and unlike when pushing with git-push[1], any updates to refs/tags/* would be accepted without + in the refspec (or --force). When fetching, we promiscuously considered all tag updates from a remote to be forced fetches. Since Git version 2.20, fetching to update refs/tags/* works the same way as when pushing. I.e. any updates will be rejected without + in the refspec (or --force). Unlike when pushing with git-push[1], any updates outside of refs/{tags,heads}/* will be accepted without + in the refspec (or --force), whether that’s swapping e.g. a tree object for a blob, or a commit for another commit that doesn’t have the previous commit as an ancestor etc. Unlike when pushing with git-push[1], there is no configuration which’ll amend these rules, and nothing like a pre-fetch hook analogous to the pre-receive hook. As with pushing with git-push[1], all of the rules described above about what’s not allowed as an update can be overridden by adding an optional leading + to a refspec (or using the --force command line option). The only exception to this is that no amount of forcing will make the refs/heads/* namespace accept a non-commit object. Note When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be a descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the + sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch. Note There is a difference between listing multiple <refspec> directly on git pull command line and having multiple remote.<repository>.fetch entries in your configuration for a <repository> and running a git pull command without any explicit <refspec> parameters. <refspec>s listed explicitly on the command line are always merged into the current branch after fetching. In other words, if you list more than one remote ref, git pull will create an Octopus merge. On the other hand, if you do not list any explicit <refspec> parameter on the command line, git pull will fetch all the <refspec>s it finds in the remote.<repository>.fetch configuration and merge only the first <refspec> found into the current branch. This is because making an Octopus from remote refs is rarely done, while keeping track of multiple remote heads in one-go by fetching more than one is often useful.\n\nNote | When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be a descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the + sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.\n\nNote | There is a difference between listing multiple <refspec> directly on git pull command line and having multiple remote.<repository>.fetch entries in your configuration for a <repository> and running a git pull command without any explicit <refspec> parameters. <refspec>s listed explicitly on the command line are always merged into the current branch after fetching. In other words, if you list more than one remote ref, git pull will create an Octopus merge. On the other hand, if you do not list any explicit <refspec> parameter on the command line, git pull will fetch all the <refspec>s it finds in the remote.<repository>.fetch configuration and merge only the first <refspec> found into the current branch. This is because making an Octopus from remote refs is rarely done, while keeping track of multiple remote heads in one-go by fetching more than one is often useful.\n\n[Note] Note When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be a descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the + sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.\n\n[Note] Note There is a difference between listing multiple <refspec> directly on git pull command line and having multiple remote.<repository>.fetch entries in your configuration for a <repository> and running a git pull command without any explicit <refspec> parameters. <refspec>s listed explicitly on the command line are always merged into the current branch after fetching. In other words, if you list more than one remote ref, git pull will create an Octopus merge. On the other hand, if you do not list any explicit <refspec> parameter on the command line, git pull will fetch all the <refspec>s it finds in the remote.<repository>.fetch configuration and merge only the first <refspec> found into the current branch. This is because making an Octopus from remote refs is rarely done, while keeping track of multiple remote heads in one-go by fetching more than one is often useful.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 49,
          "content_length": 26579
        }
      },
      {
        "header": "GIT URLS",
        "content": "In general, URLs contain information about the transport protocol, the address of the remote server, and the path to the repository. Depending on the transport protocol, some of this information may be absent.\n\nGit supports ssh, git, http, and https protocols (in addition, ftp and ftps can be used for fetching, but this is inefficient and deprecated; do not use them).\n\nThe native transport (i.e. git:// URL) does no authentication and should be used with caution on unsecured networks.\n\nThe following syntaxes may be used with them:\n\nssh://[<user>@]<host>[:<port>]/<path-to-git-repo>\n\ngit://<host>[:<port>]/<path-to-git-repo>\n\nhttp[s]://<host>[:<port>]/<path-to-git-repo>\n\nftp[s]://<host>[:<port>]/<path-to-git-repo>\n\nAn alternative scp-like syntax may also be used with the ssh protocol:\n\n[<user>@]<host>:/<path-to-git-repo>\n\nThis syntax is only recognized if there are no slashes before the first colon. This helps differentiate a local path that contains a colon. For example the local path foo:bar could be specified as an absolute path or ./foo:bar to avoid being misinterpreted as an ssh url.\n\nThe ssh and git protocols additionally support ~<username> expansion:\n\nssh://[<user>@]<host>[:<port>]/~<user>/<path-to-git-repo>\n\ngit://<host>[:<port>]/~<user>/<path-to-git-repo>\n\n[<user>@]<host>:~<user>/<path-to-git-repo>\n\nFor local repositories, also supported by Git natively, the following syntaxes may be used:\n\nfile:///path/to/repo.git/\n\nThese two syntaxes are mostly equivalent, except when cloning, when the former implies --local option. See git-clone[1] for details.\n\ngit clone, git fetch and git pull, but not git push, will also accept a suitable bundle file. See git-bundle[1].\n\nWhen Git doesn’t know how to handle a certain transport protocol, it attempts to use the remote-<transport> remote helper, if one exists. To explicitly request a remote helper, the following syntax may be used:\n\n<transport>::<address>\n\nwhere <address> may be a path, a server and path, or an arbitrary URL-like string recognized by the specific remote helper being invoked. See gitremote-helpers[7] for details.\n\nIf there are a large number of similarly-named remote repositories and you want to use a different format for them (such that the URLs you use will be rewritten into URLs that work), you can create a configuration section of the form:\n\nFor example, with this:\n\na URL like \"work:repo.git\" or like \"host.xz:/path/to/repo.git\" will be rewritten in any context that takes a URL to be \"git://git.host.xz/repo.git\".\n\nIf you want to rewrite URLs for push only, you can create a configuration section of the form:\n\nFor example, with this:\n\na URL like \"git://example.org/path/to/repo.git\" will be rewritten to \"ssh://example.org/path/to/repo.git\" for pushes, but pulls will still use the original URL.\n\n• ssh://[<user>@]<host>[:<port>]/<path-to-git-repo>\n• git://<host>[:<port>]/<path-to-git-repo>\n• http[s]://<host>[:<port>]/<path-to-git-repo>\n• ftp[s]://<host>[:<port>]/<path-to-git-repo>\n\n• [<user>@]<host>:/<path-to-git-repo>\n\n• ssh://[<user>@]<host>[:<port>]/~<user>/<path-to-git-repo>\n• git://<host>[:<port>]/~<user>/<path-to-git-repo>\n• [<user>@]<host>:~<user>/<path-to-git-repo>\n\n• /path/to/repo.git/\n• file:///path/to/repo.git/\n\n• <transport>::<address>",
        "code_examples": [
          "```bash\n[url \"<actual-url-base>\"]\n\t\tinsteadOf =<other-url-base>\n```",
          "```bash\n[url \"<actual-url-base>\"]\n\t\tpushInsteadOf =<other-url-base>\n```"
        ],
        "usage_examples": [
          "```bash\n[url \"git://git.host.xz/\"]\n\t\tinsteadOf = host.xz:/path/to/\n\t\tinsteadOf = work:\n```",
          "```bash\n[url \"ssh://example.org/\"]\n\t\tpushInsteadOf = git://example.org/\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 28,
          "content_length": 3261
        }
      },
      {
        "header": "REMOTES",
        "content": "The name of one of the following can be used instead of a URL as <repository> argument:\n\na remote in the Git configuration file: $GIT_DIR/config,\n\na file in the $GIT_DIR/remotes directory, or\n\na file in the $GIT_DIR/branches directory.\n\nAll of these also allow you to omit the refspec from the command line because they each contain a refspec which git will use by default.\n\n• a remote in the Git configuration file: $GIT_DIR/config,\n• a file in the $GIT_DIR/remotes directory, or\n• a file in the $GIT_DIR/branches directory.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 525
        }
      },
      {
        "header": "Named remote in configuration file",
        "content": "You can choose to provide the name of a remote which you had previously configured using git-remote[1], git-config[1] or even by a manual edit to the $GIT_DIR/config file. The URL of this remote will be used to access the repository. The refspec of this remote will be used by default when you do not provide a refspec on the command line. The entry in the config file would appear like this:\n\nThe <pushurl> is used for pushes only. It is optional and defaults to <URL>. Pushing to a remote affects all defined pushurls or all defined urls if no pushurls are defined. Fetch, however, will only fetch from the first defined url if multiple urls are defined.",
        "code_examples": [
          "```bash\n[remote \"<name>\"]\n\t\turl = <URL>\n\t\tpushurl = <pushurl>\n\t\tpush =<refspec>fetch =<refspec>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 656
        }
      },
      {
        "header": "Named file in $GIT_DIR/remotes",
        "content": "You can choose to provide the name of a file in $GIT_DIR/remotes. The URL in this file will be used to access the repository. The refspec in this file will be used as default when you do not provide a refspec on the command line. This file should have the following format:\n\nPush: lines are used by git push and Pull: lines are used by git pull and git fetch. Multiple Push: and Pull: lines may be specified for additional branch mappings.",
        "code_examples": [
          "```bash\nURL: one of the above URL formats\n\tPush:<refspec>Pull:<refspec>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 439
        }
      },
      {
        "header": "Named file in $GIT_DIR/branches",
        "content": "You can choose to provide the name of a file in $GIT_DIR/branches. The URL in this file will be used to access the repository. This file should have the following format:\n\n<URL> is required; #<head> is optional.\n\nDepending on the operation, git will use one of the following refspecs, if you don’t provide one on the command line. <branch> is the name of this file in $GIT_DIR/branches and <head> defaults to master.",
        "code_examples": [
          "```bash\n<URL>#<head>\n```",
          "```bash\nrefs/heads/<head>:refs/heads/<branch>\n```",
          "```bash\nHEAD:refs/heads/<head>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 416
        }
      },
      {
        "header": "MERGE STRATEGIES",
        "content": "The merge mechanism (git merge and git pull commands) allows the backend merge strategies to be chosen with -s option. Some strategies can also take their own options, which can be passed by giving -X<option> arguments to git merge and/or git pull.\n\nThis is the default merge strategy when pulling or merging one branch. This strategy can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this strategy can detect and handle merges involving renames. It does not make use of detected copies. The name for this algorithm is an acronym (\"Ostensibly Recursive’s Twin\") and came from the fact that it was written as a replacement for the previous default algorithm, recursive.\n\nIn the case where the path is a submodule, if the submodule commit used on one side of the merge is a descendant of the submodule commit used on the other side of the merge, Git attempts to fast-forward to the descendant. Otherwise, Git will treat this case as a conflict, suggesting as a resolution a submodule commit that is descendant of the conflicting ones, if one exists.\n\nThe ort strategy can take the following options:\n\nThis option forces conflicting hunks to be auto-resolved cleanly by favoring our version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side.\n\nThis should not be confused with the ours merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring our history contains all that happened in it.\n\nThis is the opposite of ours; note that, unlike ours, there is no theirs merge strategy to confuse this merge option with.\n\nTreats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also git-diff[1] -b, -w, --ignore-space-at-eol, and --ignore-cr-at-eol.\n\nIf their version only introduces whitespace changes to a line, our version is used;\n\nIf our version introduces whitespace changes but their version includes a substantial change, their version is used;\n\nOtherwise, the merge proceeds in the usual way.\n\nThis runs a virtual check-out and check-in of all three stages of any file which needs a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See \"Merging branches with differing checkin/checkout attributes\" in gitattributes[5] for details.\n\nDisables the renormalize option. This overrides the merge.renormalize configuration variable.\n\nTurn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the merge.renames configuration variable. See also git-diff[1] --find-renames.\n\nDeprecated synonym for find-renames=<n>.\n\nTurn off rename detection. This overrides the merge.renames configuration variable. See also git-diff[1] --no-renames.\n\nDeprecated synonym for diff-algorithm=histogram.\n\nDeprecated synonym for diff-algorithm=patience.\n\nUse a different diff algorithm while merging, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also git-diff[1] --diff-algorithm. Note that ort defaults to diff-algorithm=histogram, while regular diffs currently default to the diff.algorithm config setting.\n\nThis option is a more advanced form of subtree strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.\n\nThis is now a synonym for ort. It was an alternative implementation until v2.49.0, but was redirected to mean ort in v2.50.0. The previous recursive strategy was the default strategy for resolving two heads from Git v0.99.9k until v2.33.0.\n\nThis can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm. It tries to carefully detect criss-cross merge ambiguities. It does not handle renames.\n\nThis resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branch.\n\nThis resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the ort merge strategy.\n\nThis is a modified ort strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree.\n\nWith the strategies that use 3-way merge (including the default, ort), if a change is made on both branches, but later reverted on one of the branches, that change will be present in the merged result; some people find this behavior confusing. It occurs because only the heads and the merge base are considered when performing a merge, not the individual commits. The merge algorithm therefore considers the reverted change as no change at all, and substitutes the changed version instead.\n\n• If their version only introduces whitespace changes to a line, our version is used;\n• If our version introduces whitespace changes but their version includes a substantial change, their version is used;\n• Otherwise, the merge proceeds in the usual way.\n\n**ort**: This is the default merge strategy when pulling or merging one branch. This strategy can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this strategy can detect and handle merges involving renames. It does not make use of detected copies. The name for this algorithm is an acronym (\"Ostensibly Recursive’s Twin\") and came from the fact that it was written as a replacement for the previous default algorithm, recursive. In the case where the path is a submodule, if the submodule commit used on one side of the merge is a descendant of the submodule commit used on the other side of the merge, Git attempts to fast-forward to the descendant. Otherwise, Git will treat this case as a conflict, suggesting as a resolution a submodule commit that is descendant of the conflicting ones, if one exists. The ort strategy can take the following options: ours This option forces conflicting hunks to be auto-resolved cleanly by favoring our version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side. This should not be confused with the ours merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring our history contains all that happened in it. theirs This is the opposite of ours; note that, unlike ours, there is no theirs merge strategy to confuse this merge option with. ignore-space-change ignore-all-space ignore-space-at-eol ignore-cr-at-eol Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also git-diff[1] -b, -w, --ignore-space-at-eol, and --ignore-cr-at-eol. If their version only introduces whitespace changes to a line, our version is used; If our version introduces whitespace changes but their version includes a substantial change, their version is used; Otherwise, the merge proceeds in the usual way. renormalize This runs a virtual check-out and check-in of all three stages of any file which needs a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See \"Merging branches with differing checkin/checkout attributes\" in gitattributes[5] for details. no-renormalize Disables the renormalize option. This overrides the merge.renormalize configuration variable. find-renames[=<n>] Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the merge.renames configuration variable. See also git-diff[1] --find-renames. rename-threshold=<n> Deprecated synonym for find-renames=<n>. no-renames Turn off rename detection. This overrides the merge.renames configuration variable. See also git-diff[1] --no-renames. histogram Deprecated synonym for diff-algorithm=histogram. patience Deprecated synonym for diff-algorithm=patience. diff-algorithm=(histogram|minimal|myers|patience) Use a different diff algorithm while merging, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also git-diff[1] --diff-algorithm. Note that ort defaults to diff-algorithm=histogram, while regular diffs currently default to the diff.algorithm config setting. subtree[=<path>] This option is a more advanced form of subtree strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.\n**ours**: This option forces conflicting hunks to be auto-resolved cleanly by favoring our version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side. This should not be confused with the ours merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring our history contains all that happened in it.\n**theirs**: This is the opposite of ours; note that, unlike ours, there is no theirs merge strategy to confuse this merge option with.\n**ignore-space-change**: Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also git-diff[1] -b, -w, --ignore-space-at-eol, and --ignore-cr-at-eol. If their version only introduces whitespace changes to a line, our version is used; If our version introduces whitespace changes but their version includes a substantial change, their version is used; Otherwise, the merge proceeds in the usual way.\n**ignore-all-space**: This runs a virtual check-out and check-in of all three stages of any file which needs a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See \"Merging branches with differing checkin/checkout attributes\" in gitattributes[5] for details.\n**ignore-space-at-eol**: Disables the renormalize option. This overrides the merge.renormalize configuration variable.\n**ignore-cr-at-eol**: Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the merge.renames configuration variable. See also git-diff[1] --find-renames.\n**renormalize**: Deprecated synonym for find-renames=<n>.\n**no-renormalize**: Turn off rename detection. This overrides the merge.renames configuration variable. See also git-diff[1] --no-renames.\n**find-renames[=<n>]**: Deprecated synonym for diff-algorithm=histogram.\n**rename-threshold=<n>**: Deprecated synonym for diff-algorithm=patience.\n**no-renames**: Use a different diff algorithm while merging, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also git-diff[1] --diff-algorithm. Note that ort defaults to diff-algorithm=histogram, while regular diffs currently default to the diff.algorithm config setting.\n**histogram**: This option is a more advanced form of subtree strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.\n**patience**: This is now a synonym for ort. It was an alternative implementation until v2.49.0, but was redirected to mean ort in v2.50.0. The previous recursive strategy was the default strategy for resolving two heads from Git v0.99.9k until v2.33.0.\n**diff-algorithm=(histogram|minimal|myers|patience)**: This can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm. It tries to carefully detect criss-cross merge ambiguities. It does not handle renames.\n**subtree[=<path>]**: This resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branch.\n**recursive**: This resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the ort merge strategy.\n**resolve**: This is a modified ort strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree.\n**ours**: This option forces conflicting hunks to be auto-resolved cleanly by favoring our version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side. This should not be confused with the ours merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring our history contains all that happened in it.\n**theirs**: This is the opposite of ours; note that, unlike ours, there is no theirs merge strategy to confuse this merge option with.\n**ignore-space-change**: Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also git-diff[1] -b, -w, --ignore-space-at-eol, and --ignore-cr-at-eol. If their version only introduces whitespace changes to a line, our version is used; If our version introduces whitespace changes but their version includes a substantial change, their version is used; Otherwise, the merge proceeds in the usual way.\n**ignore-all-space**: This runs a virtual check-out and check-in of all three stages of any file which needs a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See \"Merging branches with differing checkin/checkout attributes\" in gitattributes[5] for details.\n**ignore-space-at-eol**: Disables the renormalize option. This overrides the merge.renormalize configuration variable.\n**ignore-cr-at-eol**: Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the merge.renames configuration variable. See also git-diff[1] --find-renames.\n**renormalize**: Deprecated synonym for find-renames=<n>.\n**no-renormalize**: Turn off rename detection. This overrides the merge.renames configuration variable. See also git-diff[1] --no-renames.\n**find-renames[=<n>]**: Deprecated synonym for diff-algorithm=histogram.\n**rename-threshold=<n>**: Deprecated synonym for diff-algorithm=patience.\n**no-renames**: Use a different diff algorithm while merging, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also git-diff[1] --diff-algorithm. Note that ort defaults to diff-algorithm=histogram, while regular diffs currently default to the diff.algorithm config setting.\n**histogram**: This option is a more advanced form of subtree strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 26,
          "content_length": 17184
        }
      },
      {
        "header": "DEFAULT BEHAVIOUR",
        "content": "Often people use git pull without giving any parameter. Traditionally, this has been equivalent to saying git pull origin. However, when configuration branch.<name>.remote is present while on branch <name>, that value is used instead of origin.\n\nIn order to determine what URL to use to fetch from, the value of the configuration remote.<origin>.url is consulted and if there is not any such variable, the value on the URL: line in $GIT_DIR/remotes/<origin> is used.\n\nIn order to determine what remote branches to fetch (and optionally store in the remote-tracking branches) when the command is run without any refspec parameters on the command line, values of the configuration variable remote.<origin>.fetch are consulted, and if there aren’t any, $GIT_DIR/remotes/<origin> is consulted and its Pull: lines are used. In addition to the refspec formats described in the OPTIONS section, you can have a globbing refspec that looks like this:\n\nA globbing refspec must have a non-empty RHS (i.e. must store what were fetched in remote-tracking branches), and its LHS and RHS must end with /*. The above specifies that all remote branches are tracked using remote-tracking branches in refs/remotes/origin/ hierarchy under the same name.\n\nThe rule to determine which remote branch to merge after fetching is a bit involved, in order not to break backward compatibility.\n\nIf explicit refspecs were given on the command line of git pull, they are all merged.\n\nWhen no refspec was given on the command line, then git pull uses the refspec from the configuration or $GIT_DIR/remotes/<origin>. In such cases, the following rules apply:\n\nIf branch.<name>.merge configuration for the current branch <name> exists, that is the name of the branch at the remote site that is merged.\n\nIf the refspec is a globbing one, nothing is merged.\n\nOtherwise the remote branch of the first refspec is merged.\n\n• If branch.<name>.merge configuration for the current branch <name> exists, that is the name of the branch at the remote site that is merged.\n• If the refspec is a globbing one, nothing is merged.\n• Otherwise the remote branch of the first refspec is merged.",
        "code_examples": [
          "```bash\nrefs/heads/*:refs/remotes/origin/*\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 2144
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Update the remote-tracking branches for the repository you cloned from, then merge one of them into your current branch:\n\nNormally the branch merged in is the HEAD of the remote repository, but the choice is determined by the branch.<name>.remote and branch.<name>.merge options; see git-config[1] for details.\n\nMerge into the current branch the remote branch next:\n\nThis leaves a copy of next temporarily in FETCH_HEAD, and updates the remote-tracking branch origin/next. The same can be done by invoking fetch and merge:\n\nIf you tried a pull which resulted in complex conflicts and would want to start over, you can recover with git reset.\n\n• Update the remote-tracking branches for the repository you cloned from, then merge one of them into your current branch: $ git pull $ git pull origin Normally the branch merged in is the HEAD of the remote repository, but the choice is determined by the branch.<name>.remote and branch.<name>.merge options; see git-config[1] for details.\n• Merge into the current branch the remote branch next: $ git pull origin next This leaves a copy of next temporarily in FETCH_HEAD, and updates the remote-tracking branch origin/next. The same can be done by invoking fetch and merge: $ git fetch origin $ git merge origin/next",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git pull\n$ git pull origin\n```",
          "```bash\n$ git pull origin next\n```",
          "```bash\n$ git fetch origin\n$ git merge origin/next\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1261
        }
      },
      {
        "header": "SECURITY",
        "content": "The fetch and push protocols are not designed to prevent one side from stealing data from the other repository that was not intended to be shared. If you have private data that you need to protect from a malicious peer, your best option is to store it in another repository. This applies to both clients and servers. In particular, namespaces on a server are not effective for read access control; you should only grant read access to a namespace to clients that you would trust with read access to the entire repository.\n\nThe known attack vectors are as follows:\n\nThe victim sends \"have\" lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn’t required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to \"merge\" X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)\n\nAs in #1, the attacker chooses an object ID X to steal. The victim sends an object Y that the attacker already has, and the attacker falsely claims to have X and not Y, so the victim sends Y as a delta against X. The delta reveals regions of X that are similar to Y to the attacker.\n\n• The victim sends \"have\" lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn’t required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to \"merge\" X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)\n• As in #1, the attacker chooses an object ID X to steal. The victim sends an object Y that the attacker already has, and the attacker falsely claims to have X and not Y, so the victim sends Y as a delta against X. The delta reveals regions of X that are similar to Y to the attacker.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 2762
        }
      },
      {
        "header": "BUGS",
        "content": "Using --recurse-submodules can only fetch new commits in already checked out submodules right now. When e.g. upstream added a new submodule in the just fetched commits of the superproject the submodule itself cannot be fetched, making it impossible to check out that submodule later without having to do a fetch again. This is expected to be fixed in a future Git version.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 372
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-fetch[1], git-merge[1], git-config[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 41
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-pull",
    "doc_type": "git",
    "total_sections": 17
  },
  {
    "title": "Git",
    "summary": "NAME git-push - Update remote refs along with associated objects\n\ngit-push - Update remote refs along with associated objects",
    "sections": [
      {
        "header": "NAME",
        "content": "git-push - Update remote refs along with associated objects",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 59
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Updates remote refs using local refs, while sending objects necessary to complete the given refs.\n\nYou can make interesting things happen to a repository every time you push into it, by setting up hooks there. See documentation for git-receive-pack[1].\n\nWhen the command line does not specify where to push with the <repository> argument, branch.*.remote configuration for the current branch is consulted to determine where to push. If the configuration is missing, it defaults to origin.\n\nWhen the command line does not specify what to push with <refspec>... arguments or --all, --mirror, --tags options, the command finds the default <refspec> by consulting remote.*.push configuration, and if it is not found, honors push.default configuration to decide what to push (See git-config[1] for the meaning of push.default).\n\nWhen neither the command-line nor the configuration specifies what to push, the default behavior is used, which corresponds to the simple value for push.default: the current branch is pushed to the corresponding upstream branch, but as a safety measure, the push is aborted if the upstream branch does not have the same name as the local one.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1166
        }
      },
      {
        "header": "OPTIONS",
        "content": "The \"remote\" repository that is the destination of a push operation. This parameter can be either a URL (see the section GIT URLS below) or the name of a remote (see the section REMOTES below).\n\nSpecify what destination ref to update with what source object. The format of a <refspec> parameter is an optional plus +, followed by the source object <src>, followed by a colon :, followed by the destination ref <dst>.\n\nThe <src> is often the name of the branch you would want to push, but it can be any arbitrary \"SHA-1 expression\", such as master~4 or HEAD (see gitrevisions[7]).\n\nThe <dst> tells which ref on the remote side is updated with this push. Arbitrary expressions cannot be used here, an actual ref must be named. If git push [<repository>] without any <refspec> argument is set to update some ref at the destination with <src> with remote.<repository>.push configuration variable, :<dst> part can be omitted—such a push will update a ref that <src> normally updates without any <refspec> on the command line. Otherwise, missing :<dst> means to update the same ref as the <src>.\n\nIf <dst> doesn’t start with refs/ (e.g. refs/heads/master) we will try to infer where in refs/* on the destination <repository> it belongs based on the type of <src> being pushed and whether <dst> is ambiguous.\n\nIf <dst> unambiguously refers to a ref on the <repository> remote, then push to that ref.\n\nIf <src> resolves to a ref starting with refs/heads/ or refs/tags/, then prepend that to <dst>.\n\nOther ambiguity resolutions might be added in the future, but for now any other cases will error out with an error indicating what we tried, and depending on the advice.pushUnqualifiedRefname configuration (see git-config[1]) suggest what refs/ namespace you may have wanted to push to.\n\nThe object referenced by <src> is used to update the <dst> reference on the remote side. Whether this is allowed depends on where in refs/* the <dst> reference lives as described in detail below, in those sections \"update\" means any modifications except deletes, which as noted after the next few sections are treated differently.\n\nThe refs/heads/* namespace will only accept commit objects, and updates only if they can be fast-forwarded.\n\nThe refs/tags/* namespace will accept any kind of object (as commits, trees and blobs can be tagged), and any updates to them will be rejected.\n\nIt’s possible to push any type of object to any namespace outside of refs/{tags,heads}/*. In the case of tags and commits, these will be treated as if they were the commits inside refs/heads/* for the purposes of whether the update is allowed.\n\nI.e. a fast-forward of commits and tags outside refs/{tags,heads}/* is allowed, even in cases where what’s being fast-forwarded is not a commit, but a tag object which happens to point to a new commit which is a fast-forward of the commit the last tag (or commit) it’s replacing. Replacing a tag with an entirely different tag is also allowed, if it points to the same commit, as well as pushing a peeled tag, i.e. pushing the commit that existing tag object points to, or a new tag object which an existing commit points to.\n\nTree and blob objects outside of refs/{tags,heads}/* will be treated the same way as if they were inside refs/tags/*, any update of them will be rejected.\n\nAll of the rules described above about what’s not allowed as an update can be overridden by adding an the optional leading + to a refspec (or using --force command line option). The only exception to this is that no amount of forcing will make the refs/heads/* namespace accept a non-commit object. Hooks and configuration can also override or amend these rules, see e.g. receive.denyNonFastForwards in git-config[1] and pre-receive and update in githooks[5].\n\nPushing an empty <src> allows you to delete the <dst> ref from the remote repository. Deletions are always accepted without a leading + in the refspec (or --force), except when forbidden by configuration or hooks. See receive.denyDeletes in git-config[1] and pre-receive and update in githooks[5].\n\nThe special refspec : (or +: to allow non-fast-forward updates) directs Git to push \"matching\" branches: for every branch that exists on the local side, the remote side is updated if a branch of the same name already exists on the remote side.\n\ntag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>.\n\nPush all branches (i.e. refs under refs/heads/); cannot be used with other <refspec>.\n\nRemove remote branches that don’t have a local counterpart. For example a remote branch tmp will be removed if a local branch with the same name doesn’t exist any more. This also respects refspecs, e.g. git push --prune remote refs/heads/*:refs/tmp/* would make sure that remote refs/tmp/foo will be removed if refs/heads/foo doesn’t exist.\n\nInstead of naming each ref to push, specifies that all refs under refs/ (which includes but is not limited to refs/heads/, refs/remotes/, and refs/tags/) be mirrored to the remote repository. Newly created local refs will be pushed to the remote end, locally updated refs will be force updated on the remote end, and deleted refs will be removed from the remote end. This is the default if the configuration option remote.<remote>.mirror is set.\n\nDo everything except actually send the updates.\n\nProduce machine-readable output. The output status line for each ref will be tab-separated and sent to stdout instead of stderr. The full symbolic names of the refs will be given.\n\nAll listed refs are deleted from the remote repository. This is the same as prefixing all refs with a colon.\n\nAll refs under refs/tags are pushed, in addition to refspecs explicitly listed on the command line.\n\nPush all the refs that would be pushed without this option, and also push annotated tags in refs/tags that are missing from the remote but are pointing at commit-ish that are reachable from the refs being pushed. This can also be specified with configuration variable push.followTags. For more information, see push.followTags in git-config[1].\n\nGPG-sign the push request to update refs on the receiving side, to allow it to be checked by the hooks and/or be logged. If false or --no-signed, no signing will be attempted. If true or --signed, the push will fail if the server does not support signed pushes. If set to if-asked, sign if and only if the server supports signed pushes. The push will also fail if the actual call to gpg --sign fails. See git-receive-pack[1] for the details on the receiving end.\n\nUse an atomic transaction on the remote side if available. Either all refs are updated, or on error, no refs are updated. If the server does not support atomic pushes the push will fail.\n\nTransmit the given string to the server, which passes them to the pre-receive as well as the post-receive hook. The given string must not contain a NUL or LF character. When multiple --push-option=<option> are given, they are all sent to the other side in the order listed on the command line. When no --push-option=<option> is given from the command line, the values of configuration variable push.pushOption are used instead.\n\nPath to the git-receive-pack program on the remote end. Sometimes useful when pushing to a remote repository over ssh, and you do not have the program in a directory on the default $PATH.\n\nUsually, \"git push\" refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it.\n\nThis option overrides this restriction if the current value of the remote ref is the expected value. \"git push\" fails otherwise.\n\nImagine that you have to rebase what you have already published. You will have to bypass the \"must fast-forward\" rule in order to replace the history you originally published with the rebased history. If somebody else built on top of your original history while you are rebasing, the tip of the branch at the remote may advance with their commit, and blindly pushing with --force will lose their work.\n\nThis option allows you to say that you expect the history you are updating is what you rebased and want to replace. If the remote ref still points at the commit you specified, you can be sure that no other people did anything to the ref. It is like taking a \"lease\" on the ref without explicitly locking it, and the remote ref is updated only if the \"lease\" is still valid.\n\n--force-with-lease alone, without specifying the details, will protect all remote refs that are going to be updated by requiring their current value to be the same as the remote-tracking branch we have for them.\n\n--force-with-lease=<refname>, without specifying the expected value, will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the remote-tracking branch we have for it.\n\n--force-with-lease=<refname>:<expect> will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the specified value <expect> (which is allowed to be different from the remote-tracking branch we have for the refname, or we do not even have to have such a remote-tracking branch when this form is used). If <expect> is the empty string, then the named ref must not already exist.\n\nNote that all forms other than --force-with-lease=<refname>:<expect> that specifies the expected current value of the ref explicitly are still experimental and their semantics may change as we gain experience with this feature.\n\n\"--no-force-with-lease\" will cancel all the previous --force-with-lease on the command line.\n\nA general note on safety: supplying this option without an expected value, i.e. as --force-with-lease or --force-with-lease=<refname> interacts very badly with anything that implicitly runs git fetch on the remote to be pushed to in the background, e.g. git fetch origin on your repository in a cronjob.\n\nThe protection it offers over --force is ensuring that subsequent changes your work wasn’t based on aren’t clobbered, but this is trivially defeated if some background process is updating refs in the background. We don’t have anything except the remote tracking info to go by as a heuristic for refs you’re expected to have seen & are willing to clobber.\n\nIf your editor or some other system is running git fetch in the background for you a way to mitigate this is to simply set up another remote:\n\nNow when the background process runs git fetch origin the references on origin-push won’t be updated, and thus commands like:\n\nWill fail unless you manually run git fetch origin-push. This method is of course entirely defeated by something that runs git fetch --all, in that case you’d need to either disable it or do something more tedious like:\n\nI.e. create a base tag for versions of the upstream code that you’ve seen and are willing to overwrite, then rewrite history, and finally force push changes to master if the remote version is still at base, regardless of what your local remotes/origin/master has been updated to in the background.\n\nAlternatively, specifying --force-if-includes as an ancillary option along with --force-with-lease[=<refname>] (i.e., without saying what exact commit the ref on the remote side must be pointing at, or which refs on the remote side are being protected) at the time of \"push\" will verify if updates from the remote-tracking refs that may have been implicitly updated in the background are integrated locally before allowing a forced update.\n\nUsually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when --force-with-lease option is used, the command refuses to update a remote ref whose current value does not match what is expected.\n\nThis flag disables these checks, and can cause the remote repository to lose commits; use it with care.\n\nNote that --force applies to all the refs that are pushed, hence using it with push.default set to matching or with multiple push destinations configured with remote.*.push may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart). To force a push to only one branch, use a + in front of the refspec to push (e.g git push origin +master to force a push to the master branch). See the <refspec>... section above for details.\n\nForce an update only if the tip of the remote-tracking ref has been integrated locally.\n\nThis option enables a check that verifies if the tip of the remote-tracking ref is reachable from one of the \"reflog\" entries of the local branch based in it for a rewrite. The check ensures that any updates from the remote have been incorporated locally by rejecting the forced update if that is not the case.\n\nIf the option is passed without specifying --force-with-lease, or specified along with --force-with-lease=<refname>:<expect>, it is a \"no-op\".\n\nSpecifying --no-force-if-includes disables this behavior.\n\nThis option is equivalent to the <repository> argument. If both are specified, the command-line argument takes precedence.\n\nFor every branch that is up to date or successfully pushed, add upstream (tracking) reference, used by argument-less git-pull[1] and other commands. For more information, see branch.<name>.merge in git-config[1].\n\nThese options are passed to git-send-pack[1]. A thin transfer significantly reduces the amount of sent data when the sender and receiver share many of the same objects in common. The default is --thin.\n\nSuppress all output, including the listing of updated refs, unless an error occurs. Progress is not reported to the standard error stream.\n\nProgress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.\n\nMay be used to make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If check is used Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing the push will be aborted and exit with non-zero status. If on-demand is used all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If only is used all submodules will be pushed while the superproject is left unpushed. A value of no or using --no-recurse-submodules can be used to override the push.recurseSubmodules configuration variable when no submodule recursion is required.\n\nWhen using on-demand or only, if a submodule has a \"push.recurseSubmodules={on-demand,only}\" or \"submodule.recurse\" configuration, further recursion will occur. In this case, \"only\" is treated as \"on-demand\".\n\nToggle the pre-push hook (see githooks[5]). The default is --verify, giving the hook a chance to prevent the push. With --no-verify, the hook is bypassed completely.\n\nUse IPv4 addresses only, ignoring IPv6 addresses.\n\nUse IPv6 addresses only, ignoring IPv4 addresses.\n\n• If <dst> unambiguously refers to a ref on the <repository> remote, then push to that ref.\n• If <src> resolves to a ref starting with refs/heads/ or refs/tags/, then prepend that to <dst>.\n• Other ambiguity resolutions might be added in the future, but for now any other cases will error out with an error indicating what we tried, and depending on the advice.pushUnqualifiedRefname configuration (see git-config[1]) suggest what refs/ namespace you may have wanted to push to.\n\n**<repository>**: The \"remote\" repository that is the destination of a push operation. This parameter can be either a URL (see the section GIT URLS below) or the name of a remote (see the section REMOTES below).\n**<refspec>…**: Specify what destination ref to update with what source object. The format of a <refspec> parameter is an optional plus +, followed by the source object <src>, followed by a colon :, followed by the destination ref <dst>. The <src> is often the name of the branch you would want to push, but it can be any arbitrary \"SHA-1 expression\", such as master~4 or HEAD (see gitrevisions[7]). The <dst> tells which ref on the remote side is updated with this push. Arbitrary expressions cannot be used here, an actual ref must be named. If git push [<repository>] without any <refspec> argument is set to update some ref at the destination with <src> with remote.<repository>.push configuration variable, :<dst> part can be omitted—such a push will update a ref that <src> normally updates without any <refspec> on the command line. Otherwise, missing :<dst> means to update the same ref as the <src>. If <dst> doesn’t start with refs/ (e.g. refs/heads/master) we will try to infer where in refs/* on the destination <repository> it belongs based on the type of <src> being pushed and whether <dst> is ambiguous. If <dst> unambiguously refers to a ref on the <repository> remote, then push to that ref. If <src> resolves to a ref starting with refs/heads/ or refs/tags/, then prepend that to <dst>. Other ambiguity resolutions might be added in the future, but for now any other cases will error out with an error indicating what we tried, and depending on the advice.pushUnqualifiedRefname configuration (see git-config[1]) suggest what refs/ namespace you may have wanted to push to. The object referenced by <src> is used to update the <dst> reference on the remote side. Whether this is allowed depends on where in refs/* the <dst> reference lives as described in detail below, in those sections \"update\" means any modifications except deletes, which as noted after the next few sections are treated differently. The refs/heads/* namespace will only accept commit objects, and updates only if they can be fast-forwarded. The refs/tags/* namespace will accept any kind of object (as commits, trees and blobs can be tagged), and any updates to them will be rejected. It’s possible to push any type of object to any namespace outside of refs/{tags,heads}/*. In the case of tags and commits, these will be treated as if they were the commits inside refs/heads/* for the purposes of whether the update is allowed. I.e. a fast-forward of commits and tags outside refs/{tags,heads}/* is allowed, even in cases where what’s being fast-forwarded is not a commit, but a tag object which happens to point to a new commit which is a fast-forward of the commit the last tag (or commit) it’s replacing. Replacing a tag with an entirely different tag is also allowed, if it points to the same commit, as well as pushing a peeled tag, i.e. pushing the commit that existing tag object points to, or a new tag object which an existing commit points to. Tree and blob objects outside of refs/{tags,heads}/* will be treated the same way as if they were inside refs/tags/*, any update of them will be rejected. All of the rules described above about what’s not allowed as an update can be overridden by adding an the optional leading + to a refspec (or using --force command line option). The only exception to this is that no amount of forcing will make the refs/heads/* namespace accept a non-commit object. Hooks and configuration can also override or amend these rules, see e.g. receive.denyNonFastForwards in git-config[1] and pre-receive and update in githooks[5]. Pushing an empty <src> allows you to delete the <dst> ref from the remote repository. Deletions are always accepted without a leading + in the refspec (or --force), except when forbidden by configuration or hooks. See receive.denyDeletes in git-config[1] and pre-receive and update in githooks[5]. The special refspec : (or +: to allow non-fast-forward updates) directs Git to push \"matching\" branches: for every branch that exists on the local side, the remote side is updated if a branch of the same name already exists on the remote side. tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>.\n**--all**: Push all branches (i.e. refs under refs/heads/); cannot be used with other <refspec>.\n**--branches**: Remove remote branches that don’t have a local counterpart. For example a remote branch tmp will be removed if a local branch with the same name doesn’t exist any more. This also respects refspecs, e.g. git push --prune remote refs/heads/*:refs/tmp/* would make sure that remote refs/tmp/foo will be removed if refs/heads/foo doesn’t exist.\n**--prune**: Instead of naming each ref to push, specifies that all refs under refs/ (which includes but is not limited to refs/heads/, refs/remotes/, and refs/tags/) be mirrored to the remote repository. Newly created local refs will be pushed to the remote end, locally updated refs will be force updated on the remote end, and deleted refs will be removed from the remote end. This is the default if the configuration option remote.<remote>.mirror is set.\n**--mirror**: Do everything except actually send the updates.\n**-n**: Produce machine-readable output. The output status line for each ref will be tab-separated and sent to stdout instead of stderr. The full symbolic names of the refs will be given.\n**--dry-run**: All listed refs are deleted from the remote repository. This is the same as prefixing all refs with a colon.\n**--porcelain**: All refs under refs/tags are pushed, in addition to refspecs explicitly listed on the command line.\n**-d**: Push all the refs that would be pushed without this option, and also push annotated tags in refs/tags that are missing from the remote but are pointing at commit-ish that are reachable from the refs being pushed. This can also be specified with configuration variable push.followTags. For more information, see push.followTags in git-config[1].\n**--delete**: GPG-sign the push request to update refs on the receiving side, to allow it to be checked by the hooks and/or be logged. If false or --no-signed, no signing will be attempted. If true or --signed, the push will fail if the server does not support signed pushes. If set to if-asked, sign if and only if the server supports signed pushes. The push will also fail if the actual call to gpg --sign fails. See git-receive-pack[1] for the details on the receiving end.\n**--tags**: Use an atomic transaction on the remote side if available. Either all refs are updated, or on error, no refs are updated. If the server does not support atomic pushes the push will fail.\n**--follow-tags**: Transmit the given string to the server, which passes them to the pre-receive as well as the post-receive hook. The given string must not contain a NUL or LF character. When multiple --push-option=<option> are given, they are all sent to the other side in the order listed on the command line. When no --push-option=<option> is given from the command line, the values of configuration variable push.pushOption are used instead.\n**--[no-]signed**: Path to the git-receive-pack program on the remote end. Sometimes useful when pushing to a remote repository over ssh, and you do not have the program in a directory on the default $PATH.\n**--signed=(true|false|if-asked)**: Usually, \"git push\" refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This option overrides this restriction if the current value of the remote ref is the expected value. \"git push\" fails otherwise. Imagine that you have to rebase what you have already published. You will have to bypass the \"must fast-forward\" rule in order to replace the history you originally published with the rebased history. If somebody else built on top of your original history while you are rebasing, the tip of the branch at the remote may advance with their commit, and blindly pushing with --force will lose their work. This option allows you to say that you expect the history you are updating is what you rebased and want to replace. If the remote ref still points at the commit you specified, you can be sure that no other people did anything to the ref. It is like taking a \"lease\" on the ref without explicitly locking it, and the remote ref is updated only if the \"lease\" is still valid. --force-with-lease alone, without specifying the details, will protect all remote refs that are going to be updated by requiring their current value to be the same as the remote-tracking branch we have for them. --force-with-lease=<refname>, without specifying the expected value, will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the remote-tracking branch we have for it. --force-with-lease=<refname>:<expect> will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the specified value <expect> (which is allowed to be different from the remote-tracking branch we have for the refname, or we do not even have to have such a remote-tracking branch when this form is used). If <expect> is the empty string, then the named ref must not already exist. Note that all forms other than --force-with-lease=<refname>:<expect> that specifies the expected current value of the ref explicitly are still experimental and their semantics may change as we gain experience with this feature. \"--no-force-with-lease\" will cancel all the previous --force-with-lease on the command line. A general note on safety: supplying this option without an expected value, i.e. as --force-with-lease or --force-with-lease=<refname> interacts very badly with anything that implicitly runs git fetch on the remote to be pushed to in the background, e.g. git fetch origin on your repository in a cronjob. The protection it offers over --force is ensuring that subsequent changes your work wasn’t based on aren’t clobbered, but this is trivially defeated if some background process is updating refs in the background. We don’t have anything except the remote tracking info to go by as a heuristic for refs you’re expected to have seen & are willing to clobber. If your editor or some other system is running git fetch in the background for you a way to mitigate this is to simply set up another remote: git remote add origin-push $(git config remote.origin.url) git fetch origin-push Now when the background process runs git fetch origin the references on origin-push won’t be updated, and thus commands like: git push --force-with-lease origin-push Will fail unless you manually run git fetch origin-push. This method is of course entirely defeated by something that runs git fetch --all, in that case you’d need to either disable it or do something more tedious like: git fetch # update 'master' from remote git tag base master # mark our base point git rebase -i master # rewrite some commits git push --force-with-lease=master:base master:master I.e. create a base tag for versions of the upstream code that you’ve seen and are willing to overwrite, then rewrite history, and finally force push changes to master if the remote version is still at base, regardless of what your local remotes/origin/master has been updated to in the background. Alternatively, specifying --force-if-includes as an ancillary option along with --force-with-lease[=<refname>] (i.e., without saying what exact commit the ref on the remote side must be pointing at, or which refs on the remote side are being protected) at the time of \"push\" will verify if updates from the remote-tracking refs that may have been implicitly updated in the background are integrated locally before allowing a forced update.\n**--[no-]atomic**: Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when --force-with-lease option is used, the command refuses to update a remote ref whose current value does not match what is expected. This flag disables these checks, and can cause the remote repository to lose commits; use it with care. Note that --force applies to all the refs that are pushed, hence using it with push.default set to matching or with multiple push destinations configured with remote.*.push may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart). To force a push to only one branch, use a + in front of the refspec to push (e.g git push origin +master to force a push to the master branch). See the <refspec>... section above for details.\n**-o <option>**: Force an update only if the tip of the remote-tracking ref has been integrated locally. This option enables a check that verifies if the tip of the remote-tracking ref is reachable from one of the \"reflog\" entries of the local branch based in it for a rewrite. The check ensures that any updates from the remote have been incorporated locally by rejecting the forced update if that is not the case. If the option is passed without specifying --force-with-lease, or specified along with --force-with-lease=<refname>:<expect>, it is a \"no-op\". Specifying --no-force-if-includes disables this behavior.\n**--push-option=<option>**: This option is equivalent to the <repository> argument. If both are specified, the command-line argument takes precedence.\n**--receive-pack=<git-receive-pack>**: For every branch that is up to date or successfully pushed, add upstream (tracking) reference, used by argument-less git-pull[1] and other commands. For more information, see branch.<name>.merge in git-config[1].\n**--exec=<git-receive-pack>**: These options are passed to git-send-pack[1]. A thin transfer significantly reduces the amount of sent data when the sender and receiver share many of the same objects in common. The default is --thin.\n**--[no-]force-with-lease**: Suppress all output, including the listing of updated refs, unless an error occurs. Progress is not reported to the standard error stream.\n**--force-with-lease=<refname>**: Run verbosely.\n**--force-with-lease=<refname>:<expect>**: Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.\n**-f**: May be used to make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If check is used Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing the push will be aborted and exit with non-zero status. If on-demand is used all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If only is used all submodules will be pushed while the superproject is left unpushed. A value of no or using --no-recurse-submodules can be used to override the push.recurseSubmodules configuration variable when no submodule recursion is required. When using on-demand or only, if a submodule has a \"push.recurseSubmodules={on-demand,only}\" or \"submodule.recurse\" configuration, further recursion will occur. In this case, \"only\" is treated as \"on-demand\".\n**--force**: Toggle the pre-push hook (see githooks[5]). The default is --verify, giving the hook a chance to prevent the push. With --no-verify, the hook is bypassed completely.\n**--[no-]force-if-includes**: Use IPv4 addresses only, ignoring IPv6 addresses.\n**--repo=<repository>**: Use IPv6 addresses only, ignoring IPv4 addresses.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit remote add origin-push $(git config remote.origin.url)\ngit fetch origin-push\n```",
          "```bash\ngit push --force-with-lease origin-push\n```",
          "```bash\ngit fetch              # update 'master' from remote\ngit tag base master    # mark our base point\ngit rebase -i master   # rewrite some commits\ngit push --force-with-lease=master:base master:master\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 63,
          "content_length": 31432
        }
      },
      {
        "header": "GIT URLS",
        "content": "In general, URLs contain information about the transport protocol, the address of the remote server, and the path to the repository. Depending on the transport protocol, some of this information may be absent.\n\nGit supports ssh, git, http, and https protocols (in addition, ftp and ftps can be used for fetching, but this is inefficient and deprecated; do not use them).\n\nThe native transport (i.e. git:// URL) does no authentication and should be used with caution on unsecured networks.\n\nThe following syntaxes may be used with them:\n\nssh://[<user>@]<host>[:<port>]/<path-to-git-repo>\n\ngit://<host>[:<port>]/<path-to-git-repo>\n\nhttp[s]://<host>[:<port>]/<path-to-git-repo>\n\nftp[s]://<host>[:<port>]/<path-to-git-repo>\n\nAn alternative scp-like syntax may also be used with the ssh protocol:\n\n[<user>@]<host>:/<path-to-git-repo>\n\nThis syntax is only recognized if there are no slashes before the first colon. This helps differentiate a local path that contains a colon. For example the local path foo:bar could be specified as an absolute path or ./foo:bar to avoid being misinterpreted as an ssh url.\n\nThe ssh and git protocols additionally support ~<username> expansion:\n\nssh://[<user>@]<host>[:<port>]/~<user>/<path-to-git-repo>\n\ngit://<host>[:<port>]/~<user>/<path-to-git-repo>\n\n[<user>@]<host>:~<user>/<path-to-git-repo>\n\nFor local repositories, also supported by Git natively, the following syntaxes may be used:\n\nfile:///path/to/repo.git/\n\nThese two syntaxes are mostly equivalent, except when cloning, when the former implies --local option. See git-clone[1] for details.\n\ngit clone, git fetch and git pull, but not git push, will also accept a suitable bundle file. See git-bundle[1].\n\nWhen Git doesn’t know how to handle a certain transport protocol, it attempts to use the remote-<transport> remote helper, if one exists. To explicitly request a remote helper, the following syntax may be used:\n\n<transport>::<address>\n\nwhere <address> may be a path, a server and path, or an arbitrary URL-like string recognized by the specific remote helper being invoked. See gitremote-helpers[7] for details.\n\nIf there are a large number of similarly-named remote repositories and you want to use a different format for them (such that the URLs you use will be rewritten into URLs that work), you can create a configuration section of the form:\n\nFor example, with this:\n\na URL like \"work:repo.git\" or like \"host.xz:/path/to/repo.git\" will be rewritten in any context that takes a URL to be \"git://git.host.xz/repo.git\".\n\nIf you want to rewrite URLs for push only, you can create a configuration section of the form:\n\nFor example, with this:\n\na URL like \"git://example.org/path/to/repo.git\" will be rewritten to \"ssh://example.org/path/to/repo.git\" for pushes, but pulls will still use the original URL.\n\n• ssh://[<user>@]<host>[:<port>]/<path-to-git-repo>\n• git://<host>[:<port>]/<path-to-git-repo>\n• http[s]://<host>[:<port>]/<path-to-git-repo>\n• ftp[s]://<host>[:<port>]/<path-to-git-repo>\n\n• [<user>@]<host>:/<path-to-git-repo>\n\n• ssh://[<user>@]<host>[:<port>]/~<user>/<path-to-git-repo>\n• git://<host>[:<port>]/~<user>/<path-to-git-repo>\n• [<user>@]<host>:~<user>/<path-to-git-repo>\n\n• /path/to/repo.git/\n• file:///path/to/repo.git/\n\n• <transport>::<address>",
        "code_examples": [
          "```bash\n[url \"<actual-url-base>\"]\n\t\tinsteadOf =<other-url-base>\n```",
          "```bash\n[url \"<actual-url-base>\"]\n\t\tpushInsteadOf =<other-url-base>\n```"
        ],
        "usage_examples": [
          "```bash\n[url \"git://git.host.xz/\"]\n\t\tinsteadOf = host.xz:/path/to/\n\t\tinsteadOf = work:\n```",
          "```bash\n[url \"ssh://example.org/\"]\n\t\tpushInsteadOf = git://example.org/\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 28,
          "content_length": 3261
        }
      },
      {
        "header": "REMOTES",
        "content": "The name of one of the following can be used instead of a URL as <repository> argument:\n\na remote in the Git configuration file: $GIT_DIR/config,\n\na file in the $GIT_DIR/remotes directory, or\n\na file in the $GIT_DIR/branches directory.\n\nAll of these also allow you to omit the refspec from the command line because they each contain a refspec which git will use by default.\n\n• a remote in the Git configuration file: $GIT_DIR/config,\n• a file in the $GIT_DIR/remotes directory, or\n• a file in the $GIT_DIR/branches directory.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 525
        }
      },
      {
        "header": "Named remote in configuration file",
        "content": "You can choose to provide the name of a remote which you had previously configured using git-remote[1], git-config[1] or even by a manual edit to the $GIT_DIR/config file. The URL of this remote will be used to access the repository. The refspec of this remote will be used by default when you do not provide a refspec on the command line. The entry in the config file would appear like this:\n\nThe <pushurl> is used for pushes only. It is optional and defaults to <URL>. Pushing to a remote affects all defined pushurls or all defined urls if no pushurls are defined. Fetch, however, will only fetch from the first defined url if multiple urls are defined.",
        "code_examples": [
          "```bash\n[remote \"<name>\"]\n\t\turl = <URL>\n\t\tpushurl = <pushurl>\n\t\tpush =<refspec>fetch =<refspec>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 656
        }
      },
      {
        "header": "Named file in $GIT_DIR/remotes",
        "content": "You can choose to provide the name of a file in $GIT_DIR/remotes. The URL in this file will be used to access the repository. The refspec in this file will be used as default when you do not provide a refspec on the command line. This file should have the following format:\n\nPush: lines are used by git push and Pull: lines are used by git pull and git fetch. Multiple Push: and Pull: lines may be specified for additional branch mappings.",
        "code_examples": [
          "```bash\nURL: one of the above URL formats\n\tPush:<refspec>Pull:<refspec>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 439
        }
      },
      {
        "header": "Named file in $GIT_DIR/branches",
        "content": "You can choose to provide the name of a file in $GIT_DIR/branches. The URL in this file will be used to access the repository. This file should have the following format:\n\n<URL> is required; #<head> is optional.\n\nDepending on the operation, git will use one of the following refspecs, if you don’t provide one on the command line. <branch> is the name of this file in $GIT_DIR/branches and <head> defaults to master.",
        "code_examples": [
          "```bash\n<URL>#<head>\n```",
          "```bash\nrefs/heads/<head>:refs/heads/<branch>\n```",
          "```bash\nHEAD:refs/heads/<head>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 416
        }
      },
      {
        "header": "OUTPUT",
        "content": "The output of \"git push\" depends on the transport method used; this section describes the output when pushing over the Git protocol (either locally or via ssh).\n\nThe status of the push is output in tabular form, with each line representing the status of a single ref. Each line is of the form:\n\nIf --porcelain is used, then each line of the output is of the form:\n\nThe status of up-to-date refs is shown only if --porcelain or --verbose option is used.\n\nA single character indicating the status of the ref:\n\nfor a successfully pushed fast-forward;\n\nfor a successful forced update;\n\nfor a successfully deleted ref;\n\nfor a successfully pushed new ref;\n\nfor a ref that was rejected or failed to push; and\n\nfor a ref that was up to date and did not need pushing.\n\nFor a successfully pushed ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to git log (this is <old>..<new> in most cases, and <old>...<new> for forced non-fast-forward updates).\n\nFor a failed update, more details are given:\n\nGit did not try to send the ref at all, typically because it is not a fast-forward and you did not force the update.\n\nThe remote end refused the update. Usually caused by a hook on the remote side, or because the remote repository has one of the following safety options in effect: receive.denyCurrentBranch (for pushes to the checked out branch), receive.denyNonFastForwards (for forced non-fast-forward updates), receive.denyDeletes or receive.denyDeleteCurrent. See git-config[1].\n\nThe remote end did not report the successful update of the ref, perhaps because of a temporary error on the remote side, a break in the network connection, or other transient error.\n\nThe name of the local ref being pushed, minus its refs/<type>/ prefix. In the case of deletion, the name of the local ref is omitted.\n\nThe name of the remote ref being updated, minus its refs/<type>/ prefix.\n\nA human-readable explanation. In the case of successfully pushed refs, no explanation is needed. For a failed ref, the reason for failure is described.\n\n**flag**: A single character indicating the status of the ref: (space) for a successfully pushed fast-forward; + for a successful forced update; - for a successfully deleted ref; * for a successfully pushed new ref; ! for a ref that was rejected or failed to push; and = for a ref that was up to date and did not need pushing.\n**(space)**: for a successfully pushed fast-forward;\n**+**: for a successful forced update;\n**-**: for a successfully deleted ref;\n*****: for a successfully pushed new ref;\n**!**: for a ref that was rejected or failed to push; and\n**=**: for a ref that was up to date and did not need pushing.\n**summary**: For a successfully pushed ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to git log (this is <old>..<new> in most cases, and <old>...<new> for forced non-fast-forward updates). For a failed update, more details are given: rejected Git did not try to send the ref at all, typically because it is not a fast-forward and you did not force the update. remote rejected The remote end refused the update. Usually caused by a hook on the remote side, or because the remote repository has one of the following safety options in effect: receive.denyCurrentBranch (for pushes to the checked out branch), receive.denyNonFastForwards (for forced non-fast-forward updates), receive.denyDeletes or receive.denyDeleteCurrent. See git-config[1]. remote failure The remote end did not report the successful update of the ref, perhaps because of a temporary error on the remote side, a break in the network connection, or other transient error.\n**rejected**: Git did not try to send the ref at all, typically because it is not a fast-forward and you did not force the update.\n**remote rejected**: The remote end refused the update. Usually caused by a hook on the remote side, or because the remote repository has one of the following safety options in effect: receive.denyCurrentBranch (for pushes to the checked out branch), receive.denyNonFastForwards (for forced non-fast-forward updates), receive.denyDeletes or receive.denyDeleteCurrent. See git-config[1].\n**remote failure**: The remote end did not report the successful update of the ref, perhaps because of a temporary error on the remote side, a break in the network connection, or other transient error.\n**from**: The name of the local ref being pushed, minus its refs/<type>/ prefix. In the case of deletion, the name of the local ref is omitted.\n**to**: The name of the remote ref being updated, minus its refs/<type>/ prefix.\n**reason**: A human-readable explanation. In the case of successfully pushed refs, no explanation is needed. For a failed ref, the reason for failure is described.\n**(space)**: for a successfully pushed fast-forward;\n**+**: for a successful forced update;\n**-**: for a successfully deleted ref;\n*****: for a successfully pushed new ref;\n**!**: for a ref that was rejected or failed to push; and\n**=**: for a ref that was up to date and did not need pushing.\n**rejected**: Git did not try to send the ref at all, typically because it is not a fast-forward and you did not force the update.\n**remote rejected**: The remote end refused the update. Usually caused by a hook on the remote side, or because the remote repository has one of the following safety options in effect: receive.denyCurrentBranch (for pushes to the checked out branch), receive.denyNonFastForwards (for forced non-fast-forward updates), receive.denyDeletes or receive.denyDeleteCurrent. See git-config[1].\n**remote failure**: The remote end did not report the successful update of the ref, perhaps because of a temporary error on the remote side, a break in the network connection, or other transient error.",
        "code_examples": [
          "```bash\n<flag> <summary> <from> -> <to> (<reason>)\n```",
          "```bash\n<flag> \\t <from>:<to> \\t <summary> (<reason>)\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 19,
          "content_length": 5805
        }
      },
      {
        "header": "NOTE ABOUT FAST-FORWARDS",
        "content": "When an update changes a branch (or more in general, a ref) that used to point at commit A to point at another commit B, it is called a fast-forward update if and only if B is a descendant of A.\n\nIn a fast-forward update from A to B, the set of commits that the original commit A built on top of is a subset of the commits the new commit B builds on top of. Hence, it does not lose any history.\n\nIn contrast, a non-fast-forward update will lose history. For example, suppose you and somebody else started at the same commit X, and you built a history leading to commit B while the other person built a history leading to commit A. The history looks like this:\n\nFurther suppose that the other person already pushed changes leading to A back to the original repository from which you two obtained the original commit X.\n\nThe push done by the other person updated the branch that used to point at commit X to point at commit A. It is a fast-forward.\n\nBut if you try to push, you will attempt to update the branch (that now points at A) with commit B. This does not fast-forward. If you did so, the changes introduced by commit A will be lost, because everybody will now start building on top of B.\n\nThe command by default does not allow an update that is not a fast-forward to prevent such loss of history.\n\nIf you do not want to lose your work (history from X to B) or the work by the other person (history from X to A), you would need to first fetch the history from the repository, create a history that contains changes done by both parties, and push the result back.\n\nYou can perform \"git pull\", resolve potential conflicts, and \"git push\" the result. A \"git pull\" will create a merge commit C between commits A and B.\n\nUpdating A with the resulting merge commit will fast-forward and your push will be accepted.\n\nAlternatively, you can rebase your change between X and B on top of A, with \"git pull --rebase\", and push the result back. The rebase will create a new commit D that builds the change between X and B on top of A.\n\nAgain, updating A with this commit will fast-forward and your push will be accepted.\n\nThere is another common situation where you may encounter non-fast-forward rejection when you try to push, and it is possible even when you are pushing into a repository nobody else pushes into. After you push commit A yourself (in the first picture in this section), replace it with \"git commit --amend\" to produce commit B, and you try to push it out, because forgot that you have pushed A out already. In such a case, and only if you are certain that nobody in the meantime fetched your earlier commit A (and started building on top of it), you can run \"git push --force\" to overwrite it. In other words, \"git push --force\" is a method reserved for a case where you do mean to lose history.",
        "code_examples": [
          "```bash\nB\n     /\n ---X---A\n```",
          "```bash\nB---C\n     /   /\n ---X---A\n```",
          "```bash\nB   D\n     /   /\n ---X---A\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 13,
          "content_length": 2809
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Works like git push <remote>, where <remote> is the current branch’s remote (or origin, if no remote is configured for the current branch).\n\nWithout additional configuration, pushes the current branch to the configured upstream (branch.<name>.merge configuration variable) if it has the same name as the current branch, and errors out without pushing otherwise.\n\nThe default behavior of this command when no <refspec> is given can be configured by setting the push option of the remote, or the push.default configuration variable.\n\nFor example, to default to pushing only the current branch to origin use git config remote.origin.push HEAD. Any valid <refspec> (like the ones in the examples below) can be configured as the default for git push origin.\n\nPush \"matching\" branches to origin. See <refspec> in the OPTIONS section above for a description of \"matching\" branches.\n\nFind a ref that matches master in the source repository (most likely, it would find refs/heads/master), and update the same ref (e.g. refs/heads/master) in origin repository with it. If master did not exist remotely, it would be created.\n\nA handy way to push the current branch to the same name on the remote.\n\nUse the source ref that matches master (e.g. refs/heads/master) to update the ref that matches satellite/master (most probably refs/remotes/satellite/master) in the mothership repository; do the same for dev and satellite/dev.\n\nSee the section describing <refspec>... above for a discussion of the matching semantics.\n\nThis is to emulate git fetch run on the mothership using git push that is run in the opposite direction in order to integrate the work done on satellite, and is often necessary when you can only make connection in one way (i.e. satellite can ssh into mothership but mothership cannot initiate connection to satellite because the latter is behind a firewall or does not run sshd).\n\nAfter running this git push on the satellite machine, you would ssh into the mothership and run git merge there to complete the emulation of git pull that were run on mothership to pull changes made on satellite.\n\nPush the current branch to the remote ref matching master in the origin repository. This form is convenient to push the current branch without thinking about its local name.\n\nCreate the branch experimental in the origin repository by copying the current master branch. This form is only needed to create a new branch or tag in the remote repository when the local name and the remote name are different; otherwise, the ref name on its own will work.\n\nFind a ref that matches experimental in the origin repository (e.g. refs/heads/experimental), and delete it.\n\nUpdate the origin repository’s master branch with the dev branch, allowing non-fast-forward updates. This can leave unreferenced commits dangling in the origin repository. Consider the following situation, where a fast-forward is not possible:\n\nThe above command would change the origin repository to\n\nCommits A and B would no longer belong to a branch with a symbolic name, and so would be unreachable. As such, these commits would be removed by a git gc command on the origin repository.\n\n**git push**: Works like git push <remote>, where <remote> is the current branch’s remote (or origin, if no remote is configured for the current branch).\n**git push origin**: Without additional configuration, pushes the current branch to the configured upstream (branch.<name>.merge configuration variable) if it has the same name as the current branch, and errors out without pushing otherwise. The default behavior of this command when no <refspec> is given can be configured by setting the push option of the remote, or the push.default configuration variable. For example, to default to pushing only the current branch to origin use git config remote.origin.push HEAD. Any valid <refspec> (like the ones in the examples below) can be configured as the default for git push origin.\n**git push origin :**: Push \"matching\" branches to origin. See <refspec> in the OPTIONS section above for a description of \"matching\" branches.\n**git push origin master**: Find a ref that matches master in the source repository (most likely, it would find refs/heads/master), and update the same ref (e.g. refs/heads/master) in origin repository with it. If master did not exist remotely, it would be created.\n**git push origin HEAD**: A handy way to push the current branch to the same name on the remote.\n**git push mothership master:satellite/master dev:satellite/dev**: Use the source ref that matches master (e.g. refs/heads/master) to update the ref that matches satellite/master (most probably refs/remotes/satellite/master) in the mothership repository; do the same for dev and satellite/dev. See the section describing <refspec>... above for a discussion of the matching semantics. This is to emulate git fetch run on the mothership using git push that is run in the opposite direction in order to integrate the work done on satellite, and is often necessary when you can only make connection in one way (i.e. satellite can ssh into mothership but mothership cannot initiate connection to satellite because the latter is behind a firewall or does not run sshd). After running this git push on the satellite machine, you would ssh into the mothership and run git merge there to complete the emulation of git pull that were run on mothership to pull changes made on satellite.\n**git push origin HEAD:master**: Push the current branch to the remote ref matching master in the origin repository. This form is convenient to push the current branch without thinking about its local name.\n**git push origin master:refs/heads/experimental**: Create the branch experimental in the origin repository by copying the current master branch. This form is only needed to create a new branch or tag in the remote repository when the local name and the remote name are different; otherwise, the ref name on its own will work.\n**git push origin :experimental**: Find a ref that matches experimental in the origin repository (e.g. refs/heads/experimental), and delete it.\n**git push origin +dev:master**: Update the origin repository’s master branch with the dev branch, allowing non-fast-forward updates. This can leave unreferenced commits dangling in the origin repository. Consider the following situation, where a fast-forward is not possible: o---o---o---A---B origin/master \\ X---Y---Z dev The above command would change the origin repository to A---B (unnamed branch) / o---o---o---X---Y---Z master Commits A and B would no longer belong to a branch with a symbolic name, and so would be unreachable. As such, these commits would be removed by a git gc command on the origin repository.",
        "code_examples": [
          "```bash\no---o---o---A---B  origin/master\n\t\t     \\\n\t\t      X---Y---Z  dev\n```",
          "```bash\nA---B  (unnamed branch)\n\t\t     /\n\t    o---o---o---X---Y---Z  master\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 17,
          "content_length": 6722
        }
      },
      {
        "header": "SECURITY",
        "content": "The fetch and push protocols are not designed to prevent one side from stealing data from the other repository that was not intended to be shared. If you have private data that you need to protect from a malicious peer, your best option is to store it in another repository. This applies to both clients and servers. In particular, namespaces on a server are not effective for read access control; you should only grant read access to a namespace to clients that you would trust with read access to the entire repository.\n\nThe known attack vectors are as follows:\n\nThe victim sends \"have\" lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn’t required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to \"merge\" X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)\n\nAs in #1, the attacker chooses an object ID X to steal. The victim sends an object Y that the attacker already has, and the attacker falsely claims to have X and not Y, so the victim sends Y as a delta against X. The delta reveals regions of X that are similar to Y to the attacker.\n\n• The victim sends \"have\" lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn’t required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to \"merge\" X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)\n• As in #1, the attacker chooses an object ID X to steal. The victim sends an object Y that the attacker already has, and the attacker falsely claims to have X and not Y, so the victim sends Y as a delta against X. The delta reveals regions of X that are similar to Y to the attacker.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 2762
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Everything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there:\n\nIf set to \"true\" assume --set-upstream on default push when no upstream tracking exists for the current branch; this option takes effect with push.default options simple, upstream, and current. It is useful if by default you want new branches to be pushed to the default remote (like the behavior of push.default=current) and you also want the upstream tracking to be set. Workflows most likely to benefit from this option are simple central workflows where all branches are expected to have the same name on the remote.\n\nDefines the action git push should take if no refspec is given (whether from the command-line, config, or elsewhere). Different values are well-suited for specific workflows; for instance, in a purely central workflow (i.e. the fetch source is equal to the push destination), upstream is probably what you want. Possible values are:\n\nnothing - do not push anything (error out) unless a refspec is given. This is primarily meant for people who want to avoid mistakes by always being explicit.\n\ncurrent - push the current branch to update a branch with the same name on the receiving end. Works in both central and non-central workflows.\n\nupstream - push the current branch back to the branch whose changes are usually integrated into the current branch (which is called @{upstream}). This mode only makes sense if you are pushing to the same repository you would normally pull from (i.e. central workflow).\n\ntracking - This is a deprecated synonym for upstream.\n\nsimple - push the current branch with the same name on the remote.\n\nIf you are working on a centralized workflow (pushing to the same repository you pull from, which is typically origin), then you need to configure an upstream branch with the same name.\n\nThis mode is the default since Git 2.0, and is the safest option suited for beginners.\n\nmatching - push all branches having the same name on both ends. This makes the repository you are pushing to remember the set of branches that will be pushed out (e.g. if you always push maint and master there and no other branches, the repository you push to will have these two branches, and your local maint and master will be pushed there).\n\nTo use this mode effectively, you have to make sure all the branches you would push out are ready to be pushed out before running git push, as the whole point of this mode is to allow you to push all of the branches in one go. If you usually finish work on only one branch and push out the result, while other branches are unfinished, this mode is not for you. Also this mode is not suitable for pushing into a shared central repository, as other people may add new branches there, or update the tip of existing branches outside your control.\n\nThis used to be the default, but not since Git 2.0 (simple is the new default).\n\nIf set to true, enable --follow-tags option by default. You may override this configuration at time of push by specifying --no-follow-tags.\n\nMay be set to a boolean value, or the string if-asked. A true value causes all pushes to be GPG signed, as if --signed is passed to git-push[1]. The string if-asked causes pushes to be signed if the server supports it, as if --signed=if-asked is passed to git push. A false value may override a value from a lower-priority config file. An explicit command-line flag always overrides this config option.\n\nWhen no --push-option=<option> argument is given from the command line, git push behaves as if each <value> of this variable is given as --push-option=<value>.\n\nThis is a multi-valued variable, and an empty value can be used in a higher priority configuration file (e.g. .git/config in a repository) to clear the values inherited from a lower priority configuration files (e.g. $HOME/.gitconfig).\n\nMay be \"check\", \"on-demand\", \"only\", or \"no\", with the same behavior as that of \"push --recurse-submodules\". If not set, no is used by default, unless submodule.recurse is set (in which case a true value means on-demand).\n\nIf set to \"true\", it is equivalent to specifying --force-if-includes as an option to git-push[1] in the command line. Adding --no-force-if-includes at the time of push overrides this configuration setting.\n\nIf set to \"true\", attempt to reduce the size of the packfile sent by rounds of negotiation in which the client and the server attempt to find commits in common. If \"false\", Git will rely solely on the server’s ref advertisement to find commits in common.\n\nIf set to \"false\", disable use of bitmaps for \"git push\" even if pack.useBitmaps is \"true\", without preventing other git operations from using bitmaps. Default is true.\n\n• nothing - do not push anything (error out) unless a refspec is given. This is primarily meant for people who want to avoid mistakes by always being explicit.\n• current - push the current branch to update a branch with the same name on the receiving end. Works in both central and non-central workflows.\n• upstream - push the current branch back to the branch whose changes are usually integrated into the current branch (which is called @{upstream}). This mode only makes sense if you are pushing to the same repository you would normally pull from (i.e. central workflow).\n• tracking - This is a deprecated synonym for upstream.\n• simple - push the current branch with the same name on the remote. If you are working on a centralized workflow (pushing to the same repository you pull from, which is typically origin), then you need to configure an upstream branch with the same name. This mode is the default since Git 2.0, and is the safest option suited for beginners.\n• matching - push all branches having the same name on both ends. This makes the repository you are pushing to remember the set of branches that will be pushed out (e.g. if you always push maint and master there and no other branches, the repository you push to will have these two branches, and your local maint and master will be pushed there). To use this mode effectively, you have to make sure all the branches you would push out are ready to be pushed out before running git push, as the whole point of this mode is to allow you to push all of the branches in one go. If you usually finish work on only one branch and push out the result, while other branches are unfinished, this mode is not for you. Also this mode is not suitable for pushing into a shared central repository, as other people may add new branches there, or update the tip of existing branches outside your control. This used to be the default, but not since Git 2.0 (simple is the new default).\n\n**push.autoSetupRemote**: If set to \"true\" assume --set-upstream on default push when no upstream tracking exists for the current branch; this option takes effect with push.default options simple, upstream, and current. It is useful if by default you want new branches to be pushed to the default remote (like the behavior of push.default=current) and you also want the upstream tracking to be set. Workflows most likely to benefit from this option are simple central workflows where all branches are expected to have the same name on the remote.\n**push.default**: Defines the action git push should take if no refspec is given (whether from the command-line, config, or elsewhere). Different values are well-suited for specific workflows; for instance, in a purely central workflow (i.e. the fetch source is equal to the push destination), upstream is probably what you want. Possible values are: nothing - do not push anything (error out) unless a refspec is given. This is primarily meant for people who want to avoid mistakes by always being explicit. current - push the current branch to update a branch with the same name on the receiving end. Works in both central and non-central workflows. upstream - push the current branch back to the branch whose changes are usually integrated into the current branch (which is called @{upstream}). This mode only makes sense if you are pushing to the same repository you would normally pull from (i.e. central workflow). tracking - This is a deprecated synonym for upstream. simple - push the current branch with the same name on the remote. If you are working on a centralized workflow (pushing to the same repository you pull from, which is typically origin), then you need to configure an upstream branch with the same name. This mode is the default since Git 2.0, and is the safest option suited for beginners. matching - push all branches having the same name on both ends. This makes the repository you are pushing to remember the set of branches that will be pushed out (e.g. if you always push maint and master there and no other branches, the repository you push to will have these two branches, and your local maint and master will be pushed there). To use this mode effectively, you have to make sure all the branches you would push out are ready to be pushed out before running git push, as the whole point of this mode is to allow you to push all of the branches in one go. If you usually finish work on only one branch and push out the result, while other branches are unfinished, this mode is not for you. Also this mode is not suitable for pushing into a shared central repository, as other people may add new branches there, or update the tip of existing branches outside your control. This used to be the default, but not since Git 2.0 (simple is the new default).\n**push.followTags**: If set to true, enable --follow-tags option by default. You may override this configuration at time of push by specifying --no-follow-tags.\n**push.gpgSign**: May be set to a boolean value, or the string if-asked. A true value causes all pushes to be GPG signed, as if --signed is passed to git-push[1]. The string if-asked causes pushes to be signed if the server supports it, as if --signed=if-asked is passed to git push. A false value may override a value from a lower-priority config file. An explicit command-line flag always overrides this config option.\n**push.pushOption**: When no --push-option=<option> argument is given from the command line, git push behaves as if each <value> of this variable is given as --push-option=<value>. This is a multi-valued variable, and an empty value can be used in a higher priority configuration file (e.g. .git/config in a repository) to clear the values inherited from a lower priority configuration files (e.g. $HOME/.gitconfig). Example: /etc/gitconfig push.pushoption = a push.pushoption = b ~/.gitconfig push.pushoption = c repo/.git/config push.pushoption = push.pushoption = b This will result in only b (a and c are cleared).\n**push.recurseSubmodules**: May be \"check\", \"on-demand\", \"only\", or \"no\", with the same behavior as that of \"push --recurse-submodules\". If not set, no is used by default, unless submodule.recurse is set (in which case a true value means on-demand).\n**push.useForceIfIncludes**: If set to \"true\", it is equivalent to specifying --force-if-includes as an option to git-push[1] in the command line. Adding --no-force-if-includes at the time of push overrides this configuration setting.\n**push.negotiate**: If set to \"true\", attempt to reduce the size of the packfile sent by rounds of negotiation in which the client and the server attempt to find commits in common. If \"false\", Git will rely solely on the server’s ref advertisement to find commits in common.\n**push.useBitmaps**: If set to \"false\", disable use of bitmaps for \"git push\" even if pack.useBitmaps is \"true\", without preventing other git operations from using bitmaps. Default is true.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nExample:\n\n/etc/gitconfig\n  push.pushoption = a\n  push.pushoption = b\n\n~/.gitconfig\n  push.pushoption = c\n\nrepo/.git/config\n  push.pushoption =\n  push.pushoption = b\n\nThis will result in only b (a and c are cleared).\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 21,
          "content_length": 11675
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-push",
    "doc_type": "git",
    "total_sections": 14
  },
  {
    "title": "Git",
    "summary": "NAME git-range-diff - Compare two commit ranges (e.g. two versions of a branch)\n\ngit-range-diff - Compare two commit ranges (e.g. two versions of a branch)",
    "sections": [
      {
        "header": "NAME",
        "content": "git-range-diff - Compare two commit ranges (e.g. two versions of a branch)",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 74
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "This command shows the differences between two versions of a patch series, or more generally, two commit ranges (ignoring merge commits).\n\nIn the presence of <path> arguments, these commit ranges are limited accordingly.\n\nTo that end, it first finds pairs of commits from both commit ranges that correspond with each other. Two commits are said to correspond when the diff between their patches (i.e. the author information, the commit message and the commit diff) is reasonably small compared to the patches' size. See ``Algorithm`` below for details.\n\nFinally, the list of matching commits is shown in the order of the second commit range, with unmatched commits being inserted just after all of their ancestors have been shown.\n\nThere are three ways to specify the commit ranges:\n\n<range1> <range2>: Either commit range can be of the form <base>..<rev>, <rev>^! or <rev>^-<n>. See SPECIFYING RANGES in gitrevisions[7] for more details.\n\n<rev1>...<rev2>. This is equivalent to <rev2>..<rev1> <rev1>..<rev2>.\n\n<base> <rev1> <rev2>: This is equivalent to <base>..<rev1> <base>..<rev2>.\n\n• <range1> <range2>: Either commit range can be of the form <base>..<rev>, <rev>^! or <rev>^-<n>. See SPECIFYING RANGES in gitrevisions[7] for more details.\n• <rev1>...<rev2>. This is equivalent to <rev2>..<rev1> <rev1>..<rev2>.\n• <base> <rev1> <rev2>: This is equivalent to <base>..<rev1> <base>..<rev2>.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1392
        }
      },
      {
        "header": "OPTIONS",
        "content": "When the commit diffs differ, git range-diff recreates the original diffs' coloring, and adds outer -/+ diff markers with the background being red/green to make it easier to see e.g. when there was a change in what exact lines were added.\n\nAdditionally, the commit diff lines that are only present in the first commit range are shown \"dimmed\" (this can be overridden using the color.diff.<slot> config setting where <slot> is one of contextDimmed, oldDimmed and newDimmed), and the commit diff lines that are only present in the second commit range are shown in bold (which can be overridden using the config settings color.diff.<slot> with <slot> being one of contextBold, oldBold or newBold).\n\nThis is known to range-diff as \"dual coloring\". Use --no-dual-color to revert to color all lines according to the outer diff markers (and completely ignore the inner diff when it comes to color).\n\nSet the creation/deletion cost fudge factor to <percent>. Defaults to 60. Try a larger value if git range-diff erroneously considers a large change a total rewrite (deletion of one commit and addition of another), and a smaller one in the reverse case. See the ``Algorithm`` section below for an explanation of why this is needed.\n\nSuppress commits that are missing from the first specified range (or the \"left range\" when using the <rev1>...<rev2> format).\n\nSuppress commits that are missing from the second specified range (or the \"right range\" when using the <rev1>...<rev2> format).\n\nInstead of ignoring merge commits, generate diffs for them using the corresponding --diff-merges=<format> option of git-log[1], and include them in the comparison.\n\nNote: In the common case, the remerge mode will be the most natural one to use, as it shows only the diff on top of what Git’s merge machinery would have produced. In other words, if a merge commit is the result of a non-conflicting git merge, the remerge mode will represent it with an empty diff.\n\nConvenience option, equivalent to --diff-merges=remerge.\n\nThis flag is passed to the git log program (see git-log[1]) that generates the patches.\n\nCompare the commits specified by the two ranges, where <range1> is considered an older version of <range2>.\n\nEquivalent to passing <rev2>..<rev1> and <rev1>..<rev2>.\n\nEquivalent to passing <base>..<rev1> and <base>..<rev2>. Note that <base> does not need to be the exact branch point of the branches. Example: after rebasing a branch my-topic, git range-diff my-topic@{u} my-topic@{1} my-topic would show the differences introduced by the rebase.\n\ngit range-diff also accepts the regular diff options (see git-diff[1]), most notably the --color=[<when>] and --no-color options. These options are used when generating the \"diff between patches\", i.e. to compare the author, commit message and diff of corresponding old/new commits. There is currently no means to tweak most of the diff options passed to git log when generating those patches.\n\n**--no-dual-color**: When the commit diffs differ, git range-diff recreates the original diffs' coloring, and adds outer -/+ diff markers with the background being red/green to make it easier to see e.g. when there was a change in what exact lines were added. Additionally, the commit diff lines that are only present in the first commit range are shown \"dimmed\" (this can be overridden using the color.diff.<slot> config setting where <slot> is one of contextDimmed, oldDimmed and newDimmed), and the commit diff lines that are only present in the second commit range are shown in bold (which can be overridden using the config settings color.diff.<slot> with <slot> being one of contextBold, oldBold or newBold). This is known to range-diff as \"dual coloring\". Use --no-dual-color to revert to color all lines according to the outer diff markers (and completely ignore the inner diff when it comes to color).\n**--creation-factor=<percent>**: Set the creation/deletion cost fudge factor to <percent>. Defaults to 60. Try a larger value if git range-diff erroneously considers a large change a total rewrite (deletion of one commit and addition of another), and a smaller one in the reverse case. See the ``Algorithm`` section below for an explanation of why this is needed.\n**--left-only**: Suppress commits that are missing from the first specified range (or the \"left range\" when using the <rev1>...<rev2> format).\n**--right-only**: Suppress commits that are missing from the second specified range (or the \"right range\" when using the <rev1>...<rev2> format).\n**--diff-merges=<format>**: Instead of ignoring merge commits, generate diffs for them using the corresponding --diff-merges=<format> option of git-log[1], and include them in the comparison. Note: In the common case, the remerge mode will be the most natural one to use, as it shows only the diff on top of what Git’s merge machinery would have produced. In other words, if a merge commit is the result of a non-conflicting git merge, the remerge mode will represent it with an empty diff.\n**--remerge-diff**: Convenience option, equivalent to --diff-merges=remerge.\n**--[no-]notes[=<ref>]**: This flag is passed to the git log program (see git-log[1]) that generates the patches.\n**<range1> <range2>**: Compare the commits specified by the two ranges, where <range1> is considered an older version of <range2>.\n**<rev1>…<rev2>**: Equivalent to passing <rev2>..<rev1> and <rev1>..<rev2>.\n**<base> <rev1> <rev2>**: Equivalent to passing <base>..<rev1> and <base>..<rev2>. Note that <base> does not need to be the exact branch point of the branches. Example: after rebasing a branch my-topic, git range-diff my-topic@{u} my-topic@{1} my-topic would show the differences introduced by the rebase.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 14,
          "content_length": 5694
        }
      },
      {
        "header": "OUTPUT STABILITY",
        "content": "The output of the range-diff command is subject to change. It is intended to be human-readable porcelain output, not something that can be used across versions of Git to get a textually stable range-diff (as opposed to something like the --stable option to git-patch-id[1]). There’s also no equivalent of git-apply[1] for range-diff, the output is not intended to be machine-readable.\n\nThis is particularly true when passing in diff options. Currently some options like --stat can, as an emergent effect, produce output that’s quite useless in the context of range-diff. Future versions of range-diff may learn to interpret such options in a manner specific to range-diff (e.g. for --stat producing human-readable output which summarizes how the diffstat changed).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 764
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "This command uses the diff.color.* and pager.range-diff settings (the latter is on by default). See git-config[1].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 114
        }
      },
      {
        "header": "EXAMPLES",
        "content": "When a rebase required merge conflicts to be resolved, compare the changes introduced by the rebase directly afterwards using:\n\nA typical output of git range-diff would look like this:\n\nIn this example, there are 3 old and 3 new commits, where the developer removed the 3rd, added a new one before the first two, and modified the commit message of the 2nd commit as well as its diff.\n\nWhen the output goes to a terminal, it is color-coded by default, just like regular git diff's output. In addition, the first line (adding a commit) is green, the last line (deleting a commit) is red, the second line (with a perfect match) is yellow like the commit header of git show's output, and the third line colors the old commit red, the new one green and the rest like git show's commit header.\n\nA naive color-coded diff of diffs is actually a bit hard to read, though, as it colors the entire lines red or green. The line that added \"What is unexpected\" in the old commit, for example, is completely red, even if the intent of the old commit was to add something.\n\nTo help with that, range uses the --dual-color mode by default. In this mode, the diff of diffs will retain the original diff colors, and prefix the lines with -/+ markers that have their background red or green, to make it more obvious that they describe how the diff itself changed.",
        "code_examples": [
          "```bash\n-:  ------- > 1:  0ddba11 Prepare for the inevitable!\n1:  c0debee = 2:  cab005e Add a helpful message at the start\n2:  f00dbal ! 3:  decafe1 Describe a bug\n    @@ -1,3 +1,3 @@\n     Author: A U Thor <author@example.com>\n\n    -TODO: Describe a bug\n    +Describe a bug\n    @@ -324,5 +324,6\n      This is expected.\n\n    -+What is unexpected is that it will also crash.\n    ++Unexpectedly, it also crashes. This is a bug, and the jury is\n    ++still out there how to fix it best. See ticket #314 for details.\n\n      Contact\n3:  bedead < -:  ------- TO-UNDO\n```"
        ],
        "usage_examples": [
          "```bash\n$ git range-diff @{u} @{1} @\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1343
        }
      },
      {
        "header": "Algorithm",
        "content": "The general idea is this: we generate a cost matrix between the commits in both commit ranges, then solve the least-cost assignment.\n\nThe cost matrix is populated thusly: for each pair of commits, both diffs are generated and the \"diff of diffs\" is generated, with 3 context lines, then the number of lines in that diff is used as cost.\n\nTo avoid false positives (e.g. when a patch has been removed, and an unrelated patch has been added between two iterations of the same patch series), the cost matrix is extended to allow for that, by adding fixed-cost entries for wholesale deletes/adds.\n\nExample: Let commits 1--2 be the first iteration of a patch series and A--C the second iteration. Let’s assume that A is a cherry-pick of 2, and C is a cherry-pick of 1 but with a small modification (say, a fixed typo). Visualize the commits as a bipartite graph:\n\nWe are looking for a \"best\" explanation of the new series in terms of the old one. We can represent an \"explanation\" as an edge in the graph:\n\nThis explanation comes for \"free\" because there was no change. Similarly C could be explained using 1, but that comes at some cost c>0 because of the modification:\n\nIn mathematical terms, what we are looking for is some sort of a minimum cost bipartite matching; 1 is matched to C at some cost, etc. The underlying graph is in fact a complete bipartite graph; the cost we associate with every edge is the size of the diff between the two commits' patches. To explain also new commits, we introduce dummy nodes on both sides:\n\nThe cost of an edge o--C is the size of C's diff, modified by a fudge factor that should be smaller than 100%. The cost of an edge o--o is free. The fudge factor is necessary because even if 1 and C have nothing in common, they may still share a few empty lines and such, possibly making the assignment 1--C, o--o slightly cheaper than 1--o, o--C even if 1 and C have nothing in common. With the fudge factor we require a much larger common part to consider patches as corresponding.\n\nThe overall time needed to compute this algorithm is the time needed to compute n+m commit diffs and then n*m diffs of patches, plus the time needed to compute the least-cost assignment between n and m diffs. Git uses an implementation of the Jonker-Volgenant algorithm to solve the assignment problem, which has cubic runtime complexity. The matching found in this case will look like this:",
        "code_examples": [
          "```bash\n1            A\n\n    2            B\n\n\t\t C\n```",
          "```bash\n1            A\n\t       /\n    2 --------'  B\n\n\t\t C\n```",
          "```bash\n1 ----.      A\n\t  |    /\n    2 ----+---'  B\n\t  |\n\t  `----- C\n\t  c>0\n```",
          "```bash\n1 ----.      A\n\t  |    /\n    2 ----+---'  B\n\t  |\n    o     `----- C\n\t  c>0\n    o            o\n\n    o            o\n```",
          "```bash\n1 ----.      A\n\t  |    /\n    2 ----+---'  B\n       .--+-----'\n    o -'  `----- C\n\t  c>0\n    o ---------- o\n\n    o ---------- o\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 2403
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-range-diff",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "Git",
    "summary": "NAME git-rebase - Reapply commits on top of another base tip\n\ngit-rebase - Reapply commits on top of another base tip",
    "sections": [
      {
        "header": "NAME",
        "content": "git-rebase - Reapply commits on top of another base tip",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 55
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "If <branch> is specified, git rebase will perform an automatic git switch <branch> before doing anything else. Otherwise it remains on the current branch.\n\nIf <upstream> is not specified, the upstream configured in branch.<name>.remote and branch.<name>.merge options will be used (see git-config[1] for details) and the --fork-point option is assumed. If you are currently not on any branch or if the current branch does not have a configured upstream, the rebase will abort.\n\nAll changes made by commits in the current branch but that are not in <upstream> are saved to a temporary area. This is the same set of commits that would be shown by git log <upstream>..HEAD; or by git log fork_point'..HEAD, if --fork-point is active (see the description on --fork-point below); or by git log HEAD, if the --root option is specified.\n\nThe current branch is reset to <upstream> or <newbase> if the --onto option was supplied. This has the exact same effect as git reset --hard <upstream> (or <newbase>). ORIG_HEAD is set to point at the tip of the branch before the reset.\n\nThe commits that were previously saved into the temporary area are then reapplied to the current branch, one by one, in order. Note that any commits in HEAD which introduce the same textual changes as a commit in HEAD..<upstream> are omitted (i.e., a patch already accepted upstream with a different commit message or timestamp will be skipped).\n\nIt is possible that a merge failure will prevent this process from being completely automatic. You will have to resolve any such merge failure and run git rebase --continue. Another option is to bypass the commit that caused the merge failure with git rebase --skip. To check out the original <branch> and remove the .git/rebase-apply working files, use the command git rebase --abort instead.\n\nAssume the following history exists and the current branch is \"topic\":\n\nFrom this point, the result of either of the following commands:\n\nNOTE: The latter form is just a short-hand of git checkout topic followed by git rebase master. When rebase exits topic will remain the checked-out branch.\n\nIf the upstream branch already contains a change you have made (e.g., because you mailed a patch which was applied upstream), then that commit will be skipped and warnings will be issued (if the merge backend is used). For example, running git rebase master on the following history (in which A' and A introduce the same set of changes, but have different committer information):\n\nHere is how you would transplant a topic branch based on one branch to another, to pretend that you forked the topic branch from the latter branch, using rebase --onto.\n\nFirst let’s assume your topic is based on branch next. For example, a feature developed in topic depends on some functionality which is found in next.\n\nWe want to make topic forked from branch master; for example, because the functionality on which topic depends was merged into the more stable master branch. We want our tree to look like this:\n\nWe can get this using the following command:\n\nAnother example of --onto option is to rebase part of a branch. If we have the following situation:\n\nThis is useful when topicB does not depend on topicA.\n\nA range of commits could also be removed with rebase. If we have the following situation:\n\nwould result in the removal of commits F and G:\n\nThis is useful if F and G were flawed in some way, or should not be part of topicA. Note that the argument to --onto and the <upstream> parameter can be any valid commit-ish.\n\nIn case of conflict, git rebase will stop at the first problematic commit and leave conflict markers in the tree. You can use git diff to locate the markers (<<<<<<) and make edits to resolve the conflict. For each file you edit, you need to tell Git that the conflict has been resolved, typically this would be done with\n\nAfter resolving the conflict manually and updating the index with the desired resolution, you can continue the rebasing process with\n\nAlternatively, you can undo the git rebase with\n\nNote | ORIG_HEAD is not guaranteed to still point to the previous branch tip at the end of the rebase if other commands that write that pseudo-ref (e.g. git reset) are used during the rebase. The previous branch tip, however, is accessible using the reflog of the current branch (i.e. @{1}, see gitrevisions[7]).\n\n[Note] Note ORIG_HEAD is not guaranteed to still point to the previous branch tip at the end of the rebase if other commands that write that pseudo-ref (e.g. git reset) are used during the rebase. The previous branch tip, however, is accessible using the reflog of the current branch (i.e. @{1}, see gitrevisions[7]).",
        "code_examples": [
          "```bash\nA---B---C topic\n         /\n    D---E---F---G master\n```",
          "```bash\nA'--B'--C' topic\n                 /\n    D---E---F---G master\n```",
          "```bash\nA---B---C topic\n         /\n    D---E---A'---F master\n```",
          "```bash\nB'---C' topic\n                  /\n    D---E---A'---F master\n```",
          "```bash\no---o---o---o---o  master\n         \\\n          o---o---o---o---o  next\n                           \\\n                            o---o---o  topic\n```",
          "```bash\no---o---o---o---o  master\n        |            \\\n        |             o'--o'--o'  topic\n         \\\n          o---o---o---o---o  next\n```",
          "```bash\nH---I---J topicB\n                           /\n                  E---F---G  topicA\n                 /\n    A---B---C---D  master\n```",
          "```bash\nH'--I'--J'  topicB\n                /\n                | E---F---G  topicA\n                |/\n    A---B---C---D  master\n```",
          "```bash\nE---F---G---H---I---J  topicA\n```",
          "```bash\nE---H'---I'---J'  topicA\n```"
        ],
        "usage_examples": [
          "```bash\ngit rebase master\ngit rebase master topic\n```",
          "```bash\ngit rebase --onto master next topic\n```",
          "```bash\ngit rebase --onto master topicA topicB\n```",
          "```bash\ngit rebase --onto topicA~5 topicA~3 topicA\n```",
          "```bash\ngit add <filename>\n```",
          "```bash\ngit rebase --continue\n```",
          "```bash\ngit rebase --abort\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 22,
          "content_length": 4659
        }
      },
      {
        "header": "MODE OPTIONS",
        "content": "The options in this section cannot be used with any other option, including not with each other:\n\nRestart the rebasing process after having resolved a merge conflict.\n\nRestart the rebasing process by skipping the current patch.\n\nAbort the rebase operation and reset HEAD to the original branch. If <branch> was provided when the rebase operation was started, then HEAD will be reset to <branch>. Otherwise HEAD will be reset to where it was when the rebase operation was started.\n\nAbort the rebase operation but HEAD is not reset back to the original branch. The index and working tree are also left unchanged as a result. If a temporary stash entry was created using --autostash, it will be saved to the stash list.\n\nEdit the todo list during an interactive rebase.\n\nShow the current patch in an interactive rebase or when rebase is stopped because of conflicts. This is the equivalent of git show REBASE_HEAD.\n\n**--continue**: Restart the rebasing process after having resolved a merge conflict.\n**--skip**: Restart the rebasing process by skipping the current patch.\n**--abort**: Abort the rebase operation and reset HEAD to the original branch. If <branch> was provided when the rebase operation was started, then HEAD will be reset to <branch>. Otherwise HEAD will be reset to where it was when the rebase operation was started.\n**--quit**: Abort the rebase operation but HEAD is not reset back to the original branch. The index and working tree are also left unchanged as a result. If a temporary stash entry was created using --autostash, it will be saved to the stash list.\n**--edit-todo**: Edit the todo list during an interactive rebase.\n**--show-current-patch**: Show the current patch in an interactive rebase or when rebase is stopped because of conflicts. This is the equivalent of git show REBASE_HEAD.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1817
        }
      },
      {
        "header": "OPTIONS",
        "content": "Starting point at which to create the new commits. If the --onto option is not specified, the starting point is <upstream>. May be any valid commit, and not just an existing branch name.\n\nAs a special case, you may use \"A...B\" as a shortcut for the merge base of A and B if there is exactly one merge base. You can leave out at most one of A and B, in which case it defaults to HEAD.\n\nSet the starting point at which to create the new commits to the merge base of <upstream> and <branch>. Running git rebase --keep-base <upstream> <branch> is equivalent to running git rebase --reapply-cherry-picks --no-fork-point --onto <upstream>...<branch> <upstream> <branch>.\n\nThis option is useful in the case where one is developing a feature on top of an upstream branch. While the feature is being worked on, the upstream branch may advance and it may not be the best idea to keep rebasing on top of the upstream but to keep the base commit as-is. As the base commit is unchanged this option implies --reapply-cherry-picks to avoid losing commits.\n\nAlthough both this option and --fork-point find the merge base between <upstream> and <branch>, this option uses the merge base as the starting point on which new commits will be created, whereas --fork-point uses the merge base to determine the set of commits which will be rebased.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nUpstream branch to compare against. May be any valid commit, not just an existing branch name. Defaults to the configured upstream for the current branch.\n\nWorking branch; defaults to HEAD.\n\nUse applying strategies to rebase (calling git-am internally). This option may become a no-op in the future once the merge backend handles everything the apply one does.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nHow to handle commits that are not empty to start and are not clean cherry-picks of any upstream commit, but which become empty after rebasing (because they contain a subset of already upstream changes):\n\nThe commit will be dropped. This is the default behavior.\n\nThe commit will be kept. This option is implied when --exec is specified unless -i/--interactive is also specified.\n\nThe rebase will halt when the commit is applied, allowing you to choose whether to drop it, edit files more, or just commit the empty changes. This option is implied when -i/--interactive is specified. ask is a deprecated synonym of stop.\n\nNote that commits which start empty are kept (unless --no-keep-empty is specified), and commits which are clean cherry-picks (as determined by git log --cherry-mark ...) are detected and dropped as a preliminary step (unless --reapply-cherry-picks or --keep-base is passed).\n\nSee also INCOMPATIBLE OPTIONS below.\n\nDo not keep commits that start empty before the rebase (i.e. that do not change anything from its parent) in the result. The default is to keep commits which start empty, since creating such commits requires passing the --allow-empty override flag to git commit, signifying that a user is very intentionally creating such a commit and thus wants to keep it.\n\nUsage of this flag will probably be rare, since you can get rid of commits that start empty by just firing up an interactive rebase and removing the lines corresponding to the commits you don’t want. This flag exists as a convenient shortcut, such as for cases where external tools generate many empty commits and you want them all removed.\n\nFor commits which do not start empty but become empty after rebasing, see the --empty flag.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nReapply all clean cherry-picks of any upstream commit instead of preemptively dropping them. (If these commits then become empty after rebasing, because they contain a subset of already upstream changes, the behavior towards them is controlled by the --empty flag.)\n\nIn the absence of --keep-base (or if --no-reapply-cherry-picks is given), these commits will be automatically dropped. Because this necessitates reading all upstream commits, this can be expensive in repositories with a large number of upstream commits that need to be read. When using the merge backend, warnings will be issued for each dropped commit (unless --quiet is given). Advice will also be issued unless advice.skippedCherryPicks is set to false (see git-config[1]).\n\n--reapply-cherry-picks allows rebase to forgo reading all upstream commits, potentially improving performance.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nNo-op. Rebasing commits with an empty message used to fail and this option would override that behavior, allowing commits with empty messages to be rebased. Now commits with an empty message do not cause rebasing to halt.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nUsing merging strategies to rebase (default).\n\nNote that a rebase merge works by replaying each commit from the working branch on top of the <upstream> branch. Because of this, when a merge conflict happens, the side reported as ours is the so-far rebased series, starting with <upstream>, and theirs is the working branch. In other words, the sides are swapped.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nUse the given merge strategy, instead of the default ort. This implies --merge.\n\nBecause git rebase replays each commit from the working branch on top of the <upstream> branch using the given strategy, using the ours strategy simply empties all patches from the <branch>, which makes little sense.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nPass the <strategy-option> through to the merge strategy. This implies --merge and, if no strategy has been specified, -s ort. Note the reversal of ours and theirs as noted above for the -m option.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nAfter the rerere mechanism reuses a recorded resolution on the current conflict to update the files in the working tree, allow it to also update the index with the result of resolution. --no-rerere-autoupdate is a good way to double-check what rerere did and catch potential mismerges, before committing the result to the index with a separate git add.\n\nGPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign.\n\nBe quiet. Implies --no-stat.\n\nBe verbose. Implies --stat.\n\nShow a diffstat of what changed upstream since the last rebase. The diffstat is also controlled by the configuration option rebase.stat.\n\nDo not show a diffstat as part of the rebase process.\n\nThis option bypasses the pre-rebase hook. See also githooks[5].\n\nAllows the pre-rebase hook to run, which is the default. This option can be used to override --no-verify. See also githooks[5].\n\nEnsure at least <n> lines of surrounding context match before and after each change. When fewer lines of surrounding context exist they all must match. By default no context is ever ignored. Implies --apply.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nIndividually replay all rebased commits instead of fast-forwarding over the unchanged ones. This ensures that the entire history of the rebased branch is composed of new commits.\n\nYou may find this helpful after reverting a topic branch merge, as this option recreates the topic branch with fresh commits so it can be remerged successfully without needing to \"revert the reversion\" (see the revert-a-faulty-merge How-To for details).\n\nUse reflog to find a better common ancestor between <upstream> and <branch> when calculating which commits have been introduced by <branch>.\n\nWhen --fork-point is active, fork_point will be used instead of <upstream> to calculate the set of commits to rebase, where fork_point is the result of git merge-base --fork-point <upstream> <branch> command (see git-merge-base[1]). If fork_point ends up being empty, the <upstream> will be used as a fallback.\n\nIf <upstream> or --keep-base is given on the command line, then the default is --no-fork-point, otherwise the default is --fork-point. See also rebase.forkpoint in git-config[1].\n\nIf your branch was based on <upstream> but <upstream> was rewound and your branch contains commits which were dropped, this option can be used with --keep-base in order to drop those commits from your branch.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nIgnore whitespace differences when trying to reconcile differences. Currently, each backend implements an approximation of this behavior:\n\nWhen applying a patch, ignore changes in whitespace in context lines. Unfortunately, this means that if the \"old\" lines being replaced by the patch differ only in whitespace from the existing file, you will get a merge conflict instead of a successful patch application.\n\nTreat lines with only whitespace changes as unchanged when merging. Unfortunately, this means that any patch hunks that were intended to modify whitespace and nothing else will be dropped, even if the other side had no changes that conflicted.\n\nThis flag is passed to the git apply program (see git-apply[1]) that applies the patch. Implies --apply.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nInstead of using the current time as the committer date, use the author date of the commit being rebased as the committer date. This option implies --force-rebase.\n\nInstead of using the author date of the original commit, use the current time as the author date of the rebased commit. This option implies --force-rebase.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nAdd a Signed-off-by trailer to all the rebased commits. Note that if --interactive is given then only commits marked to be picked, edited or reworded will have the trailer added.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nMake a list of the commits which are about to be rebased. Let the user edit that list before rebasing. This mode can also be used to split commits (see SPLITTING COMMITS below).\n\nThe commit list format can be changed by setting the configuration option rebase.instructionFormat. A customized instruction format will automatically have the commit hash prepended to the format.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nBy default, a rebase will simply drop merge commits from the todo list, and put the rebased commits into a single, linear branch. With --rebase-merges, the rebase will instead try to preserve the branching structure within the commits that are to be rebased, by recreating the merge commits. Any resolved merge conflicts or manual amendments in these merge commits will have to be resolved/re-applied manually. --no-rebase-merges can be used to countermand both the rebase.rebaseMerges config option and a previous --rebase-merges.\n\nWhen rebasing merges, there are two modes: rebase-cousins and no-rebase-cousins. If the mode is not specified, it defaults to no-rebase-cousins. In no-rebase-cousins mode, commits which do not have <upstream> as direct ancestor will keep their original branch point, i.e. commits that would be excluded by git-log[1]'s --ancestry-path option will keep their original ancestry by default. In rebase-cousins mode, such commits are instead rebased onto <upstream> (or <onto>, if specified).\n\nIt is currently only possible to recreate the merge commits using the ort merge strategy; different merge strategies can be used only via explicit exec git merge -s <strategy> [...] commands.\n\nSee also REBASING MERGES and INCOMPATIBLE OPTIONS below.\n\nAppend \"exec <cmd>\" after each line creating a commit in the final history. <cmd> will be interpreted as one or more shell commands. Any command that fails will interrupt the rebase, with exit code 1.\n\nYou may execute several commands by either using one instance of --exec with several commands:\n\nor by giving more than one --exec:\n\nIf --autosquash is used, exec lines will not be appended for the intermediate commits, and will only appear at the end of each squash/fixup series.\n\nThis uses the --interactive machinery internally, but it can be run without an explicit --interactive.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nRebase all commits reachable from <branch>, instead of limiting them with an <upstream>. This allows you to rebase the root commit(s) on a branch.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nAutomatically squash commits with specially formatted messages into previous commits being rebased. If a commit message starts with \"squash! \", \"fixup! \" or \"amend! \", the remainder of the title is taken as a commit specifier, which matches a previous commit if it matches the title or the hash of that commit. If no commit matches fully, matches of the specifier with the start of commit titles are considered.\n\nIn the rebase todo list, the actions of squash, fixup and amend commits are changed from pick to squash, fixup or fixup -C, respectively, and they are moved right after the commit they modify. The --interactive option can be used to review and edit the todo list before proceeding.\n\nThe recommended way to create commits with squash markers is by using the --squash, --fixup, --fixup=amend: or --fixup=reword: options of git-commit[1], which take the target commit as an argument and automatically fill in the title of the new commit from that.\n\nSetting configuration variable rebase.autoSquash to true enables auto-squashing by default for interactive rebase. The --no-autosquash option can be used to override that setting.\n\nSee also INCOMPATIBLE OPTIONS below.\n\nAutomatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts.\n\nAutomatically reschedule exec commands that failed. This only makes sense in interactive mode (or when an --exec option was provided).\n\nThis option applies once a rebase is started. It is preserved for the whole rebase based on, in order, the command line option provided to the initial git rebase, the rebase.rescheduleFailedExec configuration (see git-config[1] or \"CONFIGURATION\" below), or it defaults to false.\n\nRecording this option for the whole rebase is a convenience feature. Otherwise an explicit --no-reschedule-failed-exec at the start would be overridden by the presence of a rebase.rescheduleFailedExec=true configuration when git rebase --continue is invoked. Currently, you cannot pass --[no-]reschedule-failed-exec to git rebase --continue.\n\nAutomatically force-update any branches that point to commits that are being rebased. Any branches that are checked out in a worktree are not updated in this way.\n\nIf the configuration variable rebase.updateRefs is set, then this option can be used to override and disable this setting.\n\nSee also INCOMPATIBLE OPTIONS below.\n\n**--onto <newbase>**: Starting point at which to create the new commits. If the --onto option is not specified, the starting point is <upstream>. May be any valid commit, and not just an existing branch name. As a special case, you may use \"A...B\" as a shortcut for the merge base of A and B if there is exactly one merge base. You can leave out at most one of A and B, in which case it defaults to HEAD.\n**--keep-base**: Set the starting point at which to create the new commits to the merge base of <upstream> and <branch>. Running git rebase --keep-base <upstream> <branch> is equivalent to running git rebase --reapply-cherry-picks --no-fork-point --onto <upstream>...<branch> <upstream> <branch>. This option is useful in the case where one is developing a feature on top of an upstream branch. While the feature is being worked on, the upstream branch may advance and it may not be the best idea to keep rebasing on top of the upstream but to keep the base commit as-is. As the base commit is unchanged this option implies --reapply-cherry-picks to avoid losing commits. Although both this option and --fork-point find the merge base between <upstream> and <branch>, this option uses the merge base as the starting point on which new commits will be created, whereas --fork-point uses the merge base to determine the set of commits which will be rebased. See also INCOMPATIBLE OPTIONS below.\n**<upstream>**: Upstream branch to compare against. May be any valid commit, not just an existing branch name. Defaults to the configured upstream for the current branch.\n**<branch>**: Working branch; defaults to HEAD.\n**--apply**: Use applying strategies to rebase (calling git-am internally). This option may become a no-op in the future once the merge backend handles everything the apply one does. See also INCOMPATIBLE OPTIONS below.\n**--empty=(drop|keep|stop)**: How to handle commits that are not empty to start and are not clean cherry-picks of any upstream commit, but which become empty after rebasing (because they contain a subset of already upstream changes): drop The commit will be dropped. This is the default behavior. keep The commit will be kept. This option is implied when --exec is specified unless -i/--interactive is also specified. stop ask The rebase will halt when the commit is applied, allowing you to choose whether to drop it, edit files more, or just commit the empty changes. This option is implied when -i/--interactive is specified. ask is a deprecated synonym of stop. Note that commits which start empty are kept (unless --no-keep-empty is specified), and commits which are clean cherry-picks (as determined by git log --cherry-mark ...) are detected and dropped as a preliminary step (unless --reapply-cherry-picks or --keep-base is passed). See also INCOMPATIBLE OPTIONS below.\n**drop**: The commit will be dropped. This is the default behavior.\n**keep**: The commit will be kept. This option is implied when --exec is specified unless -i/--interactive is also specified.\n**stop**: The rebase will halt when the commit is applied, allowing you to choose whether to drop it, edit files more, or just commit the empty changes. This option is implied when -i/--interactive is specified. ask is a deprecated synonym of stop.\n**ask**: Do not keep commits that start empty before the rebase (i.e. that do not change anything from its parent) in the result. The default is to keep commits which start empty, since creating such commits requires passing the --allow-empty override flag to git commit, signifying that a user is very intentionally creating such a commit and thus wants to keep it. Usage of this flag will probably be rare, since you can get rid of commits that start empty by just firing up an interactive rebase and removing the lines corresponding to the commits you don’t want. This flag exists as a convenient shortcut, such as for cases where external tools generate many empty commits and you want them all removed. For commits which do not start empty but become empty after rebasing, see the --empty flag. See also INCOMPATIBLE OPTIONS below.\n**--no-keep-empty**: Reapply all clean cherry-picks of any upstream commit instead of preemptively dropping them. (If these commits then become empty after rebasing, because they contain a subset of already upstream changes, the behavior towards them is controlled by the --empty flag.) In the absence of --keep-base (or if --no-reapply-cherry-picks is given), these commits will be automatically dropped. Because this necessitates reading all upstream commits, this can be expensive in repositories with a large number of upstream commits that need to be read. When using the merge backend, warnings will be issued for each dropped commit (unless --quiet is given). Advice will also be issued unless advice.skippedCherryPicks is set to false (see git-config[1]). --reapply-cherry-picks allows rebase to forgo reading all upstream commits, potentially improving performance. See also INCOMPATIBLE OPTIONS below.\n**--keep-empty**: No-op. Rebasing commits with an empty message used to fail and this option would override that behavior, allowing commits with empty messages to be rebased. Now commits with an empty message do not cause rebasing to halt. See also INCOMPATIBLE OPTIONS below.\n**--reapply-cherry-picks**: Using merging strategies to rebase (default). Note that a rebase merge works by replaying each commit from the working branch on top of the <upstream> branch. Because of this, when a merge conflict happens, the side reported as ours is the so-far rebased series, starting with <upstream>, and theirs is the working branch. In other words, the sides are swapped. See also INCOMPATIBLE OPTIONS below.\n**--no-reapply-cherry-picks**: Use the given merge strategy, instead of the default ort. This implies --merge. Because git rebase replays each commit from the working branch on top of the <upstream> branch using the given strategy, using the ours strategy simply empties all patches from the <branch>, which makes little sense. See also INCOMPATIBLE OPTIONS below.\n**--allow-empty-message**: Pass the <strategy-option> through to the merge strategy. This implies --merge and, if no strategy has been specified, -s ort. Note the reversal of ours and theirs as noted above for the -m option. See also INCOMPATIBLE OPTIONS below.\n**-m**: After the rerere mechanism reuses a recorded resolution on the current conflict to update the files in the working tree, allow it to also update the index with the result of resolution. --no-rerere-autoupdate is a good way to double-check what rerere did and catch potential mismerges, before committing the result to the index with a separate git add.\n**--merge**: GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign.\n**-s <strategy>**: Be quiet. Implies --no-stat.\n**--strategy=<strategy>**: Be verbose. Implies --stat.\n**-X <strategy-option>**: Show a diffstat of what changed upstream since the last rebase. The diffstat is also controlled by the configuration option rebase.stat.\n**--strategy-option=<strategy-option>**: Do not show a diffstat as part of the rebase process.\n**--rerere-autoupdate**: This option bypasses the pre-rebase hook. See also githooks[5].\n**--no-rerere-autoupdate**: Allows the pre-rebase hook to run, which is the default. This option can be used to override --no-verify. See also githooks[5].\n**-S[<keyid>]**: Ensure at least <n> lines of surrounding context match before and after each change. When fewer lines of surrounding context exist they all must match. By default no context is ever ignored. Implies --apply. See also INCOMPATIBLE OPTIONS below.\n**--gpg-sign[=<keyid>]**: Individually replay all rebased commits instead of fast-forwarding over the unchanged ones. This ensures that the entire history of the rebased branch is composed of new commits. You may find this helpful after reverting a topic branch merge, as this option recreates the topic branch with fresh commits so it can be remerged successfully without needing to \"revert the reversion\" (see the revert-a-faulty-merge How-To for details).\n**--no-gpg-sign**: Use reflog to find a better common ancestor between <upstream> and <branch> when calculating which commits have been introduced by <branch>. When --fork-point is active, fork_point will be used instead of <upstream> to calculate the set of commits to rebase, where fork_point is the result of git merge-base --fork-point <upstream> <branch> command (see git-merge-base[1]). If fork_point ends up being empty, the <upstream> will be used as a fallback. If <upstream> or --keep-base is given on the command line, then the default is --no-fork-point, otherwise the default is --fork-point. See also rebase.forkpoint in git-config[1]. If your branch was based on <upstream> but <upstream> was rewound and your branch contains commits which were dropped, this option can be used with --keep-base in order to drop those commits from your branch. See also INCOMPATIBLE OPTIONS below.\n**-q**: Ignore whitespace differences when trying to reconcile differences. Currently, each backend implements an approximation of this behavior: apply backend When applying a patch, ignore changes in whitespace in context lines. Unfortunately, this means that if the \"old\" lines being replaced by the patch differ only in whitespace from the existing file, you will get a merge conflict instead of a successful patch application. merge backend Treat lines with only whitespace changes as unchanged when merging. Unfortunately, this means that any patch hunks that were intended to modify whitespace and nothing else will be dropped, even if the other side had no changes that conflicted.\n**--quiet**: When applying a patch, ignore changes in whitespace in context lines. Unfortunately, this means that if the \"old\" lines being replaced by the patch differ only in whitespace from the existing file, you will get a merge conflict instead of a successful patch application.\n**-v**: Treat lines with only whitespace changes as unchanged when merging. Unfortunately, this means that any patch hunks that were intended to modify whitespace and nothing else will be dropped, even if the other side had no changes that conflicted.\n**--verbose**: This flag is passed to the git apply program (see git-apply[1]) that applies the patch. Implies --apply. See also INCOMPATIBLE OPTIONS below.\n**--stat**: Instead of using the current time as the committer date, use the author date of the commit being rebased as the committer date. This option implies --force-rebase.\n**-n**: Instead of using the author date of the original commit, use the current time as the author date of the rebased commit. This option implies --force-rebase. See also INCOMPATIBLE OPTIONS below.\n**--no-stat**: Add a Signed-off-by trailer to all the rebased commits. Note that if --interactive is given then only commits marked to be picked, edited or reworded will have the trailer added. See also INCOMPATIBLE OPTIONS below.\n**--no-verify**: Make a list of the commits which are about to be rebased. Let the user edit that list before rebasing. This mode can also be used to split commits (see SPLITTING COMMITS below). The commit list format can be changed by setting the configuration option rebase.instructionFormat. A customized instruction format will automatically have the commit hash prepended to the format. See also INCOMPATIBLE OPTIONS below.\n**--verify**: By default, a rebase will simply drop merge commits from the todo list, and put the rebased commits into a single, linear branch. With --rebase-merges, the rebase will instead try to preserve the branching structure within the commits that are to be rebased, by recreating the merge commits. Any resolved merge conflicts or manual amendments in these merge commits will have to be resolved/re-applied manually. --no-rebase-merges can be used to countermand both the rebase.rebaseMerges config option and a previous --rebase-merges. When rebasing merges, there are two modes: rebase-cousins and no-rebase-cousins. If the mode is not specified, it defaults to no-rebase-cousins. In no-rebase-cousins mode, commits which do not have <upstream> as direct ancestor will keep their original branch point, i.e. commits that would be excluded by git-log[1]'s --ancestry-path option will keep their original ancestry by default. In rebase-cousins mode, such commits are instead rebased onto <upstream> (or <onto>, if specified). It is currently only possible to recreate the merge commits using the ort merge strategy; different merge strategies can be used only via explicit exec git merge -s <strategy> [...] commands. See also REBASING MERGES and INCOMPATIBLE OPTIONS below.\n**-C<n>**: Append \"exec <cmd>\" after each line creating a commit in the final history. <cmd> will be interpreted as one or more shell commands. Any command that fails will interrupt the rebase, with exit code 1. You may execute several commands by either using one instance of --exec with several commands: git rebase -i --exec \"cmd1 && cmd2 && ...\" or by giving more than one --exec: git rebase -i --exec \"cmd1\" --exec \"cmd2\" --exec ... If --autosquash is used, exec lines will not be appended for the intermediate commits, and will only appear at the end of each squash/fixup series. This uses the --interactive machinery internally, but it can be run without an explicit --interactive. See also INCOMPATIBLE OPTIONS below.\n**--no-ff**: Rebase all commits reachable from <branch>, instead of limiting them with an <upstream>. This allows you to rebase the root commit(s) on a branch. See also INCOMPATIBLE OPTIONS below.\n**--force-rebase**: Automatically squash commits with specially formatted messages into previous commits being rebased. If a commit message starts with \"squash! \", \"fixup! \" or \"amend! \", the remainder of the title is taken as a commit specifier, which matches a previous commit if it matches the title or the hash of that commit. If no commit matches fully, matches of the specifier with the start of commit titles are considered. In the rebase todo list, the actions of squash, fixup and amend commits are changed from pick to squash, fixup or fixup -C, respectively, and they are moved right after the commit they modify. The --interactive option can be used to review and edit the todo list before proceeding. The recommended way to create commits with squash markers is by using the --squash, --fixup, --fixup=amend: or --fixup=reword: options of git-commit[1], which take the target commit as an argument and automatically fill in the title of the new commit from that. Setting configuration variable rebase.autoSquash to true enables auto-squashing by default for interactive rebase. The --no-autosquash option can be used to override that setting. See also INCOMPATIBLE OPTIONS below.\n**-f**: Automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts.\n**--fork-point**: Automatically reschedule exec commands that failed. This only makes sense in interactive mode (or when an --exec option was provided). This option applies once a rebase is started. It is preserved for the whole rebase based on, in order, the command line option provided to the initial git rebase, the rebase.rescheduleFailedExec configuration (see git-config[1] or \"CONFIGURATION\" below), or it defaults to false. Recording this option for the whole rebase is a convenience feature. Otherwise an explicit --no-reschedule-failed-exec at the start would be overridden by the presence of a rebase.rescheduleFailedExec=true configuration when git rebase --continue is invoked. Currently, you cannot pass --[no-]reschedule-failed-exec to git rebase --continue.\n**--no-fork-point**: Automatically force-update any branches that point to commits that are being rebased. Any branches that are checked out in a worktree are not updated in this way. If the configuration variable rebase.updateRefs is set, then this option can be used to override and disable this setting. See also INCOMPATIBLE OPTIONS below.\n**drop**: The commit will be dropped. This is the default behavior.\n**keep**: The commit will be kept. This option is implied when --exec is specified unless -i/--interactive is also specified.\n**stop**: The rebase will halt when the commit is applied, allowing you to choose whether to drop it, edit files more, or just commit the empty changes. This option is implied when -i/--interactive is specified. ask is a deprecated synonym of stop.\n**apply backend**: When applying a patch, ignore changes in whitespace in context lines. Unfortunately, this means that if the \"old\" lines being replaced by the patch differ only in whitespace from the existing file, you will get a merge conflict instead of a successful patch application.\n**merge backend**: Treat lines with only whitespace changes as unchanged when merging. Unfortunately, this means that any patch hunks that were intended to modify whitespace and nothing else will be dropped, even if the other side had no changes that conflicted.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit rebase -i --exec \"cmd1 && cmd2 && ...\"\n```",
          "```bash\ngit rebase -i --exec \"cmd1\" --exec \"cmd2\" --exec ...\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 88,
          "content_length": 32134
        }
      },
      {
        "header": "INCOMPATIBLE OPTIONS",
        "content": "The following options:\n\nare incompatible with the following options:\n\n--[no-]reapply-cherry-picks when used without --keep-base\n\n--root when used without --onto\n\nIn addition, the following pairs of options are incompatible:\n\n--keep-base and --onto\n\n--keep-base and --root\n\n--fork-point and --root\n\n• --whitespace\n\n• --strategy-option\n• --autosquash\n• --rebase-merges\n• --interactive\n• --no-keep-empty\n• --[no-]reapply-cherry-picks when used without --keep-base\n• --update-refs\n• --root when used without --onto\n\n• --keep-base and --onto\n• --keep-base and --root\n• --fork-point and --root",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 587
        }
      },
      {
        "header": "BEHAVIORAL DIFFERENCES",
        "content": "git rebase has two primary backends: apply and merge. (The apply backend used to be known as the am backend, but the name led to confusion as it looks like a verb instead of a noun. Also, the merge backend used to be known as the interactive backend, but it is now used for non-interactive cases as well. Both were renamed based on lower-level functionality that underpinned each.) There are some subtle differences in how these two backends behave:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 449
        }
      },
      {
        "header": "Empty commits",
        "content": "The apply backend unfortunately drops intentionally empty commits, i.e. commits that started empty, though these are rare in practice. It also drops commits that become empty and has no option for controlling this behavior.\n\nThe merge backend keeps intentionally empty commits by default (though with -i they are marked as empty in the todo list editor, or they can be dropped automatically with --no-keep-empty).\n\nSimilar to the apply backend, by default the merge backend drops commits that become empty unless -i/--interactive is specified (in which case it stops and asks the user what to do). The merge backend also has an --empty=(drop|keep|stop) option for changing the behavior of handling commits that become empty.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 724
        }
      },
      {
        "header": "Directory rename detection",
        "content": "Due to the lack of accurate tree information (arising from constructing fake ancestors with the limited information available in patches), directory rename detection is disabled in the apply backend. Disabled directory rename detection means that if one side of history renames a directory and the other adds new files to the old directory, then the new files will be left behind in the old directory without any warning at the time of rebasing that you may want to move these files into the new directory.\n\nDirectory rename detection works with the merge backend to provide you warnings in such cases.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 602
        }
      },
      {
        "header": "Context",
        "content": "The apply backend works by creating a sequence of patches (by calling format-patch internally), and then applying the patches in sequence (calling am internally). Patches are composed of multiple hunks, each with line numbers, a context region, and the actual changes. The line numbers have to be taken with some offset, since the other side will likely have inserted or deleted lines earlier in the file. The context region is meant to help find how to adjust the line numbers in order to apply the changes to the right lines. However, if multiple areas of the code have the same surrounding lines of context, the wrong one can be picked. There are real-world cases where this has caused commits to be reapplied incorrectly with no conflicts reported. Setting diff.context to a larger value may prevent such types of problems, but increases the chance of spurious conflicts (since it will require more lines of matching context to apply).\n\nThe merge backend works with a full copy of each relevant file, insulating it from these types of problems.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 1048
        }
      },
      {
        "header": "Labelling of conflicts markers",
        "content": "When there are content conflicts, the merge machinery tries to annotate each side’s conflict markers with the commits where the content came from. Since the apply backend drops the original information about the rebased commits and their parents (and instead generates new fake commits based off limited information in the generated patches), those commits cannot be identified; instead it has to fall back to a commit summary. Also, when merge.conflictStyle is set to diff3 or zdiff3, the apply backend will use \"constructed merge base\" to label the content from the merge base, and thus provide no information about the merge base commit whatsoever.\n\nThe merge backend works with the full commits on both sides of history and thus has no such limitations.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 757
        }
      },
      {
        "header": "Hooks",
        "content": "The apply backend has not traditionally called the post-commit hook, while the merge backend has. Both have called the post-checkout hook, though the merge backend has squelched its output. Further, both backends only call the post-checkout hook with the starting point commit of the rebase, not the intermediate commits nor the final commit. In each case, the calling of these hooks was by accident of implementation rather than by design (both backends were originally implemented as shell scripts and happened to invoke other commands like git checkout or git commit that would call the hooks). Both backends should have the same behavior, though it is not entirely clear which, if any, is correct. We will likely make rebase stop calling either of these hooks in the future.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 778
        }
      },
      {
        "header": "Interruptability",
        "content": "The apply backend has safety problems with an ill-timed interrupt; if the user presses Ctrl-C at the wrong time to try to abort the rebase, the rebase can enter a state where it cannot be aborted with a subsequent git rebase --abort. The merge backend does not appear to suffer from the same shortcoming. (See https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/ for details.)",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 385
        }
      },
      {
        "header": "Commit Rewording",
        "content": "When a conflict occurs while rebasing, rebase stops and asks the user to resolve. Since the user may need to make notable changes while resolving conflicts, after conflicts are resolved and the user has run git rebase --continue, the rebase should open an editor and ask the user to update the commit message. The merge backend does this, while the apply backend blindly applies the original commit message.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 407
        }
      },
      {
        "header": "Miscellaneous differences",
        "content": "There are a few more behavioral differences that most folks would probably consider inconsequential but which are mentioned for completeness:\n\nReflog: The two backends will use different wording when describing the changes made in the reflog, though both will make use of the word \"rebase\".\n\nProgress, informational, and error messages: The two backends provide slightly different progress and informational messages. Also, the apply backend writes error messages (such as \"Your files would be overwritten…\") to stdout, while the merge backend writes them to stderr.\n\nState directories: The two backends keep their state in different directories under .git/\n\n• Reflog: The two backends will use different wording when describing the changes made in the reflog, though both will make use of the word \"rebase\".\n• Progress, informational, and error messages: The two backends provide slightly different progress and informational messages. Also, the apply backend writes error messages (such as \"Your files would be overwritten…\") to stdout, while the merge backend writes them to stderr.\n• State directories: The two backends keep their state in different directories under .git/",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1177
        }
      },
      {
        "header": "MERGE STRATEGIES",
        "content": "The merge mechanism (git merge and git pull commands) allows the backend merge strategies to be chosen with -s option. Some strategies can also take their own options, which can be passed by giving -X<option> arguments to git merge and/or git pull.\n\nThis is the default merge strategy when pulling or merging one branch. This strategy can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this strategy can detect and handle merges involving renames. It does not make use of detected copies. The name for this algorithm is an acronym (\"Ostensibly Recursive’s Twin\") and came from the fact that it was written as a replacement for the previous default algorithm, recursive.\n\nIn the case where the path is a submodule, if the submodule commit used on one side of the merge is a descendant of the submodule commit used on the other side of the merge, Git attempts to fast-forward to the descendant. Otherwise, Git will treat this case as a conflict, suggesting as a resolution a submodule commit that is descendant of the conflicting ones, if one exists.\n\nThe ort strategy can take the following options:\n\nThis option forces conflicting hunks to be auto-resolved cleanly by favoring our version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side.\n\nThis should not be confused with the ours merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring our history contains all that happened in it.\n\nThis is the opposite of ours; note that, unlike ours, there is no theirs merge strategy to confuse this merge option with.\n\nTreats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also git-diff[1] -b, -w, --ignore-space-at-eol, and --ignore-cr-at-eol.\n\nIf their version only introduces whitespace changes to a line, our version is used;\n\nIf our version introduces whitespace changes but their version includes a substantial change, their version is used;\n\nOtherwise, the merge proceeds in the usual way.\n\nThis runs a virtual check-out and check-in of all three stages of any file which needs a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See \"Merging branches with differing checkin/checkout attributes\" in gitattributes[5] for details.\n\nDisables the renormalize option. This overrides the merge.renormalize configuration variable.\n\nTurn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the merge.renames configuration variable. See also git-diff[1] --find-renames.\n\nDeprecated synonym for find-renames=<n>.\n\nTurn off rename detection. This overrides the merge.renames configuration variable. See also git-diff[1] --no-renames.\n\nDeprecated synonym for diff-algorithm=histogram.\n\nDeprecated synonym for diff-algorithm=patience.\n\nUse a different diff algorithm while merging, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also git-diff[1] --diff-algorithm. Note that ort defaults to diff-algorithm=histogram, while regular diffs currently default to the diff.algorithm config setting.\n\nThis option is a more advanced form of subtree strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.\n\nThis is now a synonym for ort. It was an alternative implementation until v2.49.0, but was redirected to mean ort in v2.50.0. The previous recursive strategy was the default strategy for resolving two heads from Git v0.99.9k until v2.33.0.\n\nThis can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm. It tries to carefully detect criss-cross merge ambiguities. It does not handle renames.\n\nThis resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branch.\n\nThis resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the ort merge strategy.\n\nThis is a modified ort strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree.\n\nWith the strategies that use 3-way merge (including the default, ort), if a change is made on both branches, but later reverted on one of the branches, that change will be present in the merged result; some people find this behavior confusing. It occurs because only the heads and the merge base are considered when performing a merge, not the individual commits. The merge algorithm therefore considers the reverted change as no change at all, and substitutes the changed version instead.\n\n• If their version only introduces whitespace changes to a line, our version is used;\n• If our version introduces whitespace changes but their version includes a substantial change, their version is used;\n• Otherwise, the merge proceeds in the usual way.\n\n**ort**: This is the default merge strategy when pulling or merging one branch. This strategy can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this strategy can detect and handle merges involving renames. It does not make use of detected copies. The name for this algorithm is an acronym (\"Ostensibly Recursive’s Twin\") and came from the fact that it was written as a replacement for the previous default algorithm, recursive. In the case where the path is a submodule, if the submodule commit used on one side of the merge is a descendant of the submodule commit used on the other side of the merge, Git attempts to fast-forward to the descendant. Otherwise, Git will treat this case as a conflict, suggesting as a resolution a submodule commit that is descendant of the conflicting ones, if one exists. The ort strategy can take the following options: ours This option forces conflicting hunks to be auto-resolved cleanly by favoring our version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side. This should not be confused with the ours merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring our history contains all that happened in it. theirs This is the opposite of ours; note that, unlike ours, there is no theirs merge strategy to confuse this merge option with. ignore-space-change ignore-all-space ignore-space-at-eol ignore-cr-at-eol Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also git-diff[1] -b, -w, --ignore-space-at-eol, and --ignore-cr-at-eol. If their version only introduces whitespace changes to a line, our version is used; If our version introduces whitespace changes but their version includes a substantial change, their version is used; Otherwise, the merge proceeds in the usual way. renormalize This runs a virtual check-out and check-in of all three stages of any file which needs a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See \"Merging branches with differing checkin/checkout attributes\" in gitattributes[5] for details. no-renormalize Disables the renormalize option. This overrides the merge.renormalize configuration variable. find-renames[=<n>] Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the merge.renames configuration variable. See also git-diff[1] --find-renames. rename-threshold=<n> Deprecated synonym for find-renames=<n>. no-renames Turn off rename detection. This overrides the merge.renames configuration variable. See also git-diff[1] --no-renames. histogram Deprecated synonym for diff-algorithm=histogram. patience Deprecated synonym for diff-algorithm=patience. diff-algorithm=(histogram|minimal|myers|patience) Use a different diff algorithm while merging, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also git-diff[1] --diff-algorithm. Note that ort defaults to diff-algorithm=histogram, while regular diffs currently default to the diff.algorithm config setting. subtree[=<path>] This option is a more advanced form of subtree strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.\n**ours**: This option forces conflicting hunks to be auto-resolved cleanly by favoring our version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side. This should not be confused with the ours merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring our history contains all that happened in it.\n**theirs**: This is the opposite of ours; note that, unlike ours, there is no theirs merge strategy to confuse this merge option with.\n**ignore-space-change**: Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also git-diff[1] -b, -w, --ignore-space-at-eol, and --ignore-cr-at-eol. If their version only introduces whitespace changes to a line, our version is used; If our version introduces whitespace changes but their version includes a substantial change, their version is used; Otherwise, the merge proceeds in the usual way.\n**ignore-all-space**: This runs a virtual check-out and check-in of all three stages of any file which needs a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See \"Merging branches with differing checkin/checkout attributes\" in gitattributes[5] for details.\n**ignore-space-at-eol**: Disables the renormalize option. This overrides the merge.renormalize configuration variable.\n**ignore-cr-at-eol**: Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the merge.renames configuration variable. See also git-diff[1] --find-renames.\n**renormalize**: Deprecated synonym for find-renames=<n>.\n**no-renormalize**: Turn off rename detection. This overrides the merge.renames configuration variable. See also git-diff[1] --no-renames.\n**find-renames[=<n>]**: Deprecated synonym for diff-algorithm=histogram.\n**rename-threshold=<n>**: Deprecated synonym for diff-algorithm=patience.\n**no-renames**: Use a different diff algorithm while merging, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also git-diff[1] --diff-algorithm. Note that ort defaults to diff-algorithm=histogram, while regular diffs currently default to the diff.algorithm config setting.\n**histogram**: This option is a more advanced form of subtree strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.\n**patience**: This is now a synonym for ort. It was an alternative implementation until v2.49.0, but was redirected to mean ort in v2.50.0. The previous recursive strategy was the default strategy for resolving two heads from Git v0.99.9k until v2.33.0.\n**diff-algorithm=(histogram|minimal|myers|patience)**: This can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm. It tries to carefully detect criss-cross merge ambiguities. It does not handle renames.\n**subtree[=<path>]**: This resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branch.\n**recursive**: This resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the ort merge strategy.\n**resolve**: This is a modified ort strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree.\n**ours**: This option forces conflicting hunks to be auto-resolved cleanly by favoring our version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side. This should not be confused with the ours merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring our history contains all that happened in it.\n**theirs**: This is the opposite of ours; note that, unlike ours, there is no theirs merge strategy to confuse this merge option with.\n**ignore-space-change**: Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also git-diff[1] -b, -w, --ignore-space-at-eol, and --ignore-cr-at-eol. If their version only introduces whitespace changes to a line, our version is used; If our version introduces whitespace changes but their version includes a substantial change, their version is used; Otherwise, the merge proceeds in the usual way.\n**ignore-all-space**: This runs a virtual check-out and check-in of all three stages of any file which needs a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See \"Merging branches with differing checkin/checkout attributes\" in gitattributes[5] for details.\n**ignore-space-at-eol**: Disables the renormalize option. This overrides the merge.renormalize configuration variable.\n**ignore-cr-at-eol**: Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the merge.renames configuration variable. See also git-diff[1] --find-renames.\n**renormalize**: Deprecated synonym for find-renames=<n>.\n**no-renormalize**: Turn off rename detection. This overrides the merge.renames configuration variable. See also git-diff[1] --no-renames.\n**find-renames[=<n>]**: Deprecated synonym for diff-algorithm=histogram.\n**rename-threshold=<n>**: Deprecated synonym for diff-algorithm=patience.\n**no-renames**: Use a different diff algorithm while merging, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also git-diff[1] --diff-algorithm. Note that ort defaults to diff-algorithm=histogram, while regular diffs currently default to the diff.algorithm config setting.\n**histogram**: This option is a more advanced form of subtree strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 26,
          "content_length": 17184
        }
      },
      {
        "header": "NOTES",
        "content": "You should understand the implications of using git rebase on a repository that you share. See also RECOVERING FROM UPSTREAM REBASE below.\n\nWhen the rebase is run, it will first execute a pre-rebase hook if one exists. You can use this hook to do sanity checks and reject the rebase if it isn’t appropriate. Please see the template pre-rebase hook script for an example.\n\nUpon completion, <branch> will be the current branch.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 425
        }
      },
      {
        "header": "INTERACTIVE MODE",
        "content": "Rebasing interactively means that you have a chance to edit the commits which are rebased. You can reorder the commits, and you can remove them (weeding out bad or otherwise unwanted patches).\n\nThe interactive mode is meant for this type of workflow:\n\nhave a wonderful idea\n\nprepare a series for submission\n\nwhere point 2. consists of several instances of\n\nfinish something worthy of a commit\n\nb) independent fixup\n\nrealize that something does not work\n\nSometimes the thing fixed in b.2. cannot be amended to the not-quite perfect commit it fixes, because that commit is buried deeply in a patch series. That is exactly what interactive rebase is for: use it after plenty of \"a\"s and \"b\"s, by rearranging and editing commits, and squashing multiple commits into one.\n\nStart it with the last commit you want to retain as-is:\n\nAn editor will be fired up with all the commits in your current branch (ignoring merge commits), which come after the given commit. You can reorder the commits in this list to your heart’s content, and you can remove them. The list looks more or less like this:\n\nThe oneline descriptions are purely for your pleasure; git rebase will not look at them but at the commit names (\"deadbee\" and \"fa1afe1\" in this example), so do not delete or edit the names.\n\nBy replacing the command \"pick\" with the command \"edit\", you can tell git rebase to stop after applying that commit, so that you can edit the files and/or the commit message, amend the commit, and continue rebasing.\n\nTo interrupt the rebase (just like an \"edit\" command would do, but without cherry-picking any commit first), use the \"break\" command.\n\nIf you just want to edit the commit message for a commit, replace the command \"pick\" with the command \"reword\".\n\nTo drop a commit, replace the command \"pick\" with \"drop\", or just delete the matching line.\n\nIf you want to fold two or more commits into one, replace the command \"pick\" for the second and subsequent commits with \"squash\" or \"fixup\". If the commits had different authors, the folded commit will be attributed to the author of the first commit. The suggested commit message for the folded commit is the concatenation of the first commit’s message with those identified by \"squash\" commands, omitting the messages of commits identified by \"fixup\" commands, unless \"fixup -c\" is used. In that case the suggested commit message is only the message of the \"fixup -c\" commit, and an editor is opened allowing you to edit the message. The contents (patch) of the \"fixup -c\" commit are still incorporated into the folded commit. If there is more than one \"fixup -c\" commit, the message from the final one is used. You can also use \"fixup -C\" to get the same behavior as \"fixup -c\" except without opening an editor.\n\ngit rebase will stop when \"pick\" has been replaced with \"edit\" or when a command fails due to merge errors. When you are done editing and/or resolving conflicts you can continue with git rebase --continue.\n\nFor example, if you want to reorder the last 5 commits, such that what was HEAD~4 becomes the new HEAD. To achieve that, you would call git rebase like this:\n\nAnd move the first patch to the end of the list.\n\nYou might want to recreate merge commits, e.g. if you have a history like this:\n\nSuppose you want to rebase the side branch starting at \"A\" to \"Q\". Make sure that the current HEAD is \"B\", and call\n\nReordering and editing commits usually creates untested intermediate steps. You may want to check that your history editing did not break anything by running a test, or at least recompiling at intermediate points in history by using the \"exec\" command (shortcut \"x\"). You may do so by creating a todo list like this one:\n\nThe interactive rebase will stop when a command fails (i.e. exits with non-0 status) to give you an opportunity to fix the problem. You can continue with git rebase --continue.\n\nThe \"exec\" command launches the command in a shell (the default one, usually /bin/sh), so you can use shell features (like \"cd\", \">\", \";\" …). The command is run from the root of the working tree.\n\nThis command lets you check that intermediate commits are compilable. The todo list becomes like that:\n\n• have a wonderful idea\n• hack on the code\n• prepare a series for submission\n\n• finish something worthy of a commit\n\n• realize that something does not work",
        "code_examples": [
          "```bash\npick deadbee The oneline of this commit\npick fa1afe1 The oneline of the next commit\n...\n```",
          "```bash\nX\n            \\\n         A---M---B\n        /\n---o---O---P---Q\n```",
          "```bash\npick deadbee Implement feature XXX\nfixup f1a5c00 Fix to feature XXX\nexec make\npick c0ffeee The oneline of the next commit\nedit deadbab The oneline of the commit after\nexec cd subdir; make test\n...\n```",
          "```bash\npick 5928aea one\nexec make test\npick 04d0fda two\nexec make test\npick ba46169 three\nexec make test\npick f4593f9 four\nexec make test\n```"
        ],
        "usage_examples": [
          "```bash\ngit rebase -i <after-this-commit>\n```",
          "```bash\n$ git rebase -i HEAD~5\n```",
          "```bash\n$ git rebase -i -r --onto Q O\n```",
          "```bash\n$ git rebase -i --exec \"make test\"\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 26,
          "content_length": 4323
        }
      },
      {
        "header": "SPLITTING COMMITS",
        "content": "In interactive mode, you can mark commits with the action \"edit\". However, this does not necessarily mean that git rebase expects the result of this edit to be exactly one commit. Indeed, you can undo the commit, or you can add other commits. This can be used to split a commit into two:\n\nStart an interactive rebase with git rebase -i <commit>^, where <commit> is the commit you want to split. In fact, any commit range will do, as long as it contains that commit.\n\nMark the commit you want to split with the action \"edit\".\n\nWhen it comes to editing that commit, execute git reset HEAD^. The effect is that the HEAD is rewound by one, and the index follows suit. However, the working tree stays the same.\n\nNow add the changes to the index that you want to have in the first commit. You can use git add (possibly interactively) or git gui (or both) to do that.\n\nCommit the now-current index with whatever commit message is appropriate now.\n\nRepeat the last two steps until your working tree is clean.\n\nContinue the rebase with git rebase --continue.\n\nIf you are not absolutely sure that the intermediate revisions are consistent (they compile, pass the testsuite, etc.) you should use git stash to stash away the not-yet-committed changes after each commit, test, and amend the commit if fixes are necessary.\n\n• Start an interactive rebase with git rebase -i <commit>^, where <commit> is the commit you want to split. In fact, any commit range will do, as long as it contains that commit.\n• Mark the commit you want to split with the action \"edit\".\n• When it comes to editing that commit, execute git reset HEAD^. The effect is that the HEAD is rewound by one, and the index follows suit. However, the working tree stays the same.\n• Now add the changes to the index that you want to have in the first commit. You can use git add (possibly interactively) or git gui (or both) to do that.\n• Commit the now-current index with whatever commit message is appropriate now.\n• Repeat the last two steps until your working tree is clean.\n• Continue the rebase with git rebase --continue.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 2078
        }
      },
      {
        "header": "RECOVERING FROM UPSTREAM REBASE",
        "content": "Rebasing (or any other form of rewriting) a branch that others have based work on is a bad idea: anyone downstream of it is forced to manually fix their history. This section explains how to do the fix from the downstream’s point of view. The real fix, however, would be to avoid rebasing the upstream in the first place.\n\nTo illustrate, suppose you are in a situation where someone develops a subsystem branch, and you are working on a topic that is dependent on this subsystem. You might end up with a history like the following:\n\nIf subsystem is rebased against master, the following happens:\n\nIf you now continue development as usual, and eventually merge topic to subsystem, the commits from subsystem will remain duplicated forever:\n\nSuch duplicates are generally frowned upon because they clutter up history, making it harder to follow. To clean things up, you need to transplant the commits on topic to the new subsystem tip, i.e., rebase topic. This becomes a ripple effect: anyone downstream from topic is forced to rebase too, and so on!\n\nThere are two kinds of fixes, discussed in the following subsections:\n\nThis happens if the subsystem rebase was a simple rebase and had no conflicts.\n\nThis happens if the subsystem rebase had conflicts, or used --interactive to omit, edit, squash, or fixup commits; or if the upstream used one of commit --amend, reset, or a full history rewriting command like filter-repo.\n\n**Easy case: The changes are literally the same.**: This happens if the subsystem rebase was a simple rebase and had no conflicts.\n**Hard case: The changes are not the same.**: This happens if the subsystem rebase had conflicts, or used --interactive to omit, edit, squash, or fixup commits; or if the upstream used one of commit --amend, reset, or a full history rewriting command like filter-repo.",
        "code_examples": [
          "```bash\no---o---o---o---o---o---o---o  master\n\t \\\n\t  o---o---o---o---o  subsystem\n\t\t\t   \\\n\t\t\t    *---*---*  topic\n```",
          "```bash\no---o---o---o---o---o---o---o  master\n\t \\\t\t\t \\\n\t  o---o---o---o---o\t  o'--o'--o'--o'--o'  subsystem\n\t\t\t   \\\n\t\t\t    *---*---*  topic\n```",
          "```bash\no---o---o---o---o---o---o---o  master\n\t \\\t\t\t \\\n\t  o---o---o---o---o\t  o'--o'--o'--o'--o'--M\t subsystem\n\t\t\t   \\\t\t\t     /\n\t\t\t    *---*---*-..........-*--*  topic\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1824
        }
      },
      {
        "header": "The easy case",
        "content": "Only works if the changes (patch IDs based on the diff contents) on subsystem are literally the same before and after the rebase subsystem did.\n\nIn that case, the fix is easy because git rebase knows to skip changes that are already present in the new upstream (unless --reapply-cherry-picks is given). So if you say (assuming you’re on topic)\n\nyou will end up with the fixed history",
        "code_examples": [
          "```bash\no---o---o---o---o---o---o---o  master\n\t\t\t\t \\\n\t\t\t\t  o'--o'--o'--o'--o'  subsystem\n\t\t\t\t\t\t   \\\n\t\t\t\t\t\t    *---*---*  topic\n```"
        ],
        "usage_examples": [
          "```bash\n$ git rebase subsystem\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 383
        }
      },
      {
        "header": "The hard case",
        "content": "Things get more complicated if the subsystem changes do not exactly correspond to the ones before the rebase.\n\nThe idea is to manually tell git rebase \"where the old subsystem ended and your topic began\", that is, what the old merge base between them was. You will have to find a way to name the last commit of the old subsystem, for example:\n\nWith the subsystem reflog: after git fetch, the old tip of subsystem is at subsystem@{1}. Subsequent fetches will increase the number. (See git-reflog[1].)\n\nRelative to the tip of topic: knowing that your topic has three commits, the old tip of subsystem must be topic~3.\n\nYou can then transplant the old subsystem..topic to the new tip by saying (for the reflog case, and assuming you are on topic already):\n\nThe ripple effect of a \"hard case\" recovery is especially bad: everyone downstream from topic will now have to perform a \"hard case\" recovery too!\n\n• With the subsystem reflog: after git fetch, the old tip of subsystem is at subsystem@{1}. Subsequent fetches will increase the number. (See git-reflog[1].)\n• Relative to the tip of topic: knowing that your topic has three commits, the old tip of subsystem must be topic~3.\n\nNote | While an \"easy case recovery\" sometimes appears to be successful even in the hard case, it may have unintended consequences. For example, a commit that was removed via git rebase --interactive will be resurrected!\n\n[Note] Note While an \"easy case recovery\" sometimes appears to be successful even in the hard case, it may have unintended consequences. For example, a commit that was removed via git rebase --interactive will be resurrected!",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git rebase --onto subsystem subsystem@{1}\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 6,
          "content_length": 1625
        }
      },
      {
        "header": "REBASING MERGES",
        "content": "The interactive rebase command was originally designed to handle individual patch series. As such, it makes sense to exclude merge commits from the todo list, as the developer may have merged the then-current master while working on the branch, only to rebase all the commits onto master eventually (skipping the merge commits).\n\nHowever, there are legitimate reasons why a developer may want to recreate merge commits: to keep the branch structure (or \"commit topology\") when working on multiple, inter-related branches.\n\nIn the following example, the developer works on a topic branch that refactors the way buttons are defined, and on another topic branch that uses that refactoring to implement a \"Report a bug\" button. The output of git log --graph --format=%s -5 may look like this:\n\nThe developer might want to rebase those commits to a newer master while keeping the branch topology, for example when the first topic branch is expected to be integrated into master much earlier than the second one, say, to resolve merge conflicts with changes to the DownloadButton class that made it into master.\n\nThis rebase can be performed using the --rebase-merges option. It will generate a todo list looking like this:\n\nIn contrast to a regular interactive rebase, there are label, reset and merge commands in addition to pick ones.\n\nThe label command associates a label with the current HEAD when that command is executed. These labels are created as worktree-local refs (refs/rewritten/<label>) that will be deleted when the rebase finishes. That way, rebase operations in multiple worktrees linked to the same repository do not interfere with one another. If the label command fails, it is rescheduled immediately, with a helpful message how to proceed.\n\nThe reset command resets the HEAD, index and worktree to the specified revision. It is similar to an exec git reset --hard <label>, but refuses to overwrite untracked files. If the reset command fails, it is rescheduled immediately, with a helpful message how to edit the todo list (this typically happens when a reset command was inserted into the todo list manually and contains a typo).\n\nThe merge command will merge the specified revision(s) into whatever is HEAD at that time. With -C <original-commit>, the commit message of the specified merge commit will be used. When the -C is changed to a lower-case -c, the message will be opened in an editor after a successful merge so that the user can edit the message.\n\nIf a merge command fails for any reason other than merge conflicts (i.e. when the merge operation did not even start), it is rescheduled immediately.\n\nBy default, the merge command will use the ort merge strategy for regular merges, and octopus for octopus merges. One can specify a default strategy for all merges using the --strategy argument when invoking rebase, or can override specific merges in the interactive list of commands by using an exec command to call git merge explicitly with a --strategy argument. Note that when calling git merge explicitly like this, you can make use of the fact that the labels are worktree-local refs (the ref refs/rewritten/onto would correspond to the label onto, for example) in order to refer to the branches you want to merge.\n\nNote: the first command (label onto) labels the revision onto which the commits are rebased; The name onto is just a convention, as a nod to the --onto option.\n\nIt is also possible to introduce completely new merge commits from scratch by adding a command of the form merge <merge-head>. This form will generate a tentative commit message and always open an editor to let the user edit it. This can be useful e.g. when a topic branch turns out to address more than a single concern and wants to be split into two or even more topic branches. Consider this todo list:\n\nThe one commit in this list that is not related to CMake may very well have been motivated by working on fixing all those bugs introduced by switching to CMake, but it addresses a different concern. To split this branch into two topic branches, the todo list could be edited like this:",
        "code_examples": [
          "```bash\n*   Merge branch 'report-a-bug'\n|\\\n| * Add the feedback button\n* | Merge branch 'refactor-button'\n|\\ \\\n| |/\n| * Use the Button class for all buttons\n| * Extract a generic Button class from the DownloadButton one\n```",
          "```bash\nlabel onto\n\n# Branch: refactor-button\nreset onto\npick 123456 Extract a generic Button class from the DownloadButton one\npick 654321 Use the Button class for all buttons\nlabel refactor-button\n\n# Branch: report-a-bug\nreset refactor-button # Use the Button class for all buttons\npick abcdef Add the feedback button\nlabel report-a-bug\n\nreset onto\nmerge -C a1b2c3 refactor-button # Merge 'refactor-button'\nmerge -C 6f5e4d report-a-bug # Merge 'report-a-bug'\n```",
          "```bash\npick 192837 Switch from GNU Makefiles to CMake\npick 5a6c7e Document the switch to CMake\npick 918273 Fix detection of OpenSSL in CMake\npick afbecd http: add support for TLS v1.3\npick fdbaec Fix detection of cURL in CMake on Windows\n```",
          "```bash\nlabel onto\n\npick afbecd http: add support for TLS v1.3\nlabel tlsv1.3\n\nreset onto\npick 192837 Switch from GNU Makefiles to CMake\npick 918273 Fix detection of OpenSSL in CMake\npick fdbaec Fix detection of cURL in CMake on Windows\npick 5a6c7e Document the switch to CMake\nlabel cmake\n\nreset onto\nmerge tlsv1.3\nmerge cmake\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 14,
          "content_length": 4103
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Everything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there:\n\nDefault backend to use for rebasing. Possible choices are apply or merge. In the future, if the merge backend gains all remaining capabilities of the apply backend, this setting may become unused.\n\nWhether to show a diffstat of what changed upstream since the last rebase. False by default.\n\nIf set to true, enable the --autosquash option of git-rebase[1] by default for interactive mode. This can be overridden with the --no-autosquash option.\n\nWhen set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts. This option can be overridden by the --no-autostash and --autostash options of git-rebase[1]. Defaults to false.\n\nIf set to true enable --update-refs option by default.\n\nIf set to \"warn\", git rebase -i will print a warning if some commits are removed (e.g. a line was deleted), however the rebase will still proceed. If set to \"error\", it will print the previous warning and stop the rebase, git rebase --edit-todo can then be used to correct the error. If set to \"ignore\", no checking is done. To drop a commit without warning or error, use the drop command in the todo list. Defaults to \"ignore\".\n\nA format string, as specified in git-log[1], to be used for the todo list during an interactive rebase. The format will automatically have the commit hash prepended to the format.\n\nIf set to true, git rebase will use abbreviated command names in the todo list resulting in something like this:\n\nAutomatically reschedule exec commands that failed. This only makes sense in interactive mode (or when an --exec option was provided). This is the same as specifying the --reschedule-failed-exec option.\n\nIf set to false set --no-fork-point option by default.\n\nWhether and how to set the --rebase-merges option by default. Can be rebase-cousins, no-rebase-cousins, or a boolean. Setting to true or to no-rebase-cousins is equivalent to --rebase-merges=no-rebase-cousins, setting to rebase-cousins is equivalent to --rebase-merges=rebase-cousins, and setting to false is equivalent to --no-rebase-merges. Passing --rebase-merges on the command line, with or without an argument, overrides any rebase.rebaseMerges configuration.\n\nWhen generating label names from commit subjects, truncate the names to this length. By default, the names are truncated to a little less than NAME_MAX (to allow e.g. .lock files to be written for the corresponding loose refs).\n\nText editor used by git rebase -i for editing the rebase instruction file. The value is meant to be interpreted by the shell when it is used. It can be overridden by the GIT_SEQUENCE_EDITOR environment variable. When not configured, the default commit message editor is used instead.\n\n**rebase.backend**: Default backend to use for rebasing. Possible choices are apply or merge. In the future, if the merge backend gains all remaining capabilities of the apply backend, this setting may become unused.\n**rebase.stat**: Whether to show a diffstat of what changed upstream since the last rebase. False by default.\n**rebase.autoSquash**: If set to true, enable the --autosquash option of git-rebase[1] by default for interactive mode. This can be overridden with the --no-autosquash option.\n**rebase.autoStash**: When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts. This option can be overridden by the --no-autostash and --autostash options of git-rebase[1]. Defaults to false.\n**rebase.updateRefs**: If set to true enable --update-refs option by default.\n**rebase.missingCommitsCheck**: If set to \"warn\", git rebase -i will print a warning if some commits are removed (e.g. a line was deleted), however the rebase will still proceed. If set to \"error\", it will print the previous warning and stop the rebase, git rebase --edit-todo can then be used to correct the error. If set to \"ignore\", no checking is done. To drop a commit without warning or error, use the drop command in the todo list. Defaults to \"ignore\".\n**rebase.instructionFormat**: A format string, as specified in git-log[1], to be used for the todo list during an interactive rebase. The format will automatically have the commit hash prepended to the format.\n**rebase.abbreviateCommands**: If set to true, git rebase will use abbreviated command names in the todo list resulting in something like this: p deadbee The oneline of the commit p fa1afe1 The oneline of the next commit ... instead of: pick deadbee The oneline of the commit pick fa1afe1 The oneline of the next commit ... Defaults to false.\n**rebase.rescheduleFailedExec**: Automatically reschedule exec commands that failed. This only makes sense in interactive mode (or when an --exec option was provided). This is the same as specifying the --reschedule-failed-exec option.\n**rebase.forkPoint**: If set to false set --no-fork-point option by default.\n**rebase.rebaseMerges**: Whether and how to set the --rebase-merges option by default. Can be rebase-cousins, no-rebase-cousins, or a boolean. Setting to true or to no-rebase-cousins is equivalent to --rebase-merges=no-rebase-cousins, setting to rebase-cousins is equivalent to --rebase-merges=rebase-cousins, and setting to false is equivalent to --no-rebase-merges. Passing --rebase-merges on the command line, with or without an argument, overrides any rebase.rebaseMerges configuration.\n**rebase.maxLabelLength**: When generating label names from commit subjects, truncate the names to this length. By default, the names are truncated to a little less than NAME_MAX (to allow e.g. .lock files to be written for the corresponding loose refs).\n**sequence.editor**: Text editor used by git rebase -i for editing the rebase instruction file. The value is meant to be interpreted by the shell when it is used. It can be overridden by the GIT_SEQUENCE_EDITOR environment variable. When not configured, the default commit message editor is used instead.",
        "code_examples": [
          "```bash\np deadbee The oneline of the commit\n\tp fa1afe1 The oneline of the next commit\n\t...\n```",
          "```bash\npick deadbee The oneline of the commit\n\tpick fa1afe1 The oneline of the next commit\n\t...\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 14,
          "content_length": 6436
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-rebase",
    "doc_type": "git",
    "total_sections": 24
  },
  {
    "title": "Git",
    "summary": "NAME git-reset - Reset current HEAD to the specified state\n\ngit-reset - Reset current HEAD to the specified state",
    "sections": [
      {
        "header": "NAME",
        "content": "git-reset - Reset current HEAD to the specified state",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 53
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "In the first three forms, copy entries from <tree-ish> to the index. In the last form, set the current branch head (HEAD) to <commit>, optionally modifying index and working tree to match. The <tree-ish>/<commit> defaults to HEAD in all forms.\n\nThese forms reset the index entries for all paths that match the <pathspec> to their state at <tree-ish>. (It does not affect the working tree or the current branch.)\n\nThis means that git reset <pathspec> is the opposite of git add <pathspec>. This command is equivalent to git restore [--source=<tree-ish>] --staged <pathspec>....\n\nAfter running git reset <pathspec> to update the index entry, you can use git-restore[1] to check the contents out of the index to the working tree. Alternatively, using git-restore[1] and specifying a commit with --source, you can copy the contents of a path out of a commit to the index and to the working tree in one go.\n\nInteractively select hunks in the difference between the index and <tree-ish> (defaults to HEAD). The chosen hunks are applied in reverse to the index.\n\nThis means that git reset -p is the opposite of git add -p, i.e. you can use it to selectively reset hunks. See the \"Interactive Mode\" section of git-add[1] to learn how to operate the --patch mode.\n\nThis form resets the current branch head to <commit> and possibly updates the index (resetting it to the tree of <commit>) and the working tree depending on <mode>. Before the operation, ORIG_HEAD is set to the tip of the current branch. If <mode> is omitted, defaults to --mixed. The <mode> must be one of the following:\n\nDoes not touch the index file or the working tree at all (but resets the head to <commit>, just like all modes do). This leaves all your changed files \"Changes to be committed\", as git status would put it.\n\nResets the index but not the working tree (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action.\n\nIf -N is specified, removed paths are marked as intent-to-add (see git-add[1]).\n\nResets the index and working tree. Any changes to tracked files in the working tree since <commit> are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted.\n\nResets the index and updates the files in the working tree that are different between <commit> and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added). If a file that is different between <commit> and the index has unstaged changes, reset is aborted.\n\nIn other words, --merge does something like a git read-tree -u -m <commit>, but carries forward unmerged index entries.\n\nResets index entries and updates files in the working tree that are different between <commit> and HEAD. If a file that is different between <commit> and HEAD has local changes, reset is aborted.\n\nWhen the working tree is updated, using --recurse-submodules will also recursively reset the working tree of all active submodules according to the commit recorded in the superproject, also setting the submodules' HEAD to be detached at that commit.\n\nSee \"Reset, restore and revert\" in git[1] for the differences between the three commands.\n\n**git reset [-q] [<tree-ish>] [--] <pathspec>...**: These forms reset the index entries for all paths that match the <pathspec> to their state at <tree-ish>. (It does not affect the working tree or the current branch.) This means that git reset <pathspec> is the opposite of git add <pathspec>. This command is equivalent to git restore [--source=<tree-ish>] --staged <pathspec>.... After running git reset <pathspec> to update the index entry, you can use git-restore[1] to check the contents out of the index to the working tree. Alternatively, using git-restore[1] and specifying a commit with --source, you can copy the contents of a path out of a commit to the index and to the working tree in one go.\n**git reset [-q] [--pathspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]**: Interactively select hunks in the difference between the index and <tree-ish> (defaults to HEAD). The chosen hunks are applied in reverse to the index. This means that git reset -p is the opposite of git add -p, i.e. you can use it to selectively reset hunks. See the \"Interactive Mode\" section of git-add[1] to learn how to operate the --patch mode.\n**git reset (--patch | -p) [<tree-ish>] [--] [<pathspec>...]**: This form resets the current branch head to <commit> and possibly updates the index (resetting it to the tree of <commit>) and the working tree depending on <mode>. Before the operation, ORIG_HEAD is set to the tip of the current branch. If <mode> is omitted, defaults to --mixed. The <mode> must be one of the following: --soft Does not touch the index file or the working tree at all (but resets the head to <commit>, just like all modes do). This leaves all your changed files \"Changes to be committed\", as git status would put it. --mixed Resets the index but not the working tree (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action. If -N is specified, removed paths are marked as intent-to-add (see git-add[1]). --hard Resets the index and working tree. Any changes to tracked files in the working tree since <commit> are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted. --merge Resets the index and updates the files in the working tree that are different between <commit> and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added). If a file that is different between <commit> and the index has unstaged changes, reset is aborted. In other words, --merge does something like a git read-tree -u -m <commit>, but carries forward unmerged index entries. --keep Resets index entries and updates files in the working tree that are different between <commit> and HEAD. If a file that is different between <commit> and HEAD has local changes, reset is aborted. --[no-]recurse-submodules When the working tree is updated, using --recurse-submodules will also recursively reset the working tree of all active submodules according to the commit recorded in the superproject, also setting the submodules' HEAD to be detached at that commit.\n**git reset [<mode>] [<commit>]**: Does not touch the index file or the working tree at all (but resets the head to <commit>, just like all modes do). This leaves all your changed files \"Changes to be committed\", as git status would put it.\n**--soft**: Resets the index but not the working tree (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action. If -N is specified, removed paths are marked as intent-to-add (see git-add[1]).\n**--mixed**: Resets the index and working tree. Any changes to tracked files in the working tree since <commit> are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted.\n**--hard**: Resets the index and updates the files in the working tree that are different between <commit> and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added). If a file that is different between <commit> and the index has unstaged changes, reset is aborted. In other words, --merge does something like a git read-tree -u -m <commit>, but carries forward unmerged index entries.\n**--merge**: Resets index entries and updates files in the working tree that are different between <commit> and HEAD. If a file that is different between <commit> and HEAD has local changes, reset is aborted.\n**--keep**: When the working tree is updated, using --recurse-submodules will also recursively reset the working tree of all active submodules according to the commit recorded in the superproject, also setting the submodules' HEAD to be detached at that commit.\n**--soft**: Does not touch the index file or the working tree at all (but resets the head to <commit>, just like all modes do). This leaves all your changed files \"Changes to be committed\", as git status would put it.\n**--mixed**: Resets the index but not the working tree (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action. If -N is specified, removed paths are marked as intent-to-add (see git-add[1]).\n**--hard**: Resets the index and working tree. Any changes to tracked files in the working tree since <commit> are discarded. Any untracked files or directories in the way of writing any tracked files are simply deleted.\n**--merge**: Resets the index and updates the files in the working tree that are different between <commit> and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added). If a file that is different between <commit> and the index has unstaged changes, reset is aborted. In other words, --merge does something like a git read-tree -u -m <commit>, but carries forward unmerged index entries.\n**--keep**: Resets index entries and updates files in the working tree that are different between <commit> and HEAD. If a file that is different between <commit> and HEAD has local changes, reset is aborted.\n**--[no-]recurse-submodules**: When the working tree is updated, using --recurse-submodules will also recursively reset the working tree of all active submodules according to the commit recorded in the superproject, also setting the submodules' HEAD to be detached at that commit.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 16,
          "content_length": 9715
        }
      },
      {
        "header": "OPTIONS",
        "content": "Be quiet, only report errors.\n\nRefresh the index after a mixed reset. Enabled by default.\n\nPathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config[1]). See also --pathspec-file-nul and global --literal-pathspecs.\n\nOnly meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).\n\nGenerate diffs with <n> lines of context. Defaults to diff.context or 3 if the config option is unset.\n\nShow the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n\nDo not interpret any more arguments as options.\n\nLimits the paths affected by the operation.\n\nFor more details, see the pathspec entry in gitglossary[7].\n\n**-q**: Be quiet, only report errors.\n**--quiet**: Refresh the index after a mixed reset. Enabled by default.\n**--refresh**: Pathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config[1]). See also --pathspec-file-nul and global --literal-pathspecs.\n**--no-refresh**: Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).\n**--pathspec-from-file=<file>**: Generate diffs with <n> lines of context. Defaults to diff.context or 3 if the config option is unset.\n**--pathspec-file-nul**: Show the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n**-U<n>**: Do not interpret any more arguments as options.\n**--unified=<n>**: Limits the paths affected by the operation. For more details, see the pathspec entry in gitglossary[7].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 2238
        }
      },
      {
        "header": "EXAMPLES",
        "content": "You are happily working on something, and find the changes in these files are in good order. You do not want to see them when you run git diff, because you plan to work on other files and changes with these files are distracting.\n\nSomebody asks you to pull, and the changes sound worthy of merging.\n\nHowever, you already dirtied the index (i.e. your index does not match the HEAD commit). But you know the pull you are going to make does not affect frotz.c or filfre.c, so you revert the index changes for these two files. Your changes in working tree remain there.\n\nThen you can pull and merge, leaving frotz.c and filfre.c changes still in the working tree.\n\nThis is most often done when you remembered what you just committed is incomplete, or you misspelled your commit message, or both. Leaves working tree as it was before \"reset\".\n\nMake corrections to working tree files.\n\n\"reset\" copies the old head to .git/ORIG_HEAD; redo the commit by starting with its log message. If you do not need to edit the message further, you can give -C option instead.\n\nSee also the --amend option to git-commit[1].\n\nYou have made some commits, but realize they were premature to be in the master branch. You want to continue polishing them in a topic branch, so create topic/wip branch off of the current HEAD.\n\nRewind the master branch to get rid of those three commits.\n\nSwitch to topic/wip branch and keep working.\n\nThe last three commits (HEAD, HEAD^, and HEAD~2) were bad and you do not want to ever see them again. Do not do this if you have already given these commits to somebody else. (See the \"RECOVERING FROM UPSTREAM REBASE\" section in git-rebase[1] for the implications of doing so.)\n\nTry to update from the upstream resulted in a lot of conflicts; you were not ready to spend a lot of time merging right now, so you decide to do that later.\n\n\"pull\" has not made merge commit, so git reset --hard which is a synonym for git reset --hard HEAD clears the mess from the index file and the working tree.\n\nMerge a topic branch into the current branch, which resulted in a fast-forward.\n\nBut you decided that the topic branch is not ready for public consumption yet. \"pull\" or \"merge\" always leaves the original tip of the current branch in ORIG_HEAD, so resetting hard to it brings your index file and the working tree back to that state, and resets the tip of the branch to that commit.\n\nEven if you may have local modifications in your working tree, you can safely say git pull when you know that the change in the other branch does not overlap with them.\n\nAfter inspecting the result of the merge, you may find that the change in the other branch is unsatisfactory. Running git reset --hard ORIG_HEAD will let you go back to where you were, but it will discard your local changes, which you do not want. git reset --merge keeps your local changes.\n\nSuppose you are interrupted by an urgent fix request while you are in the middle of a large change. The files in your working tree are not in any shape to be committed yet, but you need to get to the other branch for a quick bugfix.\n\nThis commit will get blown away so a throw-away log message is OK.\n\nThis removes the WIP commit from the commit history, and sets your working tree to the state just before you made that snapshot.\n\nAt this point the index file still has all the WIP changes you committed as snapshot WIP. This updates the index to show your WIP files as uncommitted.\n\nSee also git-stash[1].\n\nSuppose you have added a file to your index, but later decide you do not want to add it to your commit. You can remove the file from the index while keeping your changes with git reset.\n\nThis removes the file from the index while keeping it in the working directory.\n\nThis commits all other changes in the index.\n\nAdds the file to the index again.\n\nSuppose you are working on something and you commit it, and then you continue working a bit more, but now you think that what you have in your working tree should be in another branch that has nothing to do with what you committed previously. You can start a new branch and reset it while keeping the changes in your working tree.\n\nThis commits your first edits in branch1.\n\nIn the ideal world, you could have realized that the earlier commit did not belong to the new topic when you created and switched to branch2 (i.e. git switch -c branch2 start), but nobody is perfect.\n\nBut you can use reset --keep to remove the unwanted commit after you switched to branch2.\n\nSuppose that you have created lots of logically separate changes and committed them together. Then, later you decide that it might be better to have each logical chunk associated with its own commit. You can use git reset to rewind history without changing the contents of your local files, and then successively use git add -p to interactively select which hunks to include into each commit, using git commit -c to pre-populate the commit message.\n\nFirst, reset the history back one commit so that we remove the original commit, but leave the working tree with all the changes. The -N ensures that any new files added with HEAD are still marked so that git add -p will find them.\n\nNext, we interactively select diff hunks to add using the git add -p facility. This will ask you about each diff hunk in sequence and you can use simple commands such as \"yes, include this\", \"No don’t include this\" or even the very powerful \"edit\" facility.\n\nOnce satisfied with the hunks you want to include, you should verify what has been prepared for the first commit by using git diff --cached. This shows all the changes that have been moved into the index and are about to be committed.\n\nNext, commit the changes stored in the index. The -c option specifies to pre-populate the commit message from the original message that you started with in the first commit. This is helpful to avoid retyping it. The HEAD@{1} is a special notation for the commit that HEAD used to be at prior to the original reset commit (1 change ago). See git-reflog[1] for more details. You may also use any other valid commit reference.\n\nYou can repeat steps 2-4 multiple times to break the original code into any number of commits.\n\nNow you’ve split out many of the changes into their own commits, and might no longer use the patch mode of git add, in order to select all remaining uncommitted changes.\n\nOnce again, check to verify that you’ve included what you want to. You may also wish to verify that git diff doesn’t show any remaining changes to be committed later.\n\nAnd finally create the final commit.\n\n• You are happily working on something, and find the changes in these files are in good order. You do not want to see them when you run git diff, because you plan to work on other files and changes with these files are distracting.\n• Somebody asks you to pull, and the changes sound worthy of merging.\n• However, you already dirtied the index (i.e. your index does not match the HEAD commit). But you know the pull you are going to make does not affect frotz.c or filfre.c, so you revert the index changes for these two files. Your changes in working tree remain there.\n• Then you can pull and merge, leaving frotz.c and filfre.c changes still in the working tree.\n\n• This is most often done when you remembered what you just committed is incomplete, or you misspelled your commit message, or both. Leaves working tree as it was before \"reset\".\n• Make corrections to working tree files.\n• \"reset\" copies the old head to .git/ORIG_HEAD; redo the commit by starting with its log message. If you do not need to edit the message further, you can give -C option instead. See also the --amend option to git-commit[1].\n\n• You have made some commits, but realize they were premature to be in the master branch. You want to continue polishing them in a topic branch, so create topic/wip branch off of the current HEAD.\n• Rewind the master branch to get rid of those three commits.\n• Switch to topic/wip branch and keep working.\n\n• The last three commits (HEAD, HEAD^, and HEAD~2) were bad and you do not want to ever see them again. Do not do this if you have already given these commits to somebody else. (See the \"RECOVERING FROM UPSTREAM REBASE\" section in git-rebase[1] for the implications of doing so.)\n\n• Try to update from the upstream resulted in a lot of conflicts; you were not ready to spend a lot of time merging right now, so you decide to do that later.\n• \"pull\" has not made merge commit, so git reset --hard which is a synonym for git reset --hard HEAD clears the mess from the index file and the working tree.\n• Merge a topic branch into the current branch, which resulted in a fast-forward.\n• But you decided that the topic branch is not ready for public consumption yet. \"pull\" or \"merge\" always leaves the original tip of the current branch in ORIG_HEAD, so resetting hard to it brings your index file and the working tree back to that state, and resets the tip of the branch to that commit.\n\n• Even if you may have local modifications in your working tree, you can safely say git pull when you know that the change in the other branch does not overlap with them.\n• After inspecting the result of the merge, you may find that the change in the other branch is unsatisfactory. Running git reset --hard ORIG_HEAD will let you go back to where you were, but it will discard your local changes, which you do not want. git reset --merge keeps your local changes.\n\n• This commit will get blown away so a throw-away log message is OK.\n• This removes the WIP commit from the commit history, and sets your working tree to the state just before you made that snapshot.\n• At this point the index file still has all the WIP changes you committed as snapshot WIP. This updates the index to show your WIP files as uncommitted. See also git-stash[1].\n\n• This removes the file from the index while keeping it in the working directory.\n• This commits all other changes in the index.\n• Adds the file to the index again.\n\n• This commits your first edits in branch1.\n• In the ideal world, you could have realized that the earlier commit did not belong to the new topic when you created and switched to branch2 (i.e. git switch -c branch2 start), but nobody is perfect.\n• But you can use reset --keep to remove the unwanted commit after you switched to branch2.\n\n• First, reset the history back one commit so that we remove the original commit, but leave the working tree with all the changes. The -N ensures that any new files added with HEAD are still marked so that git add -p will find them.\n• Next, we interactively select diff hunks to add using the git add -p facility. This will ask you about each diff hunk in sequence and you can use simple commands such as \"yes, include this\", \"No don’t include this\" or even the very powerful \"edit\" facility.\n• Once satisfied with the hunks you want to include, you should verify what has been prepared for the first commit by using git diff --cached. This shows all the changes that have been moved into the index and are about to be committed.\n• Next, commit the changes stored in the index. The -c option specifies to pre-populate the commit message from the original message that you started with in the first commit. This is helpful to avoid retyping it. The HEAD@{1} is a special notation for the commit that HEAD used to be at prior to the original reset commit (1 change ago). See git-reflog[1] for more details. You may also use any other valid commit reference.\n• You can repeat steps 2-4 multiple times to break the original code into any number of commits.\n• Now you’ve split out many of the changes into their own commits, and might no longer use the patch mode of git add, in order to select all remaining uncommitted changes.\n• Once again, check to verify that you’ve included what you want to. You may also wish to verify that git diff doesn’t show any remaining changes to be committed later.\n• And finally create the final commit.\n\n**Undo add**: $ edit (1) $ git add frotz.c filfre.c $ mailx (2) $ git reset (3) $ git pull git://info.example.com/ nitfol (4) You are happily working on something, and find the changes in these files are in good order. You do not want to see them when you run git diff, because you plan to work on other files and changes with these files are distracting. Somebody asks you to pull, and the changes sound worthy of merging. However, you already dirtied the index (i.e. your index does not match the HEAD commit). But you know the pull you are going to make does not affect frotz.c or filfre.c, so you revert the index changes for these two files. Your changes in working tree remain there. Then you can pull and merge, leaving frotz.c and filfre.c changes still in the working tree.\n**Undo a commit and redo**: $ git commit ... $ git reset --soft HEAD^ (1) $ edit (2) $ git commit -a -c ORIG_HEAD (3) This is most often done when you remembered what you just committed is incomplete, or you misspelled your commit message, or both. Leaves working tree as it was before \"reset\". Make corrections to working tree files. \"reset\" copies the old head to .git/ORIG_HEAD; redo the commit by starting with its log message. If you do not need to edit the message further, you can give -C option instead. See also the --amend option to git-commit[1].\n**Undo a commit, making it a topic branch**: $ git branch topic/wip (1) $ git reset --hard HEAD~3 (2) $ git switch topic/wip (3) You have made some commits, but realize they were premature to be in the master branch. You want to continue polishing them in a topic branch, so create topic/wip branch off of the current HEAD. Rewind the master branch to get rid of those three commits. Switch to topic/wip branch and keep working.\n**Undo commits permanently**: $ git commit ... $ git reset --hard HEAD~3 (1) The last three commits (HEAD, HEAD^, and HEAD~2) were bad and you do not want to ever see them again. Do not do this if you have already given these commits to somebody else. (See the \"RECOVERING FROM UPSTREAM REBASE\" section in git-rebase[1] for the implications of doing so.)\n**Undo a merge or pull**: $ git pull (1) Auto-merging nitfol CONFLICT (content): Merge conflict in nitfol Automatic merge failed; fix conflicts and then commit the result. $ git reset --hard (2) $ git pull . topic/branch (3) Updating from 41223... to 13134... Fast-forward $ git reset --hard ORIG_HEAD (4) Try to update from the upstream resulted in a lot of conflicts; you were not ready to spend a lot of time merging right now, so you decide to do that later. \"pull\" has not made merge commit, so git reset --hard which is a synonym for git reset --hard HEAD clears the mess from the index file and the working tree. Merge a topic branch into the current branch, which resulted in a fast-forward. But you decided that the topic branch is not ready for public consumption yet. \"pull\" or \"merge\" always leaves the original tip of the current branch in ORIG_HEAD, so resetting hard to it brings your index file and the working tree back to that state, and resets the tip of the branch to that commit.\n**Undo a merge or pull inside a dirty working tree**: $ git pull (1) Auto-merging nitfol Merge made by recursive. nitfol | 20 +++++---- ... $ git reset --merge ORIG_HEAD (2) Even if you may have local modifications in your working tree, you can safely say git pull when you know that the change in the other branch does not overlap with them. After inspecting the result of the merge, you may find that the change in the other branch is unsatisfactory. Running git reset --hard ORIG_HEAD will let you go back to where you were, but it will discard your local changes, which you do not want. git reset --merge keeps your local changes.\n**Interrupted workflow**: Suppose you are interrupted by an urgent fix request while you are in the middle of a large change. The files in your working tree are not in any shape to be committed yet, but you need to get to the other branch for a quick bugfix. $ git switch feature ;# you were working in \"feature\" branch and $ work work work ;# got interrupted $ git commit -a -m \"snapshot WIP\" (1) $ git switch master $ fix fix fix $ git commit ;# commit with real log $ git switch feature $ git reset --soft HEAD^ ;# go back to WIP state (2) $ git reset (3) This commit will get blown away so a throw-away log message is OK. This removes the WIP commit from the commit history, and sets your working tree to the state just before you made that snapshot. At this point the index file still has all the WIP changes you committed as snapshot WIP. This updates the index to show your WIP files as uncommitted. See also git-stash[1].\n**Reset a single file in the index**: Suppose you have added a file to your index, but later decide you do not want to add it to your commit. You can remove the file from the index while keeping your changes with git reset. $ git reset -- frotz.c (1) $ git commit -m \"Commit files in index\" (2) $ git add frotz.c (3) This removes the file from the index while keeping it in the working directory. This commits all other changes in the index. Adds the file to the index again.\n**Keep changes in working tree while discarding some previous commits**: Suppose you are working on something and you commit it, and then you continue working a bit more, but now you think that what you have in your working tree should be in another branch that has nothing to do with what you committed previously. You can start a new branch and reset it while keeping the changes in your working tree. $ git tag start $ git switch -c branch1 $ edit $ git commit ... (1) $ edit $ git switch -c branch2 (2) $ git reset --keep start (3) This commits your first edits in branch1. In the ideal world, you could have realized that the earlier commit did not belong to the new topic when you created and switched to branch2 (i.e. git switch -c branch2 start), but nobody is perfect. But you can use reset --keep to remove the unwanted commit after you switched to branch2.\n**Split a commit apart into a sequence of commits**: Suppose that you have created lots of logically separate changes and committed them together. Then, later you decide that it might be better to have each logical chunk associated with its own commit. You can use git reset to rewind history without changing the contents of your local files, and then successively use git add -p to interactively select which hunks to include into each commit, using git commit -c to pre-populate the commit message. $ git reset -N HEAD^ (1) $ git add -p (2) $ git diff --cached (3) $ git commit -c HEAD@{1} (4) ... (5) $ git add ... (6) $ git diff --cached (7) $ git commit ... (8) First, reset the history back one commit so that we remove the original commit, but leave the working tree with all the changes. The -N ensures that any new files added with HEAD are still marked so that git add -p will find them. Next, we interactively select diff hunks to add using the git add -p facility. This will ask you about each diff hunk in sequence and you can use simple commands such as \"yes, include this\", \"No don’t include this\" or even the very powerful \"edit\" facility. Once satisfied with the hunks you want to include, you should verify what has been prepared for the first commit by using git diff --cached. This shows all the changes that have been moved into the index and are about to be committed. Next, commit the changes stored in the index. The -c option specifies to pre-populate the commit message from the original message that you started with in the first commit. This is helpful to avoid retyping it. The HEAD@{1} is a special notation for the commit that HEAD used to be at prior to the original reset commit (1 change ago). See git-reflog[1] for more details. You may also use any other valid commit reference. You can repeat steps 2-4 multiple times to break the original code into any number of commits. Now you’ve split out many of the changes into their own commits, and might no longer use the patch mode of git add, in order to select all remaining uncommitted changes. Once again, check to verify that you’ve included what you want to. You may also wish to verify that git diff doesn’t show any remaining changes to be committed later. And finally create the final commit.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ edit(1)$ git add frotz.c filfre.c\n$ mailx(2)$ git reset(3)$ git pull git://info.example.com/ nitfol(4)\n```",
          "```bash\n$ git commit ...\n$ git reset --soft HEAD^(1)$ edit(2)$ git commit -a -c ORIG_HEAD(3)\n```",
          "```bash\n$ git branch topic/wip(1)$ git reset --hard HEAD~3(2)$ git switch topic/wip(3)\n```",
          "```bash\n$ git commit ...\n$ git reset --hard HEAD~3(1)\n```",
          "```bash\n$ git pull(1)Auto-merging nitfol\nCONFLICT (content): Merge conflict in nitfol\nAutomatic merge failed; fix conflicts and then commit the result.\n$ git reset --hard(2)$ git pull . topic/branch(3)Updating from 41223... to 13134...\nFast-forward\n$ git reset --hard ORIG_HEAD(4)\n```",
          "```bash\n$ git pull(1)Auto-merging nitfol\nMerge made by recursive.\n nitfol                |   20 +++++----\n ...\n$ git reset --merge ORIG_HEAD(2)\n```",
          "```bash\n$ git switch feature  ;# you were working in \"feature\" branch and\n$ work work work      ;# got interrupted\n$ git commit -a -m \"snapshot WIP\"(1)$ git switch master\n$ fix fix fix\n$ git commit ;# commit with real log\n$ git switch feature\n$ git reset --soft HEAD^ ;# go back to WIP state(2)$ git reset(3)\n```",
          "```bash\n$ git reset -- frotz.c(1)$ git commit -m \"Commit files in index\"(2)$ git add frotz.c(3)\n```",
          "```bash\n$ git tag start\n$ git switch -c branch1\n$ edit\n$ git commit ...(1)$ edit\n$ git switch -c branch2(2)$ git reset --keep start(3)\n```",
          "```bash\n$ git reset -N HEAD^(1)$ git add -p(2)$ git diff --cached(3)$ git commit -c HEAD@{1}(4)...(5)$ git add ...(6)$ git diff --cached(7)$ git commit ...(8)\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 40,
          "content_length": 20256
        }
      },
      {
        "header": "DISCUSSION",
        "content": "The tables below show what happens when running:\n\nto reset the HEAD to another commit (target) with the different reset options depending on the state of the files.\n\nIn these tables, A, B, C and D are some different states of a file. For example, the first line of the first table means that if a file is in state A in the working tree, in state B in the index, in state C in HEAD and in state D in the target, then git reset --soft target will leave the file in the working tree in state A and in the index in state B. It resets (i.e. moves) the HEAD (i.e. the tip of the current branch, if you are on one) to target (which has the file in state D).\n\ngit reset --merge is meant to be used when resetting out of a conflicted merge. Any mergy operation guarantees that the working tree file that is involved in the merge does not have a local change with respect to the index before it starts, and that it writes the result out to the working tree. So if we see some difference between the index and the target and also between the index and the working tree, then it means that we are not resetting out from a state that a mergy operation left after failing with a conflict. That is why we disallow --merge option in this case.\n\ngit reset --keep is meant to be used when removing some of the last commits in the current branch while keeping changes in the working tree. If there could be conflicts between the changes in the commit we want to remove and the changes in the working tree we want to keep, the reset is disallowed. That’s why it is disallowed if there are both changes between the working tree and HEAD, and between HEAD and the target. To be safe, it is also disallowed when there are unmerged entries.\n\nThe following tables show what happens when there are unmerged entries:\n\nX means any state and U means an unmerged index.",
        "code_examples": [
          "```bash\nworking index HEAD target         working index HEAD\n----------------------------------------------------\n A       B     C    D     --soft   A       B     D\n\t\t\t  --mixed  A       D     D\n\t\t\t  --hard   D       D     D\n\t\t\t  --merge (disallowed)\n\t\t\t  --keep  (disallowed)\n```",
          "```bash\nworking index HEAD target         working index HEAD\n----------------------------------------------------\n A       B     C    C     --soft   A       B     C\n\t\t\t  --mixed  A       C     C\n\t\t\t  --hard   C       C     C\n\t\t\t  --merge (disallowed)\n\t\t\t  --keep   A       C     C\n```",
          "```bash\nworking index HEAD target         working index HEAD\n----------------------------------------------------\n B       B     C    D     --soft   B       B     D\n\t\t\t  --mixed  B       D     D\n\t\t\t  --hard   D       D     D\n\t\t\t  --merge  D       D     D\n\t\t\t  --keep  (disallowed)\n```",
          "```bash\nworking index HEAD target         working index HEAD\n----------------------------------------------------\n B       B     C    C     --soft   B       B     C\n\t\t\t  --mixed  B       C     C\n\t\t\t  --hard   C       C     C\n\t\t\t  --merge  C       C     C\n\t\t\t  --keep   B       C     C\n```",
          "```bash\nworking index HEAD target         working index HEAD\n----------------------------------------------------\n B       C     C    D     --soft   B       C     D\n\t\t\t  --mixed  B       D     D\n\t\t\t  --hard   D       D     D\n\t\t\t  --merge (disallowed)\n\t\t\t  --keep  (disallowed)\n```",
          "```bash\nworking index HEAD target         working index HEAD\n----------------------------------------------------\n B       C     C    C     --soft   B       C     C\n\t\t\t  --mixed  B       C     C\n\t\t\t  --hard   C       C     C\n\t\t\t  --merge  B       C     C\n\t\t\t  --keep   B       C     C\n```",
          "```bash\nworking index HEAD target         working index HEAD\n----------------------------------------------------\n X       U     A    B     --soft  (disallowed)\n\t\t\t  --mixed  X       B     B\n\t\t\t  --hard   B       B     B\n\t\t\t  --merge  B       B     B\n\t\t\t  --keep  (disallowed)\n```",
          "```bash\nworking index HEAD target         working index HEAD\n----------------------------------------------------\n X       U     A    A     --soft  (disallowed)\n\t\t\t  --mixed  X       A     A\n\t\t\t  --hard   A       A     A\n\t\t\t  --merge  A       A     A\n\t\t\t  --keep  (disallowed)\n```"
        ],
        "usage_examples": [
          "```bash\ngit reset --option target\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1839
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-reset",
    "doc_type": "git",
    "total_sections": 6
  },
  {
    "title": "Git",
    "summary": "SYNOPSIS git restore [<options>] [--source=<tree>] [--staged] [--worktree] [--] <pathspec>… git restore [<options>] [--source=<tree>] [--staged] [--worktree] --pathspec-from-file=<file> [--pathspec-file-nul] git restore (-p|--patch) [<options>] [--source=<tree>] [--staged] [--worktree] [--] [<pathspec>…]",
    "sections": [
      {
        "header": "NAME",
        "content": "git-restore - Restore working tree files",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 40
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Restore specified paths in the working tree with some contents from a restore source. If a path is tracked but does not exist in the restore source, it will be removed to match the source.\n\nThe command can also be used to restore the content in the index with --staged, or restore both the working tree and the index with --staged --worktree.\n\nBy default, if --staged is given, the contents are restored from HEAD, otherwise from the index. Use --source to restore from a different commit.\n\nSee \"Reset, restore and revert\" in git[1] for the differences between the three commands.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 580
        }
      },
      {
        "header": "OPTIONS",
        "content": "Restore the working tree files with the content from the given tree. It is common to specify the source tree by naming a commit, branch or tag associated with it.\n\nIf not specified, the contents are restored from HEAD if --staged is given, otherwise from the index.\n\nAs a special case, you may use \"<rev-A>...<rev-B>\" as a shortcut for the merge base of <rev-A> and <rev-B> if there is exactly one merge base. You can leave out at most one of <rev-A>_ and <rev-B>, in which case it defaults to HEAD.\n\nInteractively select hunks in the difference between the restore source and the restore location. See the \"Interactive Mode\" section of git-add[1] to learn how to operate the --patch mode.\n\nGenerate diffs with <n> lines of context. Defaults to diff.context or 3 if the config option is unset.\n\nShow the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n\nSpecify the restore location. If neither option is specified, by default the working tree is restored. Specifying --staged will only restore the index. Specifying both restores both.\n\nQuiet, suppress feedback messages. Implies --no-progress.\n\nProgress status is reported on the standard error stream by default when it is attached to a terminal, unless --quiet is specified. This flag enables progress reporting even if not attached to a terminal, regardless of --quiet.\n\nWhen restoring files in the working tree from the index, use stage #2 (ours) or #3 (theirs) for unmerged paths. This option cannot be used when checking out paths from a tree-ish (i.e. with the --source option).\n\nNote that during git rebase and git pull --rebase, ours and theirs may appear swapped. See the explanation of the same options in git-checkout[1] for details.\n\nWhen restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths. This option cannot be used when checking out paths from a tree-ish (i.e. with the --source option).\n\nThe same as --merge option above, but changes the way the conflicting hunks are presented, overriding the merge.conflictStyle configuration variable. Possible values are merge (default), diff3, and zdiff3.\n\nWhen restoring files on the working tree from the index, do not abort the operation if there are unmerged entries and neither --ours, --theirs, --merge or --conflict is specified. Unmerged paths on the working tree are left alone.\n\nIn sparse checkout mode, the default is to only update entries matched by <pathspec> and sparse patterns in $GIT_DIR/info/sparse-checkout. This option ignores the sparse patterns and unconditionally restores any files in <pathspec>.\n\nIf <pathspec> names an active submodule and the restore location includes the working tree, the submodule will only be updated if this option is given, in which case its working tree will be restored to the commit recorded in the superproject, and any local modifications overwritten. If nothing (or --no-recurse-submodules) is used, submodules working trees will not be updated. Just like git-checkout[1], this will detach HEAD of the submodule.\n\nIn overlay mode, never remove files when restoring. In no-overlay mode, remove tracked files that do not appear in the <tree> of --source=<tree>, to make them match <tree> exactly. The default is no-overlay mode.\n\nPathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config[1]). See also --pathspec-file-nul and global --literal-pathspecs.\n\nOnly meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).\n\nDo not interpret any more arguments as options.\n\nLimits the paths affected by the operation.\n\nFor more details, see the pathspec entry in gitglossary[7].\n\n**-s <tree>**: Restore the working tree files with the content from the given tree. It is common to specify the source tree by naming a commit, branch or tag associated with it. If not specified, the contents are restored from HEAD if --staged is given, otherwise from the index. As a special case, you may use \"<rev-A>...<rev-B>\" as a shortcut for the merge base of <rev-A> and <rev-B> if there is exactly one merge base. You can leave out at most one of <rev-A>_ and <rev-B>, in which case it defaults to HEAD.\n**--source=<tree>**: Interactively select hunks in the difference between the restore source and the restore location. See the \"Interactive Mode\" section of git-add[1] to learn how to operate the --patch mode.\n**-p**: Generate diffs with <n> lines of context. Defaults to diff.context or 3 if the config option is unset.\n**--patch**: Show the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n**-U<n>**: Specify the restore location. If neither option is specified, by default the working tree is restored. Specifying --staged will only restore the index. Specifying both restores both.\n**--unified=<n>**: Quiet, suppress feedback messages. Implies --no-progress.\n**--inter-hunk-context=<n>**: Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --quiet is specified. This flag enables progress reporting even if not attached to a terminal, regardless of --quiet.\n**-W**: When restoring files in the working tree from the index, use stage #2 (ours) or #3 (theirs) for unmerged paths. This option cannot be used when checking out paths from a tree-ish (i.e. with the --source option). Note that during git rebase and git pull --rebase, ours and theirs may appear swapped. See the explanation of the same options in git-checkout[1] for details.\n**--worktree**: When restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths. This option cannot be used when checking out paths from a tree-ish (i.e. with the --source option).\n**-S**: The same as --merge option above, but changes the way the conflicting hunks are presented, overriding the merge.conflictStyle configuration variable. Possible values are merge (default), diff3, and zdiff3.\n**--staged**: When restoring files on the working tree from the index, do not abort the operation if there are unmerged entries and neither --ours, --theirs, --merge or --conflict is specified. Unmerged paths on the working tree are left alone.\n**-q**: In sparse checkout mode, the default is to only update entries matched by <pathspec> and sparse patterns in $GIT_DIR/info/sparse-checkout. This option ignores the sparse patterns and unconditionally restores any files in <pathspec>.\n**--quiet**: If <pathspec> names an active submodule and the restore location includes the working tree, the submodule will only be updated if this option is given, in which case its working tree will be restored to the commit recorded in the superproject, and any local modifications overwritten. If nothing (or --no-recurse-submodules) is used, submodules working trees will not be updated. Just like git-checkout[1], this will detach HEAD of the submodule.\n**--progress**: In overlay mode, never remove files when restoring. In no-overlay mode, remove tracked files that do not appear in the <tree> of --source=<tree>, to make them match <tree> exactly. The default is no-overlay mode.\n**--no-progress**: Pathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config[1]). See also --pathspec-file-nul and global --literal-pathspecs.\n**--ours**: Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).\n**--theirs**: Do not interpret any more arguments as options.\n**-m**: Limits the paths affected by the operation. For more details, see the pathspec entry in gitglossary[7].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 22,
          "content_length": 8318
        }
      },
      {
        "header": "EXAMPLES",
        "content": "The following sequence switches to the master branch, reverts the Makefile to two revisions back, deletes hello.c by mistake, and gets it back from the index.\n\ntake a file out of another commit\n\nrestore hello.c from the index\n\nIf you want to restore all C source files to match the version in the index, you can say\n\nNote the quotes around *.c. The file hello.c will also be restored, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell).\n\nTo restore all files in the current directory\n\nor to restore all working tree files with top pathspec magic (see gitglossary[7])\n\nTo restore a file in the index to match the version in HEAD (this is the same as using git-reset[1])\n\nor you can restore both the index and the working tree (this is the same as using git-checkout[1])\n\nor the short form which is more practical but less readable:\n\n• take a file out of another commit\n• restore hello.c from the index",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git switch master\n$ git restore --source master~2 Makefile(1)$ rm -f hello.c\n$ git restore hello.c(2)\n```",
          "```bash\n$ git restore '*.c'\n```",
          "```bash\n$ git restore .\n```",
          "```bash\n$ git restore :/\n```",
          "```bash\n$ git restore --staged hello.c\n```",
          "```bash\n$ git restore --source=HEAD --staged --worktree hello.c\n```",
          "```bash\n$ git restore -s@ -SW hello.c\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 1001
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-checkout[1], git-reset[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 29
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-restore",
    "doc_type": "git",
    "total_sections": 6
  },
  {
    "title": "Git",
    "summary": "SYNOPSIS git revert [--[no-]edit] [-n] [-m <parent-number>] [-s] [-S[<keyid>]] <commit>… git revert (--continue | --skip | --abort | --quit)",
    "sections": [
      {
        "header": "NAME",
        "content": "git-revert - Revert some existing commits",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 41
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Given one or more existing commits, revert the changes that the related patches introduce, and record some new commits that record them. This requires your working tree to be clean (no modifications from the HEAD commit).\n\nNote: git revert is used to record some new commits to reverse the effect of some earlier commits (often only a faulty one). If you want to throw away all uncommitted changes in your working directory, you should see git-reset[1], particularly the --hard option. If you want to extract specific files as they were in another commit, you should see git-restore[1], specifically the --source option. Take care with these alternatives as both will discard uncommitted changes in your working directory.\n\nSee \"Reset, restore and revert\" in git[1] for the differences between the three commands.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 813
        }
      },
      {
        "header": "OPTIONS",
        "content": "Commits to revert. For a more complete list of ways to spell commit names, see gitrevisions[7]. Sets of commits can also be given but no traversal is done by default, see git-rev-list[1] and its --no-walk option.\n\nWith this option, git revert will let you edit the commit message prior to committing the revert. This is the default if you run the command from a terminal.\n\nUsually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.\n\nReverting a merge commit declares that you will never want the tree changes brought in by the merge. As a result, later merges will only bring in tree changes introduced by commits that are not ancestors of the previously reverted merge. This may or may not be what you want.\n\nSee the revert-a-faulty-merge How-To for more details.\n\nWith this option, git revert will not start the commit message editor.\n\nThis option determines how the commit message will be cleaned up before being passed on to the commit machinery. See git-commit[1] for more details. In particular, if the <mode> is given a value of scissors, scissors will be appended to MERGE_MSG before being passed on in the case of a conflict.\n\nUsually the command automatically creates some commits with commit log messages stating which commits were reverted. This flag applies the changes necessary to revert the named commits to your working tree and the index, but does not make the commits. In addition, when this option is used, your index does not have to match the HEAD commit. The revert is done against the beginning state of your index.\n\nThis is useful when reverting more than one commits' effect to your index in a row.\n\nGPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign.\n\nAdd a Signed-off-by trailer at the end of the commit message. See the signoff option in git-commit[1] for more information.\n\nUse the given merge strategy. Should only be used once. See the MERGE STRATEGIES section in git-merge[1] for details.\n\nPass the merge strategy-specific option through to the merge strategy. See git-merge[1] for details.\n\nAfter the rerere mechanism reuses a recorded resolution on the current conflict to update the files in the working tree, allow it to also update the index with the result of resolution. --no-rerere-autoupdate is a good way to double-check what rerere did and catch potential mismerges, before committing the result to the index with a separate git add.\n\nInstead of starting the body of the log message with \"This reverts <full-object-name-of-the-commit-being-reverted>.\", refer to the commit using \"--pretty=reference\" format (cf. git-log[1]). The revert.reference configuration variable can be used to enable this option by default.\n\n**<commit>…**: Commits to revert. For a more complete list of ways to spell commit names, see gitrevisions[7]. Sets of commits can also be given but no traversal is done by default, see git-rev-list[1] and its --no-walk option.\n**-e**: With this option, git revert will let you edit the commit message prior to committing the revert. This is the default if you run the command from a terminal.\n**--edit**: Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent. Reverting a merge commit declares that you will never want the tree changes brought in by the merge. As a result, later merges will only bring in tree changes introduced by commits that are not ancestors of the previously reverted merge. This may or may not be what you want. See the revert-a-faulty-merge How-To for more details.\n**-m parent-number**: With this option, git revert will not start the commit message editor.\n**--mainline parent-number**: This option determines how the commit message will be cleaned up before being passed on to the commit machinery. See git-commit[1] for more details. In particular, if the <mode> is given a value of scissors, scissors will be appended to MERGE_MSG before being passed on in the case of a conflict.\n**--no-edit**: Usually the command automatically creates some commits with commit log messages stating which commits were reverted. This flag applies the changes necessary to revert the named commits to your working tree and the index, but does not make the commits. In addition, when this option is used, your index does not have to match the HEAD commit. The revert is done against the beginning state of your index. This is useful when reverting more than one commits' effect to your index in a row.\n**--cleanup=<mode>**: GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign.\n**-n**: Add a Signed-off-by trailer at the end of the commit message. See the signoff option in git-commit[1] for more information.\n**--no-commit**: Use the given merge strategy. Should only be used once. See the MERGE STRATEGIES section in git-merge[1] for details.\n**-S[<keyid>]**: Pass the merge strategy-specific option through to the merge strategy. See git-merge[1] for details.\n**--gpg-sign[=<keyid>]**: After the rerere mechanism reuses a recorded resolution on the current conflict to update the files in the working tree, allow it to also update the index with the result of resolution. --no-rerere-autoupdate is a good way to double-check what rerere did and catch potential mismerges, before committing the result to the index with a separate git add.\n**--no-gpg-sign**: Instead of starting the body of the log message with \"This reverts <full-object-name-of-the-commit-being-reverted>.\", refer to the commit using \"--pretty=reference\" format (cf. git-log[1]). The revert.reference configuration variable can be used to enable this option by default.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 15,
          "content_length": 6339
        }
      },
      {
        "header": "SEQUENCER SUBCOMMANDS",
        "content": "Continue the operation in progress using the information in .git/sequencer. Can be used to continue after resolving conflicts in a failed cherry-pick or revert.\n\nSkip the current commit and continue with the rest of the sequence.\n\nForget about the current operation in progress. Can be used to clear the sequencer state after a failed cherry-pick or revert.\n\nCancel the operation and return to the pre-sequence state.\n\n**--continue**: Continue the operation in progress using the information in .git/sequencer. Can be used to continue after resolving conflicts in a failed cherry-pick or revert.\n**--skip**: Skip the current commit and continue with the rest of the sequence.\n**--quit**: Forget about the current operation in progress. Can be used to clear the sequencer state after a failed cherry-pick or revert.\n**--abort**: Cancel the operation and return to the pre-sequence state.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 886
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Revert the changes specified by the fourth last commit in HEAD and create a new commit with the reverted changes.\n\nRevert the changes done by commits from the fifth last commit in master (included) to the third last commit in master (included), but do not create any commit with the reverted changes. The revert only modifies the working tree and the index.\n\n**git revert HEAD~3**: Revert the changes specified by the fourth last commit in HEAD and create a new commit with the reverted changes.\n**git revert -n master~5..master~2**: Revert the changes done by commits from the fifth last commit in master (included) to the third last commit in master (included), but do not create any commit with the reverted changes. The revert only modifies the working tree and the index.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 776
        }
      },
      {
        "header": "DISCUSSION",
        "content": "While git creates a basic commit message automatically, it is strongly recommended to explain why the original commit is being reverted. In addition, repeatedly reverting reverts will result in increasingly unwieldy subject lines, for example Reapply \"Reapply \"<original-subject>\"\". Please consider rewording these to be shorter and more unique.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 345
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Everything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there:\n\nSetting this variable to true makes git revert behave as if the --reference option is given.\n\n**revert.reference**: Setting this variable to true makes git revert behave as if the --reference option is given.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 361
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-revert",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "Git",
    "summary": "NAME git-rm - Remove files from the working tree and from the index\n\ngit-rm - Remove files from the working tree and from the index",
    "sections": [
      {
        "header": "NAME",
        "content": "git-rm - Remove files from the working tree and from the index",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 62
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Remove files matching pathspec from the index, or from the working tree and the index. git rm will not remove a file from just your working directory. (There is no option to remove a file only from the working tree and yet keep it in the index; use /bin/rm if you want to do that.) The files being removed have to be identical to the tip of the branch, and no updates to their contents can be staged in the index, though that default behavior can be overridden with the -f option. When --cached is given, the staged content has to match either the tip of the branch or the file on disk, allowing the file to be removed from just the index. When sparse-checkouts are in use (see git-sparse-checkout[1]), git rm will only remove paths within the sparse-checkout patterns.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 769
        }
      },
      {
        "header": "OPTIONS",
        "content": "Files to remove. A leading directory name (e.g. dir to remove dir/file1 and dir/file2) can be given to remove all files in the directory, and recursively all sub-directories, but this requires the -r option to be explicitly given.\n\nThe command removes only the paths that are known to Git.\n\nFile globbing matches across directory boundaries. Thus, given two directories d and d2, there is a difference between using git rm d*' and git rm d/*', as the former will also remove all of directory d2.\n\nFor more details, see the <pathspec> entry in gitglossary[7].\n\nOverride the up-to-date check.\n\nDon’t actually remove any file(s). Instead, just show if they exist in the index and would otherwise be removed by the command.\n\nAllow recursive removal when a leading directory name is given.\n\nThis option can be used to separate command-line options from the list of files, (useful when filenames might be mistaken for command-line options).\n\nUse this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.\n\nExit with a zero status even if no files matched.\n\nAllow updating index entries outside of the sparse-checkout cone. Normally, git rm refuses to update index entries whose paths do not fit within the sparse-checkout cone. See git-sparse-checkout[1] for more.\n\ngit rm normally outputs one line (in the form of an rm command) for each file removed. This option suppresses that output.\n\nPathspec is passed in <file> instead of args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config[1]). See also --pathspec-file-nul and global --literal-pathspecs.\n\nOnly meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).\n\n**<pathspec>...**: Files to remove. A leading directory name (e.g. dir to remove dir/file1 and dir/file2) can be given to remove all files in the directory, and recursively all sub-directories, but this requires the -r option to be explicitly given. The command removes only the paths that are known to Git. File globbing matches across directory boundaries. Thus, given two directories d and d2, there is a difference between using git rm d*' and git rm d/*', as the former will also remove all of directory d2. For more details, see the <pathspec> entry in gitglossary[7].\n**-f**: Override the up-to-date check.\n**--force**: Don’t actually remove any file(s). Instead, just show if they exist in the index and would otherwise be removed by the command.\n**-n**: Allow recursive removal when a leading directory name is given.\n**--dry-run**: This option can be used to separate command-line options from the list of files, (useful when filenames might be mistaken for command-line options).\n**-r**: Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.\n**--**: Exit with a zero status even if no files matched.\n**--cached**: Allow updating index entries outside of the sparse-checkout cone. Normally, git rm refuses to update index entries whose paths do not fit within the sparse-checkout cone. See git-sparse-checkout[1] for more.\n**--ignore-unmatch**: git rm normally outputs one line (in the form of an rm command) for each file removed. This option suppresses that output.\n**--sparse**: Pathspec is passed in <file> instead of args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config[1]). See also --pathspec-file-nul and global --literal-pathspecs.\n**-q**: Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 14,
          "content_length": 4010
        }
      },
      {
        "header": "REMOVING FILES THAT HAVE DISAPPEARED FROM THE FILESYSTEM",
        "content": "There is no option for git rm to remove from the index only the paths that have disappeared from the filesystem. However, depending on the use case, there are several ways that can be done.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 189
        }
      },
      {
        "header": "Using “git commit -a”",
        "content": "If you intend that your next commit should record all modifications of tracked files in the working tree and record all removals of files that have been removed from the working tree with rm (as opposed to git rm), use git commit -a, as it will automatically notice and record all removals. You can also have a similar effect without committing by using git add -u.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 365
        }
      },
      {
        "header": "Using “git add -A”",
        "content": "When accepting a new code drop for a vendor branch, you probably want to record both the removal of paths and additions of new paths as well as modifications of existing paths.\n\nTypically you would first remove all tracked files from the working tree using this command:\n\nand then untar the new code in the working tree. Alternately you could rsync the changes into the working tree.\n\nAfter that, the easiest way to record all removals, additions, and modifications in the working tree is:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit ls-files -z | xargs -0 rm -f\n```",
          "```bash\ngit add -A\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 489
        }
      },
      {
        "header": "Other ways",
        "content": "If all you really want to do is to remove from the index the files that are no longer present in the working tree (perhaps because your working tree is dirty so that you cannot use git commit -a), use the following command:",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit diff --name-only --diff-filter=D -z | xargs -0 git rm --cached\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 223
        }
      },
      {
        "header": "SUBMODULES",
        "content": "Only submodules using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will be removed from the work tree, as their repository lives inside the .git directory of the superproject. If a submodule (or one of those nested inside it) still uses a .git directory, git rm moves the submodules git directory into the superprojects git directory to protect the submodule’s history. If it exists the submodule.<name> section in the gitmodules[5] file will also be removed and that file will be staged (unless --cached or -n are used).\n\nA submodule is considered up to date when the HEAD is the same as recorded in the index, no tracked files are modified and no untracked files that aren’t ignored are present in the submodule’s work tree. Ignored files are deemed expendable and won’t stop a submodule’s work tree from being removed.\n\nIf you only want to remove the local checkout of a submodule from your work tree without committing the removal, use git-submodule[1] deinit instead. Also see gitsubmodules[7] for details on submodule removal.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1062
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Removes all *.txt files from the index that are under the Documentation directory and any of its subdirectories.\n\nNote that the asterisk * is quoted from the shell in this example; this lets Git, and not the shell, expand the pathnames of files and subdirectories under the Documentation/ directory.\n\nBecause this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not remove subdir/git-foo.sh.\n\n**git rm Documentation/\\*.txt**: Removes all *.txt files from the index that are under the Documentation directory and any of its subdirectories. Note that the asterisk * is quoted from the shell in this example; this lets Git, and not the shell, expand the pathnames of files and subdirectories under the Documentation/ directory.\n**git rm -f git-*.sh**: Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not remove subdir/git-foo.sh.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 935
        }
      },
      {
        "header": "BUGS",
        "content": "Each time a superproject update removes a populated submodule (e.g. when switching between commits before and after the removal) a stale submodule checkout will remain in the old location. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. This step will be obsolete when recursive submodule update has been implemented.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 396
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-rm",
    "doc_type": "git",
    "total_sections": 11
  },
  {
    "title": "Git",
    "summary": "SYNOPSIS git shortlog [<options>] [<revision-range>] [[--] <path>…] git log --pretty=short | git shortlog [<options>]",
    "sections": [
      {
        "header": "NAME",
        "content": "git-shortlog - Summarize git log output",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 39
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Summarizes git log output in a format suitable for inclusion in release announcements. Each commit will be grouped by author and title.\n\nAdditionally, \"[PATCH]\" will be stripped from the commit description.\n\nIf no revisions are passed on the command line and either standard input is not a terminal or there is no current branch, git shortlog will output a summary of the log read from standard input, without reference to the current repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 446
        }
      },
      {
        "header": "OPTIONS",
        "content": "Sort output according to the number of commits per author instead of author alphabetic order.\n\nSuppress commit description and provide a commit count summary only.\n\nShow the email address of each author.\n\nInstead of the commit subject, use some other information to describe each commit. <format> can be any string accepted by the --format option of git log, such as * [%h] %s. (See the \"PRETTY FORMATS\" section of git-log[1].)\n\nEach pretty-printed commit will be rewrapped before it is shown.\n\nShow dates formatted according to the given date string. (See the --date option in the \"Commit Formatting\" section of git-log[1]). Useful with --group=format:<format>.\n\nGroup commits based on <type>. If no --group option is specified, the default is author. <type> is one of:\n\nauthor, commits are grouped by author\n\ncommitter, commits are grouped by committer (the same as -c)\n\ntrailer:<field>, the <field> is interpreted as a case-insensitive commit message trailer (see git-interpret-trailers[1]). For example, if your project uses Reviewed-by trailers, you might want to see who has been reviewing with git shortlog -ns --group=trailer:reviewed-by.\n\nformat:<format>, any string accepted by the --format option of git log. (See the \"PRETTY FORMATS\" section of git-log[1].)\n\nNote that commits that do not include the trailer will not be counted. Likewise, commits with multiple trailers (e.g., multiple signoffs) may be counted more than once (but only once per unique trailer value in that commit).\n\nShortlog will attempt to parse each trailer value as a name <email> identity. If successful, the mailmap is applied and the email is omitted unless the --email option is specified. If the value cannot be parsed as an identity, it will be taken literally and completely.\n\nIf --group is specified multiple times, commits are counted under each value (but again, only once per unique value in that commit). For example, git shortlog --group=author --group=trailer:co-authored-by counts both authors and co-authors.\n\nThis is an alias for --group=committer.\n\nLinewrap the output by wrapping each line at width. The first line of each entry is indented by indent1 spaces, and the second and subsequent lines are indented by indent2 spaces. width, indent1, and indent2 default to 76, 6 and 9 respectively.\n\nIf width is 0 (zero) then indent the lines of the output without wrapping them.\n\nShow only commits in the specified revision range. When no <revision-range> is specified, it defaults to HEAD (i.e. the whole history leading to the current commit). origin..HEAD specifies all the commits reachable from the current commit (i.e. HEAD), but not from origin. For a complete list of ways to spell <revision-range>, see the \"Specifying Ranges\" section of gitrevisions[7].\n\nConsider only commits that are enough to explain how the files that match the specified paths came to be.\n\nPaths may need to be prefixed with -- to separate them from options or the revision range, when confusion arises.\n\n• author, commits are grouped by author\n• committer, commits are grouped by committer (the same as -c)\n• trailer:<field>, the <field> is interpreted as a case-insensitive commit message trailer (see git-interpret-trailers[1]). For example, if your project uses Reviewed-by trailers, you might want to see who has been reviewing with git shortlog -ns --group=trailer:reviewed-by.\n• format:<format>, any string accepted by the --format option of git log. (See the \"PRETTY FORMATS\" section of git-log[1].) Note that commits that do not include the trailer will not be counted. Likewise, commits with multiple trailers (e.g., multiple signoffs) may be counted more than once (but only once per unique trailer value in that commit). Shortlog will attempt to parse each trailer value as a name <email> identity. If successful, the mailmap is applied and the email is omitted unless the --email option is specified. If the value cannot be parsed as an identity, it will be taken literally and completely.\n\n**-n**: Sort output according to the number of commits per author instead of author alphabetic order.\n**--numbered**: Suppress commit description and provide a commit count summary only.\n**-s**: Show the email address of each author.\n**--summary**: Instead of the commit subject, use some other information to describe each commit. <format> can be any string accepted by the --format option of git log, such as * [%h] %s. (See the \"PRETTY FORMATS\" section of git-log[1].) Each pretty-printed commit will be rewrapped before it is shown.\n**-e**: Show dates formatted according to the given date string. (See the --date option in the \"Commit Formatting\" section of git-log[1]). Useful with --group=format:<format>.\n**--email**: Group commits based on <type>. If no --group option is specified, the default is author. <type> is one of: author, commits are grouped by author committer, commits are grouped by committer (the same as -c) trailer:<field>, the <field> is interpreted as a case-insensitive commit message trailer (see git-interpret-trailers[1]). For example, if your project uses Reviewed-by trailers, you might want to see who has been reviewing with git shortlog -ns --group=trailer:reviewed-by. format:<format>, any string accepted by the --format option of git log. (See the \"PRETTY FORMATS\" section of git-log[1].) Note that commits that do not include the trailer will not be counted. Likewise, commits with multiple trailers (e.g., multiple signoffs) may be counted more than once (but only once per unique trailer value in that commit). Shortlog will attempt to parse each trailer value as a name <email> identity. If successful, the mailmap is applied and the email is omitted unless the --email option is specified. If the value cannot be parsed as an identity, it will be taken literally and completely. If --group is specified multiple times, commits are counted under each value (but again, only once per unique value in that commit). For example, git shortlog --group=author --group=trailer:co-authored-by counts both authors and co-authors.\n**--format[=<format>]**: This is an alias for --group=committer.\n**--date=<format>**: Linewrap the output by wrapping each line at width. The first line of each entry is indented by indent1 spaces, and the second and subsequent lines are indented by indent2 spaces. width, indent1, and indent2 default to 76, 6 and 9 respectively. If width is 0 (zero) then indent the lines of the output without wrapping them.\n**--group=<type>**: Show only commits in the specified revision range. When no <revision-range> is specified, it defaults to HEAD (i.e. the whole history leading to the current commit). origin..HEAD specifies all the commits reachable from the current commit (i.e. HEAD), but not from origin. For a complete list of ways to spell <revision-range>, see the \"Specifying Ranges\" section of gitrevisions[7].\n**-c**: Consider only commits that are enough to explain how the files that match the specified paths came to be. Paths may need to be prefixed with -- to separate them from options or the revision range, when confusion arises.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 20,
          "content_length": 7090
        }
      },
      {
        "header": "Commit Limiting",
        "content": "Besides specifying a range of commits that should be listed using the special notations explained in the description, additional commit limiting may be applied.\n\nUsing more options generally further limits the output (e.g. --since=<date1> limits to commits newer than <date1>, and using it with --grep=<pattern> further limits to commits whose log message has a line that matches <pattern>), unless otherwise noted.\n\nNote that these are applied before commit ordering and formatting options, such as --reverse.\n\nLimit the output to <number> commits.\n\nSkip <number> commits before starting to show the commit output.\n\nShow commits more recent than <date>.\n\nShow all commits more recent than <date>. This visits all commits in the range, rather than stopping at the first commit which is older than <date>.\n\nShow commits older than <date>.\n\nLimit the commits output to ones with author/committer header lines that match the <pattern> regular expression. With more than one --author=<pattern>, commits whose author matches any of the <pattern> are chosen (similarly for multiple --committer=<pattern>).\n\nLimit the commits output to ones with reflog entries that match the <pattern> regular expression. With more than one --grep-reflog, commits whose reflog message matches any of the given patterns are chosen. It is an error to use this option unless --walk-reflogs is in use.\n\nLimit the commits output to ones with a log message that matches the <pattern> regular expression. With more than one --grep=<pattern>, commits whose message matches any of the <pattern> are chosen (but see --all-match).\n\nWhen --notes is in effect, the message from the notes is matched as if it were part of the log message.\n\nLimit the commits output to ones that match all given --grep, instead of ones that match at least one.\n\nLimit the commits output to ones with a log message that do not match the <pattern> specified with --grep=<pattern>.\n\nMatch the regular expression limiting patterns without regard to letter case.\n\nConsider the limiting patterns to be basic regular expressions; this is the default.\n\nConsider the limiting patterns to be extended regular expressions instead of the default basic regular expressions.\n\nConsider the limiting patterns to be fixed strings (don’t interpret pattern as a regular expression).\n\nConsider the limiting patterns to be Perl-compatible regular expressions.\n\nSupport for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die.\n\nStop when a given path disappears from the tree.\n\nPrint only merge commits. This is exactly the same as --min-parents=2.\n\nDo not print commits with more than one parent. This is exactly the same as --max-parents=1.\n\nShow only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges. --max-parents=0 gives all root commits and --min-parents=3 all octopus merges.\n\n--no-min-parents and --no-max-parents reset these limits (to no limit) again. Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit).\n\nWhen finding commits to include, follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge.\n\nWhen finding commits to exclude (with a ^), follow only the first parent commit upon seeing a merge commit. This can be used to find the set of changes in a topic branch from the point where it diverged from the remote branch, given that arbitrary merges can be valid topic branch changes.\n\nReverses the meaning of the ^ prefix (or lack thereof) for all following revision specifiers, up to the next --not. When used on the command line before --stdin, the revisions passed through stdin will not be affected by it. Conversely, when passed via standard input, the revisions passed on the command line will not be affected by it.\n\nPretend as if all the refs in refs/, along with HEAD, are listed on the command line as <commit>.\n\nPretend as if all the refs in refs/heads are listed on the command line as <commit>. If <pattern> is given, limit branches to ones matching given shell glob. If <pattern> lacks ?, *, or [, /* at the end is implied.\n\nPretend as if all the refs in refs/tags are listed on the command line as <commit>. If <pattern> is given, limit tags to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied.\n\nPretend as if all the refs in refs/remotes are listed on the command line as <commit>. If <pattern> is given, limit remote-tracking branches to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied.\n\nPretend as if all the refs matching shell glob <glob-pattern> are listed on the command line as <commit>. Leading refs/, is automatically prepended if missing. If pattern lacks ?, *, or [, /* at the end is implied.\n\nDo not include refs matching <glob-pattern> that the next --all, --branches, --tags, --remotes, or --glob would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next --all, --branches, --tags, --remotes, or --glob option (other options or arguments do not clear accumulated patterns).\n\nThe patterns given should not begin with refs/heads, refs/tags, or refs/remotes when applied to --branches, --tags, or --remotes, respectively, and they must begin with refs/ when applied to --glob or --all. If a trailing /* is intended, it must be given explicitly.\n\nDo not include refs that would be hidden by git-fetch, git-receive-pack or git-upload-pack by consulting the appropriate fetch.hideRefs, receive.hideRefs or uploadpack.hideRefs configuration along with transfer.hideRefs (see git-config[1]). This option affects the next pseudo-ref option --all or --glob and is cleared after processing them.\n\nPretend as if all objects mentioned by reflogs are listed on the command line as <commit>.\n\nPretend as if all objects mentioned as ref tips of alternate repositories were listed on the command line. An alternate repository is any repository whose object directory is specified in objects/info/alternates. The set of included objects may be modified by core.alternateRefsCommand, etc. See git-config[1].\n\nBy default, all working trees will be examined by the following options when there are more than one (see git-worktree[1]): --all, --reflog and --indexed-objects. This option forces them to examine the current working tree only.\n\nUpon seeing an invalid object name in the input, pretend as if the bad input was not given.\n\nPretend as if the bad bisection ref refs/bisect/bad was listed and as if it was followed by --not and the good bisection refs refs/bisect/good-* on the command line.\n\nIn addition to getting arguments from the command line, read them from standard input as well. This accepts commits and pseudo-options like --all and --glob=. When a -- separator is seen, the following input is treated as paths and used to limit the result. Flags like --not which are read via standard input are only respected for arguments passed in the same way and will not influence any subsequent command line arguments.\n\nLike --cherry-pick (see below) but mark equivalent commits with = rather than omitting them, and inequivalent ones with +.\n\nOmit any commit that introduces the same change as another commit on the “other side” when the set of commits are limited with symmetric difference.\n\nFor example, if you have two branches, A and B, a usual way to list all commits on only one side of them is with --left-right (see the example below in the description of the --left-right option). However, it shows the commits that were cherry-picked from the other branch (for example, “3rd on b” may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output.\n\nList only commits on the respective side of a symmetric difference, i.e. only those which would be marked < resp. > by --left-right.\n\nFor example, --cherry-pick --right-only A...B omits those commits from B which are in A or are patch-equivalent to a commit in A. In other words, this lists the + commits from git cherry A B. More precisely, --cherry-pick --right-only --no-merges gives the exact list.\n\nA synonym for --right-only --cherry-mark --no-merges; useful to limit the output to the commits on our side and mark those that have been applied to the other side of a forked history with git log --cherry upstream...mybranch, similar to git cherry upstream mybranch.\n\nInstead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, ^<commit>, <commit1>..<commit2>, and <commit1>...<commit2> notations cannot be used).\n\nWith --pretty format other than oneline and reference (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as ref@{<Nth>} (where <Nth> is the reverse-chronological index in the reflog) or as ref@{<timestamp>} (with the <timestamp> for that entry), depending on a few rules:\n\nIf the starting point is specified as ref@{<Nth>}, show the index format.\n\nIf the starting point was specified as ref@{now}, show the timestamp format.\n\nIf neither was used, but --date was given on the command line, show the timestamp in the format requested by --date.\n\nOtherwise, show the index format.\n\nUnder --pretty=oneline, the commit message is prefixed with this information on the same line. This option cannot be combined with --reverse. See also git-reflog[1].\n\nUnder --pretty=reference, this information will not be shown at all.\n\nShow commits touching conflicted paths in the range HEAD...<other>, where <other> is the first existing pseudoref in MERGE_HEAD, CHERRY_PICK_HEAD, REVERT_HEAD or REBASE_HEAD. Only works when the index has unmerged entries. This option can be used to show relevant commits when resolving conflicts from a 3-way merge.\n\nOutput excluded boundary commits. Boundary commits are prefixed with -.\n\n• If the starting point is specified as ref@{<Nth>}, show the index format.\n• If the starting point was specified as ref@{now}, show the timestamp format.\n• If neither was used, but --date was given on the command line, show the timestamp in the format requested by --date.\n• Otherwise, show the index format.\n\n**-<number>**: Limit the output to <number> commits.\n**-n <number>**: Skip <number> commits before starting to show the commit output.\n**--max-count=<number>**: Show commits more recent than <date>.\n**--skip=<number>**: Show all commits more recent than <date>. This visits all commits in the range, rather than stopping at the first commit which is older than <date>.\n**--since=<date>**: Show commits older than <date>.\n**--after=<date>**: Limit the commits output to ones with author/committer header lines that match the <pattern> regular expression. With more than one --author=<pattern>, commits whose author matches any of the <pattern> are chosen (similarly for multiple --committer=<pattern>).\n**--since-as-filter=<date>**: Limit the commits output to ones with reflog entries that match the <pattern> regular expression. With more than one --grep-reflog, commits whose reflog message matches any of the given patterns are chosen. It is an error to use this option unless --walk-reflogs is in use.\n**--until=<date>**: Limit the commits output to ones with a log message that matches the <pattern> regular expression. With more than one --grep=<pattern>, commits whose message matches any of the <pattern> are chosen (but see --all-match). When --notes is in effect, the message from the notes is matched as if it were part of the log message.\n**--before=<date>**: Limit the commits output to ones that match all given --grep, instead of ones that match at least one.\n**--author=<pattern>**: Limit the commits output to ones with a log message that do not match the <pattern> specified with --grep=<pattern>.\n**--committer=<pattern>**: Match the regular expression limiting patterns without regard to letter case.\n**--grep-reflog=<pattern>**: Consider the limiting patterns to be basic regular expressions; this is the default.\n**--grep=<pattern>**: Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions.\n**--all-match**: Consider the limiting patterns to be fixed strings (don’t interpret pattern as a regular expression).\n**--invert-grep**: Consider the limiting patterns to be Perl-compatible regular expressions. Support for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die.\n**-i**: Stop when a given path disappears from the tree.\n**--regexp-ignore-case**: Print only merge commits. This is exactly the same as --min-parents=2.\n**--basic-regexp**: Do not print commits with more than one parent. This is exactly the same as --max-parents=1.\n**-E**: Show only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges. --max-parents=0 gives all root commits and --min-parents=3 all octopus merges. --no-min-parents and --no-max-parents reset these limits (to no limit) again. Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit).\n**--extended-regexp**: When finding commits to include, follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge.\n**-F**: When finding commits to exclude (with a ^), follow only the first parent commit upon seeing a merge commit. This can be used to find the set of changes in a topic branch from the point where it diverged from the remote branch, given that arbitrary merges can be valid topic branch changes.\n**--fixed-strings**: Reverses the meaning of the ^ prefix (or lack thereof) for all following revision specifiers, up to the next --not. When used on the command line before --stdin, the revisions passed through stdin will not be affected by it. Conversely, when passed via standard input, the revisions passed on the command line will not be affected by it.\n**-P**: Pretend as if all the refs in refs/, along with HEAD, are listed on the command line as <commit>.\n**--perl-regexp**: Pretend as if all the refs in refs/heads are listed on the command line as <commit>. If <pattern> is given, limit branches to ones matching given shell glob. If <pattern> lacks ?, *, or [, /* at the end is implied.\n**--remove-empty**: Pretend as if all the refs in refs/tags are listed on the command line as <commit>. If <pattern> is given, limit tags to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied.\n**--merges**: Pretend as if all the refs in refs/remotes are listed on the command line as <commit>. If <pattern> is given, limit remote-tracking branches to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied.\n**--no-merges**: Pretend as if all the refs matching shell glob <glob-pattern> are listed on the command line as <commit>. Leading refs/, is automatically prepended if missing. If pattern lacks ?, *, or [, /* at the end is implied.\n**--min-parents=<number>**: Do not include refs matching <glob-pattern> that the next --all, --branches, --tags, --remotes, or --glob would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next --all, --branches, --tags, --remotes, or --glob option (other options or arguments do not clear accumulated patterns). The patterns given should not begin with refs/heads, refs/tags, or refs/remotes when applied to --branches, --tags, or --remotes, respectively, and they must begin with refs/ when applied to --glob or --all. If a trailing /* is intended, it must be given explicitly.\n**--max-parents=<number>**: Do not include refs that would be hidden by git-fetch, git-receive-pack or git-upload-pack by consulting the appropriate fetch.hideRefs, receive.hideRefs or uploadpack.hideRefs configuration along with transfer.hideRefs (see git-config[1]). This option affects the next pseudo-ref option --all or --glob and is cleared after processing them.\n**--no-min-parents**: Pretend as if all objects mentioned by reflogs are listed on the command line as <commit>.\n**--no-max-parents**: Pretend as if all objects mentioned as ref tips of alternate repositories were listed on the command line. An alternate repository is any repository whose object directory is specified in objects/info/alternates. The set of included objects may be modified by core.alternateRefsCommand, etc. See git-config[1].\n**--first-parent**: By default, all working trees will be examined by the following options when there are more than one (see git-worktree[1]): --all, --reflog and --indexed-objects. This option forces them to examine the current working tree only.\n**--exclude-first-parent-only**: Upon seeing an invalid object name in the input, pretend as if the bad input was not given.\n**--not**: Pretend as if the bad bisection ref refs/bisect/bad was listed and as if it was followed by --not and the good bisection refs refs/bisect/good-* on the command line.\n**--all**: In addition to getting arguments from the command line, read them from standard input as well. This accepts commits and pseudo-options like --all and --glob=. When a -- separator is seen, the following input is treated as paths and used to limit the result. Flags like --not which are read via standard input are only respected for arguments passed in the same way and will not influence any subsequent command line arguments.\n**--branches[=<pattern>]**: Like --cherry-pick (see below) but mark equivalent commits with = rather than omitting them, and inequivalent ones with +.\n**--tags[=<pattern>]**: Omit any commit that introduces the same change as another commit on the “other side” when the set of commits are limited with symmetric difference. For example, if you have two branches, A and B, a usual way to list all commits on only one side of them is with --left-right (see the example below in the description of the --left-right option). However, it shows the commits that were cherry-picked from the other branch (for example, “3rd on b” may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output.\n**--remotes[=<pattern>]**: List only commits on the respective side of a symmetric difference, i.e. only those which would be marked < resp. > by --left-right. For example, --cherry-pick --right-only A...B omits those commits from B which are in A or are patch-equivalent to a commit in A. In other words, this lists the + commits from git cherry A B. More precisely, --cherry-pick --right-only --no-merges gives the exact list.\n**--glob=<glob-pattern>**: A synonym for --right-only --cherry-mark --no-merges; useful to limit the output to the commits on our side and mark those that have been applied to the other side of a forked history with git log --cherry upstream...mybranch, similar to git cherry upstream mybranch.\n**--exclude=<glob-pattern>**: Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, ^<commit>, <commit1>..<commit2>, and <commit1>...<commit2> notations cannot be used). With --pretty format other than oneline and reference (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as ref@{<Nth>} (where <Nth> is the reverse-chronological index in the reflog) or as ref@{<timestamp>} (with the <timestamp> for that entry), depending on a few rules: If the starting point is specified as ref@{<Nth>}, show the index format. If the starting point was specified as ref@{now}, show the timestamp format. If neither was used, but --date was given on the command line, show the timestamp in the format requested by --date. Otherwise, show the index format. Under --pretty=oneline, the commit message is prefixed with this information on the same line. This option cannot be combined with --reverse. See also git-reflog[1]. Under --pretty=reference, this information will not be shown at all.\n**--exclude-hidden=(fetch|receive|uploadpack)**: Show commits touching conflicted paths in the range HEAD...<other>, where <other> is the first existing pseudoref in MERGE_HEAD, CHERRY_PICK_HEAD, REVERT_HEAD or REBASE_HEAD. Only works when the index has unmerged entries. This option can be used to show relevant commits when resolving conflicts from a 3-way merge.\n**--reflog**: Output excluded boundary commits. Boundary commits are prefixed with -.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 58,
          "content_length": 21525
        }
      },
      {
        "header": "History Simplification",
        "content": "Sometimes you are only interested in parts of the history, for example the commits modifying a particular <path>. But there are two parts of History Simplification, one part is selecting the commits and the other is how to do it, as there are various strategies to simplify the history.\n\nThe following options select the commits to be shown:\n\nCommits modifying the given <paths> are selected.\n\nCommits that are referred by some branch or tag are selected.\n\nNote that extra commits can be shown to give a meaningful history.\n\nThe following options affect the way the simplification is performed:\n\nSimplifies the history to the simplest history explaining the final state of the tree. Simplest because it prunes some side branches if the end result is the same (i.e. merging branches with the same content)\n\nInclude all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent. This mode is helpful for showing the merge commits that \"first introduced\" a change to a branch.\n\nSame as the default mode, but does not prune some history.\n\nOnly the selected commits are shown, plus some to have a meaningful history.\n\nAll commits in the simplified history are shown.\n\nAdditional option to --full-history to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge.\n\nWhen given a range of commits to display (e.g. <commit1>..<commit2> or <commit2> ^<commit1>), and a commit <commit> in that range, only display commits in that range that are ancestors of <commit>, descendants of <commit>, or <commit> itself. If no commit is specified, use <commit1> (the excluded part of the range) as <commit>. Can be passed multiple times; if so, a commit is included if it is any of the commits given or if it is an ancestor or descendant of one of them.\n\nA more detailed explanation follows.\n\nSuppose you specified foo as the <paths>. We shall call commits that modify foo !TREESAME, and the rest TREESAME. (In a diff filtered for foo, they look different and equal, respectively.)\n\nIn the following, we will always refer to the same example history to illustrate the differences between simplification settings. We assume that you are filtering for a file foo in this commit graph:\n\nThe horizontal line of history A---Q is taken to be the first parent of each merge. The commits are:\n\nI is the initial commit, in which foo exists with contents asdf, and a file quux exists with contents quux. Initial commits are compared to an empty tree, so I is !TREESAME.\n\nIn A, foo contains just foo.\n\nB contains the same change as A. Its merge M is trivial and hence TREESAME to all parents.\n\nC does not change foo, but its merge N changes it to foobar, so it is not TREESAME to any parent.\n\nD sets foo to baz. Its merge O combines the strings from N and D to foobarbaz; i.e., it is not TREESAME to any parent.\n\nE changes quux to xyzzy, and its merge P combines the strings to quux xyzzy. P is TREESAME to O, but not to E.\n\nX is an independent root commit that added a new file side, and Y modified it. Y is TREESAME to X. Its merge Q added side to P, and Q is TREESAME to P, but not to Y.\n\nrev-list walks backwards through history, including or excluding commits based on whether --full-history and/or parent rewriting (via --parents or --children) are used. The following settings are available.\n\nCommits are included if they are not TREESAME to any parent (though this can be changed, see --sparse below). If the commit was a merge, and it was TREESAME to one parent, follow only that parent. (Even if there are several TREESAME parents, follow only one of them.) Otherwise, follow all parents.\n\nNote how the rule to only follow the TREESAME parent, if one is available, removed B from consideration entirely. C was considered via N, but is TREESAME. Root commits are compared to an empty tree, so I is !TREESAME.\n\nParent/child relations are only visible with --parents, but that does not affect the commits selected in default mode, so we have shown the parent lines.\n\nThis mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is! In the example, we get\n\nM was excluded because it is TREESAME to both parents. E, C and B were all walked, but only B was !TREESAME, so the others do not appear.\n\nNote that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected.\n\nOrdinary commits are only included if they are !TREESAME (though this can be changed, see --sparse below).\n\nMerges are always included. However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves. This results in\n\nCompare to --full-history without rewriting above. Note that E was pruned away because it is TREESAME, but the parent list of P was rewritten to contain E's parent I. The same happened for C and N, and X, Y and Q.\n\nIn addition to the above settings, you can change whether TREESAME affects inclusion:\n\nCommits that are walked are included if they are not TREESAME to any parent.\n\nAll commits that are walked are included.\n\nNote that without --full-history, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked.\n\nFirst, build a history graph in the same way that --full-history with parent rewriting does (see above).\n\nThen simplify each commit C to its replacement C' in the final history according to the following rules:\n\nReplace each parent P of C' with its simplification P'. In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to.\n\nIf after this parent rewriting, C' is a root or merge commit (has zero or >1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent.\n\nThe effect of this is best shown by way of comparing to --full-history with parent rewriting. The example turns into:\n\nNote the major differences in N, P, and Q over --full-history:\n\nN's parent list had I removed, because it is an ancestor of the other parent M. Still, N remained because it is !TREESAME.\n\nP's parent list similarly had I removed. P was then removed completely, because it had one parent and is TREESAME.\n\nQ's parent list had Y simplified to X. X was then removed, because it was a TREESAME root. Q was then removed completely, because it had one parent and is TREESAME.\n\nThere is another simplification mode available:\n\nLimit the displayed commits to those which are an ancestor of <commit>, or which are a descendant of <commit>, or are <commit> itself.\n\nAs an example use case, consider the following commit history:\n\nA regular D..M computes the set of commits that are ancestors of M, but excludes the ones that are ancestors of D. This is useful to see what happened to the history leading to M since D, in the sense that \"what does M have that did not exist in D\". The result in this example would be all the commits, except A and B (and D itself, of course).\n\nWhen we want to find out what commits in M are contaminated with the bug introduced by D and need fixing, however, we might want to view only the subset of D..M that are actually descendants of D, i.e. excluding C and K. This is exactly what the --ancestry-path option does. Applied to the D..M range, it results in:\n\nWe can also use --ancestry-path=D instead of --ancestry-path which means the same thing when applied to the D..M range but is just more explicit.\n\nIf we instead are interested in a given topic within this range, and all commits affected by that topic, we may only want to view the subset of D..M which contain that topic in their ancestry path. So, using --ancestry-path=H D..M for example would result in:\n\nWhereas --ancestry-path=K D..M would result in\n\nBefore discussing another option, --show-pulls, we need to create a new example history.\n\nA common problem users face when looking at simplified history is that a commit they know changed a file somehow does not appear in the file’s simplified history. Let’s demonstrate a new example and show how options such as --full-history and --simplify-merges works in that case:\n\nFor this example, suppose I created file.txt which was modified by A, B, and X in different ways. The single-parent commits C, Z, and Y do not change file.txt. The merge commit M was created by resolving the merge conflict to include both changes from A and B and hence is not TREESAME to either. The merge commit R, however, was created by ignoring the contents of file.txt at M and taking only the contents of file.txt at X. Hence, R is TREESAME to X but not M. Finally, the natural merge resolution to create N is to take the contents of file.txt at R, so N is TREESAME to R but not C. The merge commits O and P are TREESAME to their first parents, but not to their second parents, Z and Y respectively.\n\nWhen using the default mode, N and R both have a TREESAME parent, so those edges are walked and the others are ignored. The resulting history graph is:\n\nWhen using --full-history, Git walks every edge. This will discover the commits A and B and the merge M, but also will reveal the merge commits O and P. With parent rewriting, the resulting graph is:\n\nHere, the merge commits O and P contribute extra noise, as they did not actually contribute a change to file.txt. They only merged a topic that was based on an older version of file.txt. This is a common issue in repositories using a workflow where many contributors work in parallel and merge their topic branches along a single trunk: many unrelated merges appear in the --full-history results.\n\nWhen using the --simplify-merges option, the commits O and P disappear from the results. This is because the rewritten second parents of O and P are reachable from their first parents. Those edges are removed and then the commits look like single-parent commits that are TREESAME to their parent. This also happens to the commit N, resulting in a history view as follows:\n\nIn this view, we see all of the important single-parent changes from A, B, and X. We also see the carefully-resolved merge M and the not-so-carefully-resolved merge R. This is usually enough information to determine why the commits A and B \"disappeared\" from history in the default view. However, there are a few issues with this approach.\n\nThe first issue is performance. Unlike any previous option, the --simplify-merges option requires walking the entire commit history before returning a single result. This can make the option difficult to use for very large repositories.\n\nThe second issue is one of auditing. When many contributors are working on the same repository, it is important which merge commits introduced a change into an important branch. The problematic merge R above is not likely to be the merge commit that was used to merge into an important branch. Instead, the merge N was used to merge R and X into the important branch. This commit may have information about why the change X came to override the changes from A and B in its commit message.\n\nIn addition to the commits shown in the default history, show each merge commit that is not TREESAME to its first parent but is TREESAME to a later parent.\n\nWhen a merge commit is included by --show-pulls, the merge is treated as if it \"pulled\" the change from another branch. When using --show-pulls on this example (and no other options) the resulting graph is:\n\nHere, the merge commits R and N are included because they pulled the commits X and R into the base branch, respectively. These merges are the reason the commits A and B do not appear in the default history.\n\nWhen --show-pulls is paired with --simplify-merges, the graph includes all of the necessary information:\n\nNotice that since M is reachable from R, the edge from N to M was simplified away. However, N still appears in the history as an important commit because it \"pulled\" the change R into the main branch.\n\nThe --simplify-by-decoration option allows you to view only the big picture of the topology of the history, by omitting commits that are not referenced by tags. Commits are marked as !TREESAME (in other words, kept after history simplification rules described above) if (1) they are referenced by tags, or (2) they change the contents of the paths given on the command line. All other commits are marked as TREESAME (subject to be simplified away).\n\n• I is the initial commit, in which foo exists with contents asdf, and a file quux exists with contents quux. Initial commits are compared to an empty tree, so I is !TREESAME.\n• In A, foo contains just foo.\n• B contains the same change as A. Its merge M is trivial and hence TREESAME to all parents.\n• C does not change foo, but its merge N changes it to foobar, so it is not TREESAME to any parent.\n• D sets foo to baz. Its merge O combines the strings from N and D to foobarbaz; i.e., it is not TREESAME to any parent.\n• E changes quux to xyzzy, and its merge P combines the strings to quux xyzzy. P is TREESAME to O, but not to E.\n• X is an independent root commit that added a new file side, and Y modified it. Y is TREESAME to X. Its merge Q added side to P, and Q is TREESAME to P, but not to Y.\n\n• Set C' to C.\n• Replace each parent P of C' with its simplification P'. In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to.\n• If after this parent rewriting, C' is a root or merge commit (has zero or >1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent.\n\n• N's parent list had I removed, because it is an ancestor of the other parent M. Still, N remained because it is !TREESAME.\n• P's parent list similarly had I removed. P was then removed completely, because it had one parent and is TREESAME.\n• Q's parent list had Y simplified to X. X was then removed, because it was a TREESAME root. Q was then removed completely, because it had one parent and is TREESAME.\n\n**<paths>**: Commits modifying the given <paths> are selected.\n**--simplify-by-decoration**: Commits that are referred by some branch or tag are selected.\n**Default mode**: Simplifies the history to the simplest history explaining the final state of the tree. Simplest because it prunes some side branches if the end result is the same (i.e. merging branches with the same content)\n**--show-pulls**: Include all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent. This mode is helpful for showing the merge commits that \"first introduced\" a change to a branch.\n**--full-history**: Same as the default mode, but does not prune some history.\n**--dense**: Only the selected commits are shown, plus some to have a meaningful history.\n**--sparse**: All commits in the simplified history are shown.\n**--simplify-merges**: Additional option to --full-history to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge.\n**--ancestry-path[=<commit>]**: When given a range of commits to display (e.g. <commit1>..<commit2> or <commit2> ^<commit1>), and a commit <commit> in that range, only display commits in that range that are ancestors of <commit>, descendants of <commit>, or <commit> itself. If no commit is specified, use <commit1> (the excluded part of the range) as <commit>. Can be passed multiple times; if so, a commit is included if it is any of the commits given or if it is an ancestor or descendant of one of them.\n**Default mode**: Commits are included if they are not TREESAME to any parent (though this can be changed, see --sparse below). If the commit was a merge, and it was TREESAME to one parent, follow only that parent. (Even if there are several TREESAME parents, follow only one of them.) Otherwise, follow all parents. This results in: .-A---N---O / / / I---------D Note how the rule to only follow the TREESAME parent, if one is available, removed B from consideration entirely. C was considered via N, but is TREESAME. Root commits are compared to an empty tree, so I is !TREESAME. Parent/child relations are only visible with --parents, but that does not affect the commits selected in default mode, so we have shown the parent lines.\n**--full-history without parent rewriting**: This mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is! In the example, we get I A B N D O P Q M was excluded because it is TREESAME to both parents. E, C and B were all walked, but only B was !TREESAME, so the others do not appear. Note that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected.\n**--full-history with parent rewriting**: Ordinary commits are only included if they are !TREESAME (though this can be changed, see --sparse below). Merges are always included. However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves. This results in .-A---M---N---O---P---Q / / / / / I B / D / \\ / / / / `-------------' Compare to --full-history without rewriting above. Note that E was pruned away because it is TREESAME, but the parent list of P was rewritten to contain E's parent I. The same happened for C and N, and X, Y and Q.\n**--dense**: Commits that are walked are included if they are not TREESAME to any parent.\n**--sparse**: All commits that are walked are included. Note that without --full-history, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked.\n**--simplify-merges**: First, build a history graph in the same way that --full-history with parent rewriting does (see above). Then simplify each commit C to its replacement C' in the final history according to the following rules: Set C' to C. Replace each parent P of C' with its simplification P'. In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to. If after this parent rewriting, C' is a root or merge commit (has zero or >1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent. The effect of this is best shown by way of comparing to --full-history with parent rewriting. The example turns into: .-A---M---N---O / / / I B D \\ / / `---------' Note the major differences in N, P, and Q over --full-history: N's parent list had I removed, because it is an ancestor of the other parent M. Still, N remained because it is !TREESAME. P's parent list similarly had I removed. P was then removed completely, because it had one parent and is TREESAME. Q's parent list had Y simplified to X. X was then removed, because it was a TREESAME root. Q was then removed completely, because it had one parent and is TREESAME.\n**--ancestry-path[=<commit>]**: Limit the displayed commits to those which are an ancestor of <commit>, or which are a descendant of <commit>, or are <commit> itself. As an example use case, consider the following commit history: D---E-------F / \\ \\ B---C---G---H---I---J / \\ A-------K---------------L--M A regular D..M computes the set of commits that are ancestors of M, but excludes the ones that are ancestors of D. This is useful to see what happened to the history leading to M since D, in the sense that \"what does M have that did not exist in D\". The result in this example would be all the commits, except A and B (and D itself, of course). When we want to find out what commits in M are contaminated with the bug introduced by D and need fixing, however, we might want to view only the subset of D..M that are actually descendants of D, i.e. excluding C and K. This is exactly what the --ancestry-path option does. Applied to the D..M range, it results in: E-------F \\ \\ G---H---I---J \\ L--M We can also use --ancestry-path=D instead of --ancestry-path which means the same thing when applied to the D..M range but is just more explicit. If we instead are interested in a given topic within this range, and all commits affected by that topic, we may only want to view the subset of D..M which contain that topic in their ancestry path. So, using --ancestry-path=H D..M for example would result in: E \\ C---G---H---I---J \\ L--M Whereas --ancestry-path=K D..M would result in K---------------L--M\n**--show-pulls**: In addition to the commits shown in the default history, show each merge commit that is not TREESAME to its first parent but is TREESAME to a later parent. When a merge commit is included by --show-pulls, the merge is treated as if it \"pulled\" the change from another branch. When using --show-pulls on this example (and no other options) the resulting graph is: I---X---R---N Here, the merge commits R and N are included because they pulled the commits X and R into the base branch, respectively. These merges are the reason the commits A and B do not appear in the default history. When --show-pulls is paired with --simplify-merges, the graph includes all of the necessary information: .-A---M--. N / / \\ / I B R \\ / / \\ / / `---X--' Notice that since M is reachable from R, the edge from N to M was simplified away. However, N still appears in the history as an important commit because it \"pulled\" the change R into the main branch.",
        "code_examples": [
          "```bash\n.-A---M---N---O---P---Q\n\t /     /   /   /   /   /\n\tI     B   C   D   E   Y\n\t \\   /   /   /   /   /\n\t  `-------------'   X\n```",
          "```bash\n.-A---N---O\n\t /     /   /\n\tI---------D\n```",
          "```bash\nI  A  B  N  D  O  P  Q\n```",
          "```bash\n.-A---M---N---O---P---Q\n\t /     /   /   /   /\n\tI     B   /   D   /\n\t \\   /   /   /   /\n\t  `-------------'\n```",
          "```bash\n.-A---M---N---O\n\t /     /       /\n\tI     B       D\n\t \\   /       /\n\t  `---------'\n```",
          "```bash\nD---E-------F\n\t   /     \\       \\\n\t  B---C---G---H---I---J\n\t /                     \\\n\tA-------K---------------L--M\n```",
          "```bash\nE-------F\n\t\t \\       \\\n\t\t  G---H---I---J\n\t\t\t       \\\n\t\t\t\tL--M\n```",
          "```bash\nE\n\t\t \\\n\t      C---G---H---I---J\n\t\t\t       \\\n\t\t\t\tL--M\n```",
          "```bash\nK---------------L--M\n```",
          "```bash\n.-A---M-----C--N---O---P\n\t /     / \\  \\  \\/   /   /\n\tI     B   \\  R-'`-Z'   /\n\t \\   /     \\/         /\n\t  \\ /      /\\        /\n\t   `---X--'  `---Y--'\n```",
          "```bash\n.-A---M--------N---O---P\n\t /     / \\  \\  \\/   /   /\n\tI     B   \\  R-'`--'   /\n\t \\   /     \\/         /\n\t  \\ /      /\\        /\n\t   `---X--'  `------'\n```",
          "```bash\n.-A---M--.\n\t /     /    \\\n\tI     B      R\n\t \\   /      /\n\t  \\ /      /\n\t   `---X--'\n```",
          "```bash\nI---X---R---N\n```",
          "```bash\n.-A---M--.   N\n\t /     /    \\ /\n\tI     B      R\n\t \\   /      /\n\t  \\ /      /\n\t   `---X--'\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 71,
          "content_length": 22013
        }
      },
      {
        "header": "MAPPING AUTHORS",
        "content": "Note that if git shortlog is run outside of a repository (to process log contents on standard input), it will look for a .mailmap file in the current directory.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 160
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-shortlog",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "Git",
    "summary": "",
    "sections": [
      {
        "header": "NAME",
        "content": "git-show - Show various types of objects",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 40
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Shows one or more objects (blobs, trees, tags and commits).\n\nFor commits it shows the log message and textual diff. It also presents the merge commit in a special format as produced by git diff-tree --cc.\n\nFor tags, it shows the tag message and the referenced objects.\n\nFor trees, it shows the names (equivalent to git ls-tree with --name-only).\n\nFor plain blobs, it shows the plain contents.\n\nSome options that git log command understands can be used to control how the changes the commit introduces are shown.\n\nThis manual page describes only the most frequently used options.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 578
        }
      },
      {
        "header": "OPTIONS",
        "content": "The names of objects to show (defaults to HEAD). For a more complete list of ways to spell object names, see \"SPECIFYING REVISIONS\" section in gitrevisions[7].\n\nPretty-print the contents of the commit logs in a given format, where <format> can be one of oneline, short, medium, full, fuller, reference, email, raw, format:<string> and tformat:<string>. When <format> is none of the above, and has %<placeholder> in it, it acts as if --pretty=tformat:<format> were given.\n\nSee the \"PRETTY FORMATS\" section for some additional details for each format. When =<format> part is omitted, it defaults to medium.\n\nInstead of showing the full 40-byte hexadecimal commit object name, show a prefix that names the object uniquely. --abbrev=<n> (which also modifies diff output, if it is displayed) option can be used to specify the minimum length of the prefix.\n\nThis should make --pretty=oneline a whole lot more readable for people using 80-column terminals.\n\nShow the full 40-byte hexadecimal commit object name. This negates --abbrev-commit, either explicit or implied by other options such as --oneline. It also overrides the log.abbrevCommit variable.\n\nThis is a shorthand for --pretty=oneline --abbrev-commit used together.\n\nCommit objects record the character encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user. For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in X and we are outputting in X, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output. Likewise, if iconv(3) fails to convert the commit, we will quietly output the original object verbatim.\n\nPerform a tab expansion (replace each tab with enough spaces to fill to the next display column that is a multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion.\n\nBy default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e. medium, which is the default, full, and fuller).\n\nShow the notes (see git-notes[1]) that annotate the commit, when showing the commit log message. This is the default for git log, git show and git whatchanged commands when there is no --pretty, --format, or --oneline option given on the command line.\n\nBy default, the notes shown are from the notes refs listed in the core.notesRef and notes.displayRef variables (or corresponding environment overrides). See git-config[1] for more details.\n\nWith an optional <ref> argument, use the ref to find the notes to display. The ref can specify the full refname when it begins with refs/notes/; when it begins with notes/, refs/ and otherwise refs/notes/ is prefixed to form the full name of the ref.\n\nMultiple --notes options can be combined to control which notes are being displayed. Examples: \"--notes=foo\" will show only notes from refs/notes/foo; \"--notes=foo --notes\" will show both notes from \"refs/notes/foo\" and from the default notes ref(s).\n\nDo not show notes. This negates the above --notes option, by resetting the list of notes refs from which notes are shown. Options are parsed in the order given on the command line, so e.g. \"--notes --notes=foo --no-notes --notes=bar\" will only show notes from refs/notes/bar.\n\nShow the default notes unless options for displaying specific notes are given.\n\nThese options are deprecated. Use the above --notes/--no-notes options instead.\n\nCheck the validity of a signed commit object by passing the signature to gpg --verify and show the output.\n\n**<object>…**: The names of objects to show (defaults to HEAD). For a more complete list of ways to spell object names, see \"SPECIFYING REVISIONS\" section in gitrevisions[7].\n**--pretty[=<format>]**: Pretty-print the contents of the commit logs in a given format, where <format> can be one of oneline, short, medium, full, fuller, reference, email, raw, format:<string> and tformat:<string>. When <format> is none of the above, and has %<placeholder> in it, it acts as if --pretty=tformat:<format> were given. See the \"PRETTY FORMATS\" section for some additional details for each format. When =<format> part is omitted, it defaults to medium. Note you can specify the default pretty format in the repository configuration (see git-config[1]).\n**--format=<format>**: Instead of showing the full 40-byte hexadecimal commit object name, show a prefix that names the object uniquely. --abbrev=<n> (which also modifies diff output, if it is displayed) option can be used to specify the minimum length of the prefix. This should make --pretty=oneline a whole lot more readable for people using 80-column terminals.\n**--abbrev-commit**: Show the full 40-byte hexadecimal commit object name. This negates --abbrev-commit, either explicit or implied by other options such as --oneline. It also overrides the log.abbrevCommit variable.\n**--no-abbrev-commit**: This is a shorthand for --pretty=oneline --abbrev-commit used together.\n**--oneline**: Commit objects record the character encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user. For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in X and we are outputting in X, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output. Likewise, if iconv(3) fails to convert the commit, we will quietly output the original object verbatim.\n**--encoding=<encoding>**: Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is a multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion. By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e. medium, which is the default, full, and fuller).\n**--expand-tabs=<n>**: Show the notes (see git-notes[1]) that annotate the commit, when showing the commit log message. This is the default for git log, git show and git whatchanged commands when there is no --pretty, --format, or --oneline option given on the command line. By default, the notes shown are from the notes refs listed in the core.notesRef and notes.displayRef variables (or corresponding environment overrides). See git-config[1] for more details. With an optional <ref> argument, use the ref to find the notes to display. The ref can specify the full refname when it begins with refs/notes/; when it begins with notes/, refs/ and otherwise refs/notes/ is prefixed to form the full name of the ref. Multiple --notes options can be combined to control which notes are being displayed. Examples: \"--notes=foo\" will show only notes from refs/notes/foo; \"--notes=foo --notes\" will show both notes from \"refs/notes/foo\" and from the default notes ref(s).\n**--expand-tabs**: Do not show notes. This negates the above --notes option, by resetting the list of notes refs from which notes are shown. Options are parsed in the order given on the command line, so e.g. \"--notes --notes=foo --no-notes --notes=bar\" will only show notes from refs/notes/bar.\n**--no-expand-tabs**: Show the default notes unless options for displaying specific notes are given.\n**--notes[=<ref>]**: These options are deprecated. Use the above --notes/--no-notes options instead.\n**--no-notes**: Check the validity of a signed commit object by passing the signature to gpg --verify and show the output.\n\nNote | you can specify the default pretty format in the repository configuration (see git-config[1]).\n\n[Note] Note you can specify the default pretty format in the repository configuration (see git-config[1]).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 18,
          "content_length": 8023
        }
      },
      {
        "header": "PRETTY FORMATS",
        "content": "If the commit is a merge, and if the pretty-format is not oneline, email or raw, an additional line is inserted before the Author: line. This line begins with \"Merge: \" and the hashes of ancestral commits are printed, separated by spaces. Note that the listed commits may not necessarily be the list of the direct parent commits if you have limited your view of history: for example, if you are only interested in changes related to a certain directory or file.\n\nThere are several built-in formats, and you can define additional formats by setting a pretty.<name> config option to either another format name, or a format: string, as described below (see git-config[1]). Here are the details of the built-in formats:\n\nThis is designed to be as compact as possible.\n\nThis format is used to refer to another commit in a commit message and is the same as --pretty='format:%C(auto)%h (%s, %ad). By default, the date is formatted with --date=short unless another --date option is explicitly specified. As with any format: with format placeholders, its output is not affected by other options like --decorate and --walk-reflogs.\n\nLike email, but lines in the commit message starting with \"From \" (preceded by zero or more \">\") are quoted with \">\" so they aren’t confused as starting a new commit.\n\nThe raw format shows the entire commit exactly as stored in the commit object. Notably, the hashes are displayed in full, regardless of whether --abbrev or --no-abbrev are used, and parents information show the true parent commits, without taking grafts or history simplification into account. Note that this format affects the way commits are displayed, but not the way the diff is shown e.g. with git log --raw. To get full object names in a raw diff format, use --no-abbrev.\n\nformat:<format-string>\n\nThe format:<format-string> format allows you to specify which information you want to show. It works a little bit like printf format, with the notable exception that you get a newline with %n instead of \\n.\n\nE.g, format:\"The author of %h was %an, %ar%nThe title was >>%s<<%n\" would show something like this:\n\nThe placeholders are:\n\nPlaceholders that expand to a single literal character:\n\n%x followed by two hexadecimal digits is replaced with a byte with the hexadecimal digits' value (we will call this \"literal formatting code\" in the rest of this document).\n\nPlaceholders that affect formatting of later placeholders:\n\nswitch color to green\n\nswitch color to blue\n\ncolor specification, as described under Values in the \"CONFIGURATION FILE\" section of git-config[1]. By default, colors are shown only when enabled for log output (by color.diff, color.ui, or --color, and respecting the auto settings of the former if we are going to a terminal). %C(auto,<spec>) is accepted as a historical synonym for the default (e.g., %C(auto,red)). Specifying %C(always,<spec>) will show the colors even when color is not otherwise enabled (though consider just using --color=always to enable color for the whole output, including this format and anything else git might color). auto alone (i.e. %C(auto)) will turn on auto coloring on the next placeholders until the color is switched again.\n\nleft (<), right (>) or boundary (-) mark\n\nswitch line wrapping, like the -w option of git-shortlog[1].\n\nmake the next placeholder take at least N column widths, padding spaces on the right if necessary. Optionally truncate (with ellipsis ..) at the left (ltrunc) ..ft, the middle (mtrunc) mi..le, or the end (trunc) rig.., if the output is longer than <n> columns. Note 1: that truncating only works correctly with <n> >= 2. Note 2: spaces around the <n> and <m> (see below) values are optional. Note 3: Emojis and other wide characters will take two display columns, which may over-run column boundaries. Note 4: decomposed character combining marks may be misplaced at padding boundaries.\n\nmake the next placeholder take at least until <m> th display column, padding spaces on the right if necessary. Use negative <m> values for column positions measured from the right hand edge of the terminal window.\n\nsimilar to %<(<n>), %<|(<m>) respectively, but padding spaces on the left\n\nsimilar to %>(<n>), %>|(<m>) respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces\n\nsimilar to %<(<n>), %<|(<m>) respectively, but padding both sides (i.e. the text is centered)\n\nPlaceholders that expand to information extracted from the commit:\n\nabbreviated commit hash\n\nabbreviated tree hash\n\nabbreviated parent hashes\n\nauthor name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\nauthor email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\nauthor email local-part (the part before the @ sign)\n\nauthor local-part (see %al) respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\nauthor date (format respects --date= option)\n\nauthor date, RFC2822 style\n\nauthor date, relative\n\nauthor date, UNIX timestamp\n\nauthor date, ISO 8601-like format\n\nauthor date, strict ISO 8601 format\n\nauthor date, short format (YYYY-MM-DD)\n\nauthor date, human style (like the --date=human option of git-rev-list[1])\n\ncommitter name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\ncommitter email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\ncommitter email local-part (the part before the @ sign)\n\ncommitter local-part (see %cl) respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\ncommitter date (format respects --date= option)\n\ncommitter date, RFC2822 style\n\ncommitter date, relative\n\ncommitter date, UNIX timestamp\n\ncommitter date, ISO 8601-like format\n\ncommitter date, strict ISO 8601 format\n\ncommitter date, short format (YYYY-MM-DD)\n\ncommitter date, human style (like the --date=human option of git-rev-list[1])\n\nref names, like the --decorate option of git-log[1]\n\nref names without the \" (\", \")\" wrapping.\n\nref names with custom decorations. The decorate string may be followed by a colon and zero or more comma-separated options. Option values may contain literal formatting codes. These must be used for commas (%x2C) and closing parentheses (%x29), due to their role in the option syntax.\n\nprefix=<value>: Shown before the list of ref names. Defaults to \" (\".\n\nsuffix=<value>: Shown after the list of ref names. Defaults to \")\".\n\nseparator=<value>: Shown between ref names. Defaults to \", \".\n\npointer=<value>: Shown between HEAD and the branch it points to, if any. Defaults to \" → \".\n\ntag=<value>: Shown before tag names. Defaults to \"tag: \".\n\nFor example, to produce decorations with no wrapping or tag annotations, and spaces as separators:\n\n%(decorate:prefix=,suffix=,tag=,separator= )\n\nhuman-readable name, like git-describe[1]; empty string for undescribable commits. The describe string may be followed by a colon and zero or more comma-separated options. Descriptions can be inconsistent when tags are added or removed at the same time.\n\ntags[=<bool-value>]: Instead of only considering annotated tags, consider lightweight tags as well.\n\nabbrev=<number>: Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <number> digits, or as many digits as needed to form a unique object name.\n\nmatch=<pattern>: Only consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix.\n\nexclude=<pattern>: Do not consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix.\n\nref name given on the command line by which the commit was reached (like git log --source), only works with git log\n\nsanitized subject line, suitable for a filename\n\nraw body (unwrapped subject and body)\n\nraw verification message from GPG for a signed commit\n\nshow \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key) and \"N\" for no signature\n\nshow the name of the signer for a signed commit\n\nshow the key used to sign a signed commit\n\nshow the fingerprint of the key used to sign a signed commit\n\nshow the fingerprint of the primary key whose subkey was used to sign a signed commit\n\nshow the trust level for the key used to sign a signed commit\n\nreflog selector, e.g., refs/stash@{1} or refs/stash@{2 minutes ago}; the format follows the rules described for the -g option. The portion before the @ is the refname as given on the command line (so git log -g refs/heads/master would yield refs/heads/master@{0}).\n\nshortened reflog selector; same as %gD, but the refname portion is shortened for human readability (so refs/heads/master becomes just master).\n\nreflog identity name\n\nreflog identity name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\nreflog identity email\n\nreflog identity email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\ndisplay the trailers of the body as interpreted by git-interpret-trailers[1]. The trailers string may be followed by a colon and zero or more comma-separated options. If any option is provided multiple times, the last occurrence wins.\n\nkey=<key>: only show trailers with specified <key>. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the only option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with only=false. E.g., %(trailers:key=Reviewed-by) shows trailer lines with key Reviewed-by.\n\nonly[=<bool>]: select whether non-trailer lines from the trailer block should be included.\n\nseparator=<sep>: specify the separator inserted between trailer lines. Defaults to a line feed character. The string <sep> may contain the literal formatting codes described above. To use comma as separator one must use %x2C as it would otherwise be parsed as next option. E.g., %(trailers:key=Ticket,separator=%x2C ) shows all trailer lines whose key is \"Ticket\" separated by a comma and a space.\n\nunfold[=<bool>]: make it behave as if interpret-trailer’s --unfold option was given. E.g., %(trailers:only,unfold=true) unfolds and shows all trailer lines.\n\nkeyonly[=<bool>]: only show the key part of the trailer.\n\nvalueonly[=<bool>]: only show the value part of the trailer.\n\nkey_value_separator=<sep>: specify the separator inserted between the key and value of each trailer. Defaults to \": \". Otherwise it shares the same semantics as separator=<sep> above.\n\nThe boolean options accept an optional value [=<bool-value>]. The values taken by --type=bool git-config[1], like yes and off, are all accepted. Giving a boolean option without =<value> is equivalent to giving it with =true.\n\nIf you add a + (plus sign) after % of a placeholder, a line-feed is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.\n\nIf you add a - (minus sign) after % of a placeholder, all consecutive line-feeds immediately preceding the expansion are deleted if and only if the placeholder expands to an empty string.\n\nIf you add a (space) after % of a placeholder, a space is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.\n\nThe tformat: format works exactly like format:, except that it provides \"terminator\" semantics instead of \"separator\" semantics. In other words, each commit has the message terminator character (usually a newline) appended, rather than a separator placed between entries. This means that the final entry of a single-line format will be properly terminated with a new line, just as the \"oneline\" format does. For example:\n\nIn addition, any unrecognized string that has a % in it is interpreted as if it has tformat: in front of it. For example, these two are equivalent:\n\n• oneline <hash> <title-line> This is designed to be as compact as possible.\n• short commit <hash> Author: <author> <title-line>\n• medium commit <hash> Author: <author> Date: <author-date> <title-line> <full-commit-message>\n• full commit <hash> Author: <author> Commit: <committer> <title-line> <full-commit-message>\n• fuller commit <hash> Author: <author> AuthorDate: <author-date> Commit: <committer> CommitDate: <committer-date> <title-line> <full-commit-message>\n• reference <abbrev-hash> (<title-line>, <short-author-date>) This format is used to refer to another commit in a commit message and is the same as --pretty='format:%C(auto)%h (%s, %ad). By default, the date is formatted with --date=short unless another --date option is explicitly specified. As with any format: with format placeholders, its output is not affected by other options like --decorate and --walk-reflogs.\n• email From <hash> <date> From: <author> Date: <author-date> Subject: [PATCH] <title-line> <full-commit-message>\n• mboxrd Like email, but lines in the commit message starting with \"From \" (preceded by zero or more \">\") are quoted with \">\" so they aren’t confused as starting a new commit.\n• raw The raw format shows the entire commit exactly as stored in the commit object. Notably, the hashes are displayed in full, regardless of whether --abbrev or --no-abbrev are used, and parents information show the true parent commits, without taking grafts or history simplification into account. Note that this format affects the way commits are displayed, but not the way the diff is shown e.g. with git log --raw. To get full object names in a raw diff format, use --no-abbrev.\n• format:<format-string> The format:<format-string> format allows you to specify which information you want to show. It works a little bit like printf format, with the notable exception that you get a newline with %n instead of \\n. E.g, format:\"The author of %h was %an, %ar%nThe title was >>%s<<%n\" would show something like this: The author of fe6e0ee was Junio C Hamano, 23 hours ago The title was >>t4119: test autocomputing -p<n> for traditional diff input.<< The placeholders are: Placeholders that expand to a single literal character: %n newline %% a raw % %x00 %x followed by two hexadecimal digits is replaced with a byte with the hexadecimal digits' value (we will call this \"literal formatting code\" in the rest of this document). Placeholders that affect formatting of later placeholders: %Cred switch color to red %Cgreen switch color to green %Cblue switch color to blue %Creset reset color %C(<spec>) color specification, as described under Values in the \"CONFIGURATION FILE\" section of git-config[1]. By default, colors are shown only when enabled for log output (by color.diff, color.ui, or --color, and respecting the auto settings of the former if we are going to a terminal). %C(auto,<spec>) is accepted as a historical synonym for the default (e.g., %C(auto,red)). Specifying %C(always,<spec>) will show the colors even when color is not otherwise enabled (though consider just using --color=always to enable color for the whole output, including this format and anything else git might color). auto alone (i.e. %C(auto)) will turn on auto coloring on the next placeholders until the color is switched again. %m left (<), right (>) or boundary (-) mark %w([<w>[,<i1>[,<i2>]]]) switch line wrapping, like the -w option of git-shortlog[1]. %<(<n>[,(trunc|ltrunc|mtrunc)]) make the next placeholder take at least N column widths, padding spaces on the right if necessary. Optionally truncate (with ellipsis ..) at the left (ltrunc) ..ft, the middle (mtrunc) mi..le, or the end (trunc) rig.., if the output is longer than <n> columns. Note 1: that truncating only works correctly with <n> >= 2. Note 2: spaces around the <n> and <m> (see below) values are optional. Note 3: Emojis and other wide characters will take two display columns, which may over-run column boundaries. Note 4: decomposed character combining marks may be misplaced at padding boundaries. %<|(<m> ) make the next placeholder take at least until <m> th display column, padding spaces on the right if necessary. Use negative <m> values for column positions measured from the right hand edge of the terminal window. %>(<n>) %>|(<m>) similar to %<(<n>), %<|(<m>) respectively, but padding spaces on the left %>>(<n>) %>>|(<m>) similar to %>(<n>), %>|(<m>) respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces %><(<n>) %><|(<m>) similar to %<(<n>), %<|(<m>) respectively, but padding both sides (i.e. the text is centered) Placeholders that expand to information extracted from the commit: %H commit hash %h abbreviated commit hash %T tree hash %t abbreviated tree hash %P parent hashes %p abbreviated parent hashes %an author name %aN author name (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ae author email %aE author email (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %al author email local-part (the part before the @ sign) %aL author local-part (see %al) respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ad author date (format respects --date= option) %aD author date, RFC2822 style %ar author date, relative %at author date, UNIX timestamp %ai author date, ISO 8601-like format %aI author date, strict ISO 8601 format %as author date, short format (YYYY-MM-DD) %ah author date, human style (like the --date=human option of git-rev-list[1]) %cn committer name %cN committer name (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ce committer email %cE committer email (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %cl committer email local-part (the part before the @ sign) %cL committer local-part (see %cl) respecting .mailmap, see git-shortlog[1] or git-blame[1]) %cd committer date (format respects --date= option) %cD committer date, RFC2822 style %cr committer date, relative %ct committer date, UNIX timestamp %ci committer date, ISO 8601-like format %cI committer date, strict ISO 8601 format %cs committer date, short format (YYYY-MM-DD) %ch committer date, human style (like the --date=human option of git-rev-list[1]) %d ref names, like the --decorate option of git-log[1] %D ref names without the \" (\", \")\" wrapping. %(decorate[:<option>,...]) ref names with custom decorations. The decorate string may be followed by a colon and zero or more comma-separated options. Option values may contain literal formatting codes. These must be used for commas (%x2C) and closing parentheses (%x29), due to their role in the option syntax. prefix=<value>: Shown before the list of ref names. Defaults to \" (\". suffix=<value>: Shown after the list of ref names. Defaults to \")\". separator=<value>: Shown between ref names. Defaults to \", \". pointer=<value>: Shown between HEAD and the branch it points to, if any. Defaults to \" → \". tag=<value>: Shown before tag names. Defaults to \"tag: \". For example, to produce decorations with no wrapping or tag annotations, and spaces as separators: %(decorate:prefix=,suffix=,tag=,separator= ) %(describe[:<option>,...]) human-readable name, like git-describe[1]; empty string for undescribable commits. The describe string may be followed by a colon and zero or more comma-separated options. Descriptions can be inconsistent when tags are added or removed at the same time. tags[=<bool-value>]: Instead of only considering annotated tags, consider lightweight tags as well. abbrev=<number>: Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <number> digits, or as many digits as needed to form a unique object name. match=<pattern>: Only consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix. exclude=<pattern>: Do not consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix. %S ref name given on the command line by which the commit was reached (like git log --source), only works with git log %e encoding %s subject %f sanitized subject line, suitable for a filename %b body %B raw body (unwrapped subject and body) %N commit notes %GG raw verification message from GPG for a signed commit %G? show \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key) and \"N\" for no signature %GS show the name of the signer for a signed commit %GK show the key used to sign a signed commit %GF show the fingerprint of the key used to sign a signed commit %GP show the fingerprint of the primary key whose subkey was used to sign a signed commit %GT show the trust level for the key used to sign a signed commit %gD reflog selector, e.g., refs/stash@{1} or refs/stash@{2 minutes ago}; the format follows the rules described for the -g option. The portion before the @ is the refname as given on the command line (so git log -g refs/heads/master would yield refs/heads/master@{0}). %gd shortened reflog selector; same as %gD, but the refname portion is shortened for human readability (so refs/heads/master becomes just master). %gn reflog identity name %gN reflog identity name (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ge reflog identity email %gE reflog identity email (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %gs reflog subject %(trailers[:<option>,...]) display the trailers of the body as interpreted by git-interpret-trailers[1]. The trailers string may be followed by a colon and zero or more comma-separated options. If any option is provided multiple times, the last occurrence wins. key=<key>: only show trailers with specified <key>. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the only option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with only=false. E.g., %(trailers:key=Reviewed-by) shows trailer lines with key Reviewed-by. only[=<bool>]: select whether non-trailer lines from the trailer block should be included. separator=<sep>: specify the separator inserted between trailer lines. Defaults to a line feed character. The string <sep> may contain the literal formatting codes described above. To use comma as separator one must use %x2C as it would otherwise be parsed as next option. E.g., %(trailers:key=Ticket,separator=%x2C ) shows all trailer lines whose key is \"Ticket\" separated by a comma and a space. unfold[=<bool>]: make it behave as if interpret-trailer’s --unfold option was given. E.g., %(trailers:only,unfold=true) unfolds and shows all trailer lines. keyonly[=<bool>]: only show the key part of the trailer. valueonly[=<bool>]: only show the value part of the trailer. key_value_separator=<sep>: specify the separator inserted between the key and value of each trailer. Defaults to \": \". Otherwise it shares the same semantics as separator=<sep> above.\n\n• Placeholders that expand to a single literal character: %n newline %% a raw % %x00 %x followed by two hexadecimal digits is replaced with a byte with the hexadecimal digits' value (we will call this \"literal formatting code\" in the rest of this document).\n• Placeholders that affect formatting of later placeholders: %Cred switch color to red %Cgreen switch color to green %Cblue switch color to blue %Creset reset color %C(<spec>) color specification, as described under Values in the \"CONFIGURATION FILE\" section of git-config[1]. By default, colors are shown only when enabled for log output (by color.diff, color.ui, or --color, and respecting the auto settings of the former if we are going to a terminal). %C(auto,<spec>) is accepted as a historical synonym for the default (e.g., %C(auto,red)). Specifying %C(always,<spec>) will show the colors even when color is not otherwise enabled (though consider just using --color=always to enable color for the whole output, including this format and anything else git might color). auto alone (i.e. %C(auto)) will turn on auto coloring on the next placeholders until the color is switched again. %m left (<), right (>) or boundary (-) mark %w([<w>[,<i1>[,<i2>]]]) switch line wrapping, like the -w option of git-shortlog[1]. %<(<n>[,(trunc|ltrunc|mtrunc)]) make the next placeholder take at least N column widths, padding spaces on the right if necessary. Optionally truncate (with ellipsis ..) at the left (ltrunc) ..ft, the middle (mtrunc) mi..le, or the end (trunc) rig.., if the output is longer than <n> columns. Note 1: that truncating only works correctly with <n> >= 2. Note 2: spaces around the <n> and <m> (see below) values are optional. Note 3: Emojis and other wide characters will take two display columns, which may over-run column boundaries. Note 4: decomposed character combining marks may be misplaced at padding boundaries. %<|(<m> ) make the next placeholder take at least until <m> th display column, padding spaces on the right if necessary. Use negative <m> values for column positions measured from the right hand edge of the terminal window. %>(<n>) %>|(<m>) similar to %<(<n>), %<|(<m>) respectively, but padding spaces on the left %>>(<n>) %>>|(<m>) similar to %>(<n>), %>|(<m>) respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces %><(<n>) %><|(<m>) similar to %<(<n>), %<|(<m>) respectively, but padding both sides (i.e. the text is centered)\n• Placeholders that expand to information extracted from the commit: %H commit hash %h abbreviated commit hash %T tree hash %t abbreviated tree hash %P parent hashes %p abbreviated parent hashes %an author name %aN author name (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ae author email %aE author email (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %al author email local-part (the part before the @ sign) %aL author local-part (see %al) respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ad author date (format respects --date= option) %aD author date, RFC2822 style %ar author date, relative %at author date, UNIX timestamp %ai author date, ISO 8601-like format %aI author date, strict ISO 8601 format %as author date, short format (YYYY-MM-DD) %ah author date, human style (like the --date=human option of git-rev-list[1]) %cn committer name %cN committer name (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ce committer email %cE committer email (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %cl committer email local-part (the part before the @ sign) %cL committer local-part (see %cl) respecting .mailmap, see git-shortlog[1] or git-blame[1]) %cd committer date (format respects --date= option) %cD committer date, RFC2822 style %cr committer date, relative %ct committer date, UNIX timestamp %ci committer date, ISO 8601-like format %cI committer date, strict ISO 8601 format %cs committer date, short format (YYYY-MM-DD) %ch committer date, human style (like the --date=human option of git-rev-list[1]) %d ref names, like the --decorate option of git-log[1] %D ref names without the \" (\", \")\" wrapping. %(decorate[:<option>,...]) ref names with custom decorations. The decorate string may be followed by a colon and zero or more comma-separated options. Option values may contain literal formatting codes. These must be used for commas (%x2C) and closing parentheses (%x29), due to their role in the option syntax. prefix=<value>: Shown before the list of ref names. Defaults to \" (\". suffix=<value>: Shown after the list of ref names. Defaults to \")\". separator=<value>: Shown between ref names. Defaults to \", \". pointer=<value>: Shown between HEAD and the branch it points to, if any. Defaults to \" → \". tag=<value>: Shown before tag names. Defaults to \"tag: \".\n\n• prefix=<value>: Shown before the list of ref names. Defaults to \" (\".\n• suffix=<value>: Shown after the list of ref names. Defaults to \")\".\n• separator=<value>: Shown between ref names. Defaults to \", \".\n• pointer=<value>: Shown between HEAD and the branch it points to, if any. Defaults to \" → \".\n• tag=<value>: Shown before tag names. Defaults to \"tag: \".\n\n• tags[=<bool-value>]: Instead of only considering annotated tags, consider lightweight tags as well.\n• abbrev=<number>: Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <number> digits, or as many digits as needed to form a unique object name.\n• match=<pattern>: Only consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix.\n• exclude=<pattern>: Do not consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix.\n\n• key=<key>: only show trailers with specified <key>. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the only option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with only=false. E.g., %(trailers:key=Reviewed-by) shows trailer lines with key Reviewed-by.\n• only[=<bool>]: select whether non-trailer lines from the trailer block should be included.\n• separator=<sep>: specify the separator inserted between trailer lines. Defaults to a line feed character. The string <sep> may contain the literal formatting codes described above. To use comma as separator one must use %x2C as it would otherwise be parsed as next option. E.g., %(trailers:key=Ticket,separator=%x2C ) shows all trailer lines whose key is \"Ticket\" separated by a comma and a space.\n• unfold[=<bool>]: make it behave as if interpret-trailer’s --unfold option was given. E.g., %(trailers:only,unfold=true) unfolds and shows all trailer lines.\n• keyonly[=<bool>]: only show the key part of the trailer.\n• valueonly[=<bool>]: only show the value part of the trailer.\n• key_value_separator=<sep>: specify the separator inserted between the key and value of each trailer. Defaults to \": \". Otherwise it shares the same semantics as separator=<sep> above.\n\n• tformat: The tformat: format works exactly like format:, except that it provides \"terminator\" semantics instead of \"separator\" semantics. In other words, each commit has the message terminator character (usually a newline) appended, rather than a separator placed between entries. This means that the final entry of a single-line format will be properly terminated with a new line, just as the \"oneline\" format does. For example: $ git log -2 --pretty=format:%h 4da45bef \\ | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/' 4da45be 7134973 -- NO NEWLINE $ git log -2 --pretty=tformat:%h 4da45bef \\ | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/' 4da45be 7134973 In addition, any unrecognized string that has a % in it is interpreted as if it has tformat: in front of it. For example, these two are equivalent: $ git log -2 --pretty=tformat:%h 4da45bef $ git log -2 --pretty=%h 4da45bef\n\n**%n**: newline\n**%%**: a raw %\n**%x00**: %x followed by two hexadecimal digits is replaced with a byte with the hexadecimal digits' value (we will call this \"literal formatting code\" in the rest of this document).\n**%Cred**: switch color to red\n**%Cgreen**: switch color to green\n**%Cblue**: switch color to blue\n**%Creset**: reset color\n**%C(<spec>)**: color specification, as described under Values in the \"CONFIGURATION FILE\" section of git-config[1]. By default, colors are shown only when enabled for log output (by color.diff, color.ui, or --color, and respecting the auto settings of the former if we are going to a terminal). %C(auto,<spec>) is accepted as a historical synonym for the default (e.g., %C(auto,red)). Specifying %C(always,<spec>) will show the colors even when color is not otherwise enabled (though consider just using --color=always to enable color for the whole output, including this format and anything else git might color). auto alone (i.e. %C(auto)) will turn on auto coloring on the next placeholders until the color is switched again.\n**%m**: left (<), right (>) or boundary (-) mark\n**%w([<w>[,<i1>[,<i2>]]])**: switch line wrapping, like the -w option of git-shortlog[1].\n**%<(<n>[,(trunc|ltrunc|mtrunc)])**: make the next placeholder take at least N column widths, padding spaces on the right if necessary. Optionally truncate (with ellipsis ..) at the left (ltrunc) ..ft, the middle (mtrunc) mi..le, or the end (trunc) rig.., if the output is longer than <n> columns. Note 1: that truncating only works correctly with <n> >= 2. Note 2: spaces around the <n> and <m> (see below) values are optional. Note 3: Emojis and other wide characters will take two display columns, which may over-run column boundaries. Note 4: decomposed character combining marks may be misplaced at padding boundaries.\n**%<|(<m> )**: make the next placeholder take at least until <m> th display column, padding spaces on the right if necessary. Use negative <m> values for column positions measured from the right hand edge of the terminal window.\n**%>(<n>)**: similar to %<(<n>), %<|(<m>) respectively, but padding spaces on the left\n**%>|(<m>)**: similar to %>(<n>), %>|(<m>) respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces\n**%>>(<n>)**: similar to %<(<n>), %<|(<m>) respectively, but padding both sides (i.e. the text is centered)\n**%H**: commit hash\n**%h**: abbreviated commit hash\n**%T**: tree hash\n**%t**: abbreviated tree hash\n**%P**: parent hashes\n**%p**: abbreviated parent hashes\n**%an**: author name\n**%aN**: author name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%ae**: author email\n**%aE**: author email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%al**: author email local-part (the part before the @ sign)\n**%aL**: author local-part (see %al) respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%ad**: author date (format respects --date= option)\n**%aD**: author date, RFC2822 style\n**%ar**: author date, relative\n**%at**: author date, UNIX timestamp\n**%ai**: author date, ISO 8601-like format\n**%aI**: author date, strict ISO 8601 format\n**%as**: author date, short format (YYYY-MM-DD)\n**%ah**: author date, human style (like the --date=human option of git-rev-list[1])\n**%cn**: committer name\n**%cN**: committer name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%ce**: committer email\n**%cE**: committer email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%cl**: committer email local-part (the part before the @ sign)\n**%cL**: committer local-part (see %cl) respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%cd**: committer date (format respects --date= option)\n**%cD**: committer date, RFC2822 style\n**%cr**: committer date, relative\n**%ct**: committer date, UNIX timestamp\n**%ci**: committer date, ISO 8601-like format\n**%cI**: committer date, strict ISO 8601 format\n**%cs**: committer date, short format (YYYY-MM-DD)\n**%ch**: committer date, human style (like the --date=human option of git-rev-list[1])\n**%d**: ref names, like the --decorate option of git-log[1]\n**%D**: ref names without the \" (\", \")\" wrapping.\n**%(decorate[:<option>,...])**: ref names with custom decorations. The decorate string may be followed by a colon and zero or more comma-separated options. Option values may contain literal formatting codes. These must be used for commas (%x2C) and closing parentheses (%x29), due to their role in the option syntax. prefix=<value>: Shown before the list of ref names. Defaults to \" (\". suffix=<value>: Shown after the list of ref names. Defaults to \")\". separator=<value>: Shown between ref names. Defaults to \", \". pointer=<value>: Shown between HEAD and the branch it points to, if any. Defaults to \" → \". tag=<value>: Shown before tag names. Defaults to \"tag: \".\n**%(describe[:<option>,...])**: human-readable name, like git-describe[1]; empty string for undescribable commits. The describe string may be followed by a colon and zero or more comma-separated options. Descriptions can be inconsistent when tags are added or removed at the same time. tags[=<bool-value>]: Instead of only considering annotated tags, consider lightweight tags as well. abbrev=<number>: Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <number> digits, or as many digits as needed to form a unique object name. match=<pattern>: Only consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix. exclude=<pattern>: Do not consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix.\n**%S**: ref name given on the command line by which the commit was reached (like git log --source), only works with git log\n**%e**: encoding\n**%s**: subject\n**%f**: sanitized subject line, suitable for a filename\n**%b**: body\n**%B**: raw body (unwrapped subject and body)\n**%N**: commit notes\n**%GG**: raw verification message from GPG for a signed commit\n**%G?**: show \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key) and \"N\" for no signature\n**%GS**: show the name of the signer for a signed commit\n**%GK**: show the key used to sign a signed commit\n**%GF**: show the fingerprint of the key used to sign a signed commit\n**%GP**: show the fingerprint of the primary key whose subkey was used to sign a signed commit\n**%GT**: show the trust level for the key used to sign a signed commit\n**%gD**: reflog selector, e.g., refs/stash@{1} or refs/stash@{2 minutes ago}; the format follows the rules described for the -g option. The portion before the @ is the refname as given on the command line (so git log -g refs/heads/master would yield refs/heads/master@{0}).\n**%gd**: shortened reflog selector; same as %gD, but the refname portion is shortened for human readability (so refs/heads/master becomes just master).\n**%gn**: reflog identity name\n**%gN**: reflog identity name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%ge**: reflog identity email\n**%gE**: reflog identity email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%gs**: reflog subject\n**%(trailers[:<option>,...])**: display the trailers of the body as interpreted by git-interpret-trailers[1]. The trailers string may be followed by a colon and zero or more comma-separated options. If any option is provided multiple times, the last occurrence wins. key=<key>: only show trailers with specified <key>. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the only option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with only=false. E.g., %(trailers:key=Reviewed-by) shows trailer lines with key Reviewed-by. only[=<bool>]: select whether non-trailer lines from the trailer block should be included. separator=<sep>: specify the separator inserted between trailer lines. Defaults to a line feed character. The string <sep> may contain the literal formatting codes described above. To use comma as separator one must use %x2C as it would otherwise be parsed as next option. E.g., %(trailers:key=Ticket,separator=%x2C ) shows all trailer lines whose key is \"Ticket\" separated by a comma and a space. unfold[=<bool>]: make it behave as if interpret-trailer’s --unfold option was given. E.g., %(trailers:only,unfold=true) unfolds and shows all trailer lines. keyonly[=<bool>]: only show the key part of the trailer. valueonly[=<bool>]: only show the value part of the trailer. key_value_separator=<sep>: specify the separator inserted between the key and value of each trailer. Defaults to \": \". Otherwise it shares the same semantics as separator=<sep> above.\n\nNote | Some placeholders may depend on other options given to the revision traversal engine. For example, the %g* reflog options will insert an empty string unless we are traversing reflog entries (e.g., by git log -g). The %d and %D placeholders will use the \"short\" decoration format if --decorate was not already provided on the command line.\n\n[Note] Note Some placeholders may depend on other options given to the revision traversal engine. For example, the %g* reflog options will insert an empty string unless we are traversing reflog entries (e.g., by git log -g). The %d and %D placeholders will use the \"short\" decoration format if --decorate was not already provided on the command line.",
        "code_examples": [
          "```bash\n<hash><title-line>\n```",
          "```bash\ncommit<hash>Author: <author>\n```",
          "```bash\n<title-line>\n```",
          "```bash\ncommit<hash>Author: <author>\nDate:   <author-date>\n```",
          "```bash\n<title-line>\n```",
          "```bash\n<full-commit-message>\n```",
          "```bash\ncommit<hash>Author: <author>\nCommit: <committer>\n```",
          "```bash\n<title-line>\n```",
          "```bash\n<full-commit-message>\n```",
          "```bash\ncommit<hash>Author:     <author>\nAuthorDate: <author-date>\nCommit:     <committer>\nCommitDate: <committer-date>\n```",
          "```bash\n<title-line>\n```",
          "```bash\n<full-commit-message>\n```",
          "```bash\n<abbrev-hash> (<title-line>, <short-author-date>)\n```",
          "```bash\nFrom<hash><date>\nFrom: <author>\nDate: <author-date>\nSubject: [PATCH] <title-line>\n```",
          "```bash\n<full-commit-message>\n```",
          "```bash\nThe author of fe6e0ee was Junio C Hamano, 23 hours ago\nThe title was >>t4119: test autocomputing -p<n> for traditional diff input.<<\n```"
        ],
        "usage_examples": [
          "```bash\n$ git log -2 --pretty=format:%h 4da45bef \\\n  | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/'\n4da45be\n7134973 -- NO NEWLINE\n\n$ git log -2 --pretty=tformat:%h 4da45bef \\\n  | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/'\n4da45be\n7134973\n```",
          "```bash\n$ git log -2 --pretty=tformat:%h 4da45bef\n$ git log -2 --pretty=%h 4da45bef\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 96,
          "content_length": 41261
        }
      },
      {
        "header": "DIFF FORMATTING",
        "content": "The options below can be used to change the way git show generates diff output.\n\nGenerate patch (see Generating patch text with -p).\n\nSuppress all output from the diff machinery. Useful for commands like git show that show the patch by default to squelch their output, or to cancel the effect of options like --patch, --stat earlier on the command line in an alias.\n\nShow diffs for merge commits in the default format. This is similar to --diff-merges=on, except -m will produce no output unless -p is given as well.\n\nProduce combined diff output for merge commits. Shortcut for --diff-merges=combined -p.\n\nProduce dense combined diff output for merge commits. Shortcut for --diff-merges=dense-combined -p.\n\nProduce diff with respect to first parent for both merge and regular commits. Shortcut for --diff-merges=first-parent -p.\n\nProduce remerge-diff output for merge commits. Shortcut for --diff-merges=remerge -p.\n\nSynonym for --diff-merges=off.\n\nSpecify diff format to be used for merge commits. Default is `dense-combined` unless --first-parent is in use, in which case first-parent is the default.\n\nThe following formats are supported:\n\nDisable output of diffs for merge commits. Useful to override implied value.\n\nMake diff output for merge commits to be shown in the default format. The default format can be changed using log.diffMerges configuration variable, whose default value is separate.\n\nShow full diff with respect to first parent. This is the same format as --patch produces for non-merge commits.\n\nShow full diff with respect to each of parents. Separate log entry and diff is generated for each parent.\n\nShow differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents.\n\nFurther compress output produced by --diff-merges=combined by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification.\n\nRemerge two-parent merge commits to create a temporary tree object—potentially containing files with conflict markers and such. A diff is then shown between that temporary tree and the actual merge commit.\n\nThe output emitted when this option is used is subject to change, and so is its interaction with other options (unless explicitly documented).\n\nCause combined diffs (used for merge commits) to list the name of the file from all parents. It thus only has effect when --diff-merges=[dense-]combined is in use, and is likely only useful if filename changes are detected (i.e. when either rename or copy detection have been requested).\n\nGenerate diffs with <n> lines of context instead of the usual three. Implies --patch.\n\nOutput to a specific file instead of stdout.\n\nSpecify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively.\n\nFor each commit, show a summary of changes using the raw diff format. See the \"RAW OUTPUT FORMAT\" section of git-diff[1]. This is different from showing the log itself in raw format, which you can achieve with --format=raw.\n\nSynonym for -p --raw.\n\nShow the tree objects in the diff output.\n\nEnable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.\n\nDisable the indent heuristic.\n\nSpend extra time to make sure the smallest possible diff is produced.\n\nGenerate a diff using the \"patience diff\" algorithm.\n\nGenerate a diff using the \"histogram diff\" algorithm.\n\nGenerate a diff using the \"anchored diff\" algorithm.\n\nThis option may be specified more than once.\n\nIf a line exists in both the source and destination, exists only once, and starts with <text>, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the \"patience diff\" algorithm internally.\n\nChoose a diff algorithm. The variants are as follows:\n\nThe basic greedy diff algorithm. Currently, this is the default.\n\nSpend extra time to make sure the smallest possible diff is produced.\n\nUse \"patience diff\" algorithm when generating patches.\n\nThis algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n\nFor instance, if you configured the diff.algorithm variable to a non-default value and want to use the default one, then you have to use --diff-algorithm=default option.\n\nGenerate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by <width>. The width of the filename part can be limited by giving another width <name-width> after a comma or by setting diff.statNameWidth=<name-width>. The width of the graph part can be limited by using --stat-graph-width=<graph-width> or by setting diff.statGraphWidth=<graph-width>. Using --stat or --stat-graph-width affects all commands generating a stat graph, while setting diff.statNameWidth or diff.statGraphWidth does not affect git format-patch. By giving a third parameter <count>, you can limit the output to the first <count> lines, followed by ... if there are more.\n\nThese parameters can also be set individually with --stat-width=<width>, --stat-name-width=<name-width> and --stat-count=<count>.\n\nOutput a condensed summary of extended header information such as file creations or deletions (\"new\" or \"gone\", optionally +l if it’s a symlink) and mode changes (+x or -x for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies --stat.\n\nSimilar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly. For binary files, outputs two - instead of saying 0 0.\n\nOutput only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines.\n\nOutput the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config[1]). The following parameters are available:\n\nCompute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n\nCompute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n\nCompute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n\nCount changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n\nAn integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n\nExample: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative.\n\nSynonym for --dirstat=cumulative.\n\nSynonym for --dirstat=files,<param>,....\n\nOutput a condensed summary of extended header information such as creations, renames and mode changes.\n\nSynonym for -p --stat.\n\nSeparate the commits with NULs instead of newlines.\n\nAlso, when --raw or --numstat has been given, do not munge pathnames and use NULs as output field terminators.\n\nWithout this option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n\nShow only the name of each changed file in the post-image tree. The file names are often encoded in UTF-8. For more information see the discussion about encoding in the git-log[1] manual page.\n\nShow only the name(s) and status of each changed file. See the description of the --diff-filter option on what the status letters mean. Just like --name-only the file names are often encoded in UTF-8.\n\nSpecify how differences in submodules are shown. When specifying --submodule=short the short format is used. This format just shows the names of the commits at the beginning and end of the range. When --submodule or --submodule=log is specified, the log format is used. This format lists the commits in the range like git-submodule[1] summary does. When --submodule=diff is specified, the diff format is used. This format shows an inline diff of the changes in the submodule contents between the commit range. Defaults to diff.submodule or the short format if the config option is unset.\n\nShow colored diff. --color (i.e. without =<when>) is the same as --color=always. <when> can be one of always, never, or auto.\n\nTurn off colored diff. It is the same as --color=never.\n\nMoved lines of code are colored differently. The <mode> defaults to no if the option is not given and to zebra if the option with no mode is given. The mode must be one of:\n\nMoved lines are not highlighted.\n\nIs a synonym for zebra. This may change to a more sensible mode in the future.\n\nAny line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.\n\nBlocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart.\n\nBlocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected.\n\nSimilar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n\nTurn off move detection. This can be used to override configuration settings. It is the same as --color-moved=no.\n\nThis configures how whitespace is ignored when performing the move detection for --color-moved. These modes can be given as a comma separated list:\n\nDo not ignore whitespace when performing move detection.\n\nIgnore changes in whitespace at EOL.\n\nIgnore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n\nIgnore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n\nInitially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n\nDo not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as --color-moved-ws=no.\n\nBy default, words are delimited by whitespace; see --word-diff-regex below. The <mode> defaults to plain, and must be one of:\n\nHighlight changed words using only colors. Implies --color.\n\nShow words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.\n\nUse a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own.\n\nDisable word diff again.\n\nNote that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled.\n\nUse <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies --word-diff unless it was already enabled.\n\nEvery non-overlapping match of the <regex> is considered a word. Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences. You may want to append |[^[:space:]] to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline.\n\nFor example, --word-diff-regex=. will treat each character as a word and, correspondingly, show differences character by character.\n\nThe regex can also be set via a diff driver or configuration option, see gitattributes[5] or git-config[1]. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.\n\nEquivalent to --word-diff=color plus (if a regex was specified) --word-diff-regex=<regex>.\n\nTurn off rename detection, even when the configuration file gives the default to do so.\n\nWhether to use empty blobs as rename source.\n\nWarn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by core.whitespace configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.\n\nHighlight whitespace errors in the context, old or new lines of the diff. Multiple values are separated by comma, none resets previous values, default reset the list to new and all is a shorthand for old,new,context. When this option is not given, and the configuration variable diff.wsErrorHighlight is not set, only whitespace errors in new lines are highlighted. The whitespace errors are colored with color.diff.whitespace.\n\nInstead of the first handful of characters, show the full pre- and post-image blob object names on the \"index\" line when generating patch format output.\n\nIn addition to --full-index, output a binary diff that can be applied with git-apply. Implies --patch.\n\nInstead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. In diff-patch output format, --full-index takes higher precedence, i.e. if --full-index is specified, full blob names will be shown regardless of --abbrev. Non default number of digits can be specified with --abbrev=<n>.\n\nBreak complete rewrite changes into pairs of delete and create. This serves two purposes:\n\nIt affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number <m> controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).\n\nWhen used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number <n> controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file.\n\nIf generating diffs, detect and report renames for each commit. For following files across renames while traversing history, see --follow. If <n> is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed. Without a % sign, the number is to be read as a fraction, with a decimal point before it. I.e., -M5 becomes 0.5, and is thus the same as -M50%. Similarly, -M05 is the same as -M5%. To limit detection to exact renames, use -M100%. The default similarity index is 50%.\n\nDetect copies as well as renames. See also --find-copies-harder. If <n> is specified, it has the same meaning as for -M<n>.\n\nFor performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one -C option has the same effect.\n\nOmit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.\n\nWhen used together with -B, omit also the preimage in the deletion part of a delete/create pair.\n\nThe -M and -C options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources. (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.) For N sources and destinations, this exhaustive check is O(N^2). This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number. Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited.\n\nSelect only files that are Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have their type (i.e. regular file, symlink, submodule, …) changed (T), are Unmerged (U), are Unknown (X), or have had their pairing Broken (B). Any combination of the filter characters (including none) can be used. When * (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected.\n\nAlso, these upper-case letters can be downcased to exclude. E.g. --diff-filter=ad excludes added and deleted paths.\n\nNote that not all diffs can feature all types. For instance, copied and renamed entries cannot appear if detection for those types is disabled.\n\nLook for differences that change the number of occurrences of the specified <string> (i.e. addition/deletion) in a file. Intended for the scripter’s use.\n\nIt is useful when you’re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into -S, and keep going until you get the very first version of the block.\n\nBinary files are searched as well.\n\nLook for differences whose patch text contains added/removed lines that match <regex>.\n\nTo illustrate the difference between -S<regex> --pickaxe-regex and -G<regex>, consider a commit with the following diff in the same file:\n\nWhile git log -G\"frotz\\(nitfol\" will show this commit, git log -S\"frotz\\(nitfol\" --pickaxe-regex will not (because the number of occurrences of that string did not change).\n\nUnless --text is supplied patches of binary files without a textconv filter will be ignored.\n\nSee the pickaxe entry in gitdiffcore[7] for more information.\n\nLook for differences that change the number of occurrences of the specified object. Similar to -S, just the argument is different in that it doesn’t search for a specific string but for a specific object id.\n\nThe object can be a blob or a submodule commit. It implies the -t option in git-log to also find trees.\n\nWhen -S or -G finds a change, show all the changes in that changeset, not just the files that contain the change in <string>.\n\nTreat the <string> given to -S as an extended POSIX regular expression to match.\n\nControl the order in which files appear in the output. This overrides the diff.orderFile configuration variable (see git-config[1]). To cancel diff.orderFile, use -O/dev/null.\n\nThe output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.\n\n<orderfile> is parsed as follows:\n\nBlank lines are ignored, so they can be used as separators for readability.\n\nLines starting with a hash (\"#\") are ignored, so they can be used for comments. Add a backslash (\"\\\") to the beginning of the pattern if it starts with a hash.\n\nEach other line contains a single pattern.\n\nPatterns have the same syntax and semantics as patterns used for fnmatch(3) without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern. For example, the pattern \"foo*bar\" matches \"fooasdfbar\" and \"foo/bar/baz/asdf\" but not \"foobarx\".\n\nDiscard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to). These options were invented primarily for the use of the git difftool command, and may not be very useful otherwise.\n\nSwap two inputs; that is, show differences from index or on-disk file to tree contents.\n\nWhen run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative.\n\nTreat all files as text.\n\nIgnore carriage-return at the end of line when doing a comparison.\n\nIgnore changes in whitespace at EOL.\n\nIgnore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n\nIgnore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n\nIgnore changes whose lines are all blank.\n\nIgnore changes whose all lines match <regex>. This option may be specified more than once.\n\nShow the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n\nShow whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see \"Defining a custom hunk-header\" in gitattributes[5]).\n\nAllow an external diff helper to be executed. If you set an external diff driver with gitattributes[5], you need to use this option with git-log[1] and friends.\n\nDisallow external diff drivers.\n\nAllow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes[5] for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff[1] and git-log[1], but not for git-format-patch[1] or diff plumbing commands.\n\nIgnore changes to submodules in the diff generation. all is the default. Using none will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config[1] or gitmodules[5]. When untracked is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using dirty ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using all hides all changes to submodules.\n\nShow the given source <prefix> instead of \"a/\".\n\nShow the given destination <prefix> instead of \"b/\".\n\nDo not show any source or destination prefix.\n\nUse the default source and destination prefixes (\"a/\" and \"b/\"). This overrides configuration variables such as diff.noprefix, diff.srcPrefix, diff.dstPrefix, and diff.mnemonicPrefix (see git-config[1]).\n\nPrepend an additional <prefix> to every line of output.\n\nBy default entries added by git add -N appear as an existing empty file in git diff and a new file in git diff --cached. This option makes the entry appear as a new file in git diff and non-existent in git diff --cached. This option could be reverted with --ita-visible-in-index. Both options are experimental and could be removed in future.\n\nFor more detailed explanation on these common options, see also gitdiffcore[7].\n\n• Blank lines are ignored, so they can be used as separators for readability.\n• Lines starting with a hash (\"#\") are ignored, so they can be used for comments. Add a backslash (\"\\\") to the beginning of the pattern if it starts with a hash.\n• Each other line contains a single pattern.\n\n**-p**: Generate patch (see Generating patch text with -p).\n**-u**: Suppress all output from the diff machinery. Useful for commands like git show that show the patch by default to squelch their output, or to cancel the effect of options like --patch, --stat earlier on the command line in an alias.\n**--patch**: Show diffs for merge commits in the default format. This is similar to --diff-merges=on, except -m will produce no output unless -p is given as well.\n**-s**: Produce combined diff output for merge commits. Shortcut for --diff-merges=combined -p.\n**--no-patch**: Produce dense combined diff output for merge commits. Shortcut for --diff-merges=dense-combined -p.\n**-m**: Produce diff with respect to first parent for both merge and regular commits. Shortcut for --diff-merges=first-parent -p.\n**-c**: Produce remerge-diff output for merge commits. Shortcut for --diff-merges=remerge -p.\n**--cc**: Synonym for --diff-merges=off.\n**--dd**: Specify diff format to be used for merge commits. Default is `dense-combined` unless --first-parent is in use, in which case first-parent is the default. The following formats are supported: off none Disable output of diffs for merge commits. Useful to override implied value. on m Make diff output for merge commits to be shown in the default format. The default format can be changed using log.diffMerges configuration variable, whose default value is separate. first-parent 1 Show full diff with respect to first parent. This is the same format as --patch produces for non-merge commits. separate Show full diff with respect to each of parents. Separate log entry and diff is generated for each parent. combined c Show differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents. dense-combined cc Further compress output produced by --diff-merges=combined by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification. remerge r Remerge two-parent merge commits to create a temporary tree object—potentially containing files with conflict markers and such. A diff is then shown between that temporary tree and the actual merge commit. The output emitted when this option is used is subject to change, and so is its interaction with other options (unless explicitly documented).\n**--remerge-diff**: Disable output of diffs for merge commits. Useful to override implied value.\n**--no-diff-merges**: Make diff output for merge commits to be shown in the default format. The default format can be changed using log.diffMerges configuration variable, whose default value is separate.\n**--diff-merges=<format>**: Show full diff with respect to first parent. This is the same format as --patch produces for non-merge commits.\n**off**: Show full diff with respect to each of parents. Separate log entry and diff is generated for each parent.\n**none**: Show differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents.\n**on**: Further compress output produced by --diff-merges=combined by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification.\n**m**: Remerge two-parent merge commits to create a temporary tree object—potentially containing files with conflict markers and such. A diff is then shown between that temporary tree and the actual merge commit.\n**first-parent**: Cause combined diffs (used for merge commits) to list the name of the file from all parents. It thus only has effect when --diff-merges=[dense-]combined is in use, and is likely only useful if filename changes are detected (i.e. when either rename or copy detection have been requested).\n**1**: Generate diffs with <n> lines of context instead of the usual three. Implies --patch.\n**separate**: Output to a specific file instead of stdout.\n**combined**: Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively.\n**c**: For each commit, show a summary of changes using the raw diff format. See the \"RAW OUTPUT FORMAT\" section of git-diff[1]. This is different from showing the log itself in raw format, which you can achieve with --format=raw.\n**dense-combined**: Synonym for -p --raw.\n**cc**: Show the tree objects in the diff output.\n**remerge**: Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.\n**r**: Disable the indent heuristic.\n**--combined-all-paths**: Spend extra time to make sure the smallest possible diff is produced.\n**-U<n>**: Generate a diff using the \"patience diff\" algorithm.\n**--unified=<n>**: Generate a diff using the \"histogram diff\" algorithm.\n**--output=<file>**: Generate a diff using the \"anchored diff\" algorithm. This option may be specified more than once. If a line exists in both the source and destination, exists only once, and starts with <text>, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the \"patience diff\" algorithm internally.\n**--output-indicator-new=<char>**: Choose a diff algorithm. The variants are as follows: default myers The basic greedy diff algorithm. Currently, this is the default. minimal Spend extra time to make sure the smallest possible diff is produced. patience Use \"patience diff\" algorithm when generating patches. histogram This algorithm extends the patience algorithm to \"support low-occurrence common elements\". For instance, if you configured the diff.algorithm variable to a non-default value and want to use the default one, then you have to use --diff-algorithm=default option.\n**--output-indicator-old=<char>**: The basic greedy diff algorithm. Currently, this is the default.\n**--output-indicator-context=<char>**: Spend extra time to make sure the smallest possible diff is produced.\n**--raw**: Use \"patience diff\" algorithm when generating patches.\n**--patch-with-raw**: This algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n**-t**: Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by <width>. The width of the filename part can be limited by giving another width <name-width> after a comma or by setting diff.statNameWidth=<name-width>. The width of the graph part can be limited by using --stat-graph-width=<graph-width> or by setting diff.statGraphWidth=<graph-width>. Using --stat or --stat-graph-width affects all commands generating a stat graph, while setting diff.statNameWidth or diff.statGraphWidth does not affect git format-patch. By giving a third parameter <count>, you can limit the output to the first <count> lines, followed by ... if there are more. These parameters can also be set individually with --stat-width=<width>, --stat-name-width=<name-width> and --stat-count=<count>.\n**--indent-heuristic**: Output a condensed summary of extended header information such as file creations or deletions (\"new\" or \"gone\", optionally +l if it’s a symlink) and mode changes (+x or -x for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies --stat.\n**--no-indent-heuristic**: Similar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly. For binary files, outputs two - instead of saying 0 0.\n**--minimal**: Output only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines.\n**--patience**: Output the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config[1]). The following parameters are available: changes Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given. lines Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options. files Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all. cumulative Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter. <limit> An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output. Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative.\n**--histogram**: Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n**--anchored=<text>**: Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n**--diff-algorithm=(patience|minimal|histogram|myers)**: Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n**default**: Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n**myers**: An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n**minimal**: Synonym for --dirstat=cumulative.\n**patience**: Synonym for --dirstat=files,<param>,....\n**histogram**: Output a condensed summary of extended header information such as creations, renames and mode changes.\n**--stat[=<width>[,<name-width>[,<count>]]]**: Synonym for -p --stat.\n**--compact-summary**: Separate the commits with NULs instead of newlines. Also, when --raw or --numstat has been given, do not munge pathnames and use NULs as output field terminators. Without this option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n**--numstat**: Show only the name of each changed file in the post-image tree. The file names are often encoded in UTF-8. For more information see the discussion about encoding in the git-log[1] manual page.\n**--shortstat**: Show only the name(s) and status of each changed file. See the description of the --diff-filter option on what the status letters mean. Just like --name-only the file names are often encoded in UTF-8.\n**-X [<param>,...]**: Specify how differences in submodules are shown. When specifying --submodule=short the short format is used. This format just shows the names of the commits at the beginning and end of the range. When --submodule or --submodule=log is specified, the log format is used. This format lists the commits in the range like git-submodule[1] summary does. When --submodule=diff is specified, the diff format is used. This format shows an inline diff of the changes in the submodule contents between the commit range. Defaults to diff.submodule or the short format if the config option is unset.\n**--dirstat[=<param>,...]**: Show colored diff. --color (i.e. without =<when>) is the same as --color=always. <when> can be one of always, never, or auto.\n**changes**: Turn off colored diff. It is the same as --color=never.\n**lines**: Moved lines of code are colored differently. The <mode> defaults to no if the option is not given and to zebra if the option with no mode is given. The mode must be one of: no Moved lines are not highlighted. default Is a synonym for zebra. This may change to a more sensible mode in the future. plain Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation. blocks Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart. zebra Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected. dimmed-zebra Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n**files**: Moved lines are not highlighted.\n**cumulative**: Is a synonym for zebra. This may change to a more sensible mode in the future.\n**<limit>**: Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.\n**--cumulative**: Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart.\n**--dirstat-by-file[=<param>,...]**: Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected.\n**--summary**: Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n**--patch-with-stat**: Turn off move detection. This can be used to override configuration settings. It is the same as --color-moved=no.\n**-z**: This configures how whitespace is ignored when performing the move detection for --color-moved. These modes can be given as a comma separated list: no Do not ignore whitespace when performing move detection. ignore-space-at-eol Ignore changes in whitespace at EOL. ignore-space-change Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent. ignore-all-space Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none. allow-indentation-change Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n**--name-only**: Do not ignore whitespace when performing move detection.\n**--name-status**: Ignore changes in whitespace at EOL.\n**--submodule[=<format>]**: Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n**--color[=<when>]**: Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n**--no-color**: Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n**--color-moved[=<mode>]**: Do not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as --color-moved-ws=no.\n**no**: By default, words are delimited by whitespace; see --word-diff-regex below. The <mode> defaults to plain, and must be one of: color Highlight changed words using only colors. Implies --color. plain Show words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous. porcelain Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own. none Disable word diff again. Note that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled.\n**default**: Highlight changed words using only colors. Implies --color.\n**plain**: Show words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.\n**blocks**: Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own.\n**zebra**: Disable word diff again.\n**dimmed-zebra**: Use <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies --word-diff unless it was already enabled. Every non-overlapping match of the <regex> is considered a word. Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences. You may want to append |[^[:space:]] to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline. For example, --word-diff-regex=. will treat each character as a word and, correspondingly, show differences character by character. The regex can also be set via a diff driver or configuration option, see gitattributes[5] or git-config[1]. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.\n**--no-color-moved**: Equivalent to --word-diff=color plus (if a regex was specified) --word-diff-regex=<regex>.\n**--color-moved-ws=<mode>,...**: Turn off rename detection, even when the configuration file gives the default to do so.\n**no**: Whether to use empty blobs as rename source.\n**ignore-space-at-eol**: Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by core.whitespace configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.\n**ignore-space-change**: Highlight whitespace errors in the context, old or new lines of the diff. Multiple values are separated by comma, none resets previous values, default reset the list to new and all is a shorthand for old,new,context. When this option is not given, and the configuration variable diff.wsErrorHighlight is not set, only whitespace errors in new lines are highlighted. The whitespace errors are colored with color.diff.whitespace.\n**ignore-all-space**: Instead of the first handful of characters, show the full pre- and post-image blob object names on the \"index\" line when generating patch format output.\n**allow-indentation-change**: In addition to --full-index, output a binary diff that can be applied with git-apply. Implies --patch.\n**--no-color-moved-ws**: Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. In diff-patch output format, --full-index takes higher precedence, i.e. if --full-index is specified, full blob names will be shown regardless of --abbrev. Non default number of digits can be specified with --abbrev=<n>.\n**--word-diff[=<mode>]**: Break complete rewrite changes into pairs of delete and create. This serves two purposes: It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number <m> controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines). When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number <n> controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file.\n**color**: If generating diffs, detect and report renames for each commit. For following files across renames while traversing history, see --follow. If <n> is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed. Without a % sign, the number is to be read as a fraction, with a decimal point before it. I.e., -M5 becomes 0.5, and is thus the same as -M50%. Similarly, -M05 is the same as -M5%. To limit detection to exact renames, use -M100%. The default similarity index is 50%.\n**plain**: Detect copies as well as renames. See also --find-copies-harder. If <n> is specified, it has the same meaning as for -M<n>.\n**porcelain**: For performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one -C option has the same effect.\n**none**: Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option. When used together with -B, omit also the preimage in the deletion part of a delete/create pair.\n**--word-diff-regex=<regex>**: The -M and -C options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources. (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.) For N sources and destinations, this exhaustive check is O(N^2). This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number. Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited.\n**--color-words[=<regex>]**: Select only files that are Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have their type (i.e. regular file, symlink, submodule, …) changed (T), are Unmerged (U), are Unknown (X), or have had their pairing Broken (B). Any combination of the filter characters (including none) can be used. When * (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected. Also, these upper-case letters can be downcased to exclude. E.g. --diff-filter=ad excludes added and deleted paths. Note that not all diffs can feature all types. For instance, copied and renamed entries cannot appear if detection for those types is disabled.\n**--no-renames**: Look for differences that change the number of occurrences of the specified <string> (i.e. addition/deletion) in a file. Intended for the scripter’s use. It is useful when you’re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into -S, and keep going until you get the very first version of the block. Binary files are searched as well.\n**--[no-]rename-empty**: Look for differences whose patch text contains added/removed lines that match <regex>. To illustrate the difference between -S<regex> --pickaxe-regex and -G<regex>, consider a commit with the following diff in the same file: + return frotz(nitfol, two->ptr, 1, 0); ... - hit = frotz(nitfol, mf2.ptr, 1, 0); While git log -G\"frotz\\(nitfol\" will show this commit, git log -S\"frotz\\(nitfol\" --pickaxe-regex will not (because the number of occurrences of that string did not change). Unless --text is supplied patches of binary files without a textconv filter will be ignored. See the pickaxe entry in gitdiffcore[7] for more information.\n**--check**: Look for differences that change the number of occurrences of the specified object. Similar to -S, just the argument is different in that it doesn’t search for a specific string but for a specific object id. The object can be a blob or a submodule commit. It implies the -t option in git-log to also find trees.\n**--ws-error-highlight=<kind>**: When -S or -G finds a change, show all the changes in that changeset, not just the files that contain the change in <string>.\n**--full-index**: Treat the <string> given to -S as an extended POSIX regular expression to match.\n**--binary**: Control the order in which files appear in the output. This overrides the diff.orderFile configuration variable (see git-config[1]). To cancel diff.orderFile, use -O/dev/null. The output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order. <orderfile> is parsed as follows: Blank lines are ignored, so they can be used as separators for readability. Lines starting with a hash (\"#\") are ignored, so they can be used for comments. Add a backslash (\"\\\") to the beginning of the pattern if it starts with a hash. Each other line contains a single pattern. Patterns have the same syntax and semantics as patterns used for fnmatch(3) without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern. For example, the pattern \"foo*bar\" matches \"fooasdfbar\" and \"foo/bar/baz/asdf\" but not \"foobarx\".\n**--abbrev[=<n>]**: Discard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to). These options were invented primarily for the use of the git difftool command, and may not be very useful otherwise.\n**-B[<n>][/<m>]**: Swap two inputs; that is, show differences from index or on-disk file to tree contents.\n**--break-rewrites[=[<n>][/<m>]]**: When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative.\n**-M[<n>]**: Treat all files as text.\n**--find-renames[=<n>]**: Ignore carriage-return at the end of line when doing a comparison.\n**-C[<n>]**: Ignore changes in whitespace at EOL.\n**--find-copies[=<n>]**: Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n**--find-copies-harder**: Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n**-D**: Ignore changes whose lines are all blank.\n**--irreversible-delete**: Ignore changes whose all lines match <regex>. This option may be specified more than once.\n**-l<num>**: Show the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n**--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]**: Show whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see \"Defining a custom hunk-header\" in gitattributes[5]).\n**-S<string>**: Allow an external diff helper to be executed. If you set an external diff driver with gitattributes[5], you need to use this option with git-log[1] and friends.\n**-G<regex>**: Disallow external diff drivers.\n**--find-object=<object-id>**: Allow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes[5] for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff[1] and git-log[1], but not for git-format-patch[1] or diff plumbing commands.\n**--pickaxe-all**: Ignore changes to submodules in the diff generation. all is the default. Using none will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config[1] or gitmodules[5]. When untracked is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using dirty ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using all hides all changes to submodules.\n**--pickaxe-regex**: Show the given source <prefix> instead of \"a/\".\n**-O<orderfile>**: Show the given destination <prefix> instead of \"b/\".\n**--skip-to=<file>**: Do not show any source or destination prefix.\n**--rotate-to=<file>**: Use the default source and destination prefixes (\"a/\" and \"b/\"). This overrides configuration variables such as diff.noprefix, diff.srcPrefix, diff.dstPrefix, and diff.mnemonicPrefix (see git-config[1]).\n**-R**: Prepend an additional <prefix> to every line of output.\n**--relative[=<path>]**: By default entries added by git add -N appear as an existing empty file in git diff and a new file in git diff --cached. This option makes the entry appear as a new file in git diff and non-existent in git diff --cached. This option could be reverted with --ita-visible-in-index. Both options are experimental and could be removed in future.\n**off**: Disable output of diffs for merge commits. Useful to override implied value.\n**none**: Make diff output for merge commits to be shown in the default format. The default format can be changed using log.diffMerges configuration variable, whose default value is separate.\n**on**: Show full diff with respect to first parent. This is the same format as --patch produces for non-merge commits.\n**m**: Show full diff with respect to each of parents. Separate log entry and diff is generated for each parent.\n**first-parent**: Show differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents.\n**1**: Further compress output produced by --diff-merges=combined by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification.\n**separate**: Remerge two-parent merge commits to create a temporary tree object—potentially containing files with conflict markers and such. A diff is then shown between that temporary tree and the actual merge commit.\n**default**: The basic greedy diff algorithm. Currently, this is the default.\n**myers**: Spend extra time to make sure the smallest possible diff is produced.\n**minimal**: Use \"patience diff\" algorithm when generating patches.\n**patience**: This algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n**changes**: Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n**lines**: Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n**files**: Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n**cumulative**: Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n**<limit>**: An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n**no**: Moved lines are not highlighted.\n**default**: Is a synonym for zebra. This may change to a more sensible mode in the future.\n**plain**: Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.\n**blocks**: Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart.\n**zebra**: Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected.\n**dimmed-zebra**: Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n**no**: Do not ignore whitespace when performing move detection.\n**ignore-space-at-eol**: Ignore changes in whitespace at EOL.\n**ignore-space-change**: Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n**ignore-all-space**: Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n**allow-indentation-change**: Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n**color**: Highlight changed words using only colors. Implies --color.\n**plain**: Show words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.\n**porcelain**: Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own.\n**none**: Disable word diff again.",
        "code_examples": [
          "```bash\n+    return frotz(nitfol, two->ptr, 1, 0);\n...\n-    hit = frotz(nitfol, mf2.ptr, 1, 0);\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 151,
          "content_length": 66237
        }
      },
      {
        "header": "Generating patch text with -p",
        "content": "Running git-diff[1], git-log[1], git-show[1], git-diff-index[1], git-diff-tree[1], or git-diff-files[1] with the -p option produces patch text. You can customize the creation of patch text via the GIT_EXTERNAL_DIFF and the GIT_DIFF_OPTS environment variables (see git[1]), and the diff attribute (see gitattributes[5]).\n\nWhat the -p option produces is slightly different from the traditional diff format:\n\nIt is preceded by a \"git diff\" header that looks like this:\n\nThe a/ and b/ filenames are the same unless rename/copy is involved. Especially, even for a creation or a deletion, /dev/null is not used in place of the a/ or b/ filenames.\n\nWhen a rename/copy is involved, file1 and file2 show the name of the source file of the rename/copy and the name of the file that the rename/copy produces, respectively.\n\nIt is followed by one or more extended header lines:\n\nFile modes <mode> are printed as 6-digit octal numbers including the file type and file permission bits.\n\nPath names in extended headers do not include the a/ and b/ prefixes.\n\nThe similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one.\n\nThe index line includes the blob object names before and after the change. The <mode> is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.\n\nPathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n\nAll the file1 files in the output refer to files before the commit, and all the file2 files refer to files after the commit. It is incorrect to apply each change to each file sequentially. For example, this patch will swap a and b:\n\nHunk headers mention the name of the function to which the hunk applies. See \"Defining a custom hunk-header\" in gitattributes[5] for details of how to tailor this to specific languages.\n\n• It is preceded by a \"git diff\" header that looks like this: diff --git a/file1 b/file2 The a/ and b/ filenames are the same unless rename/copy is involved. Especially, even for a creation or a deletion, /dev/null is not used in place of the a/ or b/ filenames. When a rename/copy is involved, file1 and file2 show the name of the source file of the rename/copy and the name of the file that the rename/copy produces, respectively.\n• It is followed by one or more extended header lines: old mode <mode> new mode <mode> deleted file mode <mode> new file mode <mode> copy from <path> copy to <path> rename from <path> rename to <path> similarity index <number> dissimilarity index <number> index <hash>..<hash> <mode> File modes <mode> are printed as 6-digit octal numbers including the file type and file permission bits. Path names in extended headers do not include the a/ and b/ prefixes. The similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one. The index line includes the blob object names before and after the change. The <mode> is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.\n• Pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n• All the file1 files in the output refer to files before the commit, and all the file2 files refer to files after the commit. It is incorrect to apply each change to each file sequentially. For example, this patch will swap a and b: diff --git a/a b/b rename from a rename to b diff --git a/b b/a rename from b rename to a\n• Hunk headers mention the name of the function to which the hunk applies. See \"Defining a custom hunk-header\" in gitattributes[5] for details of how to tailor this to specific languages.",
        "code_examples": [
          "```bash\noldmode<mode>newmode<mode>deletedfilemode<mode>newfilemode<mode>copyfrom<path>copyto<path>renamefrom<path>renameto<path>similarityindex<number>dissimilarityindex<number>index<hash>..<hash><mode>\n```"
        ],
        "usage_examples": [
          "```bash\ndiff --git a/file1 b/file2\n```",
          "```bash\ndiff --git a/a b/b\nrename from a\nrename to b\ndiff --git a/b b/a\nrename from b\nrename to a\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 13,
          "content_length": 4196
        }
      },
      {
        "header": "Combined diff format",
        "content": "Any diff-generating command can take the -c or --cc option to produce a combined diff when showing a merge. This is the default format when showing merges with git-diff[1] or git-show[1]. Note also that you can give suitable --diff-merges option to any of these commands to force generation of diffs in a specific format.\n\nA \"combined diff\" format looks like this:\n\nIt is preceded by a \"git diff\" header, that looks like this (when the -c option is used):\n\nor like this (when the --cc option is used):\n\nIt is followed by one or more extended header lines (this example shows a merge with two parents):\n\nThe mode <mode>,<mode>..<mode> line appears only if at least one of the <mode> is different from the rest. Extended headers with information about detected content movement (renames and copying detection) are designed to work with the diff of two <tree-ish> and are not used by combined diff format.\n\nIt is followed by a two-line from-file/to-file header:\n\nSimilar to the two-line header for the traditional unified diff format, /dev/null is used to signal created or deleted files.\n\nHowever, if the --combined-all-paths option is provided, instead of a two-line from-file/to-file, you get an N+1 line from-file/to-file header, where N is the number of parents in the merge commit:\n\nThis extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents.\n\nChunk header format is modified to prevent people from accidentally feeding it to patch -p1. Combined diff format was created for review of merge commit changes, and was not meant to be applied. The change is similar to the change in the extended index header:\n\nThere are (number of parents + 1) @ characters in the chunk header for combined diff format.\n\nUnlike the traditional unified diff format, which shows two files A and B with a single column that has - (minus — appears in A but removed in B), + (plus — missing in A but added to B), or \" \" (space — unchanged) prefix, this format compares two or more files file1, file2,… with one file X, and shows how X differs from each of fileN. One column for each of fileN is prepended to the output line to note how X’s line is different from it.\n\nA - character in the column N means that the line appears in fileN but it does not appear in the result. A + character in the column N means that the line appears in the result, and fileN does not have that line (in other words, the line was added, from the point of view of that parent).\n\nIn the above example output, the function signature was changed from both files (hence two - removals from both file1 and file2, plus ++ to mean one line that was added does not appear in either file1 or file2). Also, eight other lines are the same from file1 but do not appear in file2 (hence prefixed with +).\n\nWhen shown by git diff-tree -c, it compares the parents of a merge commit with the merge result (i.e. file1..fileN are the parents). When shown by git diff-files -c, it compares the two unresolved merge parents with the working tree file (i.e. file1 is stage 2 aka \"our version\", file2 is stage 3 aka \"their version\").\n\n• It is preceded by a \"git diff\" header, that looks like this (when the -c option is used): diff --combined file or like this (when the --cc option is used): diff --cc file\n• It is followed by one or more extended header lines (this example shows a merge with two parents): index <hash>,<hash>..<hash> mode <mode>,<mode>..<mode> new file mode <mode> deleted file mode <mode>,<mode> The mode <mode>,<mode>..<mode> line appears only if at least one of the <mode> is different from the rest. Extended headers with information about detected content movement (renames and copying detection) are designed to work with the diff of two <tree-ish> and are not used by combined diff format.\n• It is followed by a two-line from-file/to-file header: --- a/file +++ b/file Similar to the two-line header for the traditional unified diff format, /dev/null is used to signal created or deleted files. However, if the --combined-all-paths option is provided, instead of a two-line from-file/to-file, you get an N+1 line from-file/to-file header, where N is the number of parents in the merge commit: --- a/file --- a/file --- a/file +++ b/file This extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents.\n• Chunk header format is modified to prevent people from accidentally feeding it to patch -p1. Combined diff format was created for review of merge commit changes, and was not meant to be applied. The change is similar to the change in the extended index header: @@@ <from-file-range> <from-file-range> <to-file-range> @@@ There are (number of parents + 1) @ characters in the chunk header for combined diff format.",
        "code_examples": [
          "```bash\ndiff --combined describe.c\nindex fabadb8,cc95eb0..4866510\n--- a/describe.c\n+++ b/describe.c\n@@@ -98,20 -98,12 +98,20 @@@\n\treturn (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;\n  }\n\n- static void describe(char *arg)\n -static void describe(struct commit *cmit, int last_one)\n++static void describe(char *arg, int last_one)\n  {\n +\tunsigned char sha1[20];\n +\tstruct commit *cmit;\n\tstruct commit_list *list;\n\tstatic int initialized = 0;\n\tstruct commit_name *n;\n\n +\tif (get_sha1(arg, sha1) < 0)\n +\t\tusage(describe_usage);\n +\tcmit = lookup_commit_reference(sha1);\n +\tif (!cmit)\n +\t\tusage(describe_usage);\n +\n\tif (!initialized) {\n\t\tinitialized = 1;\n\t\tfor_each_ref(get_name);\n```",
          "```bash\ndiff --combined file\n```",
          "```bash\ndiff --cc file\n```",
          "```bash\nindex<hash>,<hash>..<hash>mode<mode>,<mode>..<mode>newfilemode<mode>deletedfilemode<mode>,<mode>\n```",
          "```bash\n--- a/file\n+++ b/file\n```",
          "```bash\n--- a/file\n--- a/file\n--- a/file\n+++ b/file\n```",
          "```bash\n@@@ <from-file-range> <from-file-range> <to-file-range> @@@\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 16,
          "content_length": 4844
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Shows the tag v1.0.0, along with the object the tag points at.\n\nShows the tree pointed to by the tag v1.0.0.\n\nShows the subject of the commit pointed to by the tag v1.0.0.\n\nShows the contents of the file Documentation/README as they were current in the 10th last commit of the branch next.\n\nConcatenates the contents of said Makefiles in the head of the branch master.\n\n**git show v1.0.0**: Shows the tag v1.0.0, along with the object the tag points at.\n**git show v1.0.0^{tree}**: Shows the tree pointed to by the tag v1.0.0.\n**git show -s --format=%s v1.0.0^{commit}**: Shows the subject of the commit pointed to by the tag v1.0.0.\n**git show next~10:Documentation/README**: Shows the contents of the file Documentation/README as they were current in the 10th last commit of the branch next.\n**git show master:Makefile master:t/Makefile**: Concatenates the contents of said Makefiles in the head of the branch master.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 919
        }
      },
      {
        "header": "DISCUSSION",
        "content": "Git is to some extent character encoding agnostic.\n\nThe contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the core level.\n\nPath names are encoded in UTF-8 normalization form C. This applies to tree objects, the index file, ref names, as well as path names in command line arguments, environment variables and config files (.git/config (see git-config[1]), gitignore[5], gitattributes[5] and gitmodules[5]).\n\nNote that Git at the core level treats path names simply as sequences of non-NUL bytes, there are no path name encoding conversions (except on Mac and Windows). Therefore, using non-ASCII path names will mostly work even on platforms and file systems that use legacy extended ASCII encodings. However, repositories created on such systems will not work properly on UTF-8-based systems (e.g. Linux, Mac, Windows) and vice versa. Additionally, many Git-based tools simply assume path names to be UTF-8 and will fail to display other encodings correctly.\n\nCommit log messages are typically encoded in UTF-8, but other extended ASCII encodings are also supported. This includes ISO-8859-x, CP125x and many others, but not UTF-16/32, EBCDIC and CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.).\n\nAlthough we encourage that the commit log messages are encoded in UTF-8, both the core and Git Porcelain are designed not to force UTF-8 on projects. If all participants of a particular project find it more convenient to use legacy encodings, Git does not forbid it. However, there are a few things to keep in mind.\n\ngit commit and git commit-tree issue a warning if the commit log message given to it does not look like a valid UTF-8 string, unless you explicitly say your project uses a legacy encoding. The way to say this is to have i18n.commitEncoding in .git/config file, like this:\n\nCommit objects created with the above setting record the value of i18n.commitEncoding in their encoding header. This is to help other people who look at them later. Lack of this header implies that the commit log message is encoded in UTF-8.\n\ngit log, git show, git blame and friends look at the encoding header of a commit object, and try to re-code the log message into UTF-8 unless otherwise specified. You can specify the desired output encoding with i18n.logOutputEncoding in .git/config file, like this:\n\nIf you do not have this configuration variable, the value of i18n.commitEncoding is used instead.\n\nNote that we deliberately chose not to re-code the commit log message when a commit is made to force UTF-8 at the commit object level, because re-coding to UTF-8 is not necessarily a reversible operation.\n\n• The contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the core level.\n• Path names are encoded in UTF-8 normalization form C. This applies to tree objects, the index file, ref names, as well as path names in command line arguments, environment variables and config files (.git/config (see git-config[1]), gitignore[5], gitattributes[5] and gitmodules[5]). Note that Git at the core level treats path names simply as sequences of non-NUL bytes, there are no path name encoding conversions (except on Mac and Windows). Therefore, using non-ASCII path names will mostly work even on platforms and file systems that use legacy extended ASCII encodings. However, repositories created on such systems will not work properly on UTF-8-based systems (e.g. Linux, Mac, Windows) and vice versa. Additionally, many Git-based tools simply assume path names to be UTF-8 and will fail to display other encodings correctly.\n• Commit log messages are typically encoded in UTF-8, but other extended ASCII encodings are also supported. This includes ISO-8859-x, CP125x and many others, but not UTF-16/32, EBCDIC and CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.).\n\n• git commit and git commit-tree issue a warning if the commit log message given to it does not look like a valid UTF-8 string, unless you explicitly say your project uses a legacy encoding. The way to say this is to have i18n.commitEncoding in .git/config file, like this: [i18n] commitEncoding = ISO-8859-1 Commit objects created with the above setting record the value of i18n.commitEncoding in their encoding header. This is to help other people who look at them later. Lack of this header implies that the commit log message is encoded in UTF-8.\n• git log, git show, git blame and friends look at the encoding header of a commit object, and try to re-code the log message into UTF-8 unless otherwise specified. You can specify the desired output encoding with i18n.logOutputEncoding in .git/config file, like this: [i18n] logOutputEncoding = ISO-8859-1 If you do not have this configuration variable, the value of i18n.commitEncoding is used instead.",
        "code_examples": [
          "```bash\n[i18n]\n\tcommitEncoding = ISO-8859-1\n```",
          "```bash\n[i18n]\n\tlogOutputEncoding = ISO-8859-1\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 11,
          "content_length": 4852
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-show",
    "doc_type": "git",
    "total_sections": 10
  },
  {
    "title": "Git",
    "summary": "NAME git-sparse-checkout - Reduce your working tree to a subset of tracked files\n\ngit-sparse-checkout - Reduce your working tree to a subset of tracked files",
    "sections": [
      {
        "header": "NAME",
        "content": "git-sparse-checkout - Reduce your working tree to a subset of tracked files",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 75
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "This command is used to create sparse checkouts, which change the working tree from having all tracked files present to only having a subset of those files. It can also switch which subset of files are present, or undo and go back to having all tracked files present in the working copy.\n\nThe subset of files is chosen by providing a list of directories in cone mode (the default), or by providing a list of patterns in non-cone mode.\n\nWhen in a sparse-checkout, other Git commands behave a bit differently. For example, switching branches will not update paths outside the sparse-checkout directories/patterns, and git commit -a will not record paths outside the sparse-checkout directories/patterns as deleted.\n\nTHIS COMMAND IS EXPERIMENTAL. ITS BEHAVIOR, AND THE BEHAVIOR OF OTHER COMMANDS IN THE PRESENCE OF SPARSE-CHECKOUTS, WILL LIKELY CHANGE IN THE FUTURE.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 863
        }
      },
      {
        "header": "COMMANDS",
        "content": "Describe the directories or patterns in the sparse-checkout file.\n\nEnable the necessary sparse-checkout config settings (core.sparseCheckout, core.sparseCheckoutCone, and index.sparse) if they are not already set to the desired values, populate the sparse-checkout file from the list of arguments following the set subcommand, and update the working directory to match.\n\nTo ensure that adjusting the sparse-checkout settings within a worktree does not alter the sparse-checkout settings in other worktrees, the set subcommand will upgrade your repository config to use worktree-specific config if not already present. The sparsity defined by the arguments to the set subcommand are stored in the worktree-specific sparse-checkout file. See git-worktree[1] and the documentation of extensions.worktreeConfig in git-config[1] for more details.\n\nWhen the --stdin option is provided, the directories or patterns are read from standard in as a newline-delimited list instead of from the arguments.\n\nBy default, the input list is considered a list of directories, matching the output of git ls-tree -d --name-only. This includes interpreting pathnames that begin with a double quote (\") as C-style quoted strings. Note that all files under the specified directories (at any depth) will be included in the sparse checkout, as well as files that are siblings of either the given directory or any of its ancestors (see CONE PATTERN SET below for more details). In the past, this was not the default, and --cone needed to be specified or core.sparseCheckoutCone needed to be enabled.\n\nWhen --no-cone is passed, the input list is considered a list of patterns. This mode has a number of drawbacks, including not working with some options like --sparse-index. As explained in the \"Non-cone Problems\" section below, we do not recommend using it.\n\nUse the --[no-]sparse-index option to use a sparse index (the default is to not use it). A sparse index reduces the size of the index to be more closely aligned with your sparse-checkout definition. This can have significant performance advantages for commands such as git status or git add. This feature is still experimental. Some commands might be slower with a sparse index until they are properly integrated with the feature.\n\nWARNING: Using a sparse index requires modifying the index in a way that is not completely understood by external tools. If you have trouble with this compatibility, then run git sparse-checkout init --no-sparse-index to rewrite your index to not be sparse. Older versions of Git will not understand the sparse directory entries index extension and may fail to interact with your repository until it is disabled.\n\nUpdate the sparse-checkout file to include additional directories (in cone mode) or patterns (in non-cone mode). By default, these directories or patterns are read from the command-line arguments, but they can be read from stdin using the --stdin option.\n\nReapply the sparsity pattern rules to paths in the working tree. Commands like merge or rebase can materialize paths to do their work (e.g. in order to show you a conflict), and other sparse-checkout commands might fail to sparsify an individual file (e.g. because it has unstaged changes or conflicts). In such cases, it can make sense to run git sparse-checkout reapply later after cleaning up affected paths (e.g. resolving conflicts, undoing or committing changes, etc.).\n\nThe reapply command can also take --[no-]cone and --[no-]sparse-index flags, with the same meaning as the flags from the set command, in order to change which sparsity mode you are using without needing to also respecify all sparsity paths.\n\nDisable the core.sparseCheckout config setting, and restore the working directory to include all files.\n\nDeprecated command that behaves like set with no specified paths. May be removed in the future.\n\nHistorically, set did not handle all the necessary config settings, which meant that both init and set had to be called. Invoking both meant the init step would first remove nearly all tracked files (and in cone mode, ignored files too), then the set step would add many of the tracked files (but not ignored files) back. In addition to the lost files, the performance and UI of this combination was poor.\n\nAlso, historically, init would not actually initialize the sparse-checkout file if it already existed. This meant it was possible to return to a sparse-checkout without remembering which paths to pass to a subsequent set or add command. However, --cone and --sparse-index options would not be remembered across the disable command, so the easy restore of calling a plain init decreased in utility.\n\nCheck whether sparsity rules match one or more paths.\n\nBy default check-rules reads a list of paths from stdin and outputs only the ones that match the current sparsity rules. The input is expected to consist of one path per line, matching the output of git ls-tree --name-only including that pathnames that begin with a double quote (\") are interpreted as C-style quoted strings.\n\nWhen called with the --rules-file <file> flag the input files are matched against the sparse checkout rules found in <file> instead of the current ones. The rules in the files are expected to be in the same form as accepted by git sparse-checkout set --stdin (in particular, they must be newline-delimited).\n\nBy default, the rules passed to the --rules-file option are interpreted as cone mode directories. To pass non-cone mode patterns with --rules-file, combine the option with the --no-cone option.\n\nWhen called with the -z flag, the format of the paths input on stdin as well as the output paths are \\0 terminated and not quoted. Note that this does not apply to the format of the rules passed with the --rules-file option.\n\n**list**: Describe the directories or patterns in the sparse-checkout file.\n**set**: Enable the necessary sparse-checkout config settings (core.sparseCheckout, core.sparseCheckoutCone, and index.sparse) if they are not already set to the desired values, populate the sparse-checkout file from the list of arguments following the set subcommand, and update the working directory to match. To ensure that adjusting the sparse-checkout settings within a worktree does not alter the sparse-checkout settings in other worktrees, the set subcommand will upgrade your repository config to use worktree-specific config if not already present. The sparsity defined by the arguments to the set subcommand are stored in the worktree-specific sparse-checkout file. See git-worktree[1] and the documentation of extensions.worktreeConfig in git-config[1] for more details. When the --stdin option is provided, the directories or patterns are read from standard in as a newline-delimited list instead of from the arguments. By default, the input list is considered a list of directories, matching the output of git ls-tree -d --name-only. This includes interpreting pathnames that begin with a double quote (\") as C-style quoted strings. Note that all files under the specified directories (at any depth) will be included in the sparse checkout, as well as files that are siblings of either the given directory or any of its ancestors (see CONE PATTERN SET below for more details). In the past, this was not the default, and --cone needed to be specified or core.sparseCheckoutCone needed to be enabled. When --no-cone is passed, the input list is considered a list of patterns. This mode has a number of drawbacks, including not working with some options like --sparse-index. As explained in the \"Non-cone Problems\" section below, we do not recommend using it. Use the --[no-]sparse-index option to use a sparse index (the default is to not use it). A sparse index reduces the size of the index to be more closely aligned with your sparse-checkout definition. This can have significant performance advantages for commands such as git status or git add. This feature is still experimental. Some commands might be slower with a sparse index until they are properly integrated with the feature. WARNING: Using a sparse index requires modifying the index in a way that is not completely understood by external tools. If you have trouble with this compatibility, then run git sparse-checkout init --no-sparse-index to rewrite your index to not be sparse. Older versions of Git will not understand the sparse directory entries index extension and may fail to interact with your repository until it is disabled.\n**add**: Update the sparse-checkout file to include additional directories (in cone mode) or patterns (in non-cone mode). By default, these directories or patterns are read from the command-line arguments, but they can be read from stdin using the --stdin option.\n**reapply**: Reapply the sparsity pattern rules to paths in the working tree. Commands like merge or rebase can materialize paths to do their work (e.g. in order to show you a conflict), and other sparse-checkout commands might fail to sparsify an individual file (e.g. because it has unstaged changes or conflicts). In such cases, it can make sense to run git sparse-checkout reapply later after cleaning up affected paths (e.g. resolving conflicts, undoing or committing changes, etc.). The reapply command can also take --[no-]cone and --[no-]sparse-index flags, with the same meaning as the flags from the set command, in order to change which sparsity mode you are using without needing to also respecify all sparsity paths.\n**disable**: Disable the core.sparseCheckout config setting, and restore the working directory to include all files.\n**init**: Deprecated command that behaves like set with no specified paths. May be removed in the future. Historically, set did not handle all the necessary config settings, which meant that both init and set had to be called. Invoking both meant the init step would first remove nearly all tracked files (and in cone mode, ignored files too), then the set step would add many of the tracked files (but not ignored files) back. In addition to the lost files, the performance and UI of this combination was poor. Also, historically, init would not actually initialize the sparse-checkout file if it already existed. This meant it was possible to return to a sparse-checkout without remembering which paths to pass to a subsequent set or add command. However, --cone and --sparse-index options would not be remembered across the disable command, so the easy restore of calling a plain init decreased in utility.\n**check-rules**: Check whether sparsity rules match one or more paths. By default check-rules reads a list of paths from stdin and outputs only the ones that match the current sparsity rules. The input is expected to consist of one path per line, matching the output of git ls-tree --name-only including that pathnames that begin with a double quote (\") are interpreted as C-style quoted strings. When called with the --rules-file <file> flag the input files are matched against the sparse checkout rules found in <file> instead of the current ones. The rules in the files are expected to be in the same form as accepted by git sparse-checkout set --stdin (in particular, they must be newline-delimited). By default, the rules passed to the --rules-file option are interpreted as cone mode directories. To pass non-cone mode patterns with --rules-file, combine the option with the --no-cone option. When called with the -z flag, the format of the paths input on stdin as well as the output paths are \\0 terminated and not quoted. Note that this does not apply to the format of the rules passed with the --rules-file option.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 20,
          "content_length": 11610
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Change to a sparse checkout with all files (at any depth) under MY/DIR1/ and SUB/DIR2/ present in the working copy (plus all files immediately under MY/ and SUB/ and the toplevel directory). If already in a sparse checkout, change which files are present in the working copy to this new selection. Note that this command will also delete all ignored files in any directory that no longer has either tracked or non-ignored-untracked files present.\n\nRepopulate the working directory with all files, disabling sparse checkouts.\n\nAdd all files under SOME/DIR/ECTORY/ (at any depth) to the sparse checkout, as well as all files immediately under SOME/DIR/ and immediately under SOME/. Must already be in a sparse checkout before using this command.\n\nIt is possible for commands to update the working tree in a way that does not respect the selected sparsity directories. This can come from tools external to Git writing files, or even affect Git commands because of either special cases (such as hitting conflicts when merging/rebasing), or because some commands didn’t fully support sparse checkouts (e.g. the old recursive merge backend had only limited support). This command reapplies the existing sparse directory specifications to make the working directory match.\n\n**git sparse-checkout set MY/DIR1 SUB/DIR2**: Change to a sparse checkout with all files (at any depth) under MY/DIR1/ and SUB/DIR2/ present in the working copy (plus all files immediately under MY/ and SUB/ and the toplevel directory). If already in a sparse checkout, change which files are present in the working copy to this new selection. Note that this command will also delete all ignored files in any directory that no longer has either tracked or non-ignored-untracked files present.\n**git sparse-checkout disable**: Repopulate the working directory with all files, disabling sparse checkouts.\n**git sparse-checkout add SOME/DIR/ECTORY**: Add all files under SOME/DIR/ECTORY/ (at any depth) to the sparse checkout, as well as all files immediately under SOME/DIR/ and immediately under SOME/. Must already be in a sparse checkout before using this command.\n**git sparse-checkout reapply**: It is possible for commands to update the working tree in a way that does not respect the selected sparsity directories. This can come from tools external to Git writing files, or even affect Git commands because of either special cases (such as hitting conflicts when merging/rebasing), or because some commands didn’t fully support sparse checkouts (e.g. the old recursive merge backend had only limited support). This command reapplies the existing sparse directory specifications to make the working directory match.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 2686
        }
      },
      {
        "header": "INTERNALS — SPARSE CHECKOUT",
        "content": "\"Sparse checkout\" allows populating the working directory sparsely. It uses the skip-worktree bit (see git-update-index[1]) to tell Git whether a file in the working directory is worth looking at. If the skip-worktree bit is set, and the file is not present in the working tree, then its absence is ignored. Git will avoid populating the contents of those files, which makes a sparse checkout helpful when working in a repository with many files, but only a few are important to the current user.\n\nThe $GIT_DIR/info/sparse-checkout file is used to define the skip-worktree reference bitmap. When Git updates the working directory, it updates the skip-worktree bits in the index based on this file. The files matching the patterns in the file will appear in the working directory, and the rest will not.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 802
        }
      },
      {
        "header": "INTERNALS — NON-CONE PROBLEMS",
        "content": "The $GIT_DIR/info/sparse-checkout file populated by the set and add subcommands is defined to be a bunch of patterns (one per line) using the same syntax as .gitignore files. In cone mode, these patterns are restricted to matching directories (and users only ever need supply or see directory names), while in non-cone mode any gitignore-style pattern is permitted. Using the full gitignore-style patterns in non-cone mode has a number of shortcomings:\n\nFundamentally, it makes various worktree-updating processes (pull, merge, rebase, switch, reset, checkout, etc.) require O(N*M) pattern matches, where N is the number of patterns and M is the number of paths in the index. This scales poorly.\n\nAvoiding the scaling issue has to be done via limiting the number of patterns via specifying leading directory name or glob.\n\nPassing globs on the command line is error-prone as users may forget to quote the glob, causing the shell to expand it into all matching files and pass them all individually along to sparse-checkout set/add. While this could also be a problem with e.g. \"git grep — *.c\", mistakes with grep/log/status appear in the immediate output. With sparse-checkout, the mistake gets recorded at the time the sparse-checkout command is run and might not be problematic until the user later switches branches or rebases or merges, thus putting a delay between the user’s error and when they have a chance to catch/notice it.\n\nRelated to the previous item, sparse-checkout has an add subcommand but no remove subcommand. Even if a remove subcommand were added, undoing an accidental unquoted glob runs the risk of \"removing too much\", as it may remove entries that had been included before the accidental add.\n\nNon-cone mode uses gitignore-style patterns to select what to include (with the exception of negated patterns), while .gitignore files use gitignore-style patterns to select what to exclude (with the exception of negated patterns). The documentation on gitignore-style patterns usually does not talk in terms of matching or non-matching, but on what the user wants to \"exclude\". This can cause confusion for users trying to learn how to specify sparse-checkout patterns to get their desired behavior.\n\nEvery other git subcommand that wants to provide \"special path pattern matching\" of some sort uses pathspecs, but non-cone mode for sparse-checkout uses gitignore patterns, which feels inconsistent.\n\nIt has edge cases where the \"right\" behavior is unclear. Two examples:\n\nFirst, two users are in a subdirectory, and the first runs\n\nwhile the second runs\n\nShould those arguments be transliterated into\n\nbefore inserting into the sparse-checkout file? The user who typed the first command is probably aware that arguments to set/add are supposed to be patterns in non-cone mode, and probably would not be happy with such a transliteration. However, many gitignore-style patterns are just paths, which might be what the user who typed the second command was thinking, and they’d be upset if their argument wasn’t transliterated.\n\nSecond, what should bash-completion complete on for set/add commands for non-cone users? If it suggests paths, is it exacerbating the problem above? Also, if it suggests paths, what if the user has a file or directory that begins with either a ! or # or has a *, \\, ?, [, or ] in its name? And if it suggests paths, will it complete \"/pro\" to \"/proc\" (in the root filesystem) rather than to \"/progress.txt\" in the current directory? (Note that users are likely to want to start paths with a leading / in non-cone mode, for the same reason that .gitignore files often have one.) Completing on files or directories might give nasty surprises in all these cases.\n\nThe excessive flexibility made other extensions essentially impractical. --sparse-index is likely impossible in non-cone mode; even if it is somehow feasible, it would have been far more work to implement and may have been too slow in practice. Some ideas for adding coupling between partial clones and sparse checkouts are only practical with a more restricted set of paths as well.\n\nFor all these reasons, non-cone mode is deprecated. Please switch to using cone mode.\n\n• Fundamentally, it makes various worktree-updating processes (pull, merge, rebase, switch, reset, checkout, etc.) require O(N*M) pattern matches, where N is the number of patterns and M is the number of paths in the index. This scales poorly.\n• Avoiding the scaling issue has to be done via limiting the number of patterns via specifying leading directory name or glob.\n• Passing globs on the command line is error-prone as users may forget to quote the glob, causing the shell to expand it into all matching files and pass them all individually along to sparse-checkout set/add. While this could also be a problem with e.g. \"git grep — *.c\", mistakes with grep/log/status appear in the immediate output. With sparse-checkout, the mistake gets recorded at the time the sparse-checkout command is run and might not be problematic until the user later switches branches or rebases or merges, thus putting a delay between the user’s error and when they have a chance to catch/notice it.\n• Related to the previous item, sparse-checkout has an add subcommand but no remove subcommand. Even if a remove subcommand were added, undoing an accidental unquoted glob runs the risk of \"removing too much\", as it may remove entries that had been included before the accidental add.\n• Non-cone mode uses gitignore-style patterns to select what to include (with the exception of negated patterns), while .gitignore files use gitignore-style patterns to select what to exclude (with the exception of negated patterns). The documentation on gitignore-style patterns usually does not talk in terms of matching or non-matching, but on what the user wants to \"exclude\". This can cause confusion for users trying to learn how to specify sparse-checkout patterns to get their desired behavior.\n• Every other git subcommand that wants to provide \"special path pattern matching\" of some sort uses pathspecs, but non-cone mode for sparse-checkout uses gitignore patterns, which feels inconsistent.\n• It has edge cases where the \"right\" behavior is unclear. Two examples: First, two users are in a subdirectory, and the first runs git sparse-checkout set '/toplevel-dir/*.c' while the second runs git sparse-checkout set relative-dir Should those arguments be transliterated into current/subdirectory/toplevel-dir/*.c and current/subdirectory/relative-dir before inserting into the sparse-checkout file? The user who typed the first command is probably aware that arguments to set/add are supposed to be patterns in non-cone mode, and probably would not be happy with such a transliteration. However, many gitignore-style patterns are just paths, which might be what the user who typed the second command was thinking, and they’d be upset if their argument wasn’t transliterated. Second, what should bash-completion complete on for set/add commands for non-cone users? If it suggests paths, is it exacerbating the problem above? Also, if it suggests paths, what if the user has a file or directory that begins with either a ! or # or has a *, \\, ?, [, or ] in its name? And if it suggests paths, will it complete \"/pro\" to \"/proc\" (in the root filesystem) rather than to \"/progress.txt\" in the current directory? (Note that users are likely to want to start paths with a leading / in non-cone mode, for the same reason that .gitignore files often have one.) Completing on files or directories might give nasty surprises in all these cases.\n• The excessive flexibility made other extensions essentially impractical. --sparse-index is likely impossible in non-cone mode; even if it is somehow feasible, it would have been far more work to implement and may have been too slow in practice. Some ideas for adding coupling between partial clones and sparse checkouts are only practical with a more restricted set of paths as well.",
        "code_examples": [
          "```bash\ncurrent/subdirectory/toplevel-dir/*.c\n```",
          "```bash\ncurrent/subdirectory/relative-dir\n```"
        ],
        "usage_examples": [
          "```bash\ngit sparse-checkout set '/toplevel-dir/*.c'\n```",
          "```bash\ngit sparse-checkout set relative-dir\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 15,
          "content_length": 7982
        }
      },
      {
        "header": "INTERNALS — CONE MODE HANDLING",
        "content": "The \"cone mode\", which is the default, lets you specify only what directories to include. For any directory specified, all paths below that directory will be included, and any paths immediately under leading directories (including the toplevel directory) will also be included. Thus, if you specified the directory Documentation/technical/ then your sparse checkout would contain:\n\nall files in the toplevel-directory\n\nall files immediately under Documentation/\n\nall files at any depth under Documentation/technical/\n\nAlso, in cone mode, even if no directories are specified, then the files in the toplevel directory will be included.\n\nWhen changing the sparse-checkout patterns in cone mode, Git will inspect each tracked directory that is not within the sparse-checkout cone to see if it contains any untracked files. If all of those files are ignored due to the .gitignore patterns, then the directory will be deleted. If any of the untracked files within that directory is not ignored, then no deletions will occur within that directory and a warning message will appear. If these files are important, then reset your sparse-checkout definition so they are included, use git add and git commit to store them, then remove any remaining files manually to ensure Git can behave optimally.\n\nSee also the \"Internals — Cone Pattern Set\" section to learn how the directories are transformed under the hood into a subset of the Full Pattern Set of sparse-checkout.\n\n• all files in the toplevel-directory\n• all files immediately under Documentation/\n• all files at any depth under Documentation/technical/",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1600
        }
      },
      {
        "header": "INTERNALS — FULL PATTERN SET",
        "content": "The full pattern set allows for arbitrary pattern matches and complicated inclusion/exclusion rules. These can result in O(N*M) pattern matches when updating the index, where N is the number of patterns and M is the number of paths in the index. To combat this performance issue, a more restricted pattern set is allowed when core.sparseCheckoutCone is enabled.\n\nThe sparse-checkout file uses the same syntax as .gitignore files; see gitignore[5] for details. Here, though, the patterns are usually being used to select which files to include rather than which files to exclude. (However, it can get a bit confusing since gitignore-style patterns have negations defined by patterns which begin with a !, so you can also select files to not include.)\n\nFor example, to select everything, and then to remove the file unwanted (so that every file will appear in your working tree except the file named unwanted):\n\nThese patterns are just placed into the $GIT_DIR/info/sparse-checkout as-is, so the contents of that file at this point would be\n\nSee also the \"Sparse Checkout\" section of git-read-tree[1] to learn more about the gitignore-style patterns used in sparse checkouts.",
        "code_examples": [
          "```bash\n/*\n!unwanted\n```"
        ],
        "usage_examples": [
          "```bash\ngit sparse-checkout set --no-cone '/*' '!unwanted'\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1173
        }
      },
      {
        "header": "INTERNALS — CONE PATTERN SET",
        "content": "In cone mode, only directories are accepted, but they are translated into the same gitignore-style patterns used in the full pattern set. We refer to the particular patterns used in those mode as being of one of two types:\n\nRecursive: All paths inside a directory are included.\n\nParent: All files immediately inside a directory are included.\n\nSince cone mode always includes files at the toplevel, when running git sparse-checkout set with no directories specified, the toplevel directory is added as a parent pattern. At this point, the sparse-checkout file contains the following patterns:\n\nThis says \"include everything immediately under the toplevel directory, but nothing at any level below that.\"\n\nWhen in cone mode, the git sparse-checkout set subcommand takes a list of directories. The command git sparse-checkout set A/B/C sets the directory A/B/C as a recursive pattern, the directories A and A/B are added as parent patterns. The resulting sparse-checkout file is now\n\nHere, order matters, so the negative patterns are overridden by the positive patterns that appear lower in the file.\n\nUnless core.sparseCheckoutCone is explicitly set to false, Git will parse the sparse-checkout file expecting patterns of these types. Git will warn if the patterns do not match. If the patterns do match the expected format, then Git will use faster hash-based algorithms to compute inclusion in the sparse-checkout. If they do not match, git will behave as though core.sparseCheckoutCone was false, regardless of its setting.\n\nIn the cone mode case, despite the fact that full patterns are written to the $GIT_DIR/info/sparse-checkout file, the git sparse-checkout list subcommand will list the directories that define the recursive patterns. For the example sparse-checkout file above, the output is as follows:\n\nIf core.ignoreCase=true, then the pattern-matching algorithm will use a case-insensitive check. This corrects for case mismatched filenames in the git sparse-checkout set command to reflect the expected cone in the working directory.\n\n• Recursive: All paths inside a directory are included.\n• Parent: All files immediately inside a directory are included.",
        "code_examples": [
          "```bash\n/*\n!/*/\n```",
          "```bash\n/*\n!/*/\n/A/\n!/A/*/\n/A/B/\n!/A/B/*/\n/A/B/C/\n```"
        ],
        "usage_examples": [
          "```bash\n$ git sparse-checkout list\nA/B/C\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 2168
        }
      },
      {
        "header": "INTERNALS — SUBMODULES",
        "content": "If your repository contains one or more submodules, then submodules are populated based on interactions with the git submodule command. Specifically, git submodule init -- <path> will ensure the submodule at <path> is present, while git submodule deinit [-f] -- <path> will remove the files for the submodule at <path> (including any untracked files, uncommitted changes, and unpushed history). Similar to how sparse-checkout removes files from the working tree but still leaves entries in the index, deinitialized submodules are removed from the working directory but still have an entry in the index.\n\nSince submodules may have unpushed changes or untracked files, removing them could result in data loss. Thus, changing sparse inclusion/exclusion rules will not cause an already checked out submodule to be removed from the working copy. Said another way, just as checkout will not cause submodules to be automatically removed or initialized even when switching between branches that remove or add submodules, using sparse-checkout to reduce or expand the scope of \"interesting\" files will not cause submodules to be automatically deinitialized or initialized either.\n\nFurther, the above facts mean that there are multiple reasons that \"tracked\" files might not be present in the working copy: sparsity pattern application from sparse-checkout, and submodule initialization state. Thus, commands like git grep that work on tracked files in the working copy may return results that are limited by either or both of these restrictions.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1536
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-read-tree[1] gitignore[5]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 29
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-sparse-checkout",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Git",
    "summary": "NAME git-stash - Stash the changes in a dirty working directory away\n\ngit-stash - Stash the changes in a dirty working directory away",
    "sections": [
      {
        "header": "NAME",
        "content": "git-stash - Stash the changes in a dirty working directory away",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 63
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Use git stash when you want to record the current state of the working directory and the index, but want to go back to a clean working directory. The command saves your local modifications away and reverts the working directory to match the HEAD commit.\n\nThe modifications stashed away by this command can be listed with git stash list, inspected with git stash show, and restored (potentially on top of a different commit) with git stash apply. Calling git stash without any arguments is equivalent to git stash push. A stash is by default listed as \"WIP on branchname …\", but you can give a more descriptive message on the command line when you create one.\n\nThe latest stash you created is stored in refs/stash; older stashes are found in the reflog of this reference and can be named using the usual reflog syntax (e.g. stash@{0} is the most recently created stash, stash@{1} is the one before it, stash@{2.hours.ago} is also possible). Stashes may also be referenced by specifying just the stash index (e.g. the integer n is equivalent to stash@{n}).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1054
        }
      },
      {
        "header": "COMMANDS",
        "content": "Save your local modifications to a new stash entry and roll them back to HEAD (in the working tree and in the index). The <message> part is optional and gives the description along with the stashed state.\n\nFor quickly making a snapshot, you can omit \"push\". In this mode, non-option arguments are not allowed to prevent a misspelled subcommand from making an unwanted stash entry. The two exceptions to this are stash -p which acts as alias for stash push -p and pathspec elements, which are allowed after a double hyphen -- for disambiguation.\n\nThis option is deprecated in favour of git stash push. It differs from \"stash push\" in that it cannot take pathspec. Instead, all non-option arguments are concatenated to form the stash message.\n\nList the stash entries that you currently have. Each stash entry is listed with its name (e.g. stash@{0} is the latest entry, stash@{1} is the one before, etc.), the name of the branch that was current when the entry was made, and a short description of the commit the entry was based on.\n\nThe command takes options applicable to the git log command to control what is shown and how. See git-log[1].\n\nShow the changes recorded in the stash entry as a diff between the stashed contents and the commit back when the stash entry was first created. By default, the command shows the diffstat, but it will accept any format known to git diff (e.g., git stash show -p stash@{1} to view the second most recent entry in patch form). If no <diff-option> is provided, the default behavior will be given by the stash.showStat, and stash.showPatch config variables. You can also use stash.showIncludeUntracked to set whether --include-untracked is enabled by default.\n\nRemove a single stashed state from the stash list and apply it on top of the current working tree state, i.e., do the inverse operation of git stash push. The working directory must match the index.\n\nApplying the state can fail with conflicts; in this case, it is not removed from the stash list. You need to resolve the conflicts by hand and call git stash drop manually afterwards.\n\nLike pop, but do not remove the state from the stash list. Unlike pop, <stash> may be any commit that looks like a commit created by stash push or stash create.\n\nCreates and checks out a new branch named <branchname> starting from the commit at which the <stash> was originally created, applies the changes recorded in <stash> to the new working tree and index. If that succeeds, and <stash> is a reference of the form stash@{<revision>}, it then drops the <stash>.\n\nThis is useful if the branch on which you ran git stash push has changed enough that git stash apply fails due to conflicts. Since the stash entry is applied on top of the commit that was HEAD at the time git stash was run, it restores the originally stashed state with no conflicts.\n\nRemove all the stash entries. Note that those entries will then be subject to pruning, and may be impossible to recover (see Examples below for a possible strategy).\n\nRemove a single stash entry from the list of stash entries.\n\nCreate a stash entry (which is a regular commit object) and return its object name, without storing it anywhere in the ref namespace. This is intended to be useful for scripts. It is probably not the command you want to use; see \"push\" above.\n\nStore a given stash created via git stash create (which is a dangling merge commit) in the stash ref, updating the stash reflog. This is intended to be useful for scripts. It is probably not the command you want to use; see \"push\" above.\n\nExport the specified stashes, or all of them if none are specified, to a chain of commits which can be transferred using the normal fetch and push mechanisms, then imported using the import subcommand.\n\nImport the specified stashes from the specified commit, which must have been created by export, and add them to the list of stashes. To replace the existing stashes, use clear first.\n\n**push [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [(-m|--message) <message>] [--pathspec-from-file=<file> [--pathspec-file-nul]] [--] [<pathspec>…]**: Save your local modifications to a new stash entry and roll them back to HEAD (in the working tree and in the index). The <message> part is optional and gives the description along with the stashed state. For quickly making a snapshot, you can omit \"push\". In this mode, non-option arguments are not allowed to prevent a misspelled subcommand from making an unwanted stash entry. The two exceptions to this are stash -p which acts as alias for stash push -p and pathspec elements, which are allowed after a double hyphen -- for disambiguation.\n**save [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [<message>]**: This option is deprecated in favour of git stash push. It differs from \"stash push\" in that it cannot take pathspec. Instead, all non-option arguments are concatenated to form the stash message.\n**list [<log-options>]**: List the stash entries that you currently have. Each stash entry is listed with its name (e.g. stash@{0} is the latest entry, stash@{1} is the one before, etc.), the name of the branch that was current when the entry was made, and a short description of the commit the entry was based on. stash@{0}: WIP on submit: 6ebd0e2... Update git-stash documentation stash@{1}: On master: 9cc0589... Add git-stash The command takes options applicable to the git log command to control what is shown and how. See git-log[1].\n**show [-u|--include-untracked|--only-untracked] [<diff-options>] [<stash>]**: Show the changes recorded in the stash entry as a diff between the stashed contents and the commit back when the stash entry was first created. By default, the command shows the diffstat, but it will accept any format known to git diff (e.g., git stash show -p stash@{1} to view the second most recent entry in patch form). If no <diff-option> is provided, the default behavior will be given by the stash.showStat, and stash.showPatch config variables. You can also use stash.showIncludeUntracked to set whether --include-untracked is enabled by default.\n**pop [--index] [-q|--quiet] [<stash>]**: Remove a single stashed state from the stash list and apply it on top of the current working tree state, i.e., do the inverse operation of git stash push. The working directory must match the index. Applying the state can fail with conflicts; in this case, it is not removed from the stash list. You need to resolve the conflicts by hand and call git stash drop manually afterwards.\n**apply [--index] [-q|--quiet] [<stash>]**: Like pop, but do not remove the state from the stash list. Unlike pop, <stash> may be any commit that looks like a commit created by stash push or stash create.\n**branch <branchname> [<stash>]**: Creates and checks out a new branch named <branchname> starting from the commit at which the <stash> was originally created, applies the changes recorded in <stash> to the new working tree and index. If that succeeds, and <stash> is a reference of the form stash@{<revision>}, it then drops the <stash>. This is useful if the branch on which you ran git stash push has changed enough that git stash apply fails due to conflicts. Since the stash entry is applied on top of the commit that was HEAD at the time git stash was run, it restores the originally stashed state with no conflicts.\n**clear**: Remove all the stash entries. Note that those entries will then be subject to pruning, and may be impossible to recover (see Examples below for a possible strategy).\n**drop [-q|--quiet] [<stash>]**: Remove a single stash entry from the list of stash entries.\n**create**: Create a stash entry (which is a regular commit object) and return its object name, without storing it anywhere in the ref namespace. This is intended to be useful for scripts. It is probably not the command you want to use; see \"push\" above.\n**store**: Store a given stash created via git stash create (which is a dangling merge commit) in the stash ref, updating the stash reflog. This is intended to be useful for scripts. It is probably not the command you want to use; see \"push\" above.\n**export ( --print | --to-ref <ref> ) [<stash>…]**: Export the specified stashes, or all of them if none are specified, to a chain of commits which can be transferred using the normal fetch and push mechanisms, then imported using the import subcommand.\n**import <commit>**: Import the specified stashes from the specified commit, which must have been created by export, and add them to the list of stashes. To replace the existing stashes, use clear first.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nstash@{0}: WIP on submit: 6ebd0e2... Update git-stash documentation\nstash@{1}: On master: 9cc0589... Add git-stash\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 17,
          "content_length": 8659
        }
      },
      {
        "header": "OPTIONS",
        "content": "This option is only valid for push and save commands.\n\nAll ignored and untracked files are also stashed and then cleaned up with git clean.\n\nWhen used with the push and save commands, all untracked files are also stashed and then cleaned up with git clean.\n\nWhen used with the show command, show the untracked files in the stash entry as part of the diff.\n\nThis option is only valid for the show command.\n\nShow only the untracked files in the stash entry as part of the diff.\n\nThis option is only valid for pop and apply commands.\n\nTries to reinstate not only the working tree’s changes, but also the index’s ones. However, this can fail, when you have conflicts (which are stored in the index, where you therefore can no longer apply the changes as they were originally).\n\nThis option is only valid for push and save commands.\n\nAll changes already added to the index are left intact.\n\nThis option is only valid for push and save commands.\n\nInteractively select hunks from the diff between HEAD and the working tree to be stashed. The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree. See the “Interactive Mode” section of git-add[1] to learn how to operate the --patch mode.\n\nThe --patch option implies --keep-index. You can use --no-keep-index to override this.\n\nGenerate diffs with <n> lines of context. Defaults to diff.context or 3 if the config option is unset.\n\nShow the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n\nThis option is only valid for push and save commands.\n\nStash only the changes that are currently staged. This is similar to basic git commit except the state is committed to the stash instead of current branch.\n\nThe --patch option has priority over this one.\n\nThis option is only valid for push command.\n\nPathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config[1]). See also --pathspec-file-nul and global --literal-pathspecs.\n\nThis option is only valid for push command.\n\nOnly meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).\n\nThis option is only valid for apply, drop, pop, push, save, store commands.\n\nQuiet, suppress feedback messages.\n\nThis option is only valid for the export command.\n\nCreate the chain of commits representing the exported stashes without storing it anywhere in the ref namespace and print the object ID to standard output. This is designed for scripts.\n\nThis option is only valid for the export command.\n\nCreate the chain of commits representing the exported stashes and store it to the specified ref.\n\nThis option is only valid for push command.\n\nSeparates pathspec from options for disambiguation purposes.\n\nThis option is only valid for push command.\n\nThe new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.\n\nFor more details, see the pathspec entry in gitglossary[7].\n\nThis option is only valid for apply, branch, drop, pop, show, and export commands.\n\nA reference of the form stash@{<revision>}. When no <stash> is given, the latest stash is assumed (that is, stash@{0}).\n\n**-a**: This option is only valid for push and save commands. All ignored and untracked files are also stashed and then cleaned up with git clean.\n**--all**: When used with the push and save commands, all untracked files are also stashed and then cleaned up with git clean. When used with the show command, show the untracked files in the stash entry as part of the diff.\n**-u**: This option is only valid for the show command. Show only the untracked files in the stash entry as part of the diff.\n**--include-untracked**: This option is only valid for pop and apply commands. Tries to reinstate not only the working tree’s changes, but also the index’s ones. However, this can fail, when you have conflicts (which are stored in the index, where you therefore can no longer apply the changes as they were originally).\n**--no-include-untracked**: This option is only valid for push and save commands. All changes already added to the index are left intact.\n**--only-untracked**: This option is only valid for push and save commands. Interactively select hunks from the diff between HEAD and the working tree to be stashed. The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree. See the “Interactive Mode” section of git-add[1] to learn how to operate the --patch mode. The --patch option implies --keep-index. You can use --no-keep-index to override this.\n**--index**: Generate diffs with <n> lines of context. Defaults to diff.context or 3 if the config option is unset.\n**-k**: Show the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n**--keep-index**: This option is only valid for push and save commands. Stash only the changes that are currently staged. This is similar to basic git commit except the state is committed to the stash instead of current branch. The --patch option has priority over this one.\n**--no-keep-index**: This option is only valid for push command. Pathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config[1]). See also --pathspec-file-nul and global --literal-pathspecs.\n**-p**: This option is only valid for push command. Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).\n**--patch**: This option is only valid for apply, drop, pop, push, save, store commands. Quiet, suppress feedback messages.\n**-U<n>**: This option is only valid for the export command. Create the chain of commits representing the exported stashes without storing it anywhere in the ref namespace and print the object ID to standard output. This is designed for scripts.\n**--unified=<n>**: This option is only valid for the export command. Create the chain of commits representing the exported stashes and store it to the specified ref.\n**--inter-hunk-context=<n>**: This option is only valid for push command. Separates pathspec from options for disambiguation purposes.\n**-S**: This option is only valid for push command. The new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact. For more details, see the pathspec entry in gitglossary[7].\n**--staged**: This option is only valid for apply, branch, drop, pop, show, and export commands. A reference of the form stash@{<revision>}. When no <stash> is given, the latest stash is assumed (that is, stash@{0}).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 35,
          "content_length": 7793
        }
      },
      {
        "header": "DISCUSSION",
        "content": "A stash entry is represented as a commit whose tree records the state of the working directory, and its first parent is the commit at HEAD when the entry was created. The tree of the second parent records the state of the index when the entry is made, and it is made a child of the HEAD commit. The ancestry graph looks like this:\n\nwhere H is the HEAD commit, I is a commit that records the state of the index, and W is a commit that records the state of the working tree.",
        "code_examples": [
          "```bash\n.----W\n      /    /\n-----H----I\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 472
        }
      },
      {
        "header": "EXAMPLES",
        "content": "When you are in the middle of something, you learn that there are upstream changes that are possibly relevant to what you are doing. When your local changes do not conflict with the changes in the upstream, a simple git pull will let you move forward.\n\nHowever, there are cases in which your local changes do conflict with the upstream changes, and git pull refuses to overwrite your changes. In such a case, you can stash your changes away, perform a pull, and then unstash, like this:\n\nWhen you are in the middle of something, your boss comes in and demands that you fix something immediately. Traditionally, you would make a commit to a temporary branch to store your changes away, and return to your original branch to make the emergency fix, like this:\n\nYou can use git stash to simplify the above, like this:\n\nYou can use git stash push --keep-index when you want to make two or more commits out of the changes in the work tree, and you want to test each change before committing:\n\nWhen you are in the middle of massive changes and you find some unrelated issue that you don’t want to forget to fix, you can do the change(s), stage them, and use git stash push --staged to stash them out for future use. This is similar to committing the staged changes, only the commit ends-up being in the stash and not on the current branch.\n\nIf you mistakenly drop or clear stash entries, they cannot be recovered through the normal safety mechanisms. However, you can try the following incantation to get a list of stash entries that are still in your repository, but not reachable any more:\n\n**Pulling into a dirty tree**: When you are in the middle of something, you learn that there are upstream changes that are possibly relevant to what you are doing. When your local changes do not conflict with the changes in the upstream, a simple git pull will let you move forward. However, there are cases in which your local changes do conflict with the upstream changes, and git pull refuses to overwrite your changes. In such a case, you can stash your changes away, perform a pull, and then unstash, like this: $ git pull ... file foobar not up to date, cannot merge. $ git stash $ git pull $ git stash pop\n**Interrupted workflow**: When you are in the middle of something, your boss comes in and demands that you fix something immediately. Traditionally, you would make a commit to a temporary branch to store your changes away, and return to your original branch to make the emergency fix, like this: # ... hack hack hack ... $ git switch -c my_wip $ git commit -a -m \"WIP\" $ git switch master $ edit emergency fix $ git commit -a -m \"Fix in a hurry\" $ git switch my_wip $ git reset --soft HEAD^ # ... continue hacking ... You can use git stash to simplify the above, like this: # ... hack hack hack ... $ git stash $ edit emergency fix $ git commit -a -m \"Fix in a hurry\" $ git stash pop # ... continue hacking ...\n**Testing partial commits**: You can use git stash push --keep-index when you want to make two or more commits out of the changes in the work tree, and you want to test each change before committing: # ... hack hack hack ... $ git add --patch foo # add just first part to the index $ git stash push --keep-index # save all other changes to the stash $ edit/build/test first part $ git commit -m 'First part' # commit fully tested change $ git stash pop # prepare to work on all other changes # ... repeat above five steps until one commit remains ... $ edit/build/test remaining parts $ git commit foo -m 'Remaining parts'\n**Saving unrelated changes for future use**: When you are in the middle of massive changes and you find some unrelated issue that you don’t want to forget to fix, you can do the change(s), stage them, and use git stash push --staged to stash them out for future use. This is similar to committing the staged changes, only the commit ends-up being in the stash and not on the current branch. # ... hack hack hack ... $ git add --patch foo # add unrelated changes to the index $ git stash push --staged # save these changes to the stash # ... hack hack hack, finish current changes ... $ git commit -m 'Massive' # commit fully tested changes $ git switch fixup-branch # switch to another branch $ git stash pop # to finish work on the saved changes\n**Recovering stash entries that were cleared/dropped erroneously**: If you mistakenly drop or clear stash entries, they cannot be recovered through the normal safety mechanisms. However, you can try the following incantation to get a list of stash entries that are still in your repository, but not reachable any more: git fsck --unreachable | grep commit | cut -d\\ -f3 | xargs git log --merges --no-walk --grep=WIP",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git pull\n ...\nfile foobar not up to date, cannot merge.\n$ git stash\n$ git pull\n$ git stash pop\n```",
          "```bash\n# ... hack hack hack ...\n$ git switch -c my_wip\n$ git commit -a -m \"WIP\"\n$ git switch master\n$ edit emergency fix\n$ git commit -a -m \"Fix in a hurry\"\n$ git switch my_wip\n$ git reset --soft HEAD^\n# ... continue hacking ...\n```",
          "```bash\n# ... hack hack hack ...\n$ git stash\n$ edit emergency fix\n$ git commit -a -m \"Fix in a hurry\"\n$ git stash pop\n# ... continue hacking ...\n```",
          "```bash\n# ... hack hack hack ...\n$ git add --patch foo            # add just first part to the index\n$ git stash push --keep-index    # save all other changes to the stash\n$ edit/build/test first part\n$ git commit -m 'First part'     # commit fully tested change\n$ git stash pop                  # prepare to work on all other changes\n# ... repeat above five steps until one commit remains ...\n$ edit/build/test remaining parts\n$ git commit foo -m 'Remaining parts'\n```",
          "```bash\n# ... hack hack hack ...\n$ git add --patch foo           # add unrelated changes to the index\n$ git stash push --staged       # save these changes to the stash\n# ... hack hack hack, finish current changes ...\n$ git commit -m 'Massive'       # commit fully tested changes\n$ git switch fixup-branch       # switch to another branch\n$ git stash pop                 # to finish work on the saved changes\n```",
          "```bash\ngit fsck --unreachable |\ngrep commit | cut -d\\  -f3 |\nxargs git log --merges --no-walk --grep=WIP\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 4696
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Everything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there:\n\nIf this is set to true, the git stash show command will show the untracked files of a stash entry. Defaults to false. See the description of the show command in git-stash[1].\n\nIf this is set to true, the git stash show command without an option will show the stash entry in patch form. Defaults to false. See the description of the show command in git-stash[1].\n\nIf this is set to true, the git stash show command without an option will show a diffstat of the stash entry. Defaults to true. See the description of the show command in git-stash[1].\n\n**stash.showIncludeUntracked**: If this is set to true, the git stash show command will show the untracked files of a stash entry. Defaults to false. See the description of the show command in git-stash[1].\n**stash.showPatch**: If this is set to true, the git stash show command without an option will show the stash entry in patch form. Defaults to false. See the description of the show command in git-stash[1].\n**stash.showStat**: If this is set to true, the git stash show command without an option will show a diffstat of the stash entry. Defaults to true. See the description of the show command in git-stash[1].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1320
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-checkout[1], git-commit[1], git-reflog[1], git-reset[1], git-switch[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 74
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-stash",
    "doc_type": "git",
    "total_sections": 9
  },
  {
    "title": "Git",
    "summary": "",
    "sections": [
      {
        "header": "NAME",
        "content": "git-status - Show the working tree status",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 41
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Displays paths that have differences between the index file and the current HEAD commit, paths that have differences between the working tree and the index file, and paths in the working tree that are not tracked by Git (and are not ignored by gitignore[5]). The first are what you would commit by running git commit; the second and third are what you could commit by running git add before running git commit.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 410
        }
      },
      {
        "header": "OPTIONS",
        "content": "Give the output in the short-format.\n\nShow the branch and tracking info even in short-format.\n\nShow the number of entries currently stashed away.\n\nGive the output in an easy-to-parse format for scripts. This is similar to the short output, but will remain stable across Git versions and regardless of user configuration. See below for details.\n\nThe version parameter is used to specify the format version. This is optional and defaults to the original version v1 format.\n\nGive the output in the long-format. This is the default.\n\nIn addition to the names of files that have been changed, also show the textual changes that are staged to be committed (i.e., like the output of git diff --cached). If -v is specified twice, then also show the changes in the working tree that have not yet been staged (i.e., like the output of git diff).\n\nShow untracked files.\n\nThe mode parameter is used to specify the handling of untracked files. It is optional: it defaults to all, and if specified, it must be stuck to the option (e.g. -uno, but not -u no).\n\nThe possible options are:\n\nno - Show no untracked files.\n\nnormal - Shows untracked files and directories.\n\nall - Also shows individual files in untracked directories.\n\nWhen -u option is not used, untracked files and directories are shown (i.e. the same as specifying normal), to help you avoid forgetting to add newly created files. Because it takes extra work to find untracked files in the filesystem, this mode may take some time in a large working tree. Consider enabling untracked cache and split index if supported (see git update-index --untracked-cache and git update-index --split-index), Otherwise you can use no to have git status return more quickly without showing untracked files. All usual spellings for Boolean value true are taken as normal and false as no.\n\nThe default can be changed using the status.showUntrackedFiles configuration variable documented in git-config[1].\n\nIgnore changes to submodules when looking for changes. <when> can be either \"none\", \"untracked\", \"dirty\" or \"all\", which is the default. Using \"none\" will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config[1] or gitmodules[5]. When \"untracked\" is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using \"dirty\" ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior before 1.7.0). Using \"all\" hides all changes to submodules (and suppresses the output of submodule summaries when the config option status.submoduleSummary is set).\n\nShow ignored files as well.\n\nThe mode parameter is used to specify the handling of ignored files. It is optional: it defaults to traditional.\n\nThe possible options are:\n\ntraditional - Shows ignored files and directories, unless --untracked-files=all is specified, in which case individual files in ignored directories are displayed.\n\nno - Show no ignored files.\n\nmatching - Shows ignored files and directories matching an ignore pattern.\n\nWhen matching mode is specified, paths that explicitly match an ignored pattern are shown. If a directory matches an ignore pattern, then it is shown, but not paths contained in the ignored directory. If a directory does not match an ignore pattern, but all contents are ignored, then the directory is not shown, but all contents are shown.\n\nTerminate entries with NUL, instead of LF. This implies the --porcelain=v1 output format if no other format is given.\n\nDisplay untracked files in columns. See configuration variable column.status for option syntax. --column and --no-column without options are equivalent to always and never respectively.\n\nDisplay or do not display detailed ahead/behind counts for the branch relative to its upstream branch. Defaults to true.\n\nTurn on/off rename detection regardless of user configuration. See also git-diff[1] --no-renames.\n\nTurn on rename detection, optionally setting the similarity threshold. See also git-diff[1] --find-renames.\n\nSee the pathspec entry in gitglossary[7].\n\n• no - Show no untracked files.\n• normal - Shows untracked files and directories.\n• all - Also shows individual files in untracked directories.\n\n• traditional - Shows ignored files and directories, unless --untracked-files=all is specified, in which case individual files in ignored directories are displayed.\n• no - Show no ignored files.\n• matching - Shows ignored files and directories matching an ignore pattern.\n\n**-s**: Give the output in the short-format.\n**--short**: Show the branch and tracking info even in short-format.\n**-b**: Show the number of entries currently stashed away.\n**--branch**: Give the output in an easy-to-parse format for scripts. This is similar to the short output, but will remain stable across Git versions and regardless of user configuration. See below for details. The version parameter is used to specify the format version. This is optional and defaults to the original version v1 format.\n**--show-stash**: Give the output in the long-format. This is the default.\n**--porcelain[=<version>]**: In addition to the names of files that have been changed, also show the textual changes that are staged to be committed (i.e., like the output of git diff --cached). If -v is specified twice, then also show the changes in the working tree that have not yet been staged (i.e., like the output of git diff).\n**--long**: Show untracked files. The mode parameter is used to specify the handling of untracked files. It is optional: it defaults to all, and if specified, it must be stuck to the option (e.g. -uno, but not -u no). The possible options are: no - Show no untracked files. normal - Shows untracked files and directories. all - Also shows individual files in untracked directories. When -u option is not used, untracked files and directories are shown (i.e. the same as specifying normal), to help you avoid forgetting to add newly created files. Because it takes extra work to find untracked files in the filesystem, this mode may take some time in a large working tree. Consider enabling untracked cache and split index if supported (see git update-index --untracked-cache and git update-index --split-index), Otherwise you can use no to have git status return more quickly without showing untracked files. All usual spellings for Boolean value true are taken as normal and false as no. The default can be changed using the status.showUntrackedFiles configuration variable documented in git-config[1].\n**-v**: Ignore changes to submodules when looking for changes. <when> can be either \"none\", \"untracked\", \"dirty\" or \"all\", which is the default. Using \"none\" will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config[1] or gitmodules[5]. When \"untracked\" is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using \"dirty\" ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior before 1.7.0). Using \"all\" hides all changes to submodules (and suppresses the output of submodule summaries when the config option status.submoduleSummary is set).\n**--verbose**: Show ignored files as well. The mode parameter is used to specify the handling of ignored files. It is optional: it defaults to traditional. The possible options are: traditional - Shows ignored files and directories, unless --untracked-files=all is specified, in which case individual files in ignored directories are displayed. no - Show no ignored files. matching - Shows ignored files and directories matching an ignore pattern. When matching mode is specified, paths that explicitly match an ignored pattern are shown. If a directory matches an ignore pattern, then it is shown, but not paths contained in the ignored directory. If a directory does not match an ignore pattern, but all contents are ignored, then the directory is not shown, but all contents are shown.\n**-u[<mode>]**: Terminate entries with NUL, instead of LF. This implies the --porcelain=v1 output format if no other format is given.\n**--untracked-files[=<mode>]**: Display untracked files in columns. See configuration variable column.status for option syntax. --column and --no-column without options are equivalent to always and never respectively.\n**--ignore-submodules[=<when>]**: Display or do not display detailed ahead/behind counts for the branch relative to its upstream branch. Defaults to true.\n**--ignored[=<mode>]**: Turn on/off rename detection regardless of user configuration. See also git-diff[1] --no-renames.\n**-z**: Turn on rename detection, optionally setting the similarity threshold. See also git-diff[1] --find-renames.\n**--column[=<options>]**: See the pathspec entry in gitglossary[7].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 29,
          "content_length": 9195
        }
      },
      {
        "header": "OUTPUT",
        "content": "The output from this command is designed to be used as a commit template comment. The default, long format, is designed to be human readable, verbose and descriptive. Its contents and format are subject to change at any time.\n\nThe paths mentioned in the output, unlike many other Git commands, are made relative to the current directory if you are working in a subdirectory (this is on purpose, to help cutting and pasting). See the status.relativePaths config option below.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 474
        }
      },
      {
        "header": "Short Format",
        "content": "In the short-format, the status of each path is shown as one of these forms\n\nwhere ORIG_PATH is where the renamed/copied contents came from. ORIG_PATH is only shown when the entry is renamed or copied. The XY is a two-letter status code.\n\nThe fields (including the ->) are separated from each other by a single space. If a filename contains whitespace or other nonprintable characters, that field will be quoted in the manner of a C string literal: surrounded by ASCII double quote (34) characters, and with interior special characters backslash-escaped.\n\nThere are three different types of states that are shown using this format, and each one uses the XY syntax differently:\n\nWhen a merge is occurring and the merge was successful, or outside of a merge situation, X shows the status of the index and Y shows the status of the working tree.\n\nWhen a merge conflict has occurred and has not yet been resolved, X and Y show the state introduced by each head of the merge, relative to the common ancestor. These paths are said to be unmerged.\n\nWhen a path is untracked, X and Y are always the same, since they are unknown to the index. ?? is used for untracked paths. Ignored files are not listed unless --ignored is used; if it is, ignored files are indicated by !!.\n\nNote that the term merge here also includes rebases using the default --merge strategy, cherry-picks, and anything else using the merge machinery.\n\nIn the following table, these three classes are shown in separate sections, and these characters are used for X and Y fields for the first two sections that show tracked paths:\n\nT = file type changed (regular file, symbolic link or submodule)\n\nC = copied (if config option status.renames is set to \"copies\")\n\nU = updated but unmerged\n\nSubmodules have more state and instead report\n\nM = the submodule has a different HEAD than recorded in the index\n\nm = the submodule has modified content\n\n? = the submodule has untracked files\n\nThis is since modified content or untracked files in a submodule cannot be added via git add in the superproject to prepare a commit.\n\nm and ? are applied recursively. For example if a nested submodule in a submodule contains an untracked file, this is reported as ? as well.\n\nIf -b is used the short-format status is preceded by a line\n\n• When a merge is occurring and the merge was successful, or outside of a merge situation, X shows the status of the index and Y shows the status of the working tree.\n• When a merge conflict has occurred and has not yet been resolved, X and Y show the state introduced by each head of the merge, relative to the common ancestor. These paths are said to be unmerged.\n• When a path is untracked, X and Y are always the same, since they are unknown to the index. ?? is used for untracked paths. Ignored files are not listed unless --ignored is used; if it is, ignored files are indicated by !!.\n\n• ' ' = unmodified\n• M = modified\n• T = file type changed (regular file, symbolic link or submodule)\n• D = deleted\n• R = renamed\n• C = copied (if config option status.renames is set to \"copies\")\n• U = updated but unmerged\n\n• M = the submodule has a different HEAD than recorded in the index\n• m = the submodule has modified content\n• ? = the submodule has untracked files",
        "code_examples": [
          "```bash\nXY PATH\nXY ORIG_PATH -> PATH\n```",
          "```bash\nX          Y     Meaning\n-------------------------------------------------\n\t [AMD]   not updated\nM        [ MTD]  updated in index\nT        [ MTD]  type changed in index\nA        [ MTD]  added to index\nD                deleted from index\nR        [ MTD]  renamed in index\nC        [ MTD]  copied in index\n[MTARC]          index and work tree matches\n[ MTARC]    M    work tree changed since index\n[ MTARC]    T    type changed in work tree since index\n[ MTARC]    D    deleted in work tree\n\t    R    renamed in work tree\n\t    C    copied in work tree\n-------------------------------------------------\nD           D    unmerged, both deleted\nA           U    unmerged, added by us\nU           D    unmerged, deleted by them\nU           A    unmerged, added by them\nD           U    unmerged, deleted by us\nA           A    unmerged, both added\nU           U    unmerged, both modified\n-------------------------------------------------\n?           ?    untracked\n!           !    ignored\n-------------------------------------------------\n```",
          "```bash\n## branchname tracking info\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 19,
          "content_length": 3245
        }
      },
      {
        "header": "Porcelain Format Version 1",
        "content": "Version 1 porcelain format is similar to the short format, but is guaranteed not to change in a backwards-incompatible way between Git versions or based on user configuration. This makes it ideal for parsing by scripts. The description of the short format above also describes the porcelain format, with a few exceptions:\n\nThe user’s color.status configuration is not respected; color will always be off.\n\nThe user’s status.relativePaths configuration is not respected; paths shown will always be relative to the repository root.\n\nThere is also an alternate -z format recommended for machine parsing. In that format, the status field is the same, but some other things change. First, the -> is omitted from rename entries and the field order is reversed (e.g from -> to becomes to from). Second, a NUL (ASCII 0) follows each filename, replacing space as a field separator and the terminating newline (but a space still separates the status field from the first filename). Third, filenames containing special characters are not specially formatted; no quoting or backslash-escaping is performed.\n\nAny submodule changes are reported as modified M instead of m or single ?.\n\n• The user’s color.status configuration is not respected; color will always be off.\n• The user’s status.relativePaths configuration is not respected; paths shown will always be relative to the repository root.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1381
        }
      },
      {
        "header": "Porcelain Format Version 2",
        "content": "Version 2 format adds more detailed information about the state of the worktree and changed items. Version 2 also defines an extensible set of easy to parse optional headers.\n\nHeader lines start with \"#\" and are added in response to specific command line arguments. Parsers should ignore headers they don’t recognize.\n\nIf --branch is given, a series of header lines are printed with information about the current branch.\n\nIf --show-stash is given, one line is printed showing the number of stash entries if non-zero:\n\nFollowing the headers, a series of lines are printed for tracked entries. One of three different line formats may be used to describe an entry depending on the type of change. Tracked entries are printed in an undefined order; parsers should allow for a mixture of the 3 line types in any order.\n\nOrdinary changed entries have the following format:\n\nRenamed or copied entries have the following format:\n\nUnmerged entries have the following format; the first character is a \"u\" to distinguish from ordinary changed entries.\n\nFollowing the tracked entries (and if requested), a series of lines will be printed for untracked and then ignored items found in the worktree.\n\nUntracked items have the following format:\n\nIgnored items have the following format:\n\nWhen the -z option is given, pathnames are printed as is and without any quoting and lines are terminated with a NUL (ASCII 0x00) byte.\n\nWithout the -z option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).",
        "code_examples": [
          "```bash\nLine                                     Notes\n------------------------------------------------------------\n# branch.oid<commit>| (initial)        Current commit.\n# branch.head<branch>| (detached)      Current branch.\n# branch.upstream <upstream-branch>      If upstream is set.\n# branch.ab +<ahead> -<behind>           If upstream is set and\n\t\t\t\t\t the commit is present.\n------------------------------------------------------------\n```",
          "```bash\n# stash <N>\n```",
          "```bash\n1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>\n```",
          "```bash\n2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>\n```",
          "```bash\nField       Meaning\n--------------------------------------------------------\n<XY>        A 2 character field containing the staged and\n\t    unstaged XY values described in the short format,\n\t    with unchanged indicated by a \".\" rather than\n\t    a space.\n<sub>       A 4 character field describing the submodule state.\n\t    \"N...\" when the entry is not a submodule.\n\t    \"S<c><m><u>\" when the entry is a submodule.\n\t    <c> is \"C\" if the commit changed; otherwise \".\".\n\t    <m> is \"M\" if it has tracked changes; otherwise \".\".\n\t    <u> is \"U\" if there are untracked changes; otherwise \".\".\n<mH>        The octal file mode in HEAD.\n<mI>        The octal file mode in the index.\n<mW>        The octal file mode in the worktree.\n<hH>        The object name in HEAD.\n<hI>        The object name in the index.\n<X><score>  The rename or copy score (denoting the percentage\n\t    of similarity between the source and target of the\n\t    move or copy). For example \"R100\" or \"C75\".\n<path>      The pathname.  In a renamed/copied entry, this\n\t    is the target path.\n<sep>       When the `-z` option is used, the 2 pathnames are separated\n\t    with a NUL (ASCII 0x00) byte; otherwise, a tab (ASCII 0x09)\n\t    byte separates them.\n<origPath>  The pathname in the commit at HEAD or in the index.\n\t    This is only present in a renamed/copied entry, and\n\t    tells where the renamed/copied contents came from.\n--------------------------------------------------------\n```",
          "```bash\nu <XY> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>\n```",
          "```bash\nField       Meaning\n--------------------------------------------------------\n<XY>        A 2 character field describing the conflict type\n\t    as described in the short format.\n<sub>       A 4 character field describing the submodule state\n\t    as described above.\n<m1>        The octal file mode in stage 1.\n<m2>        The octal file mode in stage 2.\n<m3>        The octal file mode in stage 3.\n<mW>        The octal file mode in the worktree.\n<h1>        The object name in stage 1.\n<h2>        The object name in stage 2.\n<h3>        The object name in stage 3.\n<path>      The pathname.\n--------------------------------------------------------\n```",
          "```bash\n? <path>\n```",
          "```bash\n! <path>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 13,
          "content_length": 1559
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "The command honors color.status (or status.color — they mean the same thing and the latter is kept for backward compatibility) and color.status.<slot> configuration variables to colorize its output.\n\nIf the config variable status.relativePaths is set to false, then all paths shown are relative to the repository root, not to the current directory.\n\nIf status.submoduleSummary is set to a non zero number or true (identical to -1 or an unlimited number), the submodule summary will be enabled for the long format and a summary of commits for modified submodules will be shown (see --summary-limit option of git-submodule[1]). Please note that the summary output from the status command will be suppressed for all submodules when diff.ignoreSubmodules is set to all or only for those submodules where submodule.<name>.ignore=all. To also view the summary for ignored submodules you can either use the --ignore-submodules=dirty command line option or the git submodule summary command, which shows a similar output but does not honor these settings.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1047
        }
      },
      {
        "header": "BACKGROUND REFRESH",
        "content": "By default, git status will automatically refresh the index, updating the cached stat information from the working tree and writing out the result. Writing out the updated index is an optimization that isn’t strictly necessary (status computes the values for itself, but writing them out is just to save subsequent programs from repeating our computation). When status is run in the background, the lock held during the write may conflict with other simultaneous processes, causing them to fail. Scripts running status in the background should consider using git --no-optional-locks status (see git[1] for details).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 615
        }
      },
      {
        "header": "UNTRACKED FILES AND PERFORMANCE",
        "content": "git status can be very slow in large worktrees if/when it needs to search for untracked files and directories. There are many configuration options available to speed this up by either avoiding the work or making use of cached results from previous Git commands. There is no single optimum set of settings right for everyone. We’ll list a summary of the relevant options to help you, but before going into the list, you may want to run git status again, because your configuration may already be caching git status results, so it could be faster on subsequent runs.\n\nThe --untracked-files=no flag or the status.showUntrackedFiles=no config (see above for both): indicate that git status should not report untracked files. This is the fastest option. git status will not list the untracked files, so you need to be careful to remember if you create any new files and manually git add them.\n\nadvice.statusUoption=false (see git-config[1]): setting this variable to false disables the warning message given when enumerating untracked files takes more than 2 seconds. In a large project, it may take longer and the user may have already accepted the trade off (e.g. using \"-uno\" may not be an acceptable option for the user), in which case, there is no point issuing the warning message, and in such a case, disabling the warning may be the best.\n\ncore.untrackedCache=true (see git-update-index[1]): enable the untracked cache feature and only search directories that have been modified since the previous git status command. Git remembers the set of untracked files within each directory and assumes that if a directory has not been modified, then the set of untracked files within has not changed. This is much faster than enumerating the contents of every directory, but still not without cost, because Git still has to search for the set of modified directories. The untracked cache is stored in the .git/index file. The reduced cost of searching for untracked files is offset slightly by the increased size of the index and the cost of keeping it up-to-date. That reduced search time is usually worth the additional size.\n\ncore.untrackedCache=true and core.fsmonitor=true or core.fsmonitor=<hook-command-pathname> (see git-update-index[1]): enable both the untracked cache and FSMonitor features and only search directories that have been modified since the previous git status command. This is faster than using just the untracked cache alone because Git can also avoid searching for modified directories. Git only has to enumerate the exact set of directories that have changed recently. While the FSMonitor feature can be enabled without the untracked cache, the benefits are greatly reduced in that case.\n\nNote that after you turn on the untracked cache and/or FSMonitor features it may take a few git status commands for the various caches to warm up before you see improved command times. This is normal.\n\n• The --untracked-files=no flag or the status.showUntrackedFiles=no config (see above for both): indicate that git status should not report untracked files. This is the fastest option. git status will not list the untracked files, so you need to be careful to remember if you create any new files and manually git add them.\n• advice.statusUoption=false (see git-config[1]): setting this variable to false disables the warning message given when enumerating untracked files takes more than 2 seconds. In a large project, it may take longer and the user may have already accepted the trade off (e.g. using \"-uno\" may not be an acceptable option for the user), in which case, there is no point issuing the warning message, and in such a case, disabling the warning may be the best.\n• core.untrackedCache=true (see git-update-index[1]): enable the untracked cache feature and only search directories that have been modified since the previous git status command. Git remembers the set of untracked files within each directory and assumes that if a directory has not been modified, then the set of untracked files within has not changed. This is much faster than enumerating the contents of every directory, but still not without cost, because Git still has to search for the set of modified directories. The untracked cache is stored in the .git/index file. The reduced cost of searching for untracked files is offset slightly by the increased size of the index and the cost of keeping it up-to-date. That reduced search time is usually worth the additional size.\n• core.untrackedCache=true and core.fsmonitor=true or core.fsmonitor=<hook-command-pathname> (see git-update-index[1]): enable both the untracked cache and FSMonitor features and only search directories that have been modified since the previous git status command. This is faster than using just the untracked cache alone because Git can also avoid searching for modified directories. Git only has to enumerate the exact set of directories that have changed recently. While the FSMonitor feature can be enabled without the untracked cache, the benefits are greatly reduced in that case.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 5060
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-status",
    "doc_type": "git",
    "total_sections": 11
  },
  {
    "title": "Git",
    "summary": "NAME git-submodule - Initialize, update or inspect submodules\n\ngit-submodule - Initialize, update or inspect submodules",
    "sections": [
      {
        "header": "NAME",
        "content": "git-submodule - Initialize, update or inspect submodules",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 56
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Inspects, updates and manages submodules.\n\nFor more information about submodules, see gitsubmodules[7].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 103
        }
      },
      {
        "header": "COMMANDS",
        "content": "With no arguments, shows the status of existing submodules. Several subcommands are available to perform operations on the submodules.\n\nAdd the given repository as a submodule at the given path to the changeset to be committed next to the current project: the current project is termed the \"superproject\".\n\n<repository> is the URL of the new submodule’s origin repository. This may be either an absolute URL, or (if it begins with ./ or ../), the location relative to the superproject’s default remote repository (Please note that to specify a repository foo.git which is located right next to a superproject bar.git, you’ll have to use ../foo.git instead of ./foo.git - as one might expect when following the rules for relative URLs - because the evaluation of relative URLs in Git is identical to that of relative directories).\n\nThe default remote is the remote of the remote-tracking branch of the current branch. If no such remote-tracking branch exists or the HEAD is detached, \"origin\" is assumed to be the default remote. If the superproject doesn’t have a default remote configured the superproject is its own authoritative upstream and the current working directory is used instead.\n\nThe optional argument <path> is the relative location for the cloned submodule to exist in the superproject. If <path> is not given, the canonical part of the source repository is used (\"repo\" for \"/path/to/repo.git\" and \"foo\" for \"host.xz:foo/.git\"). If <path> exists and is already a valid Git repository, then it is staged for commit without cloning. The <path> is also used as the submodule’s logical name in its configuration entries unless --name is used to specify a logical name.\n\nThe given URL is recorded into .gitmodules for use by subsequent users cloning the superproject. If the URL is given relative to the superproject’s repository, the presumption is the superproject and submodule repositories will be kept together in the same relative location, and only the superproject’s URL needs to be provided. git-submodule will correctly locate the submodule using the relative URL in .gitmodules.\n\nIf --ref-format <format> is specified, the ref storage format of newly cloned submodules will be set accordingly.\n\nShow the status of the submodules. This will print the SHA-1 of the currently checked out commit for each submodule, along with the submodule path and the output of git describe for the SHA-1. Each SHA-1 will possibly be prefixed with - if the submodule is not initialized, + if the currently checked out submodule commit does not match the SHA-1 found in the index of the containing repository and U if the submodule has merge conflicts.\n\nIf --cached is specified, this command will instead print the SHA-1 recorded in the superproject for each submodule.\n\nIf --recursive is specified, this command will recurse into nested submodules, and show their status as well.\n\nIf you are only interested in changes of the currently initialized submodules with respect to the commit recorded in the index or the HEAD, git-status[1] and git-diff[1] will provide that information too (and can also report changes to a submodule’s work tree).\n\nInitialize the submodules recorded in the index (which were added and committed elsewhere) by setting submodule.$name.url in .git/config, using the same setting from .gitmodules as a template. If the URL is relative, it will be resolved using the default remote. If there is no default remote, the current repository will be assumed to be upstream.\n\nOptional <path> arguments limit which submodules will be initialized. If no path is specified and submodule.active has been configured, submodules configured to be active will be initialized, otherwise all submodules are initialized.\n\nIt will also copy the value of submodule.$name.update, if present in the .gitmodules file, to .git/config, but (1) this command does not alter existing information in .git/config, and (2) submodule.$name.update that is set to a custom command is not copied for security reasons.\n\nYou can then customize the submodule clone URLs in .git/config for your local setup and proceed to git submodule update; you can also just use git submodule update --init without the explicit init step if you do not intend to customize any submodule locations.\n\nSee the add subcommand for the definition of default remote.\n\nUnregister the given submodules, i.e. remove the whole submodule.$name section from .git/config together with their work tree. Further calls to git submodule update, git submodule foreach and git submodule sync will skip any unregistered submodules until they are initialized again, so use this command if you don’t want to have a local checkout of the submodule in your working tree anymore.\n\nWhen the command is run without pathspec, it errors out, instead of deinit-ing everything, to prevent mistakes.\n\nIf --force is specified, the submodule’s working tree will be removed even if it contains local modifications.\n\nIf you really want to remove a submodule from the repository and commit that use git-rm[1] instead. See gitsubmodules[7] for removal options.\n\nUpdate the registered submodules to match what the superproject expects by cloning missing submodules, fetching missing commits in submodules and updating the working tree of the submodules. The \"updating\" can be done in several ways depending on command line options and the value of submodule.<name>.update configuration variable. The command line option takes precedence over the configuration variable. If neither is given, a checkout is performed. (note: what is in .gitmodules file is irrelevant at this point; see git submodule init above for how .gitmodules is used). The update procedures supported both from the command line as well as through the submodule.<name>.update configuration are:\n\nthe commit recorded in the superproject will be checked out in the submodule on a detached HEAD.\n\nIf --force is specified, the submodule will be checked out (using git checkout --force), even if the commit specified in the index of the containing repository already matches the commit checked out in the submodule.\n\nthe current branch of the submodule will be rebased onto the commit recorded in the superproject.\n\nthe commit recorded in the superproject will be merged into the current branch in the submodule.\n\nThe following update procedures have additional limitations:\n\nmechanism for running arbitrary commands with the commit ID as an argument. Specifically, if the submodule.<name>.update configuration variable is set to !custom command, the object name of the commit recorded in the superproject for the submodule is appended to the custom command string and executed. Note that this mechanism is not supported in the .gitmodules file or on the command line.\n\nthe submodule is not updated. This update procedure is not allowed on the command line.\n\nIf the submodule is not yet initialized, and you just want to use the setting as stored in .gitmodules, you can automatically initialize the submodule with the --init option.\n\nIf --recursive is specified, this command will recurse into the registered submodules, and update any nested submodules within.\n\nIf --ref-format <format> is specified, the ref storage format of newly cloned submodules will be set accordingly.\n\nIf --filter <filter-spec> is specified, the given partial clone filter will be applied to the submodule. See git-rev-list[1] for details on filter specifications.\n\nSets the default remote tracking branch for the submodule. The --branch option allows the remote branch to be specified. The --default option removes the submodule.<name>.branch configuration key, which causes the tracking branch to default to the remote HEAD.\n\nSets the URL of the specified submodule to <newurl>. Then, it will automatically synchronize the submodule’s new remote URL configuration.\n\nShow commit summary between the given commit (defaults to HEAD) and working tree/index. For a submodule in question, a series of commits in the submodule between the given super project commit and the index or working tree (switched by --cached) are shown. If the option --files is given, show the series of commits in the submodule between the index of the super project and the working tree of the submodule (this option doesn’t allow to use the --cached option or to provide an explicit commit).\n\nUsing the --submodule=log option with git-diff[1] will provide that information too.\n\nEvaluates an arbitrary shell command in each checked out submodule. The command has access to the variables $name, $sm_path, $displaypath, $sha1 and $toplevel: $name is the name of the relevant submodule section in .gitmodules, $sm_path is the path of the submodule as recorded in the immediate superproject, $displaypath contains the relative path from the current working directory to the submodules root directory, $sha1 is the commit as recorded in the immediate superproject, and $toplevel is the absolute path to the top-level of the immediate superproject. Note that to avoid conflicts with $PATH on Windows, the $path variable is now a deprecated synonym of $sm_path variable. Any submodules defined in the superproject but not checked out are ignored by this command. Unless given --quiet, foreach prints the name of each submodule before evaluating the command. If --recursive is given, submodules are traversed recursively (i.e. the given shell command is evaluated in nested submodules as well). A non-zero return from the command in any submodule causes the processing to terminate. This can be overridden by adding || : to the end of the command.\n\nAs an example, the command below will show the path and currently checked out commit for each submodule:\n\nSynchronizes submodules' remote URL configuration setting to the value specified in .gitmodules. It will only affect those submodules which already have a URL entry in .git/config (that is the case when they are initialized or freshly added). This is useful when submodule URLs change upstream and you need to update your local repositories accordingly.\n\ngit submodule sync synchronizes all submodules while git submodule sync -- A synchronizes submodule \"A\" only.\n\nIf --recursive is specified, this command will recurse into the registered submodules, and sync any nested submodules within.\n\nIf a git directory of a submodule is inside the submodule, move the git directory of the submodule into its superproject’s $GIT_DIR/modules path and then connect the git directory and its working directory by setting the core.worktree and adding a .git file pointing to the git directory embedded in the superprojects git directory.\n\nA repository that was cloned independently and later added as a submodule or old setups have the submodules git directory inside the submodule instead of embedded into the superprojects git directory.\n\nThis command is recursive by default.\n\n**add [-b <branch>] [-f|--force] [--name <name>] [--reference <repository>] [--ref-format <format>] [--depth <depth>] [--] <repository> [<path>]**: Add the given repository as a submodule at the given path to the changeset to be committed next to the current project: the current project is termed the \"superproject\". <repository> is the URL of the new submodule’s origin repository. This may be either an absolute URL, or (if it begins with ./ or ../), the location relative to the superproject’s default remote repository (Please note that to specify a repository foo.git which is located right next to a superproject bar.git, you’ll have to use ../foo.git instead of ./foo.git - as one might expect when following the rules for relative URLs - because the evaluation of relative URLs in Git is identical to that of relative directories). The default remote is the remote of the remote-tracking branch of the current branch. If no such remote-tracking branch exists or the HEAD is detached, \"origin\" is assumed to be the default remote. If the superproject doesn’t have a default remote configured the superproject is its own authoritative upstream and the current working directory is used instead. The optional argument <path> is the relative location for the cloned submodule to exist in the superproject. If <path> is not given, the canonical part of the source repository is used (\"repo\" for \"/path/to/repo.git\" and \"foo\" for \"host.xz:foo/.git\"). If <path> exists and is already a valid Git repository, then it is staged for commit without cloning. The <path> is also used as the submodule’s logical name in its configuration entries unless --name is used to specify a logical name. The given URL is recorded into .gitmodules for use by subsequent users cloning the superproject. If the URL is given relative to the superproject’s repository, the presumption is the superproject and submodule repositories will be kept together in the same relative location, and only the superproject’s URL needs to be provided. git-submodule will correctly locate the submodule using the relative URL in .gitmodules. If --ref-format <format> is specified, the ref storage format of newly cloned submodules will be set accordingly.\n**status [--cached] [--recursive] [--] [<path>…]**: Show the status of the submodules. This will print the SHA-1 of the currently checked out commit for each submodule, along with the submodule path and the output of git describe for the SHA-1. Each SHA-1 will possibly be prefixed with - if the submodule is not initialized, + if the currently checked out submodule commit does not match the SHA-1 found in the index of the containing repository and U if the submodule has merge conflicts. If --cached is specified, this command will instead print the SHA-1 recorded in the superproject for each submodule. If --recursive is specified, this command will recurse into nested submodules, and show their status as well. If you are only interested in changes of the currently initialized submodules with respect to the commit recorded in the index or the HEAD, git-status[1] and git-diff[1] will provide that information too (and can also report changes to a submodule’s work tree).\n**init [--] [<path>…]**: Initialize the submodules recorded in the index (which were added and committed elsewhere) by setting submodule.$name.url in .git/config, using the same setting from .gitmodules as a template. If the URL is relative, it will be resolved using the default remote. If there is no default remote, the current repository will be assumed to be upstream. Optional <path> arguments limit which submodules will be initialized. If no path is specified and submodule.active has been configured, submodules configured to be active will be initialized, otherwise all submodules are initialized. It will also copy the value of submodule.$name.update, if present in the .gitmodules file, to .git/config, but (1) this command does not alter existing information in .git/config, and (2) submodule.$name.update that is set to a custom command is not copied for security reasons. You can then customize the submodule clone URLs in .git/config for your local setup and proceed to git submodule update; you can also just use git submodule update --init without the explicit init step if you do not intend to customize any submodule locations. See the add subcommand for the definition of default remote.\n**deinit [-f|--force] (--all|[--] <path>…)**: Unregister the given submodules, i.e. remove the whole submodule.$name section from .git/config together with their work tree. Further calls to git submodule update, git submodule foreach and git submodule sync will skip any unregistered submodules until they are initialized again, so use this command if you don’t want to have a local checkout of the submodule in your working tree anymore. When the command is run without pathspec, it errors out, instead of deinit-ing everything, to prevent mistakes. If --force is specified, the submodule’s working tree will be removed even if it contains local modifications. If you really want to remove a submodule from the repository and commit that use git-rm[1] instead. See gitsubmodules[7] for removal options.\n**update [--init] [--remote] [-N|--no-fetch] [--[no-]recommend-shallow] [-f|--force] [--checkout|--rebase|--merge] [--reference <repository>] [--ref-format <format>] [--depth <depth>] [--recursive] [--jobs <n>] [--[no-]single-branch] [--filter <filter-spec>] [--] [<path>…]**: Update the registered submodules to match what the superproject expects by cloning missing submodules, fetching missing commits in submodules and updating the working tree of the submodules. The \"updating\" can be done in several ways depending on command line options and the value of submodule.<name>.update configuration variable. The command line option takes precedence over the configuration variable. If neither is given, a checkout is performed. (note: what is in .gitmodules file is irrelevant at this point; see git submodule init above for how .gitmodules is used). The update procedures supported both from the command line as well as through the submodule.<name>.update configuration are: checkout the commit recorded in the superproject will be checked out in the submodule on a detached HEAD. If --force is specified, the submodule will be checked out (using git checkout --force), even if the commit specified in the index of the containing repository already matches the commit checked out in the submodule. rebase the current branch of the submodule will be rebased onto the commit recorded in the superproject. merge the commit recorded in the superproject will be merged into the current branch in the submodule. The following update procedures have additional limitations: custom command mechanism for running arbitrary commands with the commit ID as an argument. Specifically, if the submodule.<name>.update configuration variable is set to !custom command, the object name of the commit recorded in the superproject for the submodule is appended to the custom command string and executed. Note that this mechanism is not supported in the .gitmodules file or on the command line. none the submodule is not updated. This update procedure is not allowed on the command line. If the submodule is not yet initialized, and you just want to use the setting as stored in .gitmodules, you can automatically initialize the submodule with the --init option. If --recursive is specified, this command will recurse into the registered submodules, and update any nested submodules within. If --ref-format <format> is specified, the ref storage format of newly cloned submodules will be set accordingly. If --filter <filter-spec> is specified, the given partial clone filter will be applied to the submodule. See git-rev-list[1] for details on filter specifications.\n**checkout**: the commit recorded in the superproject will be checked out in the submodule on a detached HEAD. If --force is specified, the submodule will be checked out (using git checkout --force), even if the commit specified in the index of the containing repository already matches the commit checked out in the submodule.\n**rebase**: the current branch of the submodule will be rebased onto the commit recorded in the superproject.\n**merge**: the commit recorded in the superproject will be merged into the current branch in the submodule.\n**custom command**: mechanism for running arbitrary commands with the commit ID as an argument. Specifically, if the submodule.<name>.update configuration variable is set to !custom command, the object name of the commit recorded in the superproject for the submodule is appended to the custom command string and executed. Note that this mechanism is not supported in the .gitmodules file or on the command line.\n**none**: the submodule is not updated. This update procedure is not allowed on the command line.\n**set-branch (-b|--branch) <branch> [--] <path>**: Sets the default remote tracking branch for the submodule. The --branch option allows the remote branch to be specified. The --default option removes the submodule.<name>.branch configuration key, which causes the tracking branch to default to the remote HEAD.\n**set-branch (-d|--default) [--] <path>**: Sets the URL of the specified submodule to <newurl>. Then, it will automatically synchronize the submodule’s new remote URL configuration.\n**set-url [--] <path> <newurl>**: Show commit summary between the given commit (defaults to HEAD) and working tree/index. For a submodule in question, a series of commits in the submodule between the given super project commit and the index or working tree (switched by --cached) are shown. If the option --files is given, show the series of commits in the submodule between the index of the super project and the working tree of the submodule (this option doesn’t allow to use the --cached option or to provide an explicit commit). Using the --submodule=log option with git-diff[1] will provide that information too.\n**summary [--cached|--files] [(-n|--summary-limit) <n>] [commit] [--] [<path>…]**: Evaluates an arbitrary shell command in each checked out submodule. The command has access to the variables $name, $sm_path, $displaypath, $sha1 and $toplevel: $name is the name of the relevant submodule section in .gitmodules, $sm_path is the path of the submodule as recorded in the immediate superproject, $displaypath contains the relative path from the current working directory to the submodules root directory, $sha1 is the commit as recorded in the immediate superproject, and $toplevel is the absolute path to the top-level of the immediate superproject. Note that to avoid conflicts with $PATH on Windows, the $path variable is now a deprecated synonym of $sm_path variable. Any submodules defined in the superproject but not checked out are ignored by this command. Unless given --quiet, foreach prints the name of each submodule before evaluating the command. If --recursive is given, submodules are traversed recursively (i.e. the given shell command is evaluated in nested submodules as well). A non-zero return from the command in any submodule causes the processing to terminate. This can be overridden by adding || : to the end of the command. As an example, the command below will show the path and currently checked out commit for each submodule: git submodule foreach 'echo $sm_path `git rev-parse HEAD`'\n**foreach [--recursive] <command>**: Synchronizes submodules' remote URL configuration setting to the value specified in .gitmodules. It will only affect those submodules which already have a URL entry in .git/config (that is the case when they are initialized or freshly added). This is useful when submodule URLs change upstream and you need to update your local repositories accordingly. git submodule sync synchronizes all submodules while git submodule sync -- A synchronizes submodule \"A\" only. If --recursive is specified, this command will recurse into the registered submodules, and sync any nested submodules within.\n**sync [--recursive] [--] [<path>…]**: If a git directory of a submodule is inside the submodule, move the git directory of the submodule into its superproject’s $GIT_DIR/modules path and then connect the git directory and its working directory by setting the core.worktree and adding a .git file pointing to the git directory embedded in the superprojects git directory. A repository that was cloned independently and later added as a submodule or old setups have the submodules git directory inside the submodule instead of embedded into the superprojects git directory. This command is recursive by default.\n**checkout**: the commit recorded in the superproject will be checked out in the submodule on a detached HEAD. If --force is specified, the submodule will be checked out (using git checkout --force), even if the commit specified in the index of the containing repository already matches the commit checked out in the submodule.\n**rebase**: the current branch of the submodule will be rebased onto the commit recorded in the superproject.\n**merge**: the commit recorded in the superproject will be merged into the current branch in the submodule.\n**custom command**: mechanism for running arbitrary commands with the commit ID as an argument. Specifically, if the submodule.<name>.update configuration variable is set to !custom command, the object name of the commit recorded in the superproject for the submodule is appended to the custom command string and executed. Note that this mechanism is not supported in the .gitmodules file or on the command line.\n**none**: the submodule is not updated. This update procedure is not allowed on the command line.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit submodule foreach 'echo $sm_path `git rev-parse HEAD`'\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 44,
          "content_length": 24606
        }
      },
      {
        "header": "OPTIONS",
        "content": "Only print error messages.\n\nThis option is only valid for add and update commands. Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.\n\nThis option is only valid for the deinit command. Unregister all submodules in the working tree.\n\nBranch of repository to add as submodule. The name of the branch is recorded as submodule.<name>.branch in .gitmodules for update --remote. A special value of . is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository. If the option is not specified, it defaults to the remote HEAD.\n\nThis option is only valid for add, deinit and update commands. When running add, allow adding an otherwise ignored submodule path. This option is also used to bypass a check that the submodule’s name is not already in use. By default, git submodule add will fail if the proposed name (which is derived from the path) is already registered for another submodule in the repository. Using --force allows the command to proceed by automatically generating a unique name by appending a number to the conflicting name (e.g., if a submodule named child exists, it will try child1, and so on). When running deinit the submodule working trees will be removed even if they contain local changes. When running update (only effective with the checkout procedure), throw away local changes in submodules when switching to a different commit; and always run a checkout operation in the submodule, even if the commit listed in the index of the containing repository matches the commit checked out in the submodule.\n\nThis option is only valid for status and summary commands. These commands typically use the commit found in the submodule HEAD, but with this option, the commit stored in the index is used instead.\n\nThis option is only valid for the summary command. This command compares the commit in the index with that in the submodule HEAD when this option is used.\n\nThis option is only valid for the summary command. Limit the summary size (number of commits shown in total). Giving 0 will disable the summary; a negative number means unlimited (the default). This limit only applies to modified submodules. The size is always limited to 1 for added/deleted/typechanged submodules.\n\nThis option is only valid for the update command. Instead of using the superproject’s recorded SHA-1 to update the submodule, use the status of the submodule’s remote-tracking branch. The remote used is branch’s remote (branch.<name>.remote), defaulting to origin. The remote branch used defaults to the remote HEAD, but the branch name may be overridden by setting the submodule.<name>.branch option in either .gitmodules or .git/config (with .git/config taking precedence).\n\nThis works for any of the supported update procedures (--checkout, --rebase, etc.). The only change is the source of the target SHA-1. For example, submodule update --remote --merge will merge upstream submodule changes into the submodules, while submodule update --merge will merge superproject gitlink changes into the submodules.\n\nIn order to ensure a current tracking branch state, update --remote fetches the submodule’s remote repository before calculating the SHA-1. If you don’t want to fetch, you should use submodule update --remote --no-fetch.\n\nUse this option to integrate changes from the upstream subproject with your submodule’s current HEAD. Alternatively, you can run git pull from the submodule, which is equivalent except for the remote branch name: update --remote uses the default upstream repository and submodule.<name>.branch, while git pull uses the submodule’s branch.<name>.merge. Prefer submodule.<name>.branch if you want to distribute the default upstream branch with the superproject and branch.<name>.merge if you want a more native feel while working in the submodule itself.\n\nThis option is only valid for the update command. Don’t fetch new objects from the remote site.\n\nThis option is only valid for the update command. Checkout the commit recorded in the superproject on a detached HEAD in the submodule. This is the default behavior, the main use of this option is to override submodule.$name.update when set to a value other than checkout. If the key submodule.$name.update is either not explicitly set or set to checkout, this option is implicit.\n\nThis option is only valid for the update command. Merge the commit recorded in the superproject into the current branch of the submodule. If this option is given, the submodule’s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve the resulting conflicts within the submodule with the usual conflict resolution tools. If the key submodule.$name.update is set to merge, this option is implicit.\n\nThis option is only valid for the update command. Rebase the current branch onto the commit recorded in the superproject. If this option is given, the submodule’s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve these failures with git-rebase[1]. If the key submodule.$name.update is set to rebase, this option is implicit.\n\nThis option is only valid for the update command. Initialize all submodules for which \"git submodule init\" has not been called so far before updating.\n\nThis option is only valid for the add command. It sets the submodule’s name to the given string instead of defaulting to its path. The name must be valid as a directory name and may not end with a /.\n\nThis option is only valid for add and update commands. These commands sometimes need to clone a remote repository. In this case, this option will be passed to the git-clone[1] command.\n\nNOTE: Do not use this option unless you have read the note for git-clone[1]'s --reference, --shared, and --dissociate options carefully.\n\nThis option is only valid for add and update commands. These commands sometimes need to clone a remote repository. In this case, this option will be passed to the git-clone[1] command.\n\nNOTE: see the NOTE for the --reference option.\n\nThis option is only valid for foreach, update, status and sync commands. Traverse submodules recursively. The operation is performed not only in the submodules of the current repo, but also in any nested submodules inside those submodules (and so on).\n\nThis option is valid for add and update commands. Create a shallow clone with a history truncated to the specified number of revisions. See git-clone[1]\n\nThis option is only valid for the update command. The initial clone of a submodule will use the recommended submodule.<name>.shallow as provided by the .gitmodules file by default. To ignore the suggestions use --no-recommend-shallow.\n\nThis option is only valid for the update command. Clone new submodules in parallel with as many jobs. Defaults to the submodule.fetchJobs option.\n\nThis option is only valid for the update command. Clone only one branch during update: HEAD or one specified by --branch.\n\nPaths to submodule(s). When specified this will restrict the command to only operate on the submodules found at the specified paths. (This argument is required with add).\n\n**-q**: Only print error messages.\n**--quiet**: This option is only valid for add and update commands. Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.\n**--progress**: This option is only valid for the deinit command. Unregister all submodules in the working tree.\n**--all**: Branch of repository to add as submodule. The name of the branch is recorded as submodule.<name>.branch in .gitmodules for update --remote. A special value of . is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository. If the option is not specified, it defaults to the remote HEAD.\n**-b <branch>**: This option is only valid for add, deinit and update commands. When running add, allow adding an otherwise ignored submodule path. This option is also used to bypass a check that the submodule’s name is not already in use. By default, git submodule add will fail if the proposed name (which is derived from the path) is already registered for another submodule in the repository. Using --force allows the command to proceed by automatically generating a unique name by appending a number to the conflicting name (e.g., if a submodule named child exists, it will try child1, and so on). When running deinit the submodule working trees will be removed even if they contain local changes. When running update (only effective with the checkout procedure), throw away local changes in submodules when switching to a different commit; and always run a checkout operation in the submodule, even if the commit listed in the index of the containing repository matches the commit checked out in the submodule.\n**--branch <branch>**: This option is only valid for status and summary commands. These commands typically use the commit found in the submodule HEAD, but with this option, the commit stored in the index is used instead.\n**-f**: This option is only valid for the summary command. This command compares the commit in the index with that in the submodule HEAD when this option is used.\n**--force**: This option is only valid for the summary command. Limit the summary size (number of commits shown in total). Giving 0 will disable the summary; a negative number means unlimited (the default). This limit only applies to modified submodules. The size is always limited to 1 for added/deleted/typechanged submodules.\n**--cached**: This option is only valid for the update command. Instead of using the superproject’s recorded SHA-1 to update the submodule, use the status of the submodule’s remote-tracking branch. The remote used is branch’s remote (branch.<name>.remote), defaulting to origin. The remote branch used defaults to the remote HEAD, but the branch name may be overridden by setting the submodule.<name>.branch option in either .gitmodules or .git/config (with .git/config taking precedence). This works for any of the supported update procedures (--checkout, --rebase, etc.). The only change is the source of the target SHA-1. For example, submodule update --remote --merge will merge upstream submodule changes into the submodules, while submodule update --merge will merge superproject gitlink changes into the submodules. In order to ensure a current tracking branch state, update --remote fetches the submodule’s remote repository before calculating the SHA-1. If you don’t want to fetch, you should use submodule update --remote --no-fetch. Use this option to integrate changes from the upstream subproject with your submodule’s current HEAD. Alternatively, you can run git pull from the submodule, which is equivalent except for the remote branch name: update --remote uses the default upstream repository and submodule.<name>.branch, while git pull uses the submodule’s branch.<name>.merge. Prefer submodule.<name>.branch if you want to distribute the default upstream branch with the superproject and branch.<name>.merge if you want a more native feel while working in the submodule itself.\n**--files**: This option is only valid for the update command. Don’t fetch new objects from the remote site.\n**-n**: This option is only valid for the update command. Checkout the commit recorded in the superproject on a detached HEAD in the submodule. This is the default behavior, the main use of this option is to override submodule.$name.update when set to a value other than checkout. If the key submodule.$name.update is either not explicitly set or set to checkout, this option is implicit.\n**--summary-limit**: This option is only valid for the update command. Merge the commit recorded in the superproject into the current branch of the submodule. If this option is given, the submodule’s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve the resulting conflicts within the submodule with the usual conflict resolution tools. If the key submodule.$name.update is set to merge, this option is implicit.\n**--remote**: This option is only valid for the update command. Rebase the current branch onto the commit recorded in the superproject. If this option is given, the submodule’s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve these failures with git-rebase[1]. If the key submodule.$name.update is set to rebase, this option is implicit.\n**-N**: This option is only valid for the update command. Initialize all submodules for which \"git submodule init\" has not been called so far before updating.\n**--no-fetch**: This option is only valid for the add command. It sets the submodule’s name to the given string instead of defaulting to its path. The name must be valid as a directory name and may not end with a /.\n**--checkout**: This option is only valid for add and update commands. These commands sometimes need to clone a remote repository. In this case, this option will be passed to the git-clone[1] command. NOTE: Do not use this option unless you have read the note for git-clone[1]'s --reference, --shared, and --dissociate options carefully.\n**--merge**: This option is only valid for add and update commands. These commands sometimes need to clone a remote repository. In this case, this option will be passed to the git-clone[1] command. NOTE: see the NOTE for the --reference option.\n**--rebase**: This option is only valid for foreach, update, status and sync commands. Traverse submodules recursively. The operation is performed not only in the submodules of the current repo, but also in any nested submodules inside those submodules (and so on).\n**--init**: This option is valid for add and update commands. Create a shallow clone with a history truncated to the specified number of revisions. See git-clone[1]\n**--name**: This option is only valid for the update command. The initial clone of a submodule will use the recommended submodule.<name>.shallow as provided by the .gitmodules file by default. To ignore the suggestions use --no-recommend-shallow.\n**--reference <repository>**: This option is only valid for the update command. Clone new submodules in parallel with as many jobs. Defaults to the submodule.fetchJobs option.\n**--dissociate**: This option is only valid for the update command. Clone only one branch during update: HEAD or one specified by --branch.\n**--recursive**: Paths to submodule(s). When specified this will restrict the command to only operate on the submodules found at the specified paths. (This argument is required with add).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 28,
          "content_length": 14932
        }
      },
      {
        "header": "FILES",
        "content": "When initializing submodules, a .gitmodules file in the top-level directory of the containing repository is used to find the url of each submodule. This file should be formatted in the same way as $GIT_DIR/config. The key to each submodule url is \"submodule.$name.url\". See gitmodules[5] for details.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 300
        }
      },
      {
        "header": "SEE ALSO",
        "content": "gitsubmodules[7], gitmodules[5].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 32
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-submodule",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "Git",
    "summary": "SYNOPSIS git switch [<options>] [--no-guess] <branch> git switch [<options>] --detach [<start-point>] git switch [<options>] (-c|-C) <new-branch> [<start-point>] git switch [<options>] --orphan <new-branch>",
    "sections": [
      {
        "header": "NAME",
        "content": "git-switch - Switch branches",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 28
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Switch to a specified branch. The working tree and the index are updated to match the branch. All new commits will be added to the tip of this branch.\n\nOptionally a new branch could be created with either -c, -C, automatically from a remote branch of same name (see --guess), or detach the working tree from any branch with --detach, along with switching.\n\nSwitching branches does not require a clean index and working tree (i.e. no differences compared to HEAD). The operation is aborted however if the operation leads to loss of local changes, unless told otherwise with --discard-changes or --merge.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 602
        }
      },
      {
        "header": "OPTIONS",
        "content": "Branch to switch to.\n\nName for the new branch.\n\nThe starting point for the new branch. Specifying a <start-point> allows you to create a branch based on some other point in history than where HEAD currently points. (Or, in the case of --detach, allows you to inspect and detach from some other point.)\n\nYou can use the @{-<N>} syntax to refer to the <N>-th last branch/commit switched to using git switch or git checkout operation. You may also specify - which is synonymous to @{-1}. This is often used to switch quickly between two branches, or to undo a branch switch by mistake.\n\nAs a special case, you may use <rev-a>...<rev-b> as a shortcut for the merge base of <rev-a> and <rev-b> if there is exactly one merge base. You can leave out at most one of <rev-a> and <rev-b>, in which case it defaults to HEAD.\n\nCreate a new branch named <new-branch> starting at <start-point> before switching to the branch. This is the transactional equivalent of\n\nthat is to say, the branch is not reset/created unless git switch is successful (e.g., when the branch is in use in another worktree, not just the current branch stays the same, but the branch is not reset to the start-point, either).\n\nSimilar to --create except that if <new-branch> already exists, it will be reset to <start-point>. This is a convenient shortcut for:\n\nSwitch to a commit for inspection and discardable experiments. See the \"DETACHED HEAD\" section in git-checkout[1] for details.\n\nIf <branch> is not found but there does exist a tracking branch in exactly one remote (call it <remote>) with a matching name, treat as equivalent to\n\nIf the branch exists in multiple remotes and one of them is named by the checkout.defaultRemote configuration variable, we’ll use that one for the purposes of disambiguation, even if the <branch> isn’t unique across all remotes. Set it to e.g. checkout.defaultRemote=origin to always checkout remote branches from there if <branch> is ambiguous but exists on the origin remote. See also checkout.defaultRemote in git-config[1].\n\n--guess is the default behavior. Use --no-guess to disable it.\n\nThe default behavior can be set via the checkout.guess configuration variable.\n\nAn alias for --discard-changes.\n\nProceed even if the index or the working tree differs from HEAD. Both the index and working tree are restored to match the switching target. If --recurse-submodules is specified, submodule content is also restored to match the switching target. This is used to throw away local changes.\n\nIf you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.\n\nWhen a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with git add (or git rm if the merge should result in deletion of the path).\n\nThe same as --merge option above, but changes the way the conflicting hunks are presented, overriding the merge.conflictStyle configuration variable. Possible values are merge (default), diff3, and zdiff3.\n\nQuiet, suppress feedback messages.\n\nProgress status is reported on the standard error stream by default when it is attached to a terminal, unless --quiet is specified. This flag enables progress reporting even if not attached to a terminal, regardless of --quiet.\n\nWhen creating a new branch, set up \"upstream\" configuration. -c is implied. See --track in git-branch[1] for details.\n\nIf no -c option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the \"*\". This would tell us to use hack as the local branch when branching off of origin/hack (or remotes/origin/hack, or even refs/remotes/origin/hack). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with -c in such a case.\n\nDo not set up \"upstream\" configuration, even if the branch.autoSetupMerge configuration variable is true.\n\nCreate a new unborn branch, named <new-branch>. All tracked files are removed.\n\ngit switch refuses when the wanted ref is already checked out by another worktree. This option makes it check the ref out anyway. In other words, the ref can be held by more than one worktree.\n\nUsing --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject. If nothing (or --no-recurse-submodules) is used, submodules working trees will not be updated. Just like git-submodule[1], this will detach HEAD of the submodules.\n\n**<branch>**: Branch to switch to.\n**<new-branch>**: Name for the new branch.\n**<start-point>**: The starting point for the new branch. Specifying a <start-point> allows you to create a branch based on some other point in history than where HEAD currently points. (Or, in the case of --detach, allows you to inspect and detach from some other point.) You can use the @{-<N>} syntax to refer to the <N>-th last branch/commit switched to using git switch or git checkout operation. You may also specify - which is synonymous to @{-1}. This is often used to switch quickly between two branches, or to undo a branch switch by mistake. As a special case, you may use <rev-a>...<rev-b> as a shortcut for the merge base of <rev-a> and <rev-b> if there is exactly one merge base. You can leave out at most one of <rev-a> and <rev-b>, in which case it defaults to HEAD.\n**-c <new-branch>**: Create a new branch named <new-branch> starting at <start-point> before switching to the branch. This is the transactional equivalent of $ git branch <new-branch> $ git switch <new-branch> that is to say, the branch is not reset/created unless git switch is successful (e.g., when the branch is in use in another worktree, not just the current branch stays the same, but the branch is not reset to the start-point, either).\n**--create <new-branch>**: Similar to --create except that if <new-branch> already exists, it will be reset to <start-point>. This is a convenient shortcut for: $ git branch -f _<new-branch>_ $ git switch _<new-branch>_\n**-C <new-branch>**: Switch to a commit for inspection and discardable experiments. See the \"DETACHED HEAD\" section in git-checkout[1] for details.\n**--force-create <new-branch>**: If <branch> is not found but there does exist a tracking branch in exactly one remote (call it <remote>) with a matching name, treat as equivalent to $ git switch -c <branch> --track <remote>/<branch> If the branch exists in multiple remotes and one of them is named by the checkout.defaultRemote configuration variable, we’ll use that one for the purposes of disambiguation, even if the <branch> isn’t unique across all remotes. Set it to e.g. checkout.defaultRemote=origin to always checkout remote branches from there if <branch> is ambiguous but exists on the origin remote. See also checkout.defaultRemote in git-config[1]. --guess is the default behavior. Use --no-guess to disable it. The default behavior can be set via the checkout.guess configuration variable.\n**-d**: An alias for --discard-changes.\n**--detach**: Proceed even if the index or the working tree differs from HEAD. Both the index and working tree are restored to match the switching target. If --recurse-submodules is specified, submodule content is also restored to match the switching target. This is used to throw away local changes.\n**--guess**: If you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch. When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with git add (or git rm if the merge should result in deletion of the path).\n**--no-guess**: The same as --merge option above, but changes the way the conflicting hunks are presented, overriding the merge.conflictStyle configuration variable. Possible values are merge (default), diff3, and zdiff3.\n**-f**: Quiet, suppress feedback messages.\n**--force**: Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --quiet is specified. This flag enables progress reporting even if not attached to a terminal, regardless of --quiet.\n**--discard-changes**: When creating a new branch, set up \"upstream\" configuration. -c is implied. See --track in git-branch[1] for details. If no -c option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the \"*\". This would tell us to use hack as the local branch when branching off of origin/hack (or remotes/origin/hack, or even refs/remotes/origin/hack). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with -c in such a case.\n**-m**: Do not set up \"upstream\" configuration, even if the branch.autoSetupMerge configuration variable is true.\n**--merge**: Create a new unborn branch, named <new-branch>. All tracked files are removed.\n**--conflict=<style>**: git switch refuses when the wanted ref is already checked out by another worktree. This option makes it check the ref out anyway. In other words, the ref can be held by more than one worktree.\n**-q**: Using --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject. If nothing (or --no-recurse-submodules) is used, submodules working trees will not be updated. Just like git-submodule[1], this will detach HEAD of the submodules.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git branch <new-branch>\n$ git switch <new-branch>\n```",
          "```bash\n$ git branch -f _<new-branch>_\n$ git switch _<new-branch>_\n```",
          "```bash\n$ git switch -c<branch>--track <remote>/<branch>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 26,
          "content_length": 10316
        }
      },
      {
        "header": "EXAMPLES",
        "content": "The following command switches to the \"master\" branch:\n\nAfter working in the wrong branch, switching to the correct branch would be done using:\n\nHowever, your \"wrong\" branch and correct \"mytopic\" branch may differ in files that you have modified locally, in which case the above switch would fail like this:\n\nYou can give the -m flag to the command, which would try a three-way merge:\n\nAfter this three-way merge, the local modifications are not registered in your index file, so git diff would show you what changes you made since the tip of the new branch.\n\nTo switch back to the previous branch before we switched to mytopic (i.e. \"master\" branch):\n\nYou can grow a new branch from any commit. For example, switch to \"HEAD~3\" and create branch \"fixup\":\n\nIf you want to start a new branch from a remote branch of the same name:\n\nTo check out commit HEAD~3 for temporary inspection or experiment without creating a new branch:\n\nIf it turns out whatever you have done is worth keeping, you can always create a new name for it (without switching away):",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git switch master\n```",
          "```bash\n$ git switch mytopic\n```",
          "```bash\n$ git switch mytopic\nerror: You have local changes to 'frotz'; not switching branches.\n```",
          "```bash\n$ git switch -m mytopic\nAuto-merging frotz\n```",
          "```bash\n$ git switch -\n```",
          "```bash\n$ git switch -c fixup HEAD~3\nSwitched to a new branch 'fixup'\n```",
          "```bash\n$ git switch new-topic\nBranch `new-topic` set up to track remote branch `new-topic` from `origin`\nSwitched to a new branch `new-topic`\n```",
          "```bash\n$ git switch --detach HEAD~3\nHEAD is now at 9fc9555312 Merge branch 'cc/shared-index-permbits'\n```",
          "```bash\n$ git switch -c good-surprises\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 1050
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "Everything below this line in this section is selectively included from the git-config[1] documentation. The content is the same as what’s found there:\n\nWhen you run git checkout <something> or git switch <something> and only have one remote, it may implicitly fall back on checking out and tracking e.g. origin/<something>. This stops working as soon as you have more than one remote with a <something> reference. This setting allows for setting the name of a preferred remote that should always win when it comes to disambiguation. The typical use-case is to set this to origin.\n\nCurrently this is used by git-switch[1] and git-checkout[1] when git checkout <something> or git switch <something> will checkout the <something> branch on another remote, and by git-worktree[1] when git worktree add refers to a remote branch. This setting might be used for other checkout-like commands or functionality in the future.\n\nProvides the default value for the --guess or --no-guess option in git checkout and git switch. See git-switch[1] and git-checkout[1].\n\nThe number of parallel workers to use when updating the working tree. The default is one, i.e. sequential execution. If set to a value less than one, Git will use as many workers as the number of logical cores available. This setting and checkout.thresholdForParallelism affect all commands that perform checkout. E.g. checkout, clone, reset, sparse-checkout, etc.\n\nWhen running parallel checkout with a small number of files, the cost of subprocess spawning and inter-process communication might outweigh the parallelization gains. This setting allows you to define the minimum number of files for which parallel checkout should be attempted. The default is 100.\n\n**checkout.defaultRemote**: When you run git checkout <something> or git switch <something> and only have one remote, it may implicitly fall back on checking out and tracking e.g. origin/<something>. This stops working as soon as you have more than one remote with a <something> reference. This setting allows for setting the name of a preferred remote that should always win when it comes to disambiguation. The typical use-case is to set this to origin. Currently this is used by git-switch[1] and git-checkout[1] when git checkout <something> or git switch <something> will checkout the <something> branch on another remote, and by git-worktree[1] when git worktree add refers to a remote branch. This setting might be used for other checkout-like commands or functionality in the future.\n**checkout.guess**: Provides the default value for the --guess or --no-guess option in git checkout and git switch. See git-switch[1] and git-checkout[1].\n**checkout.workers**: The number of parallel workers to use when updating the working tree. The default is one, i.e. sequential execution. If set to a value less than one, Git will use as many workers as the number of logical cores available. This setting and checkout.thresholdForParallelism affect all commands that perform checkout. E.g. checkout, clone, reset, sparse-checkout, etc. Note Parallel checkout usually delivers better performance for repositories located on SSDs or over NFS. For repositories on spinning disks and/or machines with a small number of cores, the default sequential checkout often performs better. The size and compression level of a repository might also influence how well the parallel version performs.\n**checkout.thresholdForParallelism**: When running parallel checkout with a small number of files, the cost of subprocess spawning and inter-process communication might outweigh the parallelization gains. This setting allows you to define the minimum number of files for which parallel checkout should be attempted. The default is 100.\n\nNote | Parallel checkout usually delivers better performance for repositories located on SSDs or over NFS. For repositories on spinning disks and/or machines with a small number of cores, the default sequential checkout often performs better. The size and compression level of a repository might also influence how well the parallel version performs.\n\n[Note] Note Parallel checkout usually delivers better performance for repositories located on SSDs or over NFS. For repositories on spinning disks and/or machines with a small number of cores, the default sequential checkout often performs better. The size and compression level of a repository might also influence how well the parallel version performs.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 6,
          "content_length": 4447
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-checkout[1], git-branch[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 30
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-switch",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "Git",
    "summary": "NAME git-tag - Create, list, delete or verify a tag object signed with GPG\n\ngit-tag - Create, list, delete or verify a tag object signed with GPG",
    "sections": [
      {
        "header": "NAME",
        "content": "git-tag - Create, list, delete or verify a tag object signed with GPG",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 69
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Add a tag reference in refs/tags/, unless -d/-l/-v is given to delete, list or verify tags.\n\nUnless -f is given, the named tag must not yet exist.\n\nIf one of -a, -s, or -u <key-id> is passed, the command creates a tag object, and requires a tag message. Unless -m <msg> or -F <file> is given, an editor is started for the user to type in the tag message.\n\nIf -m <msg> or -F <file> or --trailer <token>[=<value>] is given and -a, -s, and -u <key-id> are absent, -a is implied.\n\nOtherwise, a tag reference that points directly at the given object (i.e., a lightweight tag) is created.\n\nA GnuPG signed tag object will be created when -s or -u <key-id> is used. When -u <key-id> is not used, the committer identity for the current user is used to find the GnuPG key for signing. The configuration variable gpg.program is used to specify custom GnuPG binary.\n\nTag objects (created with -a, -s, or -u) are called \"annotated\" tags; they contain a creation date, the tagger name and e-mail, a tagging message, and an optional GnuPG signature. Whereas a \"lightweight\" tag is simply a name for an object (usually a commit object).\n\nAnnotated tags are meant for release while lightweight tags are meant for private or temporary object labels. For this reason, some git commands for naming objects (like git describe) will ignore lightweight tags by default.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1346
        }
      },
      {
        "header": "OPTIONS",
        "content": "Make an unsigned, annotated tag object\n\nMake a GPG-signed tag, using the default e-mail address’s key. The default behavior of tag GPG-signing is controlled by tag.gpgSign configuration variable if it exists, or disabled otherwise. See git-config[1].\n\nOverride tag.gpgSign configuration variable that is set to force each and every tag to be signed.\n\nMake a GPG-signed tag, using the given key.\n\nReplace an existing tag with the given name (instead of failing)\n\nDelete existing tags with the given names.\n\nVerify the GPG signature of the given tag names.\n\n<num> specifies how many lines from the annotation, if any, are printed when using -l. Implies --list.\n\nThe default is not to print any annotation lines. If no number is given to -n, only the first line is printed. If the tag is not annotated, the commit message is displayed instead.\n\nList tags. With optional <pattern>..., e.g. git tag --list v-*', list only the tags that match the pattern(s).\n\nRunning \"git tag\" without arguments also lists all tags. The pattern is a shell wildcard (i.e., matched using fnmatch(3)). Multiple patterns may be given; if any of them matches, the tag is shown.\n\nThis option is implicitly supplied if any other list-like option such as --contains is provided. See the documentation for each of those options for details.\n\nSort based on the key given. Prefix - to sort in descending order of the value. You may use the --sort=<key> option multiple times, in which case the last key becomes the primary key. Also supports \"version:refname\" or \"v:refname\" (tag names are treated as versions). The \"version:refname\" sort order can also be affected by the \"versionsort.suffix\" configuration variable. The keys supported are the same as those in git for-each-ref. Sort order defaults to the value configured for the tag.sort variable if it exists, or lexicographic order otherwise. See git-config[1].\n\nRespect any colors specified in the --format option. The <when> field must be one of always, never, or auto (if <when> is absent, behave as if always was given).\n\nSorting and filtering tags are case insensitive.\n\nDo not print a newline after formatted refs where the format expands to the empty string.\n\nDisplay tag listing in columns. See configuration variable column.tag for option syntax. --column and --no-column without options are equivalent to always and never respectively.\n\nThis option is only applicable when listing tags without annotation lines.\n\nOnly list tags which contain the specified commit (HEAD if not specified). Implies --list.\n\nOnly list tags which don’t contain the specified commit (HEAD if not specified). Implies --list.\n\nOnly list tags whose commits are reachable from the specified commit (HEAD if not specified).\n\nOnly list tags whose commits are not reachable from the specified commit (HEAD if not specified).\n\nOnly list tags of the given object (HEAD if not specified). Implies --list.\n\nUse the given tag message (instead of prompting). If multiple -m options are given, their values are concatenated as separate paragraphs. Implies -a if none of -a, -s, or -u <key-id> is given.\n\nTake the tag message from the given file. Use - to read the message from the standard input. Implies -a if none of -a, -s, or -u <key-id> is given.\n\nSpecify a (<token>, <value>) pair that should be applied as a trailer. (e.g. git tag --trailer \"Custom-Key: value\" will add a \"Custom-Key\" trailer to the tag message.) The trailer.* configuration variables (git-interpret-trailers[1]) can be used to define if a duplicated trailer is omitted, where in the run of trailers each trailer would appear, and other details. The trailers can be extracted in git tag --list, using --format=\"%(trailers)\" placeholder.\n\nThe message taken from file with -F and command line with -m are usually used as the tag message unmodified. This option lets you further edit the message taken from these sources.\n\nThis option sets how the tag message is cleaned up. The <mode> can be one of verbatim, whitespace and strip. The strip mode is default. The verbatim mode does not change message at all, whitespace removes just leading/trailing whitespace lines and strip removes both whitespace and commentary.\n\nCreate a reflog for the tag. To globally enable reflogs for tags, see core.logAllRefUpdates in git-config[1]. The negated form --no-create-reflog only overrides an earlier --create-reflog, but currently does not negate the setting of core.logAllRefUpdates.\n\nA string that interpolates %(fieldname) from a tag ref being shown and the object it points at. The format is the same as that of git-for-each-ref[1]. When unspecified, defaults to %(refname:strip=2).\n\nThe name of the tag to create, delete, or describe. The new tag name must pass all checks defined by git-check-ref-format[1]. Some of these checks may restrict the characters allowed in a tag name.\n\nThe object that the new tag will refer to, usually a commit. Defaults to HEAD.\n\n**-a**: Make an unsigned, annotated tag object\n**--annotate**: Make a GPG-signed tag, using the default e-mail address’s key. The default behavior of tag GPG-signing is controlled by tag.gpgSign configuration variable if it exists, or disabled otherwise. See git-config[1].\n**-s**: Override tag.gpgSign configuration variable that is set to force each and every tag to be signed.\n**--sign**: Make a GPG-signed tag, using the given key.\n**--no-sign**: Replace an existing tag with the given name (instead of failing)\n**-u <key-id>**: Delete existing tags with the given names.\n**--local-user=<key-id>**: Verify the GPG signature of the given tag names.\n**-f**: <num> specifies how many lines from the annotation, if any, are printed when using -l. Implies --list. The default is not to print any annotation lines. If no number is given to -n, only the first line is printed. If the tag is not annotated, the commit message is displayed instead.\n**--force**: List tags. With optional <pattern>..., e.g. git tag --list v-*', list only the tags that match the pattern(s). Running \"git tag\" without arguments also lists all tags. The pattern is a shell wildcard (i.e., matched using fnmatch(3)). Multiple patterns may be given; if any of them matches, the tag is shown. This option is implicitly supplied if any other list-like option such as --contains is provided. See the documentation for each of those options for details.\n**-d**: Sort based on the key given. Prefix - to sort in descending order of the value. You may use the --sort=<key> option multiple times, in which case the last key becomes the primary key. Also supports \"version:refname\" or \"v:refname\" (tag names are treated as versions). The \"version:refname\" sort order can also be affected by the \"versionsort.suffix\" configuration variable. The keys supported are the same as those in git for-each-ref. Sort order defaults to the value configured for the tag.sort variable if it exists, or lexicographic order otherwise. See git-config[1].\n**--delete**: Respect any colors specified in the --format option. The <when> field must be one of always, never, or auto (if <when> is absent, behave as if always was given).\n**-v**: Sorting and filtering tags are case insensitive.\n**--verify**: Do not print a newline after formatted refs where the format expands to the empty string.\n**-n<num>**: Display tag listing in columns. See configuration variable column.tag for option syntax. --column and --no-column without options are equivalent to always and never respectively. This option is only applicable when listing tags without annotation lines.\n**-l**: Only list tags which contain the specified commit (HEAD if not specified). Implies --list.\n**--list**: Only list tags which don’t contain the specified commit (HEAD if not specified). Implies --list.\n**--sort=<key>**: Only list tags whose commits are reachable from the specified commit (HEAD if not specified).\n**--color[=<when>]**: Only list tags whose commits are not reachable from the specified commit (HEAD if not specified).\n**-i**: Only list tags of the given object (HEAD if not specified). Implies --list.\n**--ignore-case**: Use the given tag message (instead of prompting). If multiple -m options are given, their values are concatenated as separate paragraphs. Implies -a if none of -a, -s, or -u <key-id> is given.\n**--omit-empty**: Take the tag message from the given file. Use - to read the message from the standard input. Implies -a if none of -a, -s, or -u <key-id> is given.\n**--column[=<options>]**: Specify a (<token>, <value>) pair that should be applied as a trailer. (e.g. git tag --trailer \"Custom-Key: value\" will add a \"Custom-Key\" trailer to the tag message.) The trailer.* configuration variables (git-interpret-trailers[1]) can be used to define if a duplicated trailer is omitted, where in the run of trailers each trailer would appear, and other details. The trailers can be extracted in git tag --list, using --format=\"%(trailers)\" placeholder.\n**--no-column**: The message taken from file with -F and command line with -m are usually used as the tag message unmodified. This option lets you further edit the message taken from these sources.\n**--contains [<commit>]**: This option sets how the tag message is cleaned up. The <mode> can be one of verbatim, whitespace and strip. The strip mode is default. The verbatim mode does not change message at all, whitespace removes just leading/trailing whitespace lines and strip removes both whitespace and commentary.\n**--no-contains [<commit>]**: Create a reflog for the tag. To globally enable reflogs for tags, see core.logAllRefUpdates in git-config[1]. The negated form --no-create-reflog only overrides an earlier --create-reflog, but currently does not negate the setting of core.logAllRefUpdates.\n**--merged [<commit>]**: A string that interpolates %(fieldname) from a tag ref being shown and the object it points at. The format is the same as that of git-for-each-ref[1]. When unspecified, defaults to %(refname:strip=2).\n**--no-merged [<commit>]**: The name of the tag to create, delete, or describe. The new tag name must pass all checks defined by git-check-ref-format[1]. Some of these checks may restrict the characters allowed in a tag name.\n**--points-at <object>**: The object that the new tag will refer to, usually a commit. Defaults to HEAD.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 32,
          "content_length": 10280
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "By default, git tag in sign-with-default mode (-s) will use your committer identity (of the form Your Name <your@email.address>) to find a key. If you want to use a different default key, you can specify it in the repository configuration as follows:\n\npager.tag is only respected when listing tags, i.e., when -l is used or implied. The default is to use a pager. See git-config[1].",
        "code_examples": [
          "```bash\n[user]\n    signingKey = <gpg-key-id>\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 382
        }
      },
      {
        "header": "On Re-tagging",
        "content": "What should you do when you tag a wrong commit and you would want to re-tag?\n\nIf you never pushed anything out, just re-tag it. Use \"-f\" to replace the old one. And you’re done.\n\nBut if you have pushed things out (or others could just read your repository directly), then others will have already seen the old tag. In that case you can do one of two things:\n\nThe sane thing. Just admit you screwed up, and use a different name. Others have already seen one tag-name, and if you keep the same name, you may be in the situation that two people both have \"version X\", but they actually have different \"X\"'s. So just call it \"X.1\" and be done with it.\n\nThe insane thing. You really want to call the new version \"X\" too, even though others have already seen the old one. So just use git tag -f again, as if you hadn’t already published the old one.\n\nHowever, Git does not (and it should not) change tags behind users back. So if somebody already got the old tag, doing a git pull on your tree shouldn’t just make them overwrite the old one.\n\nIf somebody got a release tag from you, you cannot just change the tag for them by updating your own one. This is a big security issue, in that people MUST be able to trust their tag-names. If you really want to do the insane thing, you need to just fess up to it, and tell people that you messed up. You can do that by making a very public announcement saying:\n\nDoes this seem a bit complicated? It should be. There is no way that it would be correct to just \"fix\" it automatically. People need to know that their tags might have been changed.\n\n• The sane thing. Just admit you screwed up, and use a different name. Others have already seen one tag-name, and if you keep the same name, you may be in the situation that two people both have \"version X\", but they actually have different \"X\"'s. So just call it \"X.1\" and be done with it.\n• The insane thing. You really want to call the new version \"X\" too, even though others have already seen the old one. So just use git tag -f again, as if you hadn’t already published the old one.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nOk, I messed up, and I pushed out an earlier version tagged as X. I\nthen fixed something, and retagged the *fixed* tree as X again.\n\nIf you got the wrong tag, and want the new one, please delete\nthe old one and fetch the new one by doing:\n\n\tgit tag -d X\n\tgit fetch origin tag X\n\nto get my updated tag.\n\nYou can test which tag you have by doing\n\n\tgit rev-parse X\n\nwhich should return 0123456789abcdef.. if you have the new version.\n\nSorry for the inconvenience.\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 2070
        }
      },
      {
        "header": "On Automatic following",
        "content": "If you are following somebody else’s tree, you are most likely using remote-tracking branches (eg. refs/remotes/origin/master). You usually want the tags from the other end.\n\nOn the other hand, if you are fetching because you would want a one-shot merge from somebody else, you typically do not want to get tags from there. This happens more often for people near the toplevel but not limited to them. Mere mortals when pulling from each other do not necessarily want to automatically get private anchor point tags from the other person.\n\nOften, \"please pull\" messages on the mailing list just provide two pieces of information: a repo URL and a branch name; this is designed to be easily cut&pasted at the end of a git fetch command line:\n\nIn such a case, you do not want to automatically follow the other person’s tags.\n\nOne important aspect of Git is its distributed nature, which largely means there is no inherent \"upstream\" or \"downstream\" in the system. On the face of it, the above example might seem to indicate that the tag namespace is owned by the upper echelon of people and that tags only flow downwards, but that is not the case. It only shows that the usage pattern determines who are interested in whose tags.\n\nA one-shot pull is a sign that a commit history is now crossing the boundary between one circle of people (e.g. \"people who are primarily interested in the networking part of the kernel\") who may have their own set of tags (e.g. \"this is the third release candidate from the networking group to be proposed for general consumption with 2.6.21 release\") to another circle of people (e.g. \"people who integrate various subsystem improvements\"). The latter are usually not interested in the detailed tags used internally in the former group (that is what \"internal\" means). That is why it is desirable not to follow tags automatically in this case.\n\nIt may well be that among networking people, they may want to exchange the tags internal to their group, but in that workflow they are most likely tracking each other’s progress by having remote-tracking branches. Again, the heuristic to automatically follow such tags is a good thing.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nLinus, please pull from\n\n\tgit://git..../proj.git master\n\nto get the following updates...\n```",
          "```bash\n$ git pull git://git..../proj.git master\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 2160
        }
      },
      {
        "header": "On Backdating Tags",
        "content": "If you have imported some changes from another VCS and would like to add tags for major releases of your work, it is useful to be able to specify the date to embed inside of the tag object; such data in the tag object affects, for example, the ordering of tags in the gitweb interface.\n\nTo set the date used in future tag objects, set the environment variable GIT_COMMITTER_DATE (see the later discussion of possible values; the most common form is \"YYYY-MM-DD HH:MM\").",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ GIT_COMMITTER_DATE=\"2006-10-02 10:31\" git tag -s v1.0.1\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 469
        }
      },
      {
        "header": "DATE FORMATS",
        "content": "The GIT_AUTHOR_DATE and GIT_COMMITTER_DATE environment variables support the following date formats:\n\nIt is <unix-timestamp> <time-zone-offset>, where <unix-timestamp> is the number of seconds since the UNIX epoch. <time-zone-offset> is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is +0100.\n\nThe standard date format as described by RFC 2822, for example Thu, 07 Apr 2005 22:13:13 +0200.\n\nTime and date specified by the ISO 8601 standard, for example 2005-04-07T22:13:13. The parser accepts a space instead of the T character as well. Fractional parts of a second will be ignored, for example 2005-04-07T22:13:13.019 will be treated as 2005-04-07T22:13:13.\n\n**Git internal format**: It is <unix-timestamp> <time-zone-offset>, where <unix-timestamp> is the number of seconds since the UNIX epoch. <time-zone-offset> is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is +0100.\n**RFC 2822**: The standard date format as described by RFC 2822, for example Thu, 07 Apr 2005 22:13:13 +0200.\n**ISO 8601**: Time and date specified by the ISO 8601 standard, for example 2005-04-07T22:13:13. The parser accepts a space instead of the T character as well. Fractional parts of a second will be ignored, for example 2005-04-07T22:13:13.019 will be treated as 2005-04-07T22:13:13. Note In addition, the date part is accepted in the following formats: YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY.\n\nNote | In addition, the date part is accepted in the following formats: YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY.\n\n[Note] Note In addition, the date part is accepted in the following formats: YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 4,
          "content_length": 1687
        }
      },
      {
        "header": "FILES",
        "content": "This file contains the message of an in-progress annotated tag. If git tag exits due to an error before creating an annotated tag then the tag message that has been provided by the user in an editor session will be available in this file, but may be overwritten by the next invocation of git tag.\n\n**$GIT_DIR/TAG_EDITMSG**: This file contains the message of an in-progress annotated tag. If git tag exits due to an error before creating an annotated tag then the tag message that has been provided by the user in an editor session will be available in this file, but may be overwritten by the next invocation of git tag.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 620
        }
      },
      {
        "header": "NOTES",
        "content": "When combining multiple --contains and --no-contains filters, only references that contain at least one of the --contains commits and contain none of the --no-contains commits are shown.\n\nWhen combining multiple --merged and --no-merged filters, only references that are reachable from at least one of the --merged commits and from none of the --no-merged commits are shown.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 374
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-check-ref-format[1]. git-config[1].",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 39
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-tag",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Git",
    "summary": "SYNOPSIS git worktree add [-f] [--detach] [--checkout] [--lock [--reason <string>]] [--orphan] [(-b | -B) <new-branch>] <path> [<commit-ish>] git worktree list [-v | --porcelain [-z]] git worktree lock [--reason <string>] <worktree> git worktree move <worktree> <new-path> git worktree prune [-n] [-v] [--expire <expire>] git worktree remove [-f] <worktree> git worktree repair [<path>…] git worktree unlock <worktree>",
    "sections": [
      {
        "header": "NAME",
        "content": "git-worktree - Manage multiple working trees",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 44
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Manage multiple working trees attached to the same repository.\n\nA git repository can support multiple working trees, allowing you to check out more than one branch at a time. With git worktree add a new working tree is associated with the repository, along with additional metadata that differentiates that working tree from others in the same repository. The working tree, along with this metadata, is called a \"worktree\".\n\nThis new worktree is called a \"linked worktree\" as opposed to the \"main worktree\" prepared by git-init[1] or git-clone[1]. A repository has one main worktree (if it’s not a bare repository) and zero or more linked worktrees. When you are done with a linked worktree, remove it with git worktree remove.\n\nIn its simplest form, git worktree add <path> automatically creates a new branch whose name is the final component of <path>, which is convenient if you plan to work on a new topic. For instance, git worktree add ../hotfix creates new branch hotfix and checks it out at path ../hotfix. To instead work on an existing branch in a new worktree, use git worktree add <path> <branch>. On the other hand, if you just plan to make some experimental changes or do testing without disturbing existing development, it is often convenient to create a throwaway worktree not associated with any branch. For instance, git worktree add -d <path> creates a new worktree with a detached HEAD at the same commit as the current branch.\n\nIf a working tree is deleted without using git worktree remove, then its associated administrative files, which reside in the repository (see \"DETAILS\" below), will eventually be removed automatically (see gc.worktreePruneExpire in git-config[1]), or you can run git worktree prune in the main or any linked worktree to clean up any stale administrative files.\n\nIf the working tree for a linked worktree is stored on a portable device or network share which is not always mounted, you can prevent its administrative files from being pruned by issuing the git worktree lock command, optionally specifying --reason to explain why the worktree is locked.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 2100
        }
      },
      {
        "header": "COMMANDS",
        "content": "Create a worktree at <path> and checkout <commit-ish> into it. The new worktree is linked to the current repository, sharing everything except per-worktree files such as HEAD, index, etc. As a convenience, <commit-ish> may be a bare \"-\", which is synonymous with @{-1}.\n\nIf <commit-ish> is a branch name (call it <branch>) and is not found, and neither -b nor -B nor --detach are used, but there does exist a tracking branch in exactly one remote (call it <remote>) with a matching name, treat as equivalent to:\n\nIf the branch exists in multiple remotes and one of them is named by the checkout.defaultRemote configuration variable, we’ll use that one for the purposes of disambiguation, even if the <branch> isn’t unique across all remotes. Set it to e.g. checkout.defaultRemote=origin to always checkout remote branches from there if <branch> is ambiguous but exists on the origin remote. See also checkout.defaultRemote in git-config[1].\n\nIf <commit-ish> is omitted and neither -b nor -B nor --detach used, then, as a convenience, the new worktree is associated with a branch (call it <branch>) named after $(basename <path>). If <branch> doesn’t exist, a new branch based on HEAD is automatically created as if -b <branch> was given. If <branch> does exist, it will be checked out in the new worktree, if it’s not checked out anywhere else, otherwise the command will refuse to create the worktree (unless --force is used).\n\nIf <commit-ish> is omitted, neither --detach, or --orphan is used, and there are no valid local branches (or remote branches if --guess-remote is specified) then, as a convenience, the new worktree is associated with a new unborn branch named <branch> (after $(basename <path>) if neither -b or -B is used) as if --orphan was passed to the command. In the event the repository has a remote and --guess-remote is used, but no remote or local branches exist, then the command fails with a warning reminding the user to fetch from their remote first (or override by using -f/--force).\n\nList details of each worktree. The main worktree is listed first, followed by each of the linked worktrees. The output details include whether the worktree is bare, the revision currently checked out, the branch currently checked out (or \"detached HEAD\" if none), \"locked\" if the worktree is locked, \"prunable\" if the worktree can be pruned by the prune command.\n\nIf a worktree is on a portable device or network share which is not always mounted, lock it to prevent its administrative files from being pruned automatically. This also prevents it from being moved or deleted. Optionally, specify a reason for the lock with --reason.\n\nMove a worktree to a new location. Note that the main worktree or linked worktrees containing submodules cannot be moved with this command. (The git worktree repair command, however, can reestablish the connection with linked worktrees if you move the main worktree manually.)\n\nPrune worktree information in $GIT_DIR/worktrees.\n\nRemove a worktree. Only clean worktrees (no untracked files and no modification in tracked files) can be removed. Unclean worktrees or ones with submodules can be removed with --force. The main worktree cannot be removed.\n\nRepair worktree administrative files, if possible, if they have become corrupted or outdated due to external factors.\n\nFor instance, if the main worktree (or bare repository) is moved, linked worktrees will be unable to locate it. Running repair in the main worktree will reestablish the connection from linked worktrees back to the main worktree.\n\nSimilarly, if the working tree for a linked worktree is moved without using git worktree move, the main worktree (or bare repository) will be unable to locate it. Running repair within the recently-moved worktree will reestablish the connection. If multiple linked worktrees are moved, running repair from any worktree with each tree’s new <path> as an argument, will reestablish the connection to all the specified paths.\n\nIf both the main worktree and linked worktrees have been moved or copied manually, then running repair in the main worktree and specifying the new <path> of each linked worktree will reestablish all connections in both directions.\n\nUnlock a worktree, allowing it to be pruned, moved or deleted.\n\n**add <path> [<commit-ish>]**: Create a worktree at <path> and checkout <commit-ish> into it. The new worktree is linked to the current repository, sharing everything except per-worktree files such as HEAD, index, etc. As a convenience, <commit-ish> may be a bare \"-\", which is synonymous with @{-1}. If <commit-ish> is a branch name (call it <branch>) and is not found, and neither -b nor -B nor --detach are used, but there does exist a tracking branch in exactly one remote (call it <remote>) with a matching name, treat as equivalent to: $ git worktree add --track -b <branch> <path> <remote>/<branch> If the branch exists in multiple remotes and one of them is named by the checkout.defaultRemote configuration variable, we’ll use that one for the purposes of disambiguation, even if the <branch> isn’t unique across all remotes. Set it to e.g. checkout.defaultRemote=origin to always checkout remote branches from there if <branch> is ambiguous but exists on the origin remote. See also checkout.defaultRemote in git-config[1]. If <commit-ish> is omitted and neither -b nor -B nor --detach used, then, as a convenience, the new worktree is associated with a branch (call it <branch>) named after $(basename <path>). If <branch> doesn’t exist, a new branch based on HEAD is automatically created as if -b <branch> was given. If <branch> does exist, it will be checked out in the new worktree, if it’s not checked out anywhere else, otherwise the command will refuse to create the worktree (unless --force is used). If <commit-ish> is omitted, neither --detach, or --orphan is used, and there are no valid local branches (or remote branches if --guess-remote is specified) then, as a convenience, the new worktree is associated with a new unborn branch named <branch> (after $(basename <path>) if neither -b or -B is used) as if --orphan was passed to the command. In the event the repository has a remote and --guess-remote is used, but no remote or local branches exist, then the command fails with a warning reminding the user to fetch from their remote first (or override by using -f/--force).\n**list**: List details of each worktree. The main worktree is listed first, followed by each of the linked worktrees. The output details include whether the worktree is bare, the revision currently checked out, the branch currently checked out (or \"detached HEAD\" if none), \"locked\" if the worktree is locked, \"prunable\" if the worktree can be pruned by the prune command.\n**lock**: If a worktree is on a portable device or network share which is not always mounted, lock it to prevent its administrative files from being pruned automatically. This also prevents it from being moved or deleted. Optionally, specify a reason for the lock with --reason.\n**move**: Move a worktree to a new location. Note that the main worktree or linked worktrees containing submodules cannot be moved with this command. (The git worktree repair command, however, can reestablish the connection with linked worktrees if you move the main worktree manually.)\n**prune**: Prune worktree information in $GIT_DIR/worktrees.\n**remove**: Remove a worktree. Only clean worktrees (no untracked files and no modification in tracked files) can be removed. Unclean worktrees or ones with submodules can be removed with --force. The main worktree cannot be removed.\n**repair [<path>…]**: Repair worktree administrative files, if possible, if they have become corrupted or outdated due to external factors. For instance, if the main worktree (or bare repository) is moved, linked worktrees will be unable to locate it. Running repair in the main worktree will reestablish the connection from linked worktrees back to the main worktree. Similarly, if the working tree for a linked worktree is moved without using git worktree move, the main worktree (or bare repository) will be unable to locate it. Running repair within the recently-moved worktree will reestablish the connection. If multiple linked worktrees are moved, running repair from any worktree with each tree’s new <path> as an argument, will reestablish the connection to all the specified paths. If both the main worktree and linked worktrees have been moved or copied manually, then running repair in the main worktree and specifying the new <path> of each linked worktree will reestablish all connections in both directions.\n**unlock**: Unlock a worktree, allowing it to be pruned, moved or deleted.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git worktree add --track -b<branch><path> <remote>/<branch>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 15,
          "content_length": 8700
        }
      },
      {
        "header": "OPTIONS",
        "content": "By default, add refuses to create a new worktree when <commit-ish> is a branch name and is already checked out by another worktree, or if <path> is already assigned to some worktree but is missing (for instance, if <path> was deleted manually). This option overrides these safeguards. To add a missing but locked worktree path, specify --force twice.\n\nmove refuses to move a locked worktree unless --force is specified twice. If the destination is already assigned to some other worktree but is missing (for instance, if <new-path> was deleted manually), then --force allows the move to proceed; use --force twice if the destination is locked.\n\nremove refuses to remove an unclean worktree unless --force is used. To remove a locked worktree, specify --force twice.\n\nWith add, create a new branch named <new-branch> starting at <commit-ish>, and check out <new-branch> into the new worktree. If <commit-ish> is omitted, it defaults to HEAD. By default, -b refuses to create a new branch if it already exists. -B overrides this safeguard, resetting <new-branch> to <commit-ish>.\n\nWith add, detach HEAD in the new worktree. See \"DETACHED HEAD\" in git-checkout[1].\n\nBy default, add checks out <commit-ish>, however, --no-checkout can be used to suppress checkout in order to make customizations, such as configuring sparse-checkout. See \"Sparse checkout\" in git-read-tree[1].\n\nWith worktree add <path>, without <commit-ish>, instead of creating a new branch from HEAD, if there exists a tracking branch in exactly one remote matching the basename of <path>, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as \"upstream\" from the new branch.\n\nThis can also be set up as the default behaviour by using the worktree.guessRemote config option.\n\nLink worktrees using relative paths or absolute paths (default). Overrides the worktree.useRelativePaths config option, see git-config[1].\n\nWith repair, the linking files will be updated if there’s an absolute/relative mismatch, even if the links are correct.\n\nWhen creating a new branch, if <commit-ish> is a branch, mark it as \"upstream\" from the new branch. This is the default if <commit-ish> is a remote-tracking branch. See --track in git-branch[1] for details.\n\nKeep the worktree locked after creation. This is the equivalent of git worktree lock after git worktree add, but without a race condition.\n\nWith prune, do not remove anything; just report what it would remove.\n\nWith add, make the new worktree and index empty, associating the worktree with a new unborn branch named <new-branch>.\n\nWith list, output in an easy-to-parse format for scripts. This format will remain stable across Git versions and regardless of user configuration. It is recommended to combine this with -z. See below for details.\n\nTerminate each line with a NUL rather than a newline when --porcelain is specified with list. This makes it possible to parse the output when a worktree path contains a newline character.\n\nWith add, suppress feedback messages.\n\nWith prune, report all removals.\n\nWith list, output additional information about worktrees (see below).\n\nWith prune, only expire unused worktrees older than <time>.\n\nWith list, annotate missing worktrees as prunable if they are older than <time>.\n\nWith lock or with add --lock, an explanation why the worktree is locked.\n\nWorktrees can be identified by path, either relative or absolute.\n\nIf the last path components in the worktree’s path is unique among worktrees, it can be used to identify a worktree. For example if you only have two worktrees, at /abc/def/ghi and /abc/def/ggg, then ghi or def/ghi is enough to point to the former worktree.\n\n**-f**: By default, add refuses to create a new worktree when <commit-ish> is a branch name and is already checked out by another worktree, or if <path> is already assigned to some worktree but is missing (for instance, if <path> was deleted manually). This option overrides these safeguards. To add a missing but locked worktree path, specify --force twice. move refuses to move a locked worktree unless --force is specified twice. If the destination is already assigned to some other worktree but is missing (for instance, if <new-path> was deleted manually), then --force allows the move to proceed; use --force twice if the destination is locked. remove refuses to remove an unclean worktree unless --force is used. To remove a locked worktree, specify --force twice.\n**--force**: With add, create a new branch named <new-branch> starting at <commit-ish>, and check out <new-branch> into the new worktree. If <commit-ish> is omitted, it defaults to HEAD. By default, -b refuses to create a new branch if it already exists. -B overrides this safeguard, resetting <new-branch> to <commit-ish>.\n**-b <new-branch>**: With add, detach HEAD in the new worktree. See \"DETACHED HEAD\" in git-checkout[1].\n**-B <new-branch>**: By default, add checks out <commit-ish>, however, --no-checkout can be used to suppress checkout in order to make customizations, such as configuring sparse-checkout. See \"Sparse checkout\" in git-read-tree[1].\n**-d**: With worktree add <path>, without <commit-ish>, instead of creating a new branch from HEAD, if there exists a tracking branch in exactly one remote matching the basename of <path>, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as \"upstream\" from the new branch. This can also be set up as the default behaviour by using the worktree.guessRemote config option.\n**--detach**: Link worktrees using relative paths or absolute paths (default). Overrides the worktree.useRelativePaths config option, see git-config[1]. With repair, the linking files will be updated if there’s an absolute/relative mismatch, even if the links are correct.\n**--[no-]checkout**: When creating a new branch, if <commit-ish> is a branch, mark it as \"upstream\" from the new branch. This is the default if <commit-ish> is a remote-tracking branch. See --track in git-branch[1] for details.\n**--[no-]guess-remote**: Keep the worktree locked after creation. This is the equivalent of git worktree lock after git worktree add, but without a race condition.\n**--[no-]relative-paths**: With prune, do not remove anything; just report what it would remove.\n**--[no-]track**: With add, make the new worktree and index empty, associating the worktree with a new unborn branch named <new-branch>.\n**--lock**: With list, output in an easy-to-parse format for scripts. This format will remain stable across Git versions and regardless of user configuration. It is recommended to combine this with -z. See below for details.\n**-n**: Terminate each line with a NUL rather than a newline when --porcelain is specified with list. This makes it possible to parse the output when a worktree path contains a newline character.\n**--dry-run**: With add, suppress feedback messages.\n**--orphan**: With prune, report all removals. With list, output additional information about worktrees (see below).\n**--porcelain**: With prune, only expire unused worktrees older than <time>. With list, annotate missing worktrees as prunable if they are older than <time>.\n**-z**: With lock or with add --lock, an explanation why the worktree is locked.\n**-q**: Worktrees can be identified by path, either relative or absolute. If the last path components in the worktree’s path is unique among worktrees, it can be used to identify a worktree. For example if you only have two worktrees, at /abc/def/ghi and /abc/def/ggg, then ghi or def/ghi is enough to point to the former worktree.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 24,
          "content_length": 7567
        }
      },
      {
        "header": "REFS",
        "content": "When using multiple worktrees, some refs are shared between all worktrees, but others are specific to an individual worktree. One example is HEAD, which is different for each worktree. This section is about the sharing rules and how to access refs of one worktree from another.\n\nIn general, all pseudo refs are per-worktree and all refs starting with refs/ are shared. Pseudo refs are ones like HEAD which are directly under $GIT_DIR instead of inside $GIT_DIR/refs. There are exceptions, however: refs inside refs/bisect, refs/worktree and refs/rewritten are not shared.\n\nRefs that are per-worktree can still be accessed from another worktree via two special paths, main-worktree and worktrees. The former gives access to per-worktree refs of the main worktree, while the latter to all linked worktrees.\n\nFor example, main-worktree/HEAD or main-worktree/refs/bisect/good resolve to the same value as the main worktree’s HEAD and refs/bisect/good respectively. Similarly, worktrees/foo/HEAD or worktrees/bar/refs/bisect/bad are the same as $GIT_COMMON_DIR/worktrees/foo/HEAD and $GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad.\n\nTo access refs, it’s best not to look inside $GIT_DIR directly. Instead use commands such as git-rev-parse[1] or git-update-ref[1] which will handle refs correctly.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1291
        }
      },
      {
        "header": "CONFIGURATION FILE",
        "content": "By default, the repository config file is shared across all worktrees. If the config variables core.bare or core.worktree are present in the common config file and extensions.worktreeConfig is disabled, then they will be applied to the main worktree only.\n\nIn order to have worktree-specific configuration, you can turn on the worktreeConfig extension, e.g.:\n\nIn this mode, specific configuration stays in the path pointed by git rev-parse --git-path config.worktree. You can add or update configuration in this file with git config --worktree. Older Git versions will refuse to access repositories with this extension.\n\nNote that in this file, the exception for core.bare and core.worktree is gone. If they exist in $GIT_DIR/config, you must move them to the config.worktree of the main worktree. You may also take this opportunity to review and move other configuration that you do not want to share to all worktrees:\n\ncore.worktree should never be shared.\n\ncore.bare should not be shared if the value is core.bare=true.\n\ncore.sparseCheckout should not be shared, unless you are sure you always use sparse checkout for all worktrees.\n\nSee the documentation of extensions.worktreeConfig in git-config[1] for more details.\n\n• core.worktree should never be shared.\n• core.bare should not be shared if the value is core.bare=true.\n• core.sparseCheckout should not be shared, unless you are sure you always use sparse checkout for all worktrees.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git config extensions.worktreeConfig true\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1442
        }
      },
      {
        "header": "DETAILS",
        "content": "Each linked worktree has a private sub-directory in the repository’s $GIT_DIR/worktrees directory. The private sub-directory’s name is usually the base name of the linked worktree’s path, possibly appended with a number to make it unique. For example, when $GIT_DIR=/path/main/.git the command git worktree add /path/other/test-next next creates the linked worktree in /path/other/test-next and also creates a $GIT_DIR/worktrees/test-next directory (or $GIT_DIR/worktrees/test-next1 if test-next is already taken).\n\nWithin a linked worktree, $GIT_DIR is set to point to this private directory (e.g. /path/main/.git/worktrees/test-next in the example) and $GIT_COMMON_DIR is set to point back to the main worktree’s $GIT_DIR (e.g. /path/main/.git). These settings are made in a .git file located at the top directory of the linked worktree.\n\nPath resolution via git rev-parse --git-path uses either $GIT_DIR or $GIT_COMMON_DIR depending on the path. For example, in the linked worktree git rev-parse --git-path HEAD returns /path/main/.git/worktrees/test-next/HEAD (not /path/other/test-next/.git/HEAD or /path/main/.git/HEAD) while git rev-parse --git-path refs/heads/master uses $GIT_COMMON_DIR and returns /path/main/.git/refs/heads/master, since refs are shared across all worktrees, except refs/bisect, refs/worktree and refs/rewritten.\n\nSee gitrepository-layout[5] for more information. The rule of thumb is do not make any assumption about whether a path belongs to $GIT_DIR or $GIT_COMMON_DIR when you need to directly access something inside $GIT_DIR. Use git rev-parse --git-path to get the final path.\n\nIf you manually move a linked worktree, you need to update the gitdir file in the entry’s directory. For example, if a linked worktree is moved to /newpath/test-next and its .git file points to /path/main/.git/worktrees/test-next, then update /path/main/.git/worktrees/test-next/gitdir to reference /newpath/test-next instead. Better yet, run git worktree repair to reestablish the connection automatically.\n\nTo prevent a $GIT_DIR/worktrees entry from being pruned (which can be useful in some situations, such as when the entry’s worktree is stored on a portable device), use the git worktree lock command, which adds a file named locked to the entry’s directory. The file contains the reason in plain text. For example, if a linked worktree’s .git file points to /path/main/.git/worktrees/test-next then a file named /path/main/.git/worktrees/test-next/locked will prevent the test-next entry from being pruned. See gitrepository-layout[5] for details.\n\nWhen extensions.worktreeConfig is enabled, the config file .git/worktrees/<id>/config.worktree is read after .git/config is.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 2693
        }
      },
      {
        "header": "LIST OUTPUT FORMAT",
        "content": "The worktree list command has two output formats. The default format shows the details on a single line with columns. For example:\n\nThe command also shows annotations for each worktree, according to its state. These annotations are:\n\nlocked, if the worktree is locked.\n\nprunable, if the worktree can be pruned via git worktree prune.\n\nFor these annotations, a reason might also be available and this can be seen using the verbose mode. The annotation is then moved to the next line indented followed by the additional information.\n\nNote that the annotation is moved to the next line if the additional information is available, otherwise it stays on the same line as the worktree itself.\n\n• locked, if the worktree is locked.\n• prunable, if the worktree can be pruned via git worktree prune.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git worktree list\n/path/to/bare-source            (bare)\n/path/to/linked-worktree        abcd1234 [master]\n/path/to/other-linked-worktree  1234abc  (detached HEAD)\n```",
          "```bash\n$ git worktree list\n/path/to/linked-worktree    abcd1234 [master]\n/path/to/locked-worktree    acbd5678 (brancha) locked\n/path/to/prunable-worktree  5678abc  (detached HEAD) prunable\n```",
          "```bash\n$ git worktree list --verbose\n/path/to/linked-worktree              abcd1234 [master]\n/path/to/locked-worktree-no-reason    abcd5678 (detached HEAD) locked\n/path/to/locked-worktree-with-reason  1234abcd (brancha)\n\tlocked: worktree path is mounted on a portable device\n/path/to/prunable-worktree            5678abc1 (detached HEAD)\n\tprunable: gitdir file points to non-existent location\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 790
        }
      },
      {
        "header": "Porcelain Format",
        "content": "The porcelain format has a line per attribute. If -z is given then the lines are terminated with NUL rather than a newline. Attributes are listed with a label and value separated by a single space. Boolean attributes (like bare and detached) are listed as a label only, and are present only if the value is true. Some attributes (like locked) can be listed as a label only or with a value depending upon whether a reason is available. The first attribute of a worktree is always worktree, an empty line indicates the end of the record. For example:\n\nUnless -z is used any \"unusual\" characters in the lock reason such as newlines are escaped and the entire reason is quoted as explained for the configuration variable core.quotePath (see git-config[1]). For Example:",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git worktree list --porcelain\nworktree /path/to/bare-source\nbare\n\nworktree /path/to/linked-worktree\nHEAD abcd1234abcd1234abcd1234abcd1234abcd1234\nbranch refs/heads/master\n\nworktree /path/to/other-linked-worktree\nHEAD 1234abc1234abc1234abc1234abc1234abc1234a\ndetached\n\nworktree /path/to/linked-worktree-locked-no-reason\nHEAD 5678abc5678abc5678abc5678abc5678abc5678c\nbranch refs/heads/locked-no-reason\nlocked\n\nworktree /path/to/linked-worktree-locked-with-reason\nHEAD 3456def3456def3456def3456def3456def3456b\nbranch refs/heads/locked-with-reason\nlocked reason why is locked\n\nworktree /path/to/linked-worktree-prunable\nHEAD 1233def1234def1234def1234def1234def1234b\ndetached\nprunable gitdir file points to non-existent location\n```",
          "```bash\n$ git worktree list --porcelain\n...\nlocked \"reason\\nwhy is locked\"\n...\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 765
        }
      },
      {
        "header": "EXAMPLES",
        "content": "You are in the middle of a refactoring session and your boss comes in and demands that you fix something immediately. You might typically use git-stash[1] to store your changes away temporarily, however, your working tree is in such a state of disarray (with new, moved, and removed files, and other bits and pieces strewn around) that you don’t want to risk disturbing any of it. Instead, you create a temporary linked worktree to make the emergency fix, remove it when done, and then resume your earlier refactoring session.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git worktree add -b emergency-fix ../temp master\n$ pushd ../temp\n# ... hack hack hack ...\n$ git commit -a -m 'emergency fix for boss'\n$ popd\n$ git worktree remove ../temp\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 526
        }
      },
      {
        "header": "BUGS",
        "content": "Multiple checkout in general is still experimental, and the support for submodules is incomplete. It is NOT recommended to make multiple checkouts of a superproject.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 165
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-worktree",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Git",
    "summary": "NAME git-cat-file - Provide contents or details of repository objects\n\ngit-cat-file - Provide contents or details of repository objects",
    "sections": [
      {
        "header": "NAME",
        "content": "git-cat-file - Provide contents or details of repository objects",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 64
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Output the contents or other properties such as size, type or delta information of one or more objects.\n\nThis command can operate in two modes, depending on whether an option from the --batch family is specified.\n\nIn non-batch mode, the command provides information on an object named on the command line.\n\nIn batch mode, arguments are read from standard input.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 361
        }
      },
      {
        "header": "OPTIONS",
        "content": "The name of the object to show. For a more complete list of ways to spell object names, see the \"SPECIFYING REVISIONS\" section in gitrevisions[7].\n\nInstead of the content, show the object type identified by <object>.\n\nInstead of the content, show the object size identified by <object>. If used with --use-mailmap option, will show the size of updated object after replacing idents using the mailmap mechanism.\n\nExit with zero status if <object> exists and is a valid object. If <object> is of an invalid format, exit with non-zero status and emit an error on stderr.\n\nPretty-print the contents of <object> based on its type.\n\nTypically this matches the real type of <object> but asking for a type that can trivially be dereferenced from the given <object> is also permitted. An example is to ask for a \"tree\" with <object> being a commit object that contains it, or to ask for a \"blob\" with <object> being a tag object that points at it.\n\nUse mailmap file to map author, committer and tagger names and email addresses to canonical real names and email addresses. See git-shortlog[1].\n\nShow the content as transformed by a textconv filter. In this case, <object> has to be of the form <tree-ish>:<path>, or :<path> in order to apply the filter to the content recorded in the index at <path>.\n\nShow the content as converted by the filters configured in the current working tree for the given <path> (i.e. smudge filters, end-of-line conversion, etc). In this case, <object> has to be of the form <tree-ish>:<path>, or :<path>.\n\nOmit objects from the list of printed objects. This can only be used in combination with one of the batched modes. Excluded objects that have been explicitly requested via any of the batch modes that read objects via standard input (--batch, --batch-check) will be reported as \"filtered\". Excluded objects in --batch-all-objects mode will not be printed at all. The <filter-spec> may be one of the following:\n\nThe form --filter=blob:none omits all blobs.\n\nThe form --filter=blob:limit=<n>[kmg] omits blobs of size at least n bytes or units. n may be zero. The suffixes k, m, and g can be used to name units in KiB, MiB, or GiB. For example, blob:limit=1k is the same as blob:limit=1024.\n\nThe form --filter=object:type=(tag|commit|tree|blob) omits all objects which are not of the requested type.\n\nFor use with --textconv or --filters, to allow specifying an object name and a path separately, e.g. when it is difficult to figure out the revision from which the blob came.\n\nPrint object information and contents for each object provided on stdin. May not be combined with any other options or arguments except --textconv, --filters, or --use-mailmap.\n\nWhen used with --textconv or --filters, the input lines must specify the path, separated by whitespace. See the section BATCH OUTPUT below for details.\n\nWhen used with --use-mailmap, for commit and tag objects, the contents part of the output shows the identities replaced using the mailmap mechanism, while the information part of the output shows the size of the object as if it actually recorded the replacement identities.\n\nPrint object information for each object provided on stdin. May not be combined with any other options or arguments except --textconv, --filters or --use-mailmap.\n\nWhen used with --textconv or --filters, the input lines must specify the path, separated by whitespace. See the section BATCH OUTPUT below for details.\n\nWhen used with --use-mailmap, for commit and tag objects, the printed object information shows the size of the object as if the identities recorded in it were replaced by the mailmap mechanism.\n\nEnter a command mode that reads commands and arguments from stdin. May only be combined with --buffer, --textconv, --use-mailmap or --filters.\n\nWhen used with --textconv or --filters, the input lines must specify the path, separated by whitespace. See the section BATCH OUTPUT below for details.\n\nWhen used with --use-mailmap, for commit and tag objects, the contents command shows the identities replaced using the mailmap mechanism, while the info command shows the size of the object as if it actually recorded the replacement identities.\n\n--batch-command recognizes the following commands:\n\nPrint object contents for object reference <object>. This corresponds to the output of --batch.\n\nPrint object info for object reference <object>. This corresponds to the output of --batch-check.\n\nUsed with --buffer to execute all preceding commands that were issued since the beginning or since the last flush was issued. When --buffer is used, no output will come until a flush is issued. When --buffer is not used, commands are flushed each time without issuing flush.\n\nInstead of reading a list of objects on stdin, perform the requested batch operation on all objects in the repository and any alternate object stores (not just reachable objects). Requires --batch or --batch-check be specified. By default, the objects are visited in order sorted by their hashes; see also --unordered below. Objects are presented as-is, without respecting the \"replace\" mechanism of git-replace[1].\n\nNormally batch output is flushed after each object is output, so that a process can interactively read and write from cat-file. With this option, the output uses normal stdio buffering; this is much more efficient when invoking --batch-check or --batch-command on a large number of objects.\n\nWhen --batch-all-objects is in use, visit objects in an order which may be more efficient for accessing the object contents than hash order. The exact details of the order are unspecified, but if you do not require a specific order, this should generally result in faster output, especially with --batch. Note that cat-file will still show each object only once, even if it is stored multiple times in the repository.\n\nWith --batch or --batch-check, follow symlinks inside the repository when requesting objects with extended SHA-1 expressions of the form tree-ish:path-in-tree. Instead of providing output about the link itself, provide output about the linked-to object. If a symlink points outside the tree-ish (e.g. a link to /foo or a root-level link to ../foo), the portion of the link which is outside the tree will be printed.\n\nThis option does not (currently) work correctly when an object in the index is specified (e.g. :link instead of HEAD:link) rather than one in the tree.\n\nThis option cannot (currently) be used unless --batch or --batch-check is used.\n\nFor example, consider a git repository containing:\n\nFor a regular file f, echo HEAD:f | git cat-file --batch would print\n\nAnd echo HEAD:link | git cat-file --batch --follow-symlinks would print the same thing, as would HEAD:dir/link, as they both point at HEAD:f.\n\nWithout --follow-symlinks, these would print data about the symlink itself. In the case of HEAD:link, you would see\n\nBoth plink and alink point outside the tree, so they would respectively print:\n\nOnly meaningful with --batch, --batch-check, or --batch-command; input and output is NUL-delimited instead of newline-delimited.\n\nOnly meaningful with --batch, --batch-check, or --batch-command; input is NUL-delimited instead of newline-delimited. This option is deprecated in favor of -Z as the output can otherwise be ambiguous.\n\n• When used with --textconv or --filters, the input lines must specify the path, separated by whitespace. See the section BATCH OUTPUT below for details.\n• When used with --use-mailmap, for commit and tag objects, the contents part of the output shows the identities replaced using the mailmap mechanism, while the information part of the output shows the size of the object as if it actually recorded the replacement identities.\n\n• When used with --textconv or --filters, the input lines must specify the path, separated by whitespace. See the section BATCH OUTPUT below for details.\n• When used with --use-mailmap, for commit and tag objects, the printed object information shows the size of the object as if the identities recorded in it were replaced by the mailmap mechanism.\n\n• When used with --textconv or --filters, the input lines must specify the path, separated by whitespace. See the section BATCH OUTPUT below for details.\n• When used with --use-mailmap, for commit and tag objects, the contents command shows the identities replaced using the mailmap mechanism, while the info command shows the size of the object as if it actually recorded the replacement identities.\n\n**<object>**: The name of the object to show. For a more complete list of ways to spell object names, see the \"SPECIFYING REVISIONS\" section in gitrevisions[7].\n**-t**: Instead of the content, show the object type identified by <object>.\n**-s**: Instead of the content, show the object size identified by <object>. If used with --use-mailmap option, will show the size of updated object after replacing idents using the mailmap mechanism.\n**-e**: Exit with zero status if <object> exists and is a valid object. If <object> is of an invalid format, exit with non-zero status and emit an error on stderr.\n**-p**: Pretty-print the contents of <object> based on its type.\n**<type>**: Typically this matches the real type of <object> but asking for a type that can trivially be dereferenced from the given <object> is also permitted. An example is to ask for a \"tree\" with <object> being a commit object that contains it, or to ask for a \"blob\" with <object> being a tag object that points at it.\n**--[no-]mailmap**: Use mailmap file to map author, committer and tagger names and email addresses to canonical real names and email addresses. See git-shortlog[1].\n**--[no-]use-mailmap**: Show the content as transformed by a textconv filter. In this case, <object> has to be of the form <tree-ish>:<path>, or :<path> in order to apply the filter to the content recorded in the index at <path>.\n**--textconv**: Show the content as converted by the filters configured in the current working tree for the given <path> (i.e. smudge filters, end-of-line conversion, etc). In this case, <object> has to be of the form <tree-ish>:<path>, or :<path>.\n**--filters**: Omit objects from the list of printed objects. This can only be used in combination with one of the batched modes. Excluded objects that have been explicitly requested via any of the batch modes that read objects via standard input (--batch, --batch-check) will be reported as \"filtered\". Excluded objects in --batch-all-objects mode will not be printed at all. The <filter-spec> may be one of the following: The form --filter=blob:none omits all blobs. The form --filter=blob:limit=<n>[kmg] omits blobs of size at least n bytes or units. n may be zero. The suffixes k, m, and g can be used to name units in KiB, MiB, or GiB. For example, blob:limit=1k is the same as blob:limit=1024. The form --filter=object:type=(tag|commit|tree|blob) omits all objects which are not of the requested type.\n**--filter=<filter-spec>**: For use with --textconv or --filters, to allow specifying an object name and a path separately, e.g. when it is difficult to figure out the revision from which the blob came.\n**--no-filter**: Print object information and contents for each object provided on stdin. May not be combined with any other options or arguments except --textconv, --filters, or --use-mailmap. When used with --textconv or --filters, the input lines must specify the path, separated by whitespace. See the section BATCH OUTPUT below for details. When used with --use-mailmap, for commit and tag objects, the contents part of the output shows the identities replaced using the mailmap mechanism, while the information part of the output shows the size of the object as if it actually recorded the replacement identities.\n**--path=<path>**: Print object information for each object provided on stdin. May not be combined with any other options or arguments except --textconv, --filters or --use-mailmap. When used with --textconv or --filters, the input lines must specify the path, separated by whitespace. See the section BATCH OUTPUT below for details. When used with --use-mailmap, for commit and tag objects, the printed object information shows the size of the object as if the identities recorded in it were replaced by the mailmap mechanism.\n**--batch**: Enter a command mode that reads commands and arguments from stdin. May only be combined with --buffer, --textconv, --use-mailmap or --filters. When used with --textconv or --filters, the input lines must specify the path, separated by whitespace. See the section BATCH OUTPUT below for details. When used with --use-mailmap, for commit and tag objects, the contents command shows the identities replaced using the mailmap mechanism, while the info command shows the size of the object as if it actually recorded the replacement identities. --batch-command recognizes the following commands: contents <object> Print object contents for object reference <object>. This corresponds to the output of --batch. info <object> Print object info for object reference <object>. This corresponds to the output of --batch-check. flush Used with --buffer to execute all preceding commands that were issued since the beginning or since the last flush was issued. When --buffer is used, no output will come until a flush is issued. When --buffer is not used, commands are flushed each time without issuing flush.\n**--batch=<format>**: Print object contents for object reference <object>. This corresponds to the output of --batch.\n**--batch-check**: Print object info for object reference <object>. This corresponds to the output of --batch-check.\n**--batch-check=<format>**: Used with --buffer to execute all preceding commands that were issued since the beginning or since the last flush was issued. When --buffer is used, no output will come until a flush is issued. When --buffer is not used, commands are flushed each time without issuing flush.\n**--batch-command**: Instead of reading a list of objects on stdin, perform the requested batch operation on all objects in the repository and any alternate object stores (not just reachable objects). Requires --batch or --batch-check be specified. By default, the objects are visited in order sorted by their hashes; see also --unordered below. Objects are presented as-is, without respecting the \"replace\" mechanism of git-replace[1].\n**--batch-command=<format>**: Normally batch output is flushed after each object is output, so that a process can interactively read and write from cat-file. With this option, the output uses normal stdio buffering; this is much more efficient when invoking --batch-check or --batch-command on a large number of objects.\n**contents <object>**: When --batch-all-objects is in use, visit objects in an order which may be more efficient for accessing the object contents than hash order. The exact details of the order are unspecified, but if you do not require a specific order, this should generally result in faster output, especially with --batch. Note that cat-file will still show each object only once, even if it is stored multiple times in the repository.\n**info <object>**: With --batch or --batch-check, follow symlinks inside the repository when requesting objects with extended SHA-1 expressions of the form tree-ish:path-in-tree. Instead of providing output about the link itself, provide output about the linked-to object. If a symlink points outside the tree-ish (e.g. a link to /foo or a root-level link to ../foo), the portion of the link which is outside the tree will be printed. This option does not (currently) work correctly when an object in the index is specified (e.g. :link instead of HEAD:link) rather than one in the tree. This option cannot (currently) be used unless --batch or --batch-check is used. For example, consider a git repository containing: f: a file containing \"hello\\n\" link: a symlink to f dir/link: a symlink to ../f plink: a symlink to ../f alink: a symlink to /etc/passwd For a regular file f, echo HEAD:f | git cat-file --batch would print ce013625030ba8dba906f756967f9e9ca394464a blob 6 And echo HEAD:link | git cat-file --batch --follow-symlinks would print the same thing, as would HEAD:dir/link, as they both point at HEAD:f. Without --follow-symlinks, these would print data about the symlink itself. In the case of HEAD:link, you would see 4d1ae35ba2c8ec712fa2a379db44ad639ca277bd blob 1 Both plink and alink point outside the tree, so they would respectively print: symlink 4 ../f symlink 11 /etc/passwd\n**flush**: Only meaningful with --batch, --batch-check, or --batch-command; input and output is NUL-delimited instead of newline-delimited.\n**--batch-all-objects**: Only meaningful with --batch, --batch-check, or --batch-command; input is NUL-delimited instead of newline-delimited. This option is deprecated in favor of -Z as the output can otherwise be ambiguous.\n**contents <object>**: Print object contents for object reference <object>. This corresponds to the output of --batch.\n**info <object>**: Print object info for object reference <object>. This corresponds to the output of --batch-check.\n**flush**: Used with --buffer to execute all preceding commands that were issued since the beginning or since the last flush was issued. When --buffer is used, no output will come until a flush is issued. When --buffer is not used, commands are flushed each time without issuing flush.",
        "code_examples": [
          "```bash\nf: a file containing \"hello\\n\"\nlink: a symlink to f\ndir/link: a symlink to ../f\nplink: a symlink to ../f\nalink: a symlink to /etc/passwd\n```",
          "```bash\nce013625030ba8dba906f756967f9e9ca394464a blob 6\n```",
          "```bash\n4d1ae35ba2c8ec712fa2a379db44ad639ca277bd blob 1\n```",
          "```bash\nsymlink 4\n../f\n```",
          "```bash\nsymlink 11\n/etc/passwd\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 40,
          "content_length": 17367
        }
      },
      {
        "header": "OUTPUT",
        "content": "If -t is specified, one of the <type>.\n\nIf -s is specified, the size of the <object> in bytes.\n\nIf -e is specified, no output, unless the <object> is malformed.\n\nIf -p is specified, the contents of <object> are pretty-printed.\n\nIf <type> is specified, the raw (though uncompressed) contents of the <object> will be returned.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 324
        }
      },
      {
        "header": "BATCH OUTPUT",
        "content": "If --batch or --batch-check is given, cat-file will read objects from stdin, one per line, and print information about them in the same order as they have been read. By default, the whole line is considered as an object, as if it were fed to git-rev-parse[1].\n\nWhen --batch-command is given, cat-file will read commands from stdin, one per line, and print information based on the command given. With --batch-command, the info command followed by an object will print information about the object the same way --batch-check would, and the contents command followed by an object prints contents in the same way --batch would.\n\nYou can specify the information shown for each object by using a custom <format>. The <format> is copied literally to stdout for each object, with placeholders of the form %(atom) expanded, followed by a newline. The available atoms are:\n\nThe full hex representation of the object name.\n\nThe type of the object (the same as cat-file -t reports).\n\nIf the specified object has mode information (such as a tree or index entry), the mode expressed as an octal integer. Otherwise, empty string.\n\nThe size, in bytes, of the object (the same as cat-file -s reports).\n\nThe size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the CAVEATS section below.\n\nIf the object is stored as a delta on-disk, this expands to the full hex representation of the delta base object name. Otherwise, expands to the null OID (all zeroes). See CAVEATS below.\n\nIf this atom is used in the output string, input lines are split at the first whitespace boundary. All characters before that whitespace are considered to be the object name; characters after that first run of whitespace (i.e., the \"rest\" of the line) are output in place of the %(rest) atom.\n\nIf no format is specified, the default format is %(objectname) %(objecttype) %(objectsize).\n\nIf --batch is specified, or if --batch-command is used with the contents command, the object information is followed by the object contents (consisting of %(objectsize) bytes), followed by a newline.\n\nFor example, --batch without a custom format would produce:\n\nWhereas --batch-check='%(objectname) %(objecttype) would produce:\n\nIf a name is specified on stdin that cannot be resolved to an object in the repository, then cat-file will ignore any custom format and print:\n\nIf a name is specified on stdin that is filtered out via --filter=, then cat-file will ignore any custom format and print:\n\nIf a name is specified that might refer to more than one object (an ambiguous short sha), then cat-file will ignore any custom format and print:\n\nIf a name is specified that refers to a submodule entry in a tree and the target object does not exist in the repository, then cat-file will ignore any custom format and print (with the object ID of the submodule):\n\nIf --follow-symlinks is used, and a symlink in the repository points outside the repository, then cat-file will ignore any custom format and print:\n\nThe symlink will either be absolute (beginning with a /), or relative to the tree root. For instance, if dir/link points to ../../foo, then <symlink> will be ../foo. <size> is the size of the symlink in bytes.\n\nIf --follow-symlinks is used, the following error messages will be displayed:\n\nis printed when the initial symlink requested does not exist.\n\nis printed when the initial symlink exists, but something that it (transitive-of) points to does not.\n\nis printed for symlink loops (or any symlinks that require more than 40 link resolutions to resolve).\n\nis printed when, during symlink resolution, a file is used as a directory name.\n\nAlternatively, when -Z is passed, the line feeds in any of the above examples are replaced with NUL terminators. This ensures that output will be parsable if the output itself would contain a linefeed and is thus recommended for scripting purposes.\n\n**objectname**: The full hex representation of the object name.\n**objecttype**: The type of the object (the same as cat-file -t reports).\n**objectmode**: If the specified object has mode information (such as a tree or index entry), the mode expressed as an octal integer. Otherwise, empty string.\n**objectsize**: The size, in bytes, of the object (the same as cat-file -s reports).\n**objectsize:disk**: The size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the CAVEATS section below.\n**deltabase**: If the object is stored as a delta on-disk, this expands to the full hex representation of the delta base object name. Otherwise, expands to the null OID (all zeroes). See CAVEATS below.\n**rest**: If this atom is used in the output string, input lines are split at the first whitespace boundary. All characters before that whitespace are considered to be the object name; characters after that first run of whitespace (i.e., the \"rest\" of the line) are output in place of the %(rest) atom.",
        "code_examples": [
          "```bash\n<oid> SP <type> SP <size> LF\n<contents> LF\n```",
          "```bash\n<oid> SP <type> LF\n```",
          "```bash\n<object>SP missing LF\n```",
          "```bash\n<object>SP excluded LF\n```",
          "```bash\n<object>SP ambiguous LF\n```",
          "```bash\n<oid> SP submodule LF\n```",
          "```bash\nsymlink SP <size> LF\n<symlink> LF\n```",
          "```bash\n<object>SP missing LF\n```",
          "```bash\ndangling SP <size> LF<object>LF\n```",
          "```bash\nloop SP <size> LF<object>LF\n```",
          "```bash\nnotdir SP <size> LF<object>LF\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 26,
          "content_length": 4902
        }
      },
      {
        "header": "CAVEATS",
        "content": "Note that the sizes of objects on disk are reported accurately, but care should be taken in drawing conclusions about which refs or objects are responsible for disk usage. The size of a packed non-delta object may be much larger than the size of objects which delta against it, but the choice of which object is the base and which is the delta is arbitrary and is subject to change during a repack.\n\nNote also that multiple copies of an object may be present in the object database; in this case, it is undefined which copy’s size or delta base will be reported.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 562
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-cat-file",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "Git",
    "summary": "NAME git-check-ignore - Debug gitignore / exclude files\n\nSYNOPSIS git check-ignore [<options>] <pathname>… git check-ignore [<options>] --stdin",
    "sections": [
      {
        "header": "NAME",
        "content": "git-check-ignore - Debug gitignore / exclude files",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 50
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "For each pathname given via the command-line or from a file via --stdin, check whether the file is excluded by .gitignore (or other input files to the exclude mechanism) and output the path if it is excluded.\n\nBy default, tracked files are not shown at all since they are not subject to exclude rules; but see ‘--no-index’.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 323
        }
      },
      {
        "header": "OPTIONS",
        "content": "Don’t output anything, just set exit status. This is only valid with a single pathname.\n\nInstead of printing the paths that are excluded, for each path that matches an exclude pattern, print the exclude pattern together with the path. (Matching an exclude pattern usually means the path is excluded, but if the pattern begins with \"!\" then it is a negated pattern and matching it means the path is NOT excluded.)\n\nFor precedence rules within and between exclude sources, see gitignore[5].\n\nRead pathnames from the standard input, one per line, instead of from the command-line.\n\nThe output format is modified to be machine-parsable (see below). If --stdin is also given, input paths are separated with a NUL character instead of a linefeed character.\n\nShow given paths which don’t match any pattern. This only makes sense when --verbose is enabled, otherwise it would not be possible to distinguish between paths which match a pattern and those which don’t.\n\nDon’t look in the index when undertaking the checks. This can be used to debug why a path became tracked by e.g. git add . and was not ignored by the rules as expected by the user or when developing patterns including negation to match a path previously added with git add -f.\n\n**-q, --quiet**: Don’t output anything, just set exit status. This is only valid with a single pathname.\n**-v, --verbose**: Instead of printing the paths that are excluded, for each path that matches an exclude pattern, print the exclude pattern together with the path. (Matching an exclude pattern usually means the path is excluded, but if the pattern begins with \"!\" then it is a negated pattern and matching it means the path is NOT excluded.) For precedence rules within and between exclude sources, see gitignore[5].\n**--stdin**: Read pathnames from the standard input, one per line, instead of from the command-line.\n**-z**: The output format is modified to be machine-parsable (see below). If --stdin is also given, input paths are separated with a NUL character instead of a linefeed character.\n**-n, --non-matching**: Show given paths which don’t match any pattern. This only makes sense when --verbose is enabled, otherwise it would not be possible to distinguish between paths which match a pattern and those which don’t.\n**--no-index**: Don’t look in the index when undertaking the checks. This can be used to debug why a path became tracked by e.g. git add . and was not ignored by the rules as expected by the user or when developing patterns including negation to match a path previously added with git add -f.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 2563
        }
      },
      {
        "header": "OUTPUT",
        "content": "By default, any of the given pathnames which match an ignore pattern will be output, one per line. If no pattern matches a given path, nothing will be output for that path; this means that path will not be ignored.\n\nIf --verbose is specified, the output is a series of lines of the form:\n\n<source> <COLON> <linenum> <COLON> <pattern> <HT> <pathname>\n\n<pathname> is the path of a file being queried, <pattern> is the matching pattern, <source> is the pattern’s source file, and <linenum> is the line number of the pattern within that source. If the pattern contained a \"!\" prefix or \"/\" suffix, it will be preserved in the output. <source> will be an absolute path when referring to the file configured by core.excludesFile, or relative to the repository root when referring to .git/info/exclude or a per-directory exclude file.\n\nIf -z is specified, the pathnames in the output are delimited by the null character; if --verbose is also specified then null characters are also used instead of colons and hard tabs:\n\n<source> <NULL> <linenum> <NULL> <pattern> <NULL> <pathname> <NULL>\n\nIf -n or --non-matching are specified, non-matching pathnames will also be output, in which case all fields in each output record except for <pathname> will be empty. This can be useful when running non-interactively, so that files can be incrementally streamed to STDIN of a long-running check-ignore process, and for each of these files, STDOUT will indicate whether that file matched a pattern or not. (Without this option, it would be impossible to tell whether the absence of output for a given file meant that it didn’t match any pattern, or that the output hadn’t been generated yet.)\n\nBuffering happens as documented under the GIT_FLUSH option in git[1]. The caller is responsible for avoiding deadlocks caused by overfilling an input buffer or reading from an empty output buffer.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1872
        }
      },
      {
        "header": "EXIT STATUS",
        "content": "One or more of the provided paths is ignored.\n\nNone of the provided paths are ignored.\n\nA fatal error was encountered.\n\n**0**: One or more of the provided paths is ignored.\n**1**: None of the provided paths are ignored.\n**128**: A fatal error was encountered.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 259
        }
      },
      {
        "header": "SEE ALSO",
        "content": "gitignore[5] git-config[1] git-ls-files[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 42
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-check-ignore",
    "doc_type": "git",
    "total_sections": 7
  },
  {
    "title": "Git",
    "summary": "NAME git-checkout-index - Copy files from the index to the working tree\n\ngit-checkout-index - Copy files from the index to the working tree",
    "sections": [
      {
        "header": "NAME",
        "content": "git-checkout-index - Copy files from the index to the working tree",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 66
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Copies all listed files from the index to the working directory (not overwriting existing files).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 97
        }
      },
      {
        "header": "OPTIONS",
        "content": "update stat information for the checked out entries in the index file.\n\nbe quiet if files exist or are not in the index\n\nforces overwrite of existing files\n\nchecks out all files in the index except for those with the skip-worktree bit set (see --ignore-skip-worktree-bits). Cannot be used together with explicit filenames.\n\nDon’t checkout new files, only refresh files already checked out.\n\nWhen creating files, prepend <string> (usually a directory including a trailing /)\n\nInstead of checking out unmerged entries, copy out the files from the named stage. <number> must be between 1 and 3. Note: --stage=all automatically implies --temp.\n\nInstead of copying the files to the working directory, write the content to temporary files. The temporary name associations will be written to stdout.\n\nCheck out all files, including those with the skip-worktree bit set.\n\nInstead of taking a list of paths from the command line, read the list of paths from the standard input. Paths are separated by LF (i.e. one path per line) by default.\n\nOnly meaningful with --stdin; paths are separated with NUL character instead of LF.\n\nDo not interpret any more arguments as options.\n\nThe order of the flags used to matter, but not anymore.\n\nJust doing git checkout-index does nothing. You probably meant git checkout-index -a. And if you want to force it, you want git checkout-index -f -a.\n\nIntuitiveness is not the goal here. Repeatability is. The reason for the \"no arguments means no work\" behavior is that from scripts you are supposed to be able to do:\n\nwhich will force all existing *.h files to be replaced with their cached copies. If an empty command line implied \"all\", then this would force-refresh everything in the index, which was not the point. But since git checkout-index accepts --stdin it would be faster to use:\n\nThe -- is just a good idea when you know the rest will be filenames; it will prevent problems with a filename of, for example, -a. Using -- is probably a good policy in scripts.\n\n**-u**: update stat information for the checked out entries in the index file.\n**--index**: be quiet if files exist or are not in the index\n**-q**: forces overwrite of existing files\n**--quiet**: checks out all files in the index except for those with the skip-worktree bit set (see --ignore-skip-worktree-bits). Cannot be used together with explicit filenames.\n**-f**: Don’t checkout new files, only refresh files already checked out.\n**--force**: When creating files, prepend <string> (usually a directory including a trailing /)\n**-a**: Instead of checking out unmerged entries, copy out the files from the named stage. <number> must be between 1 and 3. Note: --stage=all automatically implies --temp.\n**--all**: Instead of copying the files to the working directory, write the content to temporary files. The temporary name associations will be written to stdout.\n**-n**: Check out all files, including those with the skip-worktree bit set.\n**--no-create**: Instead of taking a list of paths from the command line, read the list of paths from the standard input. Paths are separated by LF (i.e. one path per line) by default.\n**--prefix=<string>**: Only meaningful with --stdin; paths are separated with NUL character instead of LF.\n**--stage=<number>|all**: Do not interpret any more arguments as options.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ find . -name '*.h' -print0 | xargs -0 git checkout-index -f --\n```",
          "```bash\n$ find . -name '*.h' -print0 | git checkout-index -f -z --stdin\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 17,
          "content_length": 3306
        }
      },
      {
        "header": "Using --temp or --stage=all",
        "content": "When --temp is used (or implied by --stage=all) git checkout-index will create a temporary file for each index entry being checked out. The index will not be updated with stat information. These options can be useful if the caller needs all stages of all unmerged entries so that the unmerged files can be processed by an external merge tool.\n\nA listing will be written to stdout providing the association of temporary file names to tracked path names. The listing format has two variations:\n\ntempname TAB path RS\n\nThe first format is what gets used when --stage is omitted or is not --stage=all. The field tempname is the temporary file name holding the file content and path is the tracked path name in the index. Only the requested entries are output.\n\nstage1temp SP stage2temp SP stage3tmp TAB path RS\n\nThe second format is what gets used when --stage=all. The three stage temporary fields (stage1temp, stage2temp, stage3temp) list the name of the temporary file if there is a stage entry in the index or . if there is no stage entry. Paths which only have a stage 0 entry will always be omitted from the output.\n\nIn both formats RS (the record separator) is newline by default but will be the null byte if -z was passed on the command line. The temporary file names are always safe strings; they will never contain directory separators or whitespace characters. The path field is always relative to the current directory and the temporary file names are always relative to the top level directory.\n\nIf the object being copied out to a temporary file is a symbolic link the content of the link will be written to a normal file. It is up to the end-user or the Porcelain to make use of this information.\n\n• tempname TAB path RS The first format is what gets used when --stage is omitted or is not --stage=all. The field tempname is the temporary file name holding the file content and path is the tracked path name in the index. Only the requested entries are output.\n• stage1temp SP stage2temp SP stage3tmp TAB path RS The second format is what gets used when --stage=all. The three stage temporary fields (stage1temp, stage2temp, stage3temp) list the name of the temporary file if there is a stage entry in the index or . if there is no stage entry. Paths which only have a stage 0 entry will always be omitted from the output.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 2332
        }
      },
      {
        "header": "EXAMPLES",
        "content": "The prefix ability basically makes it trivial to use git checkout-index as an \"export as tree\" function. Just read the desired tree into the index, and do:\n\ngit checkout-index will \"export\" the index into the specified directory.\n\nThe final \"/\" is important. The exported name is literally just prefixed with the specified string. Contrast this with the following example.\n\nThis will check out the currently cached copy of Makefile into the file .merged-Makefile.\n\n**To update and refresh only the files already checked out**: $ git checkout-index -n -f -a && git update-index --ignore-missing --refresh\n**Using git checkout-index to \"export an entire tree\"**: The prefix ability basically makes it trivial to use git checkout-index as an \"export as tree\" function. Just read the desired tree into the index, and do: $ git checkout-index --prefix=git-export-dir/ -a git checkout-index will \"export\" the index into the specified directory. The final \"/\" is important. The exported name is literally just prefixed with the specified string. Contrast this with the following example.\n**Export files with a prefix**: $ git checkout-index --prefix=.merged- Makefile This will check out the currently cached copy of Makefile into the file .merged-Makefile.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git checkout-index -n -f -a && git update-index --ignore-missing --refresh\n```",
          "```bash\n$ git checkout-index --prefix=git-export-dir/ -a\n```",
          "```bash\n$ git checkout-index --prefix=.merged- Makefile\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1250
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-checkout-index",
    "doc_type": "git",
    "total_sections": 6
  },
  {
    "title": "Git",
    "summary": "SYNOPSIS git commit-tree <tree> [(-p <parent>)…] git commit-tree [(-p <parent>)…] [-S[<keyid>]] [(-m <message>)…] [(-F <file>)…] <tree>",
    "sections": [
      {
        "header": "NAME",
        "content": "git-commit-tree - Create a new commit object",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 44
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "This is usually not what an end user wants to run directly. See git-commit[1] instead.\n\nCreates a new commit object based on the provided tree object and emits the new commit object id on stdout. The log message is read from the standard input, unless -m or -F options are given.\n\nThe -m and -F options can be given any number of times, in any order. The commit log message will be composed in the order in which the options are given.\n\nA commit object may have any number of parents. With exactly one parent, it is an ordinary commit. Having more than one parent makes the commit a merge between several lines of history. Initial (root) commits have no parents.\n\nWhile a tree represents a particular directory state of a working directory, a commit represents that state in \"time\", and explains how to get there.\n\nNormally a commit would identify a new \"HEAD\" state, and while Git doesn’t care where you save the note about that state, in practice we tend to just write the result to the file that is pointed at by .git/HEAD, so that we can always see what the last committed state was.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1087
        }
      },
      {
        "header": "OPTIONS",
        "content": "An existing tree object.\n\nEach -p indicates the id of a parent commit object.\n\nA paragraph in the commit log message. This can be given more than once and each <message> becomes its own paragraph.\n\nRead the commit log message from the given file. Use - to read from the standard input. This can be given more than once and the content of each file becomes its own paragraph.\n\nGPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand a --gpg-sign option given earlier on the command line.\n\n**<tree>**: An existing tree object.\n**-p <parent>**: Each -p indicates the id of a parent commit object.\n**-m <message>**: A paragraph in the commit log message. This can be given more than once and each <message> becomes its own paragraph.\n**-F <file>**: Read the commit log message from the given file. Use - to read from the standard input. This can be given more than once and the content of each file becomes its own paragraph.\n**-S[<keyid>]**: GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand a --gpg-sign option given earlier on the command line.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1317
        }
      },
      {
        "header": "Commit Information",
        "content": "A commit encapsulates:\n\nall parent object ids\n\nauthor name, email and date\n\ncommitter name and email and the commit time.\n\nA commit comment is read from stdin. If a changelog entry is not provided via \"<\" redirection, git commit-tree will just wait for one to be entered and terminated with ^D.\n\n• all parent object ids\n• author name, email and date\n• committer name and email and the commit time.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 397
        }
      },
      {
        "header": "DATE FORMATS",
        "content": "The GIT_AUTHOR_DATE and GIT_COMMITTER_DATE environment variables support the following date formats:\n\nIt is <unix-timestamp> <time-zone-offset>, where <unix-timestamp> is the number of seconds since the UNIX epoch. <time-zone-offset> is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is +0100.\n\nThe standard date format as described by RFC 2822, for example Thu, 07 Apr 2005 22:13:13 +0200.\n\nTime and date specified by the ISO 8601 standard, for example 2005-04-07T22:13:13. The parser accepts a space instead of the T character as well. Fractional parts of a second will be ignored, for example 2005-04-07T22:13:13.019 will be treated as 2005-04-07T22:13:13.\n\n**Git internal format**: It is <unix-timestamp> <time-zone-offset>, where <unix-timestamp> is the number of seconds since the UNIX epoch. <time-zone-offset> is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is +0100.\n**RFC 2822**: The standard date format as described by RFC 2822, for example Thu, 07 Apr 2005 22:13:13 +0200.\n**ISO 8601**: Time and date specified by the ISO 8601 standard, for example 2005-04-07T22:13:13. The parser accepts a space instead of the T character as well. Fractional parts of a second will be ignored, for example 2005-04-07T22:13:13.019 will be treated as 2005-04-07T22:13:13. Note In addition, the date part is accepted in the following formats: YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY.\n\nNote | In addition, the date part is accepted in the following formats: YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY.\n\n[Note] Note In addition, the date part is accepted in the following formats: YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": true,
          "paragraph_count": 4,
          "content_length": 1687
        }
      },
      {
        "header": "Discussion",
        "content": "Git is to some extent character encoding agnostic.\n\nThe contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the core level.\n\nPath names are encoded in UTF-8 normalization form C. This applies to tree objects, the index file, ref names, as well as path names in command line arguments, environment variables and config files (.git/config (see git-config[1]), gitignore[5], gitattributes[5] and gitmodules[5]).\n\nNote that Git at the core level treats path names simply as sequences of non-NUL bytes, there are no path name encoding conversions (except on Mac and Windows). Therefore, using non-ASCII path names will mostly work even on platforms and file systems that use legacy extended ASCII encodings. However, repositories created on such systems will not work properly on UTF-8-based systems (e.g. Linux, Mac, Windows) and vice versa. Additionally, many Git-based tools simply assume path names to be UTF-8 and will fail to display other encodings correctly.\n\nCommit log messages are typically encoded in UTF-8, but other extended ASCII encodings are also supported. This includes ISO-8859-x, CP125x and many others, but not UTF-16/32, EBCDIC and CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.).\n\nAlthough we encourage that the commit log messages are encoded in UTF-8, both the core and Git Porcelain are designed not to force UTF-8 on projects. If all participants of a particular project find it more convenient to use legacy encodings, Git does not forbid it. However, there are a few things to keep in mind.\n\ngit commit and git commit-tree issue a warning if the commit log message given to it does not look like a valid UTF-8 string, unless you explicitly say your project uses a legacy encoding. The way to say this is to have i18n.commitEncoding in .git/config file, like this:\n\nCommit objects created with the above setting record the value of i18n.commitEncoding in their encoding header. This is to help other people who look at them later. Lack of this header implies that the commit log message is encoded in UTF-8.\n\ngit log, git show, git blame and friends look at the encoding header of a commit object, and try to re-code the log message into UTF-8 unless otherwise specified. You can specify the desired output encoding with i18n.logOutputEncoding in .git/config file, like this:\n\nIf you do not have this configuration variable, the value of i18n.commitEncoding is used instead.\n\nNote that we deliberately chose not to re-code the commit log message when a commit is made to force UTF-8 at the commit object level, because re-coding to UTF-8 is not necessarily a reversible operation.\n\n• The contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the core level.\n• Path names are encoded in UTF-8 normalization form C. This applies to tree objects, the index file, ref names, as well as path names in command line arguments, environment variables and config files (.git/config (see git-config[1]), gitignore[5], gitattributes[5] and gitmodules[5]). Note that Git at the core level treats path names simply as sequences of non-NUL bytes, there are no path name encoding conversions (except on Mac and Windows). Therefore, using non-ASCII path names will mostly work even on platforms and file systems that use legacy extended ASCII encodings. However, repositories created on such systems will not work properly on UTF-8-based systems (e.g. Linux, Mac, Windows) and vice versa. Additionally, many Git-based tools simply assume path names to be UTF-8 and will fail to display other encodings correctly.\n• Commit log messages are typically encoded in UTF-8, but other extended ASCII encodings are also supported. This includes ISO-8859-x, CP125x and many others, but not UTF-16/32, EBCDIC and CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.).\n\n• git commit and git commit-tree issue a warning if the commit log message given to it does not look like a valid UTF-8 string, unless you explicitly say your project uses a legacy encoding. The way to say this is to have i18n.commitEncoding in .git/config file, like this: [i18n] commitEncoding = ISO-8859-1 Commit objects created with the above setting record the value of i18n.commitEncoding in their encoding header. This is to help other people who look at them later. Lack of this header implies that the commit log message is encoded in UTF-8.\n• git log, git show, git blame and friends look at the encoding header of a commit object, and try to re-code the log message into UTF-8 unless otherwise specified. You can specify the desired output encoding with i18n.logOutputEncoding in .git/config file, like this: [i18n] logOutputEncoding = ISO-8859-1 If you do not have this configuration variable, the value of i18n.commitEncoding is used instead.",
        "code_examples": [
          "```bash\n[i18n]\n\tcommitEncoding = ISO-8859-1\n```",
          "```bash\n[i18n]\n\tlogOutputEncoding = ISO-8859-1\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 11,
          "content_length": 4852
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-write-tree[1] git-commit[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 31
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-commit-tree",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "Git",
    "summary": "NAME git-count-objects - Count unpacked number of objects and their disk consumption\n\ngit-count-objects - Count unpacked number of objects and their disk consumption",
    "sections": [
      {
        "header": "NAME",
        "content": "git-count-objects - Count unpacked number of objects and their disk consumption",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 79
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Counts the number of unpacked object files and disk space consumed by them, to help you decide when it is a good time to repack.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 128
        }
      },
      {
        "header": "OPTIONS",
        "content": "Provide more detailed reports:\n\ncount: the number of loose objects\n\nsize: disk space consumed by loose objects, in KiB (unless -H is specified)\n\nin-pack: the number of in-pack objects\n\npacks: the number of pack files\n\nsize-pack: disk space consumed by the packs, in KiB (unless -H is specified)\n\nprune-packable: the number of loose objects that are also present in the packs. These objects could be pruned using git prune-packed.\n\ngarbage: the number of files in the object database that are neither valid loose objects nor valid packs\n\nsize-garbage: disk space consumed by garbage files, in KiB (unless -H is specified)\n\nalternate: absolute path of alternate object databases; may appear multiple times, one line per path. Note that if the path contains non-printable characters, it may be surrounded by double-quotes and contain C-style backslashed escape sequences.\n\nPrint sizes in human readable format\n\n**-v**: Provide more detailed reports: count: the number of loose objects size: disk space consumed by loose objects, in KiB (unless -H is specified) in-pack: the number of in-pack objects packs: the number of pack files size-pack: disk space consumed by the packs, in KiB (unless -H is specified) prune-packable: the number of loose objects that are also present in the packs. These objects could be pruned using git prune-packed. garbage: the number of files in the object database that are neither valid loose objects nor valid packs size-garbage: disk space consumed by garbage files, in KiB (unless -H is specified) alternate: absolute path of alternate object databases; may appear multiple times, one line per path. Note that if the path contains non-printable characters, it may be surrounded by double-quotes and contain C-style backslashed escape sequences.\n**--verbose**: Print sizes in human readable format",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 11,
          "content_length": 1827
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-count-objects",
    "doc_type": "git",
    "total_sections": 4
  },
  {
    "title": "Git",
    "summary": "NAME git-diff-index - Compare a tree to the working tree or index\n\ngit-diff-index - Compare a tree to the working tree or index",
    "sections": [
      {
        "header": "NAME",
        "content": "git-diff-index - Compare a tree to the working tree or index",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 60
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Compare the content and mode of the blobs found in a tree object with the corresponding tracked files in the working tree, or with the corresponding paths in the index. When <path> arguments are present, compare only paths matching those patterns. Otherwise all tracked files are compared.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 289
        }
      },
      {
        "header": "OPTIONS",
        "content": "Generate patch (see Generating patch text with -p).\n\nSuppress all output from the diff machinery. Useful for commands like git show that show the patch by default to squelch their output, or to cancel the effect of options like --patch, --stat earlier on the command line in an alias.\n\nGenerate diffs with <n> lines of context instead of the usual three. Implies --patch.\n\nOutput to a specific file instead of stdout.\n\nSpecify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively.\n\nGenerate the diff in raw format. This is the default.\n\nSynonym for -p --raw.\n\nEnable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.\n\nDisable the indent heuristic.\n\nSpend extra time to make sure the smallest possible diff is produced.\n\nGenerate a diff using the \"patience diff\" algorithm.\n\nGenerate a diff using the \"histogram diff\" algorithm.\n\nGenerate a diff using the \"anchored diff\" algorithm.\n\nThis option may be specified more than once.\n\nIf a line exists in both the source and destination, exists only once, and starts with <text>, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the \"patience diff\" algorithm internally.\n\nChoose a diff algorithm. The variants are as follows:\n\nThe basic greedy diff algorithm. Currently, this is the default.\n\nSpend extra time to make sure the smallest possible diff is produced.\n\nUse \"patience diff\" algorithm when generating patches.\n\nThis algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n\nFor instance, if you configured the diff.algorithm variable to a non-default value and want to use the default one, then you have to use --diff-algorithm=default option.\n\nGenerate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by <width>. The width of the filename part can be limited by giving another width <name-width> after a comma or by setting diff.statNameWidth=<name-width>. The width of the graph part can be limited by using --stat-graph-width=<graph-width> or by setting diff.statGraphWidth=<graph-width>. Using --stat or --stat-graph-width affects all commands generating a stat graph, while setting diff.statNameWidth or diff.statGraphWidth does not affect git format-patch. By giving a third parameter <count>, you can limit the output to the first <count> lines, followed by ... if there are more.\n\nThese parameters can also be set individually with --stat-width=<width>, --stat-name-width=<name-width> and --stat-count=<count>.\n\nOutput a condensed summary of extended header information such as file creations or deletions (\"new\" or \"gone\", optionally +l if it’s a symlink) and mode changes (+x or -x for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies --stat.\n\nSimilar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly. For binary files, outputs two - instead of saying 0 0.\n\nOutput only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines.\n\nOutput the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config[1]). The following parameters are available:\n\nCompute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n\nCompute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n\nCompute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n\nCount changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n\nAn integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n\nExample: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative.\n\nSynonym for --dirstat=cumulative.\n\nSynonym for --dirstat=files,<param>,....\n\nOutput a condensed summary of extended header information such as creations, renames and mode changes.\n\nSynonym for -p --stat.\n\nWhen --raw, --numstat, --name-only or --name-status has been given, do not munge pathnames and use NULs as output field terminators.\n\nWithout this option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n\nShow only the name of each changed file in the post-image tree. The file names are often encoded in UTF-8. For more information see the discussion about encoding in the git-log[1] manual page.\n\nShow only the name(s) and status of each changed file. See the description of the --diff-filter option on what the status letters mean. Just like --name-only the file names are often encoded in UTF-8.\n\nSpecify how differences in submodules are shown. When specifying --submodule=short the short format is used. This format just shows the names of the commits at the beginning and end of the range. When --submodule or --submodule=log is specified, the log format is used. This format lists the commits in the range like git-submodule[1] summary does. When --submodule=diff is specified, the diff format is used. This format shows an inline diff of the changes in the submodule contents between the commit range. Defaults to diff.submodule or the short format if the config option is unset.\n\nShow colored diff. --color (i.e. without =<when>) is the same as --color=always. <when> can be one of always, never, or auto.\n\nTurn off colored diff. It is the same as --color=never.\n\nMoved lines of code are colored differently. The <mode> defaults to no if the option is not given and to zebra if the option with no mode is given. The mode must be one of:\n\nMoved lines are not highlighted.\n\nIs a synonym for zebra. This may change to a more sensible mode in the future.\n\nAny line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.\n\nBlocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart.\n\nBlocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected.\n\nSimilar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n\nTurn off move detection. This can be used to override configuration settings. It is the same as --color-moved=no.\n\nThis configures how whitespace is ignored when performing the move detection for --color-moved. These modes can be given as a comma separated list:\n\nDo not ignore whitespace when performing move detection.\n\nIgnore changes in whitespace at EOL.\n\nIgnore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n\nIgnore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n\nInitially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n\nDo not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as --color-moved-ws=no.\n\nBy default, words are delimited by whitespace; see --word-diff-regex below. The <mode> defaults to plain, and must be one of:\n\nHighlight changed words using only colors. Implies --color.\n\nShow words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.\n\nUse a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own.\n\nDisable word diff again.\n\nNote that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled.\n\nUse <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies --word-diff unless it was already enabled.\n\nEvery non-overlapping match of the <regex> is considered a word. Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences. You may want to append |[^[:space:]] to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline.\n\nFor example, --word-diff-regex=. will treat each character as a word and, correspondingly, show differences character by character.\n\nThe regex can also be set via a diff driver or configuration option, see gitattributes[5] or git-config[1]. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.\n\nEquivalent to --word-diff=color plus (if a regex was specified) --word-diff-regex=<regex>.\n\nTurn off rename detection, even when the configuration file gives the default to do so.\n\nWhether to use empty blobs as rename source.\n\nWarn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by core.whitespace configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.\n\nHighlight whitespace errors in the context, old or new lines of the diff. Multiple values are separated by comma, none resets previous values, default reset the list to new and all is a shorthand for old,new,context. When this option is not given, and the configuration variable diff.wsErrorHighlight is not set, only whitespace errors in new lines are highlighted. The whitespace errors are colored with color.diff.whitespace.\n\nInstead of the first handful of characters, show the full pre- and post-image blob object names on the \"index\" line when generating patch format output.\n\nIn addition to --full-index, output a binary diff that can be applied with git-apply. Implies --patch.\n\nInstead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. In diff-patch output format, --full-index takes higher precedence, i.e. if --full-index is specified, full blob names will be shown regardless of --abbrev. Non default number of digits can be specified with --abbrev=<n>.\n\nBreak complete rewrite changes into pairs of delete and create. This serves two purposes:\n\nIt affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number <m> controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).\n\nWhen used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number <n> controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file.\n\nDetect renames. If <n> is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed. Without a % sign, the number is to be read as a fraction, with a decimal point before it. I.e., -M5 becomes 0.5, and is thus the same as -M50%. Similarly, -M05 is the same as -M5%. To limit detection to exact renames, use -M100%. The default similarity index is 50%.\n\nDetect copies as well as renames. See also --find-copies-harder. If <n> is specified, it has the same meaning as for -M<n>.\n\nFor performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one -C option has the same effect.\n\nOmit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.\n\nWhen used together with -B, omit also the preimage in the deletion part of a delete/create pair.\n\nThe -M and -C options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources. (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.) For N sources and destinations, this exhaustive check is O(N^2). This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number. Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited.\n\nSelect only files that are Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have their type (i.e. regular file, symlink, submodule, …) changed (T), are Unmerged (U), are Unknown (X), or have had their pairing Broken (B). Any combination of the filter characters (including none) can be used. When * (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected.\n\nAlso, these upper-case letters can be downcased to exclude. E.g. --diff-filter=ad excludes added and deleted paths.\n\nNote that not all diffs can feature all types. For instance, copied and renamed entries cannot appear if detection for those types is disabled.\n\nLook for differences that change the number of occurrences of the specified <string> (i.e. addition/deletion) in a file. Intended for the scripter’s use.\n\nIt is useful when you’re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into -S, and keep going until you get the very first version of the block.\n\nBinary files are searched as well.\n\nLook for differences whose patch text contains added/removed lines that match <regex>.\n\nTo illustrate the difference between -S<regex> --pickaxe-regex and -G<regex>, consider a commit with the following diff in the same file:\n\nWhile git log -G\"frotz\\(nitfol\" will show this commit, git log -S\"frotz\\(nitfol\" --pickaxe-regex will not (because the number of occurrences of that string did not change).\n\nUnless --text is supplied patches of binary files without a textconv filter will be ignored.\n\nSee the pickaxe entry in gitdiffcore[7] for more information.\n\nLook for differences that change the number of occurrences of the specified object. Similar to -S, just the argument is different in that it doesn’t search for a specific string but for a specific object id.\n\nThe object can be a blob or a submodule commit. It implies the -t option in git-log to also find trees.\n\nWhen -S or -G finds a change, show all the changes in that changeset, not just the files that contain the change in <string>.\n\nTreat the <string> given to -S as an extended POSIX regular expression to match.\n\nControl the order in which files appear in the output. This overrides the diff.orderFile configuration variable (see git-config[1]). To cancel diff.orderFile, use -O/dev/null.\n\nThe output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.\n\n<orderfile> is parsed as follows:\n\nBlank lines are ignored, so they can be used as separators for readability.\n\nLines starting with a hash (\"#\") are ignored, so they can be used for comments. Add a backslash (\"\\\") to the beginning of the pattern if it starts with a hash.\n\nEach other line contains a single pattern.\n\nPatterns have the same syntax and semantics as patterns used for fnmatch(3) without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern. For example, the pattern \"foo*bar\" matches \"fooasdfbar\" and \"foo/bar/baz/asdf\" but not \"foobarx\".\n\nDiscard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to). These options were invented primarily for the use of the git difftool command, and may not be very useful otherwise.\n\nSwap two inputs; that is, show differences from index or on-disk file to tree contents.\n\nWhen run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative.\n\nTreat all files as text.\n\nIgnore carriage-return at the end of line when doing a comparison.\n\nIgnore changes in whitespace at EOL.\n\nIgnore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n\nIgnore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n\nIgnore changes whose lines are all blank.\n\nIgnore changes whose all lines match <regex>. This option may be specified more than once.\n\nShow the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n\nShow whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see \"Defining a custom hunk-header\" in gitattributes[5]).\n\nMake the program exit with codes similar to diff(1). That is, it exits with 1 if there were differences and 0 means no differences.\n\nDisable all output of the program. Implies --exit-code. Disables execution of external diff helpers whose exit code is not trusted, i.e. their respective configuration option diff.trustExitCode or diff.<driver>.trustExitCode or environment variable GIT_EXTERNAL_DIFF_TRUST_EXIT_CODE is false.\n\nAllow an external diff helper to be executed. If you set an external diff driver with gitattributes[5], you need to use this option with git-log[1] and friends.\n\nDisallow external diff drivers.\n\nAllow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes[5] for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff[1] and git-log[1], but not for git-format-patch[1] or diff plumbing commands.\n\nIgnore changes to submodules in the diff generation. all is the default. Using none will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config[1] or gitmodules[5]. When untracked is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using dirty ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using all hides all changes to submodules.\n\nShow the given source <prefix> instead of \"a/\".\n\nShow the given destination <prefix> instead of \"b/\".\n\nDo not show any source or destination prefix.\n\nUse the default source and destination prefixes (\"a/\" and \"b/\"). This overrides configuration variables such as diff.noprefix, diff.srcPrefix, diff.dstPrefix, and diff.mnemonicPrefix (see git-config[1]).\n\nPrepend an additional <prefix> to every line of output.\n\nBy default entries added by git add -N appear as an existing empty file in git diff and a new file in git diff --cached. This option makes the entry appear as a new file in git diff and non-existent in git diff --cached. This option could be reverted with --ita-visible-in-index. Both options are experimental and could be removed in future.\n\nFor more detailed explanation on these common options, see also gitdiffcore[7].\n\nThe id of a tree object to diff against.\n\nDo not consider the on-disk file at all.\n\nInstead of comparing <tree-ish> directly, use the merge base between <tree-ish> and HEAD instead. <tree-ish> must be a commit.\n\nBy default, files recorded in the index but not checked out are reported as deleted. This flag makes git diff-index say that all non-checked-out files are up to date.\n\n• Blank lines are ignored, so they can be used as separators for readability.\n• Lines starting with a hash (\"#\") are ignored, so they can be used for comments. Add a backslash (\"\\\") to the beginning of the pattern if it starts with a hash.\n• Each other line contains a single pattern.\n\n**-p**: Generate patch (see Generating patch text with -p).\n**-u**: Suppress all output from the diff machinery. Useful for commands like git show that show the patch by default to squelch their output, or to cancel the effect of options like --patch, --stat earlier on the command line in an alias.\n**--patch**: Generate diffs with <n> lines of context instead of the usual three. Implies --patch.\n**-s**: Output to a specific file instead of stdout.\n**--no-patch**: Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively.\n**-U<n>**: Generate the diff in raw format. This is the default.\n**--unified=<n>**: Synonym for -p --raw.\n**--output=<file>**: Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.\n**--output-indicator-new=<char>**: Disable the indent heuristic.\n**--output-indicator-old=<char>**: Spend extra time to make sure the smallest possible diff is produced.\n**--output-indicator-context=<char>**: Generate a diff using the \"patience diff\" algorithm.\n**--raw**: Generate a diff using the \"histogram diff\" algorithm.\n**--patch-with-raw**: Generate a diff using the \"anchored diff\" algorithm. This option may be specified more than once. If a line exists in both the source and destination, exists only once, and starts with <text>, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the \"patience diff\" algorithm internally.\n**--indent-heuristic**: Choose a diff algorithm. The variants are as follows: default myers The basic greedy diff algorithm. Currently, this is the default. minimal Spend extra time to make sure the smallest possible diff is produced. patience Use \"patience diff\" algorithm when generating patches. histogram This algorithm extends the patience algorithm to \"support low-occurrence common elements\". For instance, if you configured the diff.algorithm variable to a non-default value and want to use the default one, then you have to use --diff-algorithm=default option.\n**--no-indent-heuristic**: The basic greedy diff algorithm. Currently, this is the default.\n**--minimal**: Spend extra time to make sure the smallest possible diff is produced.\n**--patience**: Use \"patience diff\" algorithm when generating patches.\n**--histogram**: This algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n**--anchored=<text>**: Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by <width>. The width of the filename part can be limited by giving another width <name-width> after a comma or by setting diff.statNameWidth=<name-width>. The width of the graph part can be limited by using --stat-graph-width=<graph-width> or by setting diff.statGraphWidth=<graph-width>. Using --stat or --stat-graph-width affects all commands generating a stat graph, while setting diff.statNameWidth or diff.statGraphWidth does not affect git format-patch. By giving a third parameter <count>, you can limit the output to the first <count> lines, followed by ... if there are more. These parameters can also be set individually with --stat-width=<width>, --stat-name-width=<name-width> and --stat-count=<count>.\n**--diff-algorithm=(patience|minimal|histogram|myers)**: Output a condensed summary of extended header information such as file creations or deletions (\"new\" or \"gone\", optionally +l if it’s a symlink) and mode changes (+x or -x for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies --stat.\n**default**: Similar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly. For binary files, outputs two - instead of saying 0 0.\n**myers**: Output only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines.\n**minimal**: Output the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config[1]). The following parameters are available: changes Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given. lines Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options. files Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all. cumulative Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter. <limit> An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output. Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative.\n**patience**: Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n**histogram**: Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n**--stat[=<width>[,<name-width>[,<count>]]]**: Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n**--compact-summary**: Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n**--numstat**: An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n**--shortstat**: Synonym for --dirstat=cumulative.\n**-X [<param>,...]**: Synonym for --dirstat=files,<param>,....\n**--dirstat[=<param>,...]**: Output a condensed summary of extended header information such as creations, renames and mode changes.\n**changes**: Synonym for -p --stat.\n**lines**: When --raw, --numstat, --name-only or --name-status has been given, do not munge pathnames and use NULs as output field terminators. Without this option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n**files**: Show only the name of each changed file in the post-image tree. The file names are often encoded in UTF-8. For more information see the discussion about encoding in the git-log[1] manual page.\n**cumulative**: Show only the name(s) and status of each changed file. See the description of the --diff-filter option on what the status letters mean. Just like --name-only the file names are often encoded in UTF-8.\n**<limit>**: Specify how differences in submodules are shown. When specifying --submodule=short the short format is used. This format just shows the names of the commits at the beginning and end of the range. When --submodule or --submodule=log is specified, the log format is used. This format lists the commits in the range like git-submodule[1] summary does. When --submodule=diff is specified, the diff format is used. This format shows an inline diff of the changes in the submodule contents between the commit range. Defaults to diff.submodule or the short format if the config option is unset.\n**--cumulative**: Show colored diff. --color (i.e. without =<when>) is the same as --color=always. <when> can be one of always, never, or auto.\n**--dirstat-by-file[=<param>,...]**: Turn off colored diff. It is the same as --color=never.\n**--summary**: Moved lines of code are colored differently. The <mode> defaults to no if the option is not given and to zebra if the option with no mode is given. The mode must be one of: no Moved lines are not highlighted. default Is a synonym for zebra. This may change to a more sensible mode in the future. plain Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation. blocks Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart. zebra Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected. dimmed-zebra Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n**--patch-with-stat**: Moved lines are not highlighted.\n**-z**: Is a synonym for zebra. This may change to a more sensible mode in the future.\n**--name-only**: Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.\n**--name-status**: Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart.\n**--submodule[=<format>]**: Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected.\n**--color[=<when>]**: Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n**--no-color**: Turn off move detection. This can be used to override configuration settings. It is the same as --color-moved=no.\n**--color-moved[=<mode>]**: This configures how whitespace is ignored when performing the move detection for --color-moved. These modes can be given as a comma separated list: no Do not ignore whitespace when performing move detection. ignore-space-at-eol Ignore changes in whitespace at EOL. ignore-space-change Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent. ignore-all-space Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none. allow-indentation-change Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n**no**: Do not ignore whitespace when performing move detection.\n**default**: Ignore changes in whitespace at EOL.\n**plain**: Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n**blocks**: Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n**zebra**: Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n**dimmed-zebra**: Do not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as --color-moved-ws=no.\n**--no-color-moved**: By default, words are delimited by whitespace; see --word-diff-regex below. The <mode> defaults to plain, and must be one of: color Highlight changed words using only colors. Implies --color. plain Show words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous. porcelain Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own. none Disable word diff again. Note that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled.\n**--color-moved-ws=<mode>,...**: Highlight changed words using only colors. Implies --color.\n**no**: Show words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.\n**ignore-space-at-eol**: Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own.\n**ignore-space-change**: Disable word diff again.\n**ignore-all-space**: Use <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies --word-diff unless it was already enabled. Every non-overlapping match of the <regex> is considered a word. Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences. You may want to append |[^[:space:]] to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline. For example, --word-diff-regex=. will treat each character as a word and, correspondingly, show differences character by character. The regex can also be set via a diff driver or configuration option, see gitattributes[5] or git-config[1]. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.\n**allow-indentation-change**: Equivalent to --word-diff=color plus (if a regex was specified) --word-diff-regex=<regex>.\n**--no-color-moved-ws**: Turn off rename detection, even when the configuration file gives the default to do so.\n**--word-diff[=<mode>]**: Whether to use empty blobs as rename source.\n**color**: Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by core.whitespace configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.\n**plain**: Highlight whitespace errors in the context, old or new lines of the diff. Multiple values are separated by comma, none resets previous values, default reset the list to new and all is a shorthand for old,new,context. When this option is not given, and the configuration variable diff.wsErrorHighlight is not set, only whitespace errors in new lines are highlighted. The whitespace errors are colored with color.diff.whitespace.\n**porcelain**: Instead of the first handful of characters, show the full pre- and post-image blob object names on the \"index\" line when generating patch format output.\n**none**: In addition to --full-index, output a binary diff that can be applied with git-apply. Implies --patch.\n**--word-diff-regex=<regex>**: Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. In diff-patch output format, --full-index takes higher precedence, i.e. if --full-index is specified, full blob names will be shown regardless of --abbrev. Non default number of digits can be specified with --abbrev=<n>.\n**--color-words[=<regex>]**: Break complete rewrite changes into pairs of delete and create. This serves two purposes: It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number <m> controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines). When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number <n> controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file.\n**--no-renames**: Detect renames. If <n> is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed. Without a % sign, the number is to be read as a fraction, with a decimal point before it. I.e., -M5 becomes 0.5, and is thus the same as -M50%. Similarly, -M05 is the same as -M5%. To limit detection to exact renames, use -M100%. The default similarity index is 50%.\n**--[no-]rename-empty**: Detect copies as well as renames. See also --find-copies-harder. If <n> is specified, it has the same meaning as for -M<n>.\n**--check**: For performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one -C option has the same effect.\n**--ws-error-highlight=<kind>**: Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option. When used together with -B, omit also the preimage in the deletion part of a delete/create pair.\n**--full-index**: The -M and -C options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources. (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.) For N sources and destinations, this exhaustive check is O(N^2). This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number. Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited.\n**--binary**: Select only files that are Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have their type (i.e. regular file, symlink, submodule, …) changed (T), are Unmerged (U), are Unknown (X), or have had their pairing Broken (B). Any combination of the filter characters (including none) can be used. When * (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected. Also, these upper-case letters can be downcased to exclude. E.g. --diff-filter=ad excludes added and deleted paths. Note that not all diffs can feature all types. For instance, copied and renamed entries cannot appear if detection for those types is disabled.\n**--abbrev[=<n>]**: Look for differences that change the number of occurrences of the specified <string> (i.e. addition/deletion) in a file. Intended for the scripter’s use. It is useful when you’re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into -S, and keep going until you get the very first version of the block. Binary files are searched as well.\n**-B[<n>][/<m>]**: Look for differences whose patch text contains added/removed lines that match <regex>. To illustrate the difference between -S<regex> --pickaxe-regex and -G<regex>, consider a commit with the following diff in the same file: + return frotz(nitfol, two->ptr, 1, 0); ... - hit = frotz(nitfol, mf2.ptr, 1, 0); While git log -G\"frotz\\(nitfol\" will show this commit, git log -S\"frotz\\(nitfol\" --pickaxe-regex will not (because the number of occurrences of that string did not change). Unless --text is supplied patches of binary files without a textconv filter will be ignored. See the pickaxe entry in gitdiffcore[7] for more information.\n**--break-rewrites[=[<n>][/<m>]]**: Look for differences that change the number of occurrences of the specified object. Similar to -S, just the argument is different in that it doesn’t search for a specific string but for a specific object id. The object can be a blob or a submodule commit. It implies the -t option in git-log to also find trees.\n**-M[<n>]**: When -S or -G finds a change, show all the changes in that changeset, not just the files that contain the change in <string>.\n**--find-renames[=<n>]**: Treat the <string> given to -S as an extended POSIX regular expression to match.\n**-C[<n>]**: Control the order in which files appear in the output. This overrides the diff.orderFile configuration variable (see git-config[1]). To cancel diff.orderFile, use -O/dev/null. The output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order. <orderfile> is parsed as follows: Blank lines are ignored, so they can be used as separators for readability. Lines starting with a hash (\"#\") are ignored, so they can be used for comments. Add a backslash (\"\\\") to the beginning of the pattern if it starts with a hash. Each other line contains a single pattern. Patterns have the same syntax and semantics as patterns used for fnmatch(3) without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern. For example, the pattern \"foo*bar\" matches \"fooasdfbar\" and \"foo/bar/baz/asdf\" but not \"foobarx\".\n**--find-copies[=<n>]**: Discard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to). These options were invented primarily for the use of the git difftool command, and may not be very useful otherwise.\n**--find-copies-harder**: Swap two inputs; that is, show differences from index or on-disk file to tree contents.\n**-D**: When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative.\n**--irreversible-delete**: Treat all files as text.\n**-l<num>**: Ignore carriage-return at the end of line when doing a comparison.\n**--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]**: Ignore changes in whitespace at EOL.\n**-S<string>**: Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n**-G<regex>**: Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n**--find-object=<object-id>**: Ignore changes whose lines are all blank.\n**--pickaxe-all**: Ignore changes whose all lines match <regex>. This option may be specified more than once.\n**--pickaxe-regex**: Show the context between diff hunks, up to the specified <number> of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset.\n**-O<orderfile>**: Show whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see \"Defining a custom hunk-header\" in gitattributes[5]).\n**--skip-to=<file>**: Make the program exit with codes similar to diff(1). That is, it exits with 1 if there were differences and 0 means no differences.\n**--rotate-to=<file>**: Disable all output of the program. Implies --exit-code. Disables execution of external diff helpers whose exit code is not trusted, i.e. their respective configuration option diff.trustExitCode or diff.<driver>.trustExitCode or environment variable GIT_EXTERNAL_DIFF_TRUST_EXIT_CODE is false.\n**-R**: Allow an external diff helper to be executed. If you set an external diff driver with gitattributes[5], you need to use this option with git-log[1] and friends.\n**--relative[=<path>]**: Disallow external diff drivers.\n**--no-relative**: Allow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes[5] for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff[1] and git-log[1], but not for git-format-patch[1] or diff plumbing commands.\n**-a**: Ignore changes to submodules in the diff generation. all is the default. Using none will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config[1] or gitmodules[5]. When untracked is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using dirty ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using all hides all changes to submodules.\n**--text**: Show the given source <prefix> instead of \"a/\".\n**--ignore-cr-at-eol**: Show the given destination <prefix> instead of \"b/\".\n**--ignore-space-at-eol**: Do not show any source or destination prefix.\n**-b**: Use the default source and destination prefixes (\"a/\" and \"b/\"). This overrides configuration variables such as diff.noprefix, diff.srcPrefix, diff.dstPrefix, and diff.mnemonicPrefix (see git-config[1]).\n**--ignore-space-change**: Prepend an additional <prefix> to every line of output.\n**-w**: By default entries added by git add -N appear as an existing empty file in git diff and a new file in git diff --cached. This option makes the entry appear as a new file in git diff and non-existent in git diff --cached. This option could be reverted with --ita-visible-in-index. Both options are experimental and could be removed in future.\n**default**: The basic greedy diff algorithm. Currently, this is the default.\n**myers**: Spend extra time to make sure the smallest possible diff is produced.\n**minimal**: Use \"patience diff\" algorithm when generating patches.\n**patience**: This algorithm extends the patience algorithm to \"support low-occurrence common elements\".\n**changes**: Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.\n**lines**: Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.\n**files**: Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.\n**cumulative**: Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.\n**<limit>**: An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.\n**no**: Moved lines are not highlighted.\n**default**: Is a synonym for zebra. This may change to a more sensible mode in the future.\n**plain**: Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.\n**blocks**: Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.(old|new)Moved color. Adjacent blocks cannot be told apart.\n**zebra**: Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.(old|new)Moved color or color.diff.(old|new)MovedAlternative. The change between the two colors indicates that a new block was detected.\n**dimmed-zebra**: Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym.\n**no**: Do not ignore whitespace when performing move detection.\n**ignore-space-at-eol**: Ignore changes in whitespace at EOL.\n**ignore-space-change**: Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.\n**ignore-all-space**: Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.\n**allow-indentation-change**: Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.\n**color**: Highlight changed words using only colors. Implies --color.\n**plain**: Show words as [-removed-] and {added}. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.\n**porcelain**: Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde ~ on a line of its own.\n**none**: Disable word diff again.\n**<tree-ish>**: The id of a tree object to diff against.\n**--cached**: Do not consider the on-disk file at all.\n**--merge-base**: Instead of comparing <tree-ish> directly, use the merge base between <tree-ish> and HEAD instead. <tree-ish> must be a commit.\n**-m**: By default, files recorded in the index but not checked out are reported as deleted. This flag makes git diff-index say that all non-checked-out files are up to date.",
        "code_examples": [
          "```bash\n+    return frotz(nitfol, two->ptr, 1, 0);\n...\n-    hit = frotz(nitfol, mf2.ptr, 1, 0);\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 137,
          "content_length": 59910
        }
      },
      {
        "header": "Raw output format",
        "content": "The raw output format from git-diff-index, git-diff-tree, git-diff-files and git diff --raw are very similar.\n\nThese commands all compare two sets of things; what is compared differs:\n\ncompares the <tree-ish> and the files on the filesystem.\n\ncompares the <tree-ish> and the index.\n\ncompares the trees named by the two arguments.\n\ncompares the index and the files on the filesystem.\n\nThe git-diff-tree command begins its output by printing the hash of what is being compared. After that, all the commands print one output line per changed file.\n\nAn output line is formatted this way:\n\nThat is, from the left to the right:\n\nmode for \"src\"; 000000 if creation or unmerged.\n\nmode for \"dst\"; 000000 if deletion or unmerged.\n\nsha1 for \"src\"; 0{40} if creation or unmerged.\n\nsha1 for \"dst\"; 0{40} if deletion, unmerged or \"work tree out of sync with the index\".\n\nstatus, followed by optional \"score\" number.\n\na tab or a NUL when -z option is used.\n\na tab or a NUL when -z option is used; only exists for C or R.\n\npath for \"dst\"; only exists for C or R.\n\nan LF or a NUL when -z option is used, to terminate the record.\n\nPossible status letters are:\n\nA: addition of a file\n\nC: copy of a file into a new one\n\nD: deletion of a file\n\nM: modification of the contents or mode of a file\n\nR: renaming of a file\n\nT: change in the type of the file (regular file, symbolic link or submodule)\n\nU: file is unmerged (you must complete the merge before it can be committed)\n\nX: \"unknown\" change type (most probably a bug, please report it)\n\nStatus letters C and R are always followed by a score (denoting the percentage of similarity between the source and target of the move or copy). Status letter M may be followed by a score (denoting the percentage of dissimilarity) for file rewrites.\n\nThe sha1 for \"dst\" is shown as all 0’s if a file on the filesystem is out of sync with the index.\n\nWithout the -z option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]). Using -z the filename is output verbatim and the line is terminated by a NUL byte.\n\n• mode for \"src\"; 000000 if creation or unmerged.\n• mode for \"dst\"; 000000 if deletion or unmerged.\n• sha1 for \"src\"; 0{40} if creation or unmerged.\n• sha1 for \"dst\"; 0{40} if deletion, unmerged or \"work tree out of sync with the index\".\n• status, followed by optional \"score\" number.\n• a tab or a NUL when -z option is used.\n• path for \"src\"\n• a tab or a NUL when -z option is used; only exists for C or R.\n• path for \"dst\"; only exists for C or R.\n• an LF or a NUL when -z option is used, to terminate the record.\n\n• A: addition of a file\n• C: copy of a file into a new one\n• D: deletion of a file\n• M: modification of the contents or mode of a file\n• R: renaming of a file\n• T: change in the type of the file (regular file, symbolic link or submodule)\n• U: file is unmerged (you must complete the merge before it can be committed)\n• X: \"unknown\" change type (most probably a bug, please report it)\n\n**git-diff-index <tree-ish>**: compares the <tree-ish> and the files on the filesystem.\n**git-diff-index --cached <tree-ish>**: compares the <tree-ish> and the index.\n**git-diff-tree [-r] <tree-ish-1> <tree-ish-2> [<pattern>...]**: compares the trees named by the two arguments.\n**git-diff-files [<pattern>...]**: compares the index and the files on the filesystem.",
        "code_examples": [
          "```bash\nin-place edit  :100644 100644 bcd1234 0123456 M file0\ncopy-edit      :100644 100644 abcd123 1234567 C68 file1 file2\nrename-edit    :100644 100644 abcd123 1234567 R86 file1 file3\ncreate         :000000 100644 0000000 1234567 A file4\ndelete         :100644 000000 1234567 0000000 D file5\nunmerged       :000000 000000 0000000 0000000 U file6\n```",
          "```bash\n:100644 100644 5be4a4a 0000000 M file.c\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 30,
          "content_length": 3370
        }
      },
      {
        "header": "diff format for merges",
        "content": "git-diff-tree, git-diff-files and git-diff --raw can take -c or --cc option to generate diff output also for merge commits. The output differs from the format described above in the following way:\n\nthere is a colon for each parent\n\nthere are more \"src\" modes and \"src\" sha1\n\nstatus is concatenated status characters for each parent\n\nno optional \"score\" number\n\ntab-separated pathname(s) of the file\n\nFor -c and --cc, only the destination or final path is shown even if the file was renamed on any side of history. With --combined-all-paths, the name of the path in each parent is shown followed by the name of the path in the merge commit.\n\nExamples for -c and --cc without --combined-all-paths:\n\nExamples when --combined-all-paths added to either -c or --cc:\n\nNote that combined diff lists only files which were modified from all parents.\n\n• there is a colon for each parent\n• there are more \"src\" modes and \"src\" sha1\n• status is concatenated status characters for each parent\n• no optional \"score\" number\n• tab-separated pathname(s) of the file",
        "code_examples": [
          "```bash\n::100644 100644 100644 fabadb8 cc95eb0 4866510 MM\tdesc.c\n::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM\tbar.sh\n::100644 100644 100644 e07d6c5 9042e82 ee91881 RR\tphooey.c\n```",
          "```bash\n::100644 100644 100644 fabadb8 cc95eb0 4866510 MM\tdesc.c\tdesc.c\tdesc.c\n::100755 100755 100755 52b7a2d 6d1ac04 d2ac7d7 RM\tfoo.sh\tbar.sh\tbar.sh\n::100644 100644 100644 e07d6c5 9042e82 ee91881 RR\tfooey.c\tfuey.c\tphooey.c\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 1047
        }
      },
      {
        "header": "Generating patch text with -p",
        "content": "Running git-diff[1], git-log[1], git-show[1], git-diff-index[1], git-diff-tree[1], or git-diff-files[1] with the -p option produces patch text. You can customize the creation of patch text via the GIT_EXTERNAL_DIFF and the GIT_DIFF_OPTS environment variables (see git[1]), and the diff attribute (see gitattributes[5]).\n\nWhat the -p option produces is slightly different from the traditional diff format:\n\nIt is preceded by a \"git diff\" header that looks like this:\n\nThe a/ and b/ filenames are the same unless rename/copy is involved. Especially, even for a creation or a deletion, /dev/null is not used in place of the a/ or b/ filenames.\n\nWhen a rename/copy is involved, file1 and file2 show the name of the source file of the rename/copy and the name of the file that the rename/copy produces, respectively.\n\nIt is followed by one or more extended header lines:\n\nFile modes <mode> are printed as 6-digit octal numbers including the file type and file permission bits.\n\nPath names in extended headers do not include the a/ and b/ prefixes.\n\nThe similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one.\n\nThe index line includes the blob object names before and after the change. The <mode> is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.\n\nPathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n\nAll the file1 files in the output refer to files before the commit, and all the file2 files refer to files after the commit. It is incorrect to apply each change to each file sequentially. For example, this patch will swap a and b:\n\nHunk headers mention the name of the function to which the hunk applies. See \"Defining a custom hunk-header\" in gitattributes[5] for details of how to tailor this to specific languages.\n\n• It is preceded by a \"git diff\" header that looks like this: diff --git a/file1 b/file2 The a/ and b/ filenames are the same unless rename/copy is involved. Especially, even for a creation or a deletion, /dev/null is not used in place of the a/ or b/ filenames. When a rename/copy is involved, file1 and file2 show the name of the source file of the rename/copy and the name of the file that the rename/copy produces, respectively.\n• It is followed by one or more extended header lines: old mode <mode> new mode <mode> deleted file mode <mode> new file mode <mode> copy from <path> copy to <path> rename from <path> rename to <path> similarity index <number> dissimilarity index <number> index <hash>..<hash> <mode> File modes <mode> are printed as 6-digit octal numbers including the file type and file permission bits. Path names in extended headers do not include the a/ and b/ prefixes. The similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one. The index line includes the blob object names before and after the change. The <mode> is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.\n• Pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]).\n• All the file1 files in the output refer to files before the commit, and all the file2 files refer to files after the commit. It is incorrect to apply each change to each file sequentially. For example, this patch will swap a and b: diff --git a/a b/b rename from a rename to b diff --git a/b b/a rename from b rename to a\n• Hunk headers mention the name of the function to which the hunk applies. See \"Defining a custom hunk-header\" in gitattributes[5] for details of how to tailor this to specific languages.",
        "code_examples": [
          "```bash\noldmode<mode>newmode<mode>deletedfilemode<mode>newfilemode<mode>copyfrom<path>copyto<path>renamefrom<path>renameto<path>similarityindex<number>dissimilarityindex<number>index<hash>..<hash><mode>\n```"
        ],
        "usage_examples": [
          "```bash\ndiff --git a/file1 b/file2\n```",
          "```bash\ndiff --git a/a b/b\nrename from a\nrename to b\ndiff --git a/b b/a\nrename from b\nrename to a\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 13,
          "content_length": 4196
        }
      },
      {
        "header": "Combined diff format",
        "content": "Any diff-generating command can take the -c or --cc option to produce a combined diff when showing a merge. This is the default format when showing merges with git-diff[1] or git-show[1]. Note also that you can give suitable --diff-merges option to any of these commands to force generation of diffs in a specific format.\n\nA \"combined diff\" format looks like this:\n\nIt is preceded by a \"git diff\" header, that looks like this (when the -c option is used):\n\nor like this (when the --cc option is used):\n\nIt is followed by one or more extended header lines (this example shows a merge with two parents):\n\nThe mode <mode>,<mode>..<mode> line appears only if at least one of the <mode> is different from the rest. Extended headers with information about detected content movement (renames and copying detection) are designed to work with the diff of two <tree-ish> and are not used by combined diff format.\n\nIt is followed by a two-line from-file/to-file header:\n\nSimilar to the two-line header for the traditional unified diff format, /dev/null is used to signal created or deleted files.\n\nHowever, if the --combined-all-paths option is provided, instead of a two-line from-file/to-file, you get an N+1 line from-file/to-file header, where N is the number of parents in the merge commit:\n\nThis extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents.\n\nChunk header format is modified to prevent people from accidentally feeding it to patch -p1. Combined diff format was created for review of merge commit changes, and was not meant to be applied. The change is similar to the change in the extended index header:\n\nThere are (number of parents + 1) @ characters in the chunk header for combined diff format.\n\nUnlike the traditional unified diff format, which shows two files A and B with a single column that has - (minus — appears in A but removed in B), + (plus — missing in A but added to B), or \" \" (space — unchanged) prefix, this format compares two or more files file1, file2,… with one file X, and shows how X differs from each of fileN. One column for each of fileN is prepended to the output line to note how X’s line is different from it.\n\nA - character in the column N means that the line appears in fileN but it does not appear in the result. A + character in the column N means that the line appears in the result, and fileN does not have that line (in other words, the line was added, from the point of view of that parent).\n\nIn the above example output, the function signature was changed from both files (hence two - removals from both file1 and file2, plus ++ to mean one line that was added does not appear in either file1 or file2). Also, eight other lines are the same from file1 but do not appear in file2 (hence prefixed with +).\n\nWhen shown by git diff-tree -c, it compares the parents of a merge commit with the merge result (i.e. file1..fileN are the parents). When shown by git diff-files -c, it compares the two unresolved merge parents with the working tree file (i.e. file1 is stage 2 aka \"our version\", file2 is stage 3 aka \"their version\").\n\n• It is preceded by a \"git diff\" header, that looks like this (when the -c option is used): diff --combined file or like this (when the --cc option is used): diff --cc file\n• It is followed by one or more extended header lines (this example shows a merge with two parents): index <hash>,<hash>..<hash> mode <mode>,<mode>..<mode> new file mode <mode> deleted file mode <mode>,<mode> The mode <mode>,<mode>..<mode> line appears only if at least one of the <mode> is different from the rest. Extended headers with information about detected content movement (renames and copying detection) are designed to work with the diff of two <tree-ish> and are not used by combined diff format.\n• It is followed by a two-line from-file/to-file header: --- a/file +++ b/file Similar to the two-line header for the traditional unified diff format, /dev/null is used to signal created or deleted files. However, if the --combined-all-paths option is provided, instead of a two-line from-file/to-file, you get an N+1 line from-file/to-file header, where N is the number of parents in the merge commit: --- a/file --- a/file --- a/file +++ b/file This extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents.\n• Chunk header format is modified to prevent people from accidentally feeding it to patch -p1. Combined diff format was created for review of merge commit changes, and was not meant to be applied. The change is similar to the change in the extended index header: @@@ <from-file-range> <from-file-range> <to-file-range> @@@ There are (number of parents + 1) @ characters in the chunk header for combined diff format.",
        "code_examples": [
          "```bash\ndiff --combined describe.c\nindex fabadb8,cc95eb0..4866510\n--- a/describe.c\n+++ b/describe.c\n@@@ -98,20 -98,12 +98,20 @@@\n\treturn (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;\n  }\n\n- static void describe(char *arg)\n -static void describe(struct commit *cmit, int last_one)\n++static void describe(char *arg, int last_one)\n  {\n +\tunsigned char sha1[20];\n +\tstruct commit *cmit;\n\tstruct commit_list *list;\n\tstatic int initialized = 0;\n\tstruct commit_name *n;\n\n +\tif (get_sha1(arg, sha1) < 0)\n +\t\tusage(describe_usage);\n +\tcmit = lookup_commit_reference(sha1);\n +\tif (!cmit)\n +\t\tusage(describe_usage);\n +\n\tif (!initialized) {\n\t\tinitialized = 1;\n\t\tfor_each_ref(get_name);\n```",
          "```bash\ndiff --combined file\n```",
          "```bash\ndiff --cc file\n```",
          "```bash\nindex<hash>,<hash>..<hash>mode<mode>,<mode>..<mode>newfilemode<mode>deletedfilemode<mode>,<mode>\n```",
          "```bash\n--- a/file\n+++ b/file\n```",
          "```bash\n--- a/file\n--- a/file\n--- a/file\n+++ b/file\n```",
          "```bash\n@@@ <from-file-range> <from-file-range> <to-file-range> @@@\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 16,
          "content_length": 4844
        }
      },
      {
        "header": "other diff formats",
        "content": "The --summary option describes newly added, deleted, renamed and copied files. The --stat option adds diffstat(1) graph to the output. These options can be combined with other options, such as -p, and are meant for human consumption.\n\nWhen showing a change that involves a rename or a copy, --stat output formats the pathnames compactly by combining common prefix and suffix of the pathnames. For example, a change that moves arch/i386/Makefile to arch/x86/Makefile while modifying 4 lines will be shown like this:\n\nThe --numstat option gives the diffstat(1) information but is designed for easier machine consumption. An entry in --numstat output looks like this:\n\nThat is, from left to right:\n\nthe number of added lines;\n\nthe number of deleted lines;\n\npathname (possibly with rename/copy information);\n\nWhen -z output option is in effect, the output is formatted this way:\n\nthe number of added lines;\n\nthe number of deleted lines;\n\na NUL (only exists if renamed/copied);\n\npathname in preimage;\n\na NUL (only exists if renamed/copied);\n\npathname in postimage (only exists if renamed/copied);\n\nThe extra NUL before the preimage path in renamed case is to allow scripts that read the output to tell if the current record being read is a single-path record or a rename/copy record without reading ahead. After reading added and deleted lines, reading up to NUL would yield the pathname, but if that is NUL, the record will show two paths.\n\n• the number of added lines;\n• the number of deleted lines;\n• pathname (possibly with rename/copy information);\n\n• the number of added lines;\n• the number of deleted lines;\n• a NUL (only exists if renamed/copied);\n• pathname in preimage;\n• a NUL (only exists if renamed/copied);\n• pathname in postimage (only exists if renamed/copied);",
        "code_examples": [
          "```bash\narch/{i386 => x86}/Makefile    |   4 +--\n```",
          "```bash\n1\t2\tREADME\n3\t1\tarch/{i386 => x86}/Makefile\n```",
          "```bash\n1\t2\tREADME NUL\n3\t1\tNUL arch/i386/Makefile NUL arch/x86/Makefile NUL\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 15,
          "content_length": 1772
        }
      },
      {
        "header": "OPERATING MODES",
        "content": "You can choose whether you want to trust the index file entirely (using the --cached flag) or ask the diff logic to show any files that don’t match the stat state as being \"tentatively changed\". Both of these operations are very useful indeed.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 243
        }
      },
      {
        "header": "CACHED MODE",
        "content": "If --cached is specified, it allows you to ask:\n\nFor example, let’s say that you have worked on your working directory, updated some files in the index and are ready to commit. You want to see exactly what you are going to commit, without having to write a new tree object and compare it that way, and to do that, you just do\n\nExample: let’s say I had renamed commit.c to git-commit.c, and I had done an update-index to make that effective in the index file. git diff-files wouldn’t show anything at all, since the index file matches my working directory. But doing a git diff-index does:\n\nYou can see easily that the above is a rename.\n\nIn fact, git diff-index --cached should always be entirely equivalent to actually doing a git write-tree and comparing that. Except this one is much nicer for the case where you just want to check where you are.\n\nSo doing a git diff-index --cached is basically very useful when you are asking yourself \"what have I already marked for being committed, and what’s the difference to a previous tree\".",
        "code_examples": [],
        "usage_examples": [
          "```bash\nshow me the differences between HEAD and the current index\ncontents (the ones I'd write using 'git write-tree')\n```",
          "```bash\ngit diff-index --cached HEAD\n```",
          "```bash\ntorvalds@ppc970:~/git> git diff-index --cached HEAD\n:100644 000000 4161aecc6700a2eb579e842af0b7f22b98443f74 0000000000000000000000000000000000000000 D\tcommit.c\n:000000 100644 0000000000000000000000000000000000000000 4161aecc6700a2eb579e842af0b7f22b98443f74 A\tgit-commit.c\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1035
        }
      },
      {
        "header": "NON-CACHED MODE",
        "content": "The \"non-cached\" mode takes a different approach, and is potentially the more useful of the two in that what it does can’t be emulated with a git write-tree + git diff-tree. Thus that’s the default mode. The non-cached version asks the question:\n\nwhich is obviously a very useful question too, since that tells you what you could commit. Again, the output matches the git diff-tree -r output to a tee, but with a twist.\n\nThe twist is that if some file doesn’t match the index, we don’t have a backing store thing for it, and we use the magic \"all-zero\" sha1 to show that. So let’s say that you have edited kernel/sched.c, but have not actually done a git update-index on it yet - there is no \"object\" associated with the new state, and you get:\n\ni.e., it shows that the tree has changed, and that kernel/sched.c is not up to date and may contain new stuff. The all-zero sha1 means that to get the real diff, you need to look at the object in the working directory directly rather than do an object-to-object diff.\n\nNote | As with other commands of this type, git diff-index does not actually look at the contents of the file at all. So maybe kernel/sched.c hasn’t actually changed, and it’s just that you touched it. In either case, it’s a note that you need to git update-index it to make the index be in sync.\n\nNote | You can have a mixture of files show up as \"has been updated\" and \"is still dirty in the working directory\" together. You can always tell which file is in which state, since the \"has been updated\" ones show a valid sha1, and the \"not in sync with the index\" ones will always have the special all-zero sha1.\n\n[Note] Note As with other commands of this type, git diff-index does not actually look at the contents of the file at all. So maybe kernel/sched.c hasn’t actually changed, and it’s just that you touched it. In either case, it’s a note that you need to git update-index it to make the index be in sync.\n\n[Note] Note You can have a mixture of files show up as \"has been updated\" and \"is still dirty in the working directory\" together. You can always tell which file is in which state, since the \"has been updated\" ones show a valid sha1, and the \"not in sync with the index\" ones will always have the special all-zero sha1.",
        "code_examples": [
          "```bash\nshow me the differences between HEAD and the currently checked out\ntree - index contents _and_ files that aren't up to date\n```"
        ],
        "usage_examples": [
          "```bash\ntorvalds@ppc970:~/v2.6/linux> git diff-index --abbrev HEAD\n:100644 100644 7476bb5ba 000000000 M\tkernel/sched.c\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 4,
          "content_length": 2249
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-diff-index",
    "doc_type": "git",
    "total_sections": 12
  },
  {
    "title": "Git",
    "summary": "NAME git-for-each-ref - Output information on each ref\n\nSYNOPSIS git for-each-ref [--count=<count>] [--shell|--perl|--python|--tcl] [(--sort=<key>)…] [--format=<format>] [--include-root-refs] [--points-at=<object>] [--merged[=<object>]] [--no-merged[=<object>]] [--contains[=<object>]] [--no-contains[=<object>]] [(--exclude=<pattern>)…] [--start-after=<marker>] [ --stdin | <pattern>... ]",
    "sections": [
      {
        "header": "NAME",
        "content": "git-for-each-ref - Output information on each ref",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 49
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Iterate over all refs that match <pattern> and show them according to the given <format>, after sorting them according to the given set of <key>. If <count> is given, stop after showing that many refs. The interpolated values in <format> can optionally be quoted as string literals in the specified host language allowing their direct evaluation in that language.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 363
        }
      },
      {
        "header": "OPTIONS",
        "content": "If one or more patterns are given, only refs are shown that match against at least one pattern, either using fnmatch(3) or literally, in the latter case matching completely or from the beginning up to a slash.\n\nIf --stdin is supplied, then the list of patterns is read from standard input instead of from the argument list.\n\nBy default the command shows all refs that match <pattern>. This option makes it stop after showing that many refs.\n\nA field name to sort on. Prefix - to sort in descending order of the value. When unspecified, refname is used. You may use the --sort=<key> option multiple times, in which case the last key becomes the primary key.\n\nA string that interpolates %(fieldname) from a ref being shown and the object it points at. In addition, the string literal %% renders as % and %xx - where xx are hex digits - renders as the character with hex code xx. For example, %00 interpolates to \\0 (NUL), %09 to \\t (TAB), and %0a to \\n (LF).\n\nWhen unspecified, <format> defaults to %(objectname) SPC %(objecttype) TAB %(refname).\n\nRespect any colors specified in the --format option. The <when> field must be one of always, never, or auto (if <when> is absent, behave as if always was given).\n\nIf given, strings that substitute %(fieldname) placeholders are quoted as string literals suitable for the specified host language. This is meant to produce a scriptlet that can directly be `eval`ed.\n\nOnly list refs which points at the given object.\n\nOnly list refs whose tips are reachable from the specified commit (HEAD if not specified).\n\nOnly list refs whose tips are not reachable from the specified commit (HEAD if not specified).\n\nOnly list refs which contain the specified commit (HEAD if not specified).\n\nOnly list refs which don’t contain the specified commit (HEAD if not specified).\n\nSorting and filtering refs are case insensitive.\n\nDo not print a newline after formatted refs where the format expands to the empty string.\n\nIf one or more patterns are given, only refs which do not match any excluded pattern(s) are shown. Matching is done using the same rules as <pattern> above.\n\nList root refs (HEAD and pseudorefs) apart from regular refs.\n\nAllows paginating the output by skipping references up to and including the specified marker. When paging, it should be noted that references may be deleted, modified or added between invocations. Output will only yield those references which follow the marker lexicographically. Output begins from the first reference that would come after the marker alphabetically. Cannot be used with --sort=<key> or --stdin options, or the <pattern> argument(s) to limit the refs.\n\n**<pattern>…**: If one or more patterns are given, only refs are shown that match against at least one pattern, either using fnmatch(3) or literally, in the latter case matching completely or from the beginning up to a slash.\n**--stdin**: If --stdin is supplied, then the list of patterns is read from standard input instead of from the argument list.\n**--count=<count>**: By default the command shows all refs that match <pattern>. This option makes it stop after showing that many refs.\n**--sort=<key>**: A field name to sort on. Prefix - to sort in descending order of the value. When unspecified, refname is used. You may use the --sort=<key> option multiple times, in which case the last key becomes the primary key.\n**--format=<format>**: A string that interpolates %(fieldname) from a ref being shown and the object it points at. In addition, the string literal %% renders as % and %xx - where xx are hex digits - renders as the character with hex code xx. For example, %00 interpolates to \\0 (NUL), %09 to \\t (TAB), and %0a to \\n (LF). When unspecified, <format> defaults to %(objectname) SPC %(objecttype) TAB %(refname).\n**--color[=<when>]**: Respect any colors specified in the --format option. The <when> field must be one of always, never, or auto (if <when> is absent, behave as if always was given).\n**--shell**: If given, strings that substitute %(fieldname) placeholders are quoted as string literals suitable for the specified host language. This is meant to produce a scriptlet that can directly be `eval`ed.\n**--perl**: Only list refs which points at the given object.\n**--python**: Only list refs whose tips are reachable from the specified commit (HEAD if not specified).\n**--tcl**: Only list refs whose tips are not reachable from the specified commit (HEAD if not specified).\n**--points-at=<object>**: Only list refs which contain the specified commit (HEAD if not specified).\n**--merged[=<object>]**: Only list refs which don’t contain the specified commit (HEAD if not specified).\n**--no-merged[=<object>]**: Sorting and filtering refs are case insensitive.\n**--contains[=<object>]**: Do not print a newline after formatted refs where the format expands to the empty string.\n**--no-contains[=<object>]**: If one or more patterns are given, only refs which do not match any excluded pattern(s) are shown. Matching is done using the same rules as <pattern> above.\n**--ignore-case**: List root refs (HEAD and pseudorefs) apart from regular refs.\n**--omit-empty**: Allows paginating the output by skipping references up to and including the specified marker. When paging, it should be noted that references may be deleted, modified or added between invocations. Output will only yield those references which follow the marker lexicographically. Output begins from the first reference that would come after the marker alphabetically. Cannot be used with --sort=<key> or --stdin options, or the <pattern> argument(s) to limit the refs.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 18,
          "content_length": 5593
        }
      },
      {
        "header": "FIELD NAMES",
        "content": "Various values from structured fields in referenced objects can be used to interpolate into the resulting output, or as sort keys.\n\nFor all objects, the following names can be used:\n\nThe name of the ref (the part after $GIT_DIR/). For a non-ambiguous short name of the ref append :short. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode. If lstrip=<N> (rstrip=<N>) is appended, strips <N> slash-separated path components from the front (back) of the refname (e.g. %(refname:lstrip=2) turns refs/tags/foo into foo and %(refname:rstrip=2) turns refs/tags/foo into refs). If <N> is a negative number, strip as many path components as necessary from the specified end to leave -<N> path components (e.g. %(refname:lstrip=-2) turns refs/tags/foo into tags/foo and %(refname:rstrip=-1) turns refs/tags/foo into refs). When the ref does not have enough components, the result becomes an empty string if stripping with positive <N>, or it becomes the full refname if stripping with negative <N>. Neither is an error.\n\nstrip can be used as a synonym to lstrip.\n\nThe type of the object (blob, tree, commit, tag).\n\nThe size of the object (the same as git cat-file -s reports). Append :disk to get the size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the CAVEATS section below.\n\nThe object name (aka SHA-1). For a non-ambiguous abbreviation of the object name append :short. For an abbreviation of the object name with desired length append :short=<length>, where the minimum length is MINIMUM_ABBREV. The length may be exceeded to ensure unique object names.\n\nThis expands to the object name of the delta base for the given object, if it is stored as a delta. Otherwise it expands to the null object name (all zeroes).\n\nThe name of a local ref which can be considered “upstream” from the displayed ref. Respects :short, :lstrip and :rstrip in the same way as refname above. Additionally respects :track to show \"[ahead N, behind M]\" and :trackshort to show the terse version: \">\" (ahead), \"<\" (behind), \"<>\" (ahead and behind), or \"=\" (in sync). :track also prints \"[gone]\" whenever unknown upstream ref is encountered. Append :track,nobracket to show tracking information without brackets (i.e \"ahead N, behind M\").\n\nFor any remote-tracking branch %(upstream), %(upstream:remotename) and %(upstream:remoteref) refer to the name of the remote and the name of the tracked remote ref, respectively. In other words, the remote-tracking branch can be updated explicitly and individually by using the refspec %(upstream:remoteref):%(upstream) to fetch from %(upstream:remotename).\n\nHas no effect if the ref does not have tracking information associated with it. All the options apart from nobracket are mutually exclusive, but if used together the last option is selected.\n\nThe name of a local ref which represents the @{push} location for the displayed ref. Respects :short, :lstrip, :rstrip, :track, :trackshort, :remotename, and :remoteref options as upstream does. Produces an empty string if no @{push} ref is configured.\n\n* if HEAD matches current ref (the checked out branch), ' ' otherwise.\n\nChange output color. Followed by :<colorname>, where color names are described under Values in the \"CONFIGURATION FILE\" section of git-config[1]. For example, %(color:bold red).\n\nLeft-, middle-, or right-align the content between %(align:…) and %(end). The \"align:\" is followed by width=<width> and position=<position> in any order separated by a comma, where the <position> is either left, right or middle, default being left and <width> is the total length of the content with alignment. For brevity, the \"width=\" and/or \"position=\" prefixes may be omitted, and bare <width> and <position> used instead. For instance, %(align:<width>,<position>). If the contents length is more than the width then no alignment is performed. If used with --quote everything in between %(align:…) and %(end) is quoted, but if nested then only the topmost level performs quoting.\n\nUsed as %(if)…%(then)…%(end) or %(if)…%(then)…%(else)…%(end). If there is an atom with value or string literal after the %(if) then everything after the %(then) is printed, else if the %(else) atom is used, then everything after %(else) is printed. We ignore space when evaluating the string before %(then), this is useful when we use the %(HEAD) atom which prints either \"*\" or \" \" and we want to apply the if condition only on the HEAD ref. Append \":equals=<string>\" or \":notequals=<string>\" to compare the value between the %(if:…) and %(then) atoms with the given string.\n\nThe ref which the given symbolic ref refers to. If not a symbolic ref, nothing is printed. Respects the :short, :lstrip and :rstrip options in the same way as refname above.\n\nThe GPG signature of a commit.\n\nShow \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key) and \"N\" for no signature.\n\nThe signer of the GPG signature of a commit.\n\nThe key of the GPG signature of a commit.\n\nThe fingerprint of the GPG signature of a commit.\n\nThe primary key fingerprint of the GPG signature of a commit.\n\nThe trust level of the GPG signature of a commit. Possible outputs are ultimate, fully, marginal, never and undefined.\n\nThe absolute path to the worktree in which the ref is checked out, if it is checked out in any linked worktree. Empty string otherwise.\n\nTwo integers, separated by a space, demonstrating the number of commits ahead and behind, respectively, when comparing the output ref to the <committish> specified in the format.\n\nIn at most one row, (<committish>) will appear to indicate the ref that is most likely the ref used as a starting point for the branch that produced <committish>. This choice is made using a heuristic: choose the ref that minimizes the number of commits in the first-parent history of <committish> and not in the first-parent history of the ref.\n\nFor example, consider the following figure of first-parent histories of several refs:\n\nHere, if A, B, and C are the filtered references, and the format string is %(refname):%(is-base:D), then the output would be\n\nThis is because the first-parent history of D has its earliest intersection with the first-parent histories of the filtered refs at a common first-parent ancestor of B and C and ties are broken by the earliest ref in the sorted order.\n\nNote that this token will not appear if the first-parent history of <committish> does not intersect the first-parent histories of the filtered refs.\n\nA human-readable name, like git-describe[1]; empty string for undescribable commits. The describe string may be followed by a colon and one or more comma-separated options.\n\nInstead of only considering annotated tags, consider lightweight tags as well; see the corresponding option in git-describe[1] for details.\n\nUse at least <number> hexadecimal digits; see the corresponding option in git-describe[1] for details.\n\nOnly consider tags matching the given glob(7) pattern, excluding the \"refs/tags/\" prefix; see the corresponding option in git-describe[1] for details.\n\nDo not consider tags matching the given glob(7) pattern, excluding the \"refs/tags/\" prefix; see the corresponding option in git-describe[1] for details.\n\nIn addition to the above, for commit and tag objects, the header field names (tree, parent, object, type, and tag) can be used to specify the value in the header field. Fields tree and parent can also be used with modifier :short and :short=<length> just like objectname.\n\nFor commit and tag objects, the special creatordate and creator fields will correspond to the appropriate date or name-email-date tuple from the committer or tagger fields depending on the object type. These are intended for working on a mix of annotated and lightweight tags.\n\nFor tag objects, a fieldname prefixed with an asterisk (*) expands to the fieldname value of the peeled object, rather than that of the tag object itself.\n\nFields that have name-email-date tuple as its value (author, committer, and tagger) can be suffixed with name, email, and date to extract the named component. For email fields (authoremail, committeremail and taggeremail), :trim can be appended to get the email without angle brackets, and :localpart to get the part before the @ symbol out of the trimmed email. In addition to these, the :mailmap option and the corresponding :mailmap,trim and :mailmap,localpart can be used (order does not matter) to get values of the name and email according to the .mailmap file or according to the file set in the mailmap.file or mailmap.blob configuration variable (see gitmailmap[5]).\n\nThe raw data in an object is raw.\n\nThe raw data size of the object.\n\nNote that --format=%(raw) can not be used with --python, --shell, --tcl, because such language may not support arbitrary binary data in their string variable type.\n\nThe message in a commit or a tag object is contents, from which contents:<part> can be used to extract various parts out of:\n\nThe size in bytes of the commit or tag message.\n\nThe first paragraph of the message, which typically is a single line, is taken as the \"subject\" of the commit or the tag message. Instead of contents:subject, field subject can also be used to obtain same results. :sanitize can be appended to subject for subject line suitable for filename.\n\nThe remainder of the commit or the tag message that follows the \"subject\".\n\nThe optional GPG signature of the tag.\n\nThe first N lines of the message.\n\nAdditionally, the trailers as interpreted by git-interpret-trailers[1] are obtained as trailers[:options] (or by using the historical alias contents:trailers[:options]). For valid [:option] values see trailers section of git-log[1].\n\nFor sorting purposes, fields with numeric values sort in numeric order (objectsize, authordate, committerdate, creatordate, taggerdate). All other fields are used to sort in their byte-value order.\n\nThere is also an option to sort by versions, this can be done by using the fieldname version:refname or its alias v:refname.\n\nIn any case, a field name that refers to a field inapplicable to the object referred by the ref does not cause an error. It returns an empty string instead.\n\nAs a special case for the date-type fields, you may specify a format for the date by adding : followed by date format name (see the values the --date option to git-rev-list[1] takes). If this formatting is provided in a --sort key, references will be sorted according to the byte-value of the formatted string rather than the numeric value of the underlying timestamp.\n\nSome atoms like %(align) and %(if) always require a matching %(end). We call them \"opening atoms\" and sometimes denote them as %($open).\n\nWhen a scripting language specific quoting is in effect, everything between a top-level opening atom and its matching %(end) is evaluated according to the semantics of the opening atom and only its result from the top-level is quoted.\n\n**refname**: The name of the ref (the part after $GIT_DIR/). For a non-ambiguous short name of the ref append :short. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode. If lstrip=<N> (rstrip=<N>) is appended, strips <N> slash-separated path components from the front (back) of the refname (e.g. %(refname:lstrip=2) turns refs/tags/foo into foo and %(refname:rstrip=2) turns refs/tags/foo into refs). If <N> is a negative number, strip as many path components as necessary from the specified end to leave -<N> path components (e.g. %(refname:lstrip=-2) turns refs/tags/foo into tags/foo and %(refname:rstrip=-1) turns refs/tags/foo into refs). When the ref does not have enough components, the result becomes an empty string if stripping with positive <N>, or it becomes the full refname if stripping with negative <N>. Neither is an error. strip can be used as a synonym to lstrip.\n**objecttype**: The type of the object (blob, tree, commit, tag).\n**objectsize**: The size of the object (the same as git cat-file -s reports). Append :disk to get the size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the CAVEATS section below.\n**objectname**: The object name (aka SHA-1). For a non-ambiguous abbreviation of the object name append :short. For an abbreviation of the object name with desired length append :short=<length>, where the minimum length is MINIMUM_ABBREV. The length may be exceeded to ensure unique object names.\n**deltabase**: This expands to the object name of the delta base for the given object, if it is stored as a delta. Otherwise it expands to the null object name (all zeroes).\n**upstream**: The name of a local ref which can be considered “upstream” from the displayed ref. Respects :short, :lstrip and :rstrip in the same way as refname above. Additionally respects :track to show \"[ahead N, behind M]\" and :trackshort to show the terse version: \">\" (ahead), \"<\" (behind), \"<>\" (ahead and behind), or \"=\" (in sync). :track also prints \"[gone]\" whenever unknown upstream ref is encountered. Append :track,nobracket to show tracking information without brackets (i.e \"ahead N, behind M\"). For any remote-tracking branch %(upstream), %(upstream:remotename) and %(upstream:remoteref) refer to the name of the remote and the name of the tracked remote ref, respectively. In other words, the remote-tracking branch can be updated explicitly and individually by using the refspec %(upstream:remoteref):%(upstream) to fetch from %(upstream:remotename). Has no effect if the ref does not have tracking information associated with it. All the options apart from nobracket are mutually exclusive, but if used together the last option is selected.\n**push**: The name of a local ref which represents the @{push} location for the displayed ref. Respects :short, :lstrip, :rstrip, :track, :trackshort, :remotename, and :remoteref options as upstream does. Produces an empty string if no @{push} ref is configured.\n**HEAD**: * if HEAD matches current ref (the checked out branch), ' ' otherwise.\n**color**: Change output color. Followed by :<colorname>, where color names are described under Values in the \"CONFIGURATION FILE\" section of git-config[1]. For example, %(color:bold red).\n**align**: Left-, middle-, or right-align the content between %(align:…) and %(end). The \"align:\" is followed by width=<width> and position=<position> in any order separated by a comma, where the <position> is either left, right or middle, default being left and <width> is the total length of the content with alignment. For brevity, the \"width=\" and/or \"position=\" prefixes may be omitted, and bare <width> and <position> used instead. For instance, %(align:<width>,<position>). If the contents length is more than the width then no alignment is performed. If used with --quote everything in between %(align:…) and %(end) is quoted, but if nested then only the topmost level performs quoting.\n**if**: Used as %(if)…%(then)…%(end) or %(if)…%(then)…%(else)…%(end). If there is an atom with value or string literal after the %(if) then everything after the %(then) is printed, else if the %(else) atom is used, then everything after %(else) is printed. We ignore space when evaluating the string before %(then), this is useful when we use the %(HEAD) atom which prints either \"*\" or \" \" and we want to apply the if condition only on the HEAD ref. Append \":equals=<string>\" or \":notequals=<string>\" to compare the value between the %(if:…) and %(then) atoms with the given string.\n**symref**: The ref which the given symbolic ref refers to. If not a symbolic ref, nothing is printed. Respects the :short, :lstrip and :rstrip options in the same way as refname above.\n**signature**: The GPG signature of a commit.\n**signature:grade**: Show \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key) and \"N\" for no signature.\n**signature:signer**: The signer of the GPG signature of a commit.\n**signature:key**: The key of the GPG signature of a commit.\n**signature:fingerprint**: The fingerprint of the GPG signature of a commit.\n**signature:primarykeyfingerprint**: The primary key fingerprint of the GPG signature of a commit.\n**signature:trustlevel**: The trust level of the GPG signature of a commit. Possible outputs are ultimate, fully, marginal, never and undefined.\n**worktreepath**: The absolute path to the worktree in which the ref is checked out, if it is checked out in any linked worktree. Empty string otherwise.\n**ahead-behind:<committish>**: Two integers, separated by a space, demonstrating the number of commits ahead and behind, respectively, when comparing the output ref to the <committish> specified in the format.\n**is-base:<committish>**: In at most one row, (<committish>) will appear to indicate the ref that is most likely the ref used as a starting point for the branch that produced <committish>. This choice is made using a heuristic: choose the ref that minimizes the number of commits in the first-parent history of <committish> and not in the first-parent history of the ref. For example, consider the following figure of first-parent histories of several refs: *--*--*--*--*--* refs/heads/A \\ \\ *--*--*--* refs/heads/B \\ \\ \\ \\ * * refs/heads/C \\ \\ *--* refs/heads/D Here, if A, B, and C are the filtered references, and the format string is %(refname):%(is-base:D), then the output would be refs/heads/A: refs/heads/B:(D) refs/heads/C: This is because the first-parent history of D has its earliest intersection with the first-parent histories of the filtered refs at a common first-parent ancestor of B and C and ties are broken by the earliest ref in the sorted order. Note that this token will not appear if the first-parent history of <committish> does not intersect the first-parent histories of the filtered refs.\n**describe[:options]**: A human-readable name, like git-describe[1]; empty string for undescribable commits. The describe string may be followed by a colon and one or more comma-separated options. tags=<bool-value> Instead of only considering annotated tags, consider lightweight tags as well; see the corresponding option in git-describe[1] for details. abbrev=<number> Use at least <number> hexadecimal digits; see the corresponding option in git-describe[1] for details. match=<pattern> Only consider tags matching the given glob(7) pattern, excluding the \"refs/tags/\" prefix; see the corresponding option in git-describe[1] for details. exclude=<pattern> Do not consider tags matching the given glob(7) pattern, excluding the \"refs/tags/\" prefix; see the corresponding option in git-describe[1] for details.\n**tags=<bool-value>**: Instead of only considering annotated tags, consider lightweight tags as well; see the corresponding option in git-describe[1] for details.\n**abbrev=<number>**: Use at least <number> hexadecimal digits; see the corresponding option in git-describe[1] for details.\n**match=<pattern>**: Only consider tags matching the given glob(7) pattern, excluding the \"refs/tags/\" prefix; see the corresponding option in git-describe[1] for details.\n**exclude=<pattern>**: Do not consider tags matching the given glob(7) pattern, excluding the \"refs/tags/\" prefix; see the corresponding option in git-describe[1] for details.\n**tags=<bool-value>**: Instead of only considering annotated tags, consider lightweight tags as well; see the corresponding option in git-describe[1] for details.\n**abbrev=<number>**: Use at least <number> hexadecimal digits; see the corresponding option in git-describe[1] for details.\n**match=<pattern>**: Only consider tags matching the given glob(7) pattern, excluding the \"refs/tags/\" prefix; see the corresponding option in git-describe[1] for details.\n**exclude=<pattern>**: Do not consider tags matching the given glob(7) pattern, excluding the \"refs/tags/\" prefix; see the corresponding option in git-describe[1] for details.\n**raw:size**: The raw data size of the object.\n**contents:size**: The size in bytes of the commit or tag message.\n**contents:subject**: The first paragraph of the message, which typically is a single line, is taken as the \"subject\" of the commit or the tag message. Instead of contents:subject, field subject can also be used to obtain same results. :sanitize can be appended to subject for subject line suitable for filename.\n**contents:body**: The remainder of the commit or the tag message that follows the \"subject\".\n**contents:signature**: The optional GPG signature of the tag.\n**contents:lines=N**: The first N lines of the message.",
        "code_examples": [
          "```bash\n*--*--*--*--*--* refs/heads/A\n\\\n \\\n  *--*--*--* refs/heads/B\n   \\     \\\n    \\     \\\n     *     * refs/heads/C\n      \\\n       \\\n\t*--* refs/heads/D\n```",
          "```bash\nrefs/heads/A:\nrefs/heads/B:(D)\nrefs/heads/C:\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 56,
          "content_length": 20923
        }
      },
      {
        "header": "EXAMPLES",
        "content": "An example directly producing formatted text. Show the most recent 3 tagged commits:\n\nA simple example showing the use of shell eval on the output, demonstrating the use of --shell. List the prefixes of all heads:\n\nA bit more elaborate report on tags, demonstrating that the format may be an entire script:\n\nAn example to show the usage of %(if)…%(then)…%(else)…%(end). This prefixes the current branch with a star.\n\nAn example to show the usage of %(if)…%(then)…%(end). This prints the authorname, if present.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n#!/bin/sh\n\ngit for-each-ref --count=3 --sort='-*authordate' \\\n--format='From: %(*authorname) %(*authoremail)\nSubject: %(*subject)\nDate: %(*authordate)\nRef: %(*refname)\n\n%(*body)\n' 'refs/tags'\n```",
          "```bash\n#!/bin/sh\n\ngit for-each-ref --shell --format=\"ref=%(refname)\" refs/heads | \\\nwhile read entry\ndo\n\teval \"$entry\"\n\techo `dirname $ref`\ndone\n```",
          "```bash\n#!/bin/sh\n\nfmt='\n\tr=%(refname)\n\tt=%(*objecttype)\n\tT=${r#refs/tags/}\n\n\to=%(*objectname)\n\tn=%(*authorname)\n\te=%(*authoremail)\n\ts=%(*subject)\n\td=%(*authordate)\n\tb=%(*body)\n\n\tkind=Tag\n\tif test \"z$t\" = z\n\tthen\n\t\t# could be a lightweight tag\n\t\tt=%(objecttype)\n\t\tkind=\"Lightweight tag\"\n\t\to=%(objectname)\n\t\tn=%(authorname)\n\t\te=%(authoremail)\n\t\ts=%(subject)\n\t\td=%(authordate)\n\t\tb=%(body)\n\tfi\n\techo \"$kind $T points at a $t object $o\"\n\tif test \"z$t\" = zcommit\n\tthen\n\t\techo \"The commit was authored by $n $e\nat $d, and titled\n\n    $s\n\nIts message reads as:\n\"\n\t\techo \"$b\" | sed -e \"s/^/    /\"\n\t\techo\n\tfi\n'\n\neval=`git for-each-ref --shell --format=\"$fmt\" \\\n\t--sort='*objecttype' \\\n\t--sort=-taggerdate \\\n\trefs/tags`\neval \"$eval\"\n```",
          "```bash\ngit for-each-ref --format=\"%(if)%(HEAD)%(then)* %(else)  %(end)%(refname:short)\" refs/heads/\n```",
          "```bash\ngit for-each-ref --format=\"%(refname)%(if)%(authorname)%(then) Authored by: %(authorname)%(end)\"\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 510
        }
      },
      {
        "header": "CAVEATS",
        "content": "Note that the sizes of objects on disk are reported accurately, but care should be taken in drawing conclusions about which refs or objects are responsible for disk usage. The size of a packed non-delta object may be much larger than the size of objects which delta against it, but the choice of which object is the base and which is the delta is arbitrary and is subject to change during a repack.\n\nNote also that multiple copies of an object may be present in the object database; in this case, it is undefined which copy’s size or delta base will be reported.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 562
        }
      },
      {
        "header": "NOTES",
        "content": "When combining multiple --contains and --no-contains filters, only references that contain at least one of the --contains commits and contain none of the --no-contains commits are shown.\n\nWhen combining multiple --merged and --no-merged filters, only references that are reachable from at least one of the --merged commits and from none of the --no-merged commits are shown.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 374
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-for-each-ref",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "Git",
    "summary": "NAME git-hash-object - Compute object ID and optionally create an object from a file\n\ngit-hash-object - Compute object ID and optionally create an object from a file",
    "sections": [
      {
        "header": "NAME",
        "content": "git-hash-object - Compute object ID and optionally create an object from a file",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 79
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Computes the object ID value for an object with specified type with the contents of the named file (which can be outside of the work tree), and optionally writes the resulting object into the object database. Reports its object ID to its standard output. When <type> is not specified, it defaults to \"blob\".",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 307
        }
      },
      {
        "header": "OPTIONS",
        "content": "Specify the type of object to be created (default: \"blob\"). Possible values are commit, tree, blob, and tag.\n\nActually write the object into the object database.\n\nRead the object from standard input instead of from a file.\n\nRead file names from the standard input, one per line, instead of from the command-line.\n\nHash object as if it were located at the given path. The location of the file does not directly influence the hash value, but the path is used to determine which Git filters should be applied to the object before it can be placed in the object database. As a result of applying filters, the actual blob put into the object database may differ from the given file. This option is mainly useful for hashing temporary files located outside of the working directory or files read from stdin.\n\nHash the contents as is, ignoring any input filter that would have been chosen by the attributes mechanism, including the end-of-line conversion. If the file is read from standard input then this is always implied, unless the --path option is given.\n\nAllow --stdin to hash any garbage into a loose object which might not otherwise pass standard object parsing or git-fsck checks. Useful for stress-testing Git itself or reproducing characteristics of corrupt or bogus objects encountered in the wild.\n\n**-t <type>**: Specify the type of object to be created (default: \"blob\"). Possible values are commit, tree, blob, and tag.\n**-w**: Actually write the object into the object database.\n**--stdin**: Read the object from standard input instead of from a file.\n**--stdin-paths**: Read file names from the standard input, one per line, instead of from the command-line.\n**--path**: Hash object as if it were located at the given path. The location of the file does not directly influence the hash value, but the path is used to determine which Git filters should be applied to the object before it can be placed in the object database. As a result of applying filters, the actual blob put into the object database may differ from the given file. This option is mainly useful for hashing temporary files located outside of the working directory or files read from stdin.\n**--no-filters**: Hash the contents as is, ignoring any input filter that would have been chosen by the attributes mechanism, including the end-of-line conversion. If the file is read from standard input then this is always implied, unless the --path option is given.\n**--literally**: Allow --stdin to hash any garbage into a loose object which might not otherwise pass standard object parsing or git-fsck checks. Useful for stress-testing Git itself or reproducing characteristics of corrupt or bogus objects encountered in the wild.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 2704
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-hash-object",
    "doc_type": "git",
    "total_sections": 4
  },
  {
    "title": "Git",
    "summary": "NAME git-ls-files - Show information about files in the index and the working tree\n\ngit-ls-files - Show information about files in the index and the working tree",
    "sections": [
      {
        "header": "NAME",
        "content": "git-ls-files - Show information about files in the index and the working tree",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 77
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "This command merges the file listing in the index with the actual working directory list, and shows different combinations of the two.\n\nSeveral flags can be used to determine which files are shown, and each file may be printed multiple times if there are multiple entries in the index or if multiple statuses are applicable for the relevant file selection options.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 364
        }
      },
      {
        "header": "OPTIONS",
        "content": "Show all files cached in Git’s index, i.e. all tracked files. (This is the default if no -c/-s/-d/-o/-u/-k/-m/--resolve-undo options are specified.)\n\nShow files with an unstaged deletion\n\nShow files with an unstaged modification (note that an unstaged deletion also counts as an unstaged modification)\n\nShow other (i.e. untracked) files in the output\n\nShow only ignored files in the output. Must be used with either an explicit -c or -o. When showing files in the index (i.e. when used with -c), print only those files matching an exclude pattern. When showing \"other\" files (i.e. when used with -o), show only those matched by an exclude pattern. Standard ignore rules are not automatically activated; therefore, at least one of the --exclude* options is required.\n\nShow staged contents' mode bits, object name and stage number in the output.\n\nIf a whole directory is classified as \"other\", show just its name (with a trailing slash) and not its whole contents. Has no effect without -o/--others.\n\nDo not list empty directories. Has no effect without --directory.\n\nShow information about unmerged files in the output, but do not show any other tracked files (forces --stage, overrides --cached).\n\nShow untracked files on the filesystem that need to be removed due to file/directory conflicts for tracked files to be able to be written to the filesystem.\n\nShow files having resolve-undo information in the index together with their resolve-undo information. (resolve-undo information is what is used to implement \"git checkout -m $PATH\", i.e. to recreate merge conflicts that were accidentally resolved)\n\n\\0 line termination on output and do not quote filenames. See OUTPUT below for more information.\n\nWhen only filenames are shown, suppress duplicates that may come from having multiple stages during a merge, or giving --deleted and --modified option at the same time. When any of the -t, --unmerged, or --stage option is in use, this option has no effect.\n\nSkip untracked files matching pattern. Note that pattern is a shell wildcard pattern. See EXCLUDE PATTERNS below for more information.\n\nRead exclude patterns from <file>; 1 per line.\n\nRead additional exclude patterns that apply only to the directory and its subdirectories in <file>. If you are trying to emulate the way Porcelain commands work, using the --exclude-standard option instead is easier and more thorough.\n\nAdd the standard Git exclusions: .git/info/exclude, .gitignore in each directory, and the user’s global exclusion file.\n\nIf any <file> does not appear in the index, treat this as an error (return 1).\n\nWhen using --error-unmatch to expand the user supplied <file> (i.e. path pattern) arguments to paths, pretend that paths which were removed in the index since the named <tree-ish> are still present. Using this option with -s or -u options does not make any sense.\n\nShow status tags together with filenames. Note that for scripting purposes, git-status[1] --porcelain and git-diff-files[1] --name-status are almost always superior alternatives; users should look at git-status[1] --short or git-diff[1] --name-status for more user-friendly alternatives.\n\nThis option provides a reason for showing each filename, in the form of a status tag (which is followed by a space and then the filename). The status tags are all single characters from the following list:\n\ntracked file that is not either unmerged or skip-worktree\n\ntracked file that is skip-worktree\n\ntracked file that is unmerged\n\ntracked file with unstaged removal/deletion\n\ntracked file with unstaged modification/change\n\nuntracked paths which are part of file/directory conflicts which prevent checking out tracked files\n\nfile with resolve-undo information\n\nSimilar to -t, but use lowercase letters for files that are marked as assume unchanged (see git-update-index[1]).\n\nSimilar to -t, but use lowercase letters for files that are marked as fsmonitor valid (see git-update-index[1]).\n\nWhen run from a subdirectory, the command usually outputs paths relative to the current directory. This option forces paths to be output relative to the project top directory.\n\nRecursively calls ls-files on each active submodule in the repository. Currently there is only support for the --cached and --stage modes.\n\nInstead of showing the full 40-byte hexadecimal object lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. Non default number of digits can be specified with --abbrev=<n>.\n\nAfter each line that describes a file, add more data about its cache entry. This is intended to show as much information as possible for manual inspection; the exact format may change at any time.\n\nShow <eolinfo> and <eolattr> of files. <eolinfo> is the file content identification used by Git when the \"text\" attribute is \"auto\" (or not set and core.autocrlf is not false). <eolinfo> is either \"-text\", \"none\", \"lf\", \"crlf\", \"mixed\" or \"\".\n\n\"\" means the file is not a regular file, it is not in the index or not accessible in the working tree.\n\n<eolattr> is the attribute that is used when checking out or committing, it is either \"\", \"-text\", \"text\", \"text=auto\", \"text eol=lf\", \"text eol=crlf\". Since Git 2.10 \"text=auto eol=lf\" and \"text=auto eol=crlf\" are supported.\n\nBoth the <eolinfo> in the index (\"i/<eolinfo>\") and in the working tree (\"w/<eolinfo>\") are shown for regular files, followed by the (\"attr/<eolattr>\").\n\nIf the index is sparse, show the sparse directories without expanding to the contained files. Sparse directories will be shown with a trailing slash, such as \"x/\" for a sparse directory \"x\".\n\nA string that interpolates %(fieldname) from the result being shown. It also interpolates %% to %, and %xXX where XX are hex digits interpolates to character with hex code XX; for example %x00 interpolates to \\0 (NUL), %x09 to \\t (TAB) and %x0a to \\n (LF). --format cannot be combined with -s, -o, -k, -t, --resolve-undo and --eol.\n\nDo not interpret any more arguments as options.\n\nFiles to show. If no files are given all files which match the other specified criteria are shown.\n\n**-c**: Show all files cached in Git’s index, i.e. all tracked files. (This is the default if no -c/-s/-d/-o/-u/-k/-m/--resolve-undo options are specified.)\n**--cached**: Show files with an unstaged deletion\n**-d**: Show files with an unstaged modification (note that an unstaged deletion also counts as an unstaged modification)\n**--deleted**: Show other (i.e. untracked) files in the output\n**-m**: Show only ignored files in the output. Must be used with either an explicit -c or -o. When showing files in the index (i.e. when used with -c), print only those files matching an exclude pattern. When showing \"other\" files (i.e. when used with -o), show only those matched by an exclude pattern. Standard ignore rules are not automatically activated; therefore, at least one of the --exclude* options is required.\n**--modified**: Show staged contents' mode bits, object name and stage number in the output.\n**-o**: If a whole directory is classified as \"other\", show just its name (with a trailing slash) and not its whole contents. Has no effect without -o/--others.\n**--others**: Do not list empty directories. Has no effect without --directory.\n**-i**: Show information about unmerged files in the output, but do not show any other tracked files (forces --stage, overrides --cached).\n**--ignored**: Show untracked files on the filesystem that need to be removed due to file/directory conflicts for tracked files to be able to be written to the filesystem.\n**-s**: Show files having resolve-undo information in the index together with their resolve-undo information. (resolve-undo information is what is used to implement \"git checkout -m $PATH\", i.e. to recreate merge conflicts that were accidentally resolved)\n**--stage**: \\0 line termination on output and do not quote filenames. See OUTPUT below for more information.\n**--directory**: When only filenames are shown, suppress duplicates that may come from having multiple stages during a merge, or giving --deleted and --modified option at the same time. When any of the -t, --unmerged, or --stage option is in use, this option has no effect.\n**--no-empty-directory**: Skip untracked files matching pattern. Note that pattern is a shell wildcard pattern. See EXCLUDE PATTERNS below for more information.\n**-u**: Read exclude patterns from <file>; 1 per line.\n**--unmerged**: Read additional exclude patterns that apply only to the directory and its subdirectories in <file>. If you are trying to emulate the way Porcelain commands work, using the --exclude-standard option instead is easier and more thorough.\n**-k**: Add the standard Git exclusions: .git/info/exclude, .gitignore in each directory, and the user’s global exclusion file.\n**--killed**: If any <file> does not appear in the index, treat this as an error (return 1).\n**--resolve-undo**: When using --error-unmatch to expand the user supplied <file> (i.e. path pattern) arguments to paths, pretend that paths which were removed in the index since the named <tree-ish> are still present. Using this option with -s or -u options does not make any sense.\n**-z**: Show status tags together with filenames. Note that for scripting purposes, git-status[1] --porcelain and git-diff-files[1] --name-status are almost always superior alternatives; users should look at git-status[1] --short or git-diff[1] --name-status for more user-friendly alternatives. This option provides a reason for showing each filename, in the form of a status tag (which is followed by a space and then the filename). The status tags are all single characters from the following list: H tracked file that is not either unmerged or skip-worktree S tracked file that is skip-worktree M tracked file that is unmerged R tracked file with unstaged removal/deletion C tracked file with unstaged modification/change K untracked paths which are part of file/directory conflicts which prevent checking out tracked files ? untracked file U file with resolve-undo information\n**--deduplicate**: tracked file that is not either unmerged or skip-worktree\n**-x <pattern>**: tracked file that is skip-worktree\n**--exclude=<pattern>**: tracked file that is unmerged\n**-X <file>**: tracked file with unstaged removal/deletion\n**--exclude-from=<file>**: tracked file with unstaged modification/change\n**--exclude-per-directory=<file>**: untracked paths which are part of file/directory conflicts which prevent checking out tracked files\n**--exclude-standard**: untracked file\n**--error-unmatch**: file with resolve-undo information\n**--with-tree=<tree-ish>**: Similar to -t, but use lowercase letters for files that are marked as assume unchanged (see git-update-index[1]).\n**-t**: Similar to -t, but use lowercase letters for files that are marked as fsmonitor valid (see git-update-index[1]).\n**H**: When run from a subdirectory, the command usually outputs paths relative to the current directory. This option forces paths to be output relative to the project top directory.\n**S**: Recursively calls ls-files on each active submodule in the repository. Currently there is only support for the --cached and --stage modes.\n**M**: Instead of showing the full 40-byte hexadecimal object lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. Non default number of digits can be specified with --abbrev=<n>.\n**R**: After each line that describes a file, add more data about its cache entry. This is intended to show as much information as possible for manual inspection; the exact format may change at any time.\n**C**: Show <eolinfo> and <eolattr> of files. <eolinfo> is the file content identification used by Git when the \"text\" attribute is \"auto\" (or not set and core.autocrlf is not false). <eolinfo> is either \"-text\", \"none\", \"lf\", \"crlf\", \"mixed\" or \"\". \"\" means the file is not a regular file, it is not in the index or not accessible in the working tree. <eolattr> is the attribute that is used when checking out or committing, it is either \"\", \"-text\", \"text\", \"text=auto\", \"text eol=lf\", \"text eol=crlf\". Since Git 2.10 \"text=auto eol=lf\" and \"text=auto eol=crlf\" are supported. Both the <eolinfo> in the index (\"i/<eolinfo>\") and in the working tree (\"w/<eolinfo>\") are shown for regular files, followed by the (\"attr/<eolattr>\").\n**K**: If the index is sparse, show the sparse directories without expanding to the contained files. Sparse directories will be shown with a trailing slash, such as \"x/\" for a sparse directory \"x\".\n**?**: A string that interpolates %(fieldname) from the result being shown. It also interpolates %% to %, and %xXX where XX are hex digits interpolates to character with hex code XX; for example %x00 interpolates to \\0 (NUL), %x09 to \\t (TAB) and %x0a to \\n (LF). --format cannot be combined with -s, -o, -k, -t, --resolve-undo and --eol.\n**U**: Do not interpret any more arguments as options.\n**-v**: Files to show. If no files are given all files which match the other specified criteria are shown.\n**H**: tracked file that is not either unmerged or skip-worktree\n**S**: tracked file that is skip-worktree\n**M**: tracked file that is unmerged\n**R**: tracked file with unstaged removal/deletion\n**C**: tracked file with unstaged modification/change\n**K**: untracked paths which are part of file/directory conflicts which prevent checking out tracked files\n**?**: untracked file\n**U**: file with resolve-undo information",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 42,
          "content_length": 13445
        }
      },
      {
        "header": "OUTPUT",
        "content": "git ls-files just outputs the filenames unless --stage is specified in which case it outputs:\n\ngit ls-files --eol will show i/<eolinfo><SPACES>w/<eolinfo><SPACES>attr/<eolattr><SPACE*><TAB><file>\n\ngit ls-files --unmerged and git ls-files --stage can be used to examine detailed information on unmerged paths.\n\nFor an unmerged path, instead of recording a single mode/SHA-1 pair, the index records up to three such pairs; one from tree O in stage 1, A in stage 2, and B in stage 3. This information can be used by the user (or the porcelain) to see what should eventually be recorded at the path. (see git-read-tree[1] for more information on state)\n\nWithout the -z option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]). Using -z the filename is output verbatim and the line is terminated by a NUL byte.\n\nIt is possible to print in a custom format by using the --format option, which is able to interpolate different fields using a %(fieldname) notation. For example, if you only care about the \"objectname\" and \"path\" fields, you can execute with a specific \"--format\" like",
        "code_examples": [
          "```bash\n[<tag>]<mode><object><stage> <file>\n```"
        ],
        "usage_examples": [
          "```bash\ngit ls-files --format='%(objectname) %(path)'\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 1153
        }
      },
      {
        "header": "FIELD NAMES",
        "content": "The way each path is shown can be customized by using the --format=<format> option, where the %(fieldname) in the <format> string for various aspects of the index entry are interpolated. The following \"fieldname\" are understood:\n\nThe mode of the file which is recorded in the index.\n\nThe object type of the file which is recorded in the index.\n\nThe name of the file which is recorded in the index.\n\nThe object size of the file which is recorded in the index (\"-\" if the object is a commit or tree). It also supports a padded format of size with \"%(objectsize:padded)\".\n\nThe stage of the file which is recorded in the index.\n\nThe <eolinfo> (see the description of the --eol option) of the contents in the index or in the worktree for the path.\n\nThe <eolattr> (see the description of the --eol option) that applies to the path.\n\nThe pathname of the file which is recorded in the index.\n\n**objectmode**: The mode of the file which is recorded in the index.\n**objecttype**: The object type of the file which is recorded in the index.\n**objectname**: The name of the file which is recorded in the index.\n**objectsize[:padded]**: The object size of the file which is recorded in the index (\"-\" if the object is a commit or tree). It also supports a padded format of size with \"%(objectsize:padded)\".\n**stage**: The stage of the file which is recorded in the index.\n**eolinfo:index**: The <eolinfo> (see the description of the --eol option) of the contents in the index or in the worktree for the path.\n**eolinfo:worktree**: The <eolattr> (see the description of the --eol option) that applies to the path.\n**eolattr**: The pathname of the file which is recorded in the index.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 1669
        }
      },
      {
        "header": "EXCLUDE PATTERNS",
        "content": "git ls-files can use a list of \"exclude patterns\" when traversing the directory tree and finding files to show when the flags --others or --ignored are specified. gitignore[5] specifies the format of exclude patterns.\n\nThese exclude patterns can be specified from the following places, in order:\n\nThe command-line flag --exclude=<pattern> specifies a single pattern. Patterns are ordered in the same order they appear in the command line.\n\nThe command-line flag --exclude-from=<file> specifies a file containing a list of patterns. Patterns are ordered in the same order they appear in the file.\n\nThe command-line flag --exclude-per-directory=<name> specifies a name of the file in each directory git ls-files examines, normally .gitignore. Files in deeper directories take precedence. Patterns are ordered in the same order they appear in the files.\n\nA pattern specified on the command line with --exclude or read from the file specified with --exclude-from is relative to the top of the directory tree. A pattern read from a file specified by --exclude-per-directory is relative to the directory that the pattern file appears in.\n\nGenerally, you should be able to use --exclude-standard when you want the exclude rules applied the same way as what Porcelain commands do. To emulate what --exclude-standard specifies, you can give --exclude-per-directory=.gitignore, and then specify:\n\nThe file specified by the core.excludesfile configuration variable, if exists, or the $XDG_CONFIG_HOME/git/ignore file.\n\nThe $GIT_DIR/info/exclude file.\n\nvia the --exclude-from= option.\n\n• The command-line flag --exclude=<pattern> specifies a single pattern. Patterns are ordered in the same order they appear in the command line.\n• The command-line flag --exclude-from=<file> specifies a file containing a list of patterns. Patterns are ordered in the same order they appear in the file.\n• The command-line flag --exclude-per-directory=<name> specifies a name of the file in each directory git ls-files examines, normally .gitignore. Files in deeper directories take precedence. Patterns are ordered in the same order they appear in the files.\n\n• The file specified by the core.excludesfile configuration variable, if exists, or the $XDG_CONFIG_HOME/git/ignore file.\n• The $GIT_DIR/info/exclude file.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 2288
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-read-tree[1], gitignore[5]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 30
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-ls-files",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "Git",
    "summary": "NAME git-ls-tree - List the contents of a tree object\n\nSYNOPSIS git ls-tree [-d] [-r] [-t] [-l] [-z] [--name-only] [--name-status] [--object-only] [--full-name] [--full-tree] [--abbrev[=<n>]] [--format=<format>] <tree-ish> [<path>…]",
    "sections": [
      {
        "header": "NAME",
        "content": "git-ls-tree - List the contents of a tree object",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 48
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Lists the contents of a given tree object, like what \"/bin/ls -a\" does in the current working directory. Note that:\n\nthe behaviour is slightly different from that of \"/bin/ls\" in that the <path> denotes just a list of patterns to match, e.g. so specifying directory name (without -r) will behave differently, and order of the arguments does not matter.\n\nthe behaviour is similar to that of \"/bin/ls\" in that the <path> is taken as relative to the current working directory. E.g. when you are in a directory sub that has a directory dir, you can run git ls-tree -r HEAD dir to list the contents of the tree (that is sub/dir in HEAD). You don’t want to give a tree that is not at the root level (e.g. git ls-tree -r HEAD:sub dir) in this case, as that would result in asking for sub/sub/dir in the HEAD commit. However, the current working directory can be ignored by passing --full-tree option.\n\n• the behaviour is slightly different from that of \"/bin/ls\" in that the <path> denotes just a list of patterns to match, e.g. so specifying directory name (without -r) will behave differently, and order of the arguments does not matter.\n• the behaviour is similar to that of \"/bin/ls\" in that the <path> is taken as relative to the current working directory. E.g. when you are in a directory sub that has a directory dir, you can run git ls-tree -r HEAD dir to list the contents of the tree (that is sub/dir in HEAD). You don’t want to give a tree that is not at the root level (e.g. git ls-tree -r HEAD:sub dir) in this case, as that would result in asking for sub/sub/dir in the HEAD commit. However, the current working directory can be ignored by passing --full-tree option.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1674
        }
      },
      {
        "header": "OPTIONS",
        "content": "Show only the named tree entry itself, not its children.\n\nRecurse into sub-trees.\n\nShow tree entries even when going to recurse them. Has no effect if -r was not passed. -d implies -t.\n\nShow object size of blob (file) entries.\n\n\\0 line termination on output and do not quote filenames. See OUTPUT FORMAT below for more information.\n\nList only filenames (instead of the \"long\" output), one per line. Cannot be combined with --object-only.\n\nList only names of the objects, one per line. Cannot be combined with --name-only or --name-status. This is equivalent to specifying --format='%(objectname), but for both this option and that exact format the command takes a hand-optimized codepath instead of going through the generic formatting mechanism.\n\nInstead of showing the full 40-byte hexadecimal object lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. Non default number of digits can be specified with --abbrev=<n>.\n\nInstead of showing the path names relative to the current working directory, show the full path names.\n\nDo not limit the listing to the current working directory. Implies --full-name.\n\nA string that interpolates %(fieldname) from the result being shown. It also interpolates %% to %, and %xNN where NN are hex digits interpolates to character with hex code NN; for example %x00 interpolates to \\0 (NUL), %x09 to \\t (TAB) and %x0a to \\n (LF). When specified, --format cannot be combined with other format-altering options, including --long, --name-only and --object-only.\n\nWhen paths are given, show them (note that this isn’t really raw pathnames, but rather a list of patterns to match). Otherwise implicitly uses the root level of the tree as the sole path argument.\n\n**<tree-ish>**: Id of a tree-ish.\n**-d**: Show only the named tree entry itself, not its children.\n**-r**: Recurse into sub-trees.\n**-t**: Show tree entries even when going to recurse them. Has no effect if -r was not passed. -d implies -t.\n**-l**: Show object size of blob (file) entries.\n**--long**: \\0 line termination on output and do not quote filenames. See OUTPUT FORMAT below for more information.\n**-z**: List only filenames (instead of the \"long\" output), one per line. Cannot be combined with --object-only.\n**--name-only**: List only names of the objects, one per line. Cannot be combined with --name-only or --name-status. This is equivalent to specifying --format='%(objectname), but for both this option and that exact format the command takes a hand-optimized codepath instead of going through the generic formatting mechanism.\n**--name-status**: Instead of showing the full 40-byte hexadecimal object lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. Non default number of digits can be specified with --abbrev=<n>.\n**--object-only**: Instead of showing the path names relative to the current working directory, show the full path names.\n**--abbrev[=<n>]**: Do not limit the listing to the current working directory. Implies --full-name.\n**--full-name**: A string that interpolates %(fieldname) from the result being shown. It also interpolates %% to %, and %xNN where NN are hex digits interpolates to character with hex code NN; for example %x00 interpolates to \\0 (NUL), %x09 to \\t (TAB) and %x0a to \\n (LF). When specified, --format cannot be combined with other format-altering options, including --long, --name-only and --object-only.\n**--full-tree**: When paths are given, show them (note that this isn’t really raw pathnames, but rather a list of patterns to match). Otherwise implicitly uses the root level of the tree as the sole path argument.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 12,
          "content_length": 3662
        }
      },
      {
        "header": "Output Format",
        "content": "The output format of ls-tree is determined by either the --format option, or other format-altering options such as --name-only etc. (see --format above).\n\nThe use of certain --format directives is equivalent to using those options, but invoking the full formatting machinery can be slower than using an appropriate formatting option.\n\nIn cases where the --format would exactly map to an existing option ls-tree will use the appropriate faster path. Thus the default format is equivalent to:\n\nThis output format is compatible with what --index-info --stdin of git update-index expects.\n\nWhen the -l option is used, format changes to\n\nObject size identified by <objectname> is given in bytes, and right-justified with minimum width of 7 characters. Object size is given only for blobs (file) entries; for other entries - character is used in place of size.\n\nWithout the -z option, pathnames with \"unusual\" characters are quoted as explained for the configuration variable core.quotePath (see git-config[1]). Using -z the filename is output verbatim and the line is terminated by a NUL byte.\n\nIt is possible to print in a custom format by using the --format option, which is able to interpolate different fields using a %(fieldname) notation. For example, if you only care about the \"objectname\" and \"path\" fields, you can execute with a specific \"--format\" like",
        "code_examples": [
          "```bash\n%(objectmode) %(objecttype) %(objectname)%x09%(path)\n```",
          "```bash\n%(objectmode) %(objecttype) %(objectname) %(objectsize:padded)%x09%(path)\n```"
        ],
        "usage_examples": [
          "```bash\ngit ls-tree --format='%(objectname) %(path)'<tree-ish>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1359
        }
      },
      {
        "header": "FIELD NAMES",
        "content": "Various values from structured fields can be used to interpolate into the resulting output. For each outputting line, the following names can be used:\n\nThe mode of the object.\n\nThe type of the object (commit, blob or tree).\n\nThe name of the object.\n\nThe size of a blob object (\"-\" if it’s a commit or tree). It also supports a padded format of size with \"%(objectsize:padded)\".\n\nThe pathname of the object.\n\n**objectmode**: The mode of the object.\n**objecttype**: The type of the object (commit, blob or tree).\n**objectname**: The name of the object.\n**objectsize[:padded]**: The size of a blob object (\"-\" if it’s a commit or tree). It also supports a padded format of size with \"%(objectsize:padded)\".\n**path**: The pathname of the object.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 741
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-ls-tree",
    "doc_type": "git",
    "total_sections": 6
  },
  {
    "title": "Git",
    "summary": "NAME git-merge-base - Find as good common ancestors as possible for a merge\n\ngit-merge-base - Find as good common ancestors as possible for a merge",
    "sections": [
      {
        "header": "NAME",
        "content": "git-merge-base - Find as good common ancestors as possible for a merge",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 70
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "git merge-base finds the best common ancestor(s) between two commits to use in a three-way merge. One common ancestor is better than another common ancestor if the latter is an ancestor of the former. A common ancestor that does not have any better common ancestor is a best common ancestor, i.e. a merge base. Note that there can be more than one merge base for a pair of commits.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 381
        }
      },
      {
        "header": "OPERATION MODES",
        "content": "In the most common special case, specifying only two commits on the command line means computing the merge base between the given two commits.\n\nMore generally, among the two commits to compute the merge base from, one is specified by the first commit argument on the command line; the other commit is a (possibly hypothetical) commit that is a merge across all the remaining commits on the command line.\n\nAs a consequence, the merge base is not necessarily contained in each of the commit arguments if more than two commits are specified. This is different from git-show-branch[1] when used with the --merge-base option.\n\nCompute the best common ancestors of all supplied commits, in preparation for an n-way merge. This mimics the behavior of git show-branch --merge-base.\n\nInstead of printing merge bases, print a minimal subset of the supplied commits with the same ancestors. In other words, among the commits given, list those which cannot be reached from any other. This mimics the behavior of git show-branch --independent.\n\nCheck if the first <commit> is an ancestor of the second <commit>, and exit with status 0 if true, or with status 1 if not. Errors are signaled by a non-zero status that is not 1.\n\nFind the point at which a branch (or any history that leads to <commit>) forked from another branch (or any reference) <ref>. This does not just look for the common ancestor of the two commits, but also takes into account the reflog of <ref> to see if the history leading to <commit> forked from an earlier incarnation of the branch <ref> (see discussion of this mode below).\n\n**--octopus**: Compute the best common ancestors of all supplied commits, in preparation for an n-way merge. This mimics the behavior of git show-branch --merge-base.\n**--independent**: Instead of printing merge bases, print a minimal subset of the supplied commits with the same ancestors. In other words, among the commits given, list those which cannot be reached from any other. This mimics the behavior of git show-branch --independent.\n**--is-ancestor**: Check if the first <commit> is an ancestor of the second <commit>, and exit with status 0 if true, or with status 1 if not. Errors are signaled by a non-zero status that is not 1.\n**--fork-point**: Find the point at which a branch (or any history that leads to <commit>) forked from another branch (or any reference) <ref>. This does not just look for the common ancestor of the two commits, but also takes into account the reflog of <ref> to see if the history leading to <commit> forked from an earlier incarnation of the branch <ref> (see discussion of this mode below).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 2624
        }
      },
      {
        "header": "OPTIONS",
        "content": "Output all merge bases for the commits, instead of just one.\n\n**-a**: Output all merge bases for the commits, instead of just one.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 130
        }
      },
      {
        "header": "DISCUSSION",
        "content": "Given two commits A and B, git merge-base A B will output a commit which is reachable from both A and B through the parent relationship.\n\nFor example, with this topology:\n\nthe merge base between A and B is 1.\n\nGiven three commits A, B, and C, git merge-base A B C will compute the merge base between A and a hypothetical commit M, which is a merge between B and C. For example, with this topology:\n\nthe result of git merge-base A B C is 1. This is because the equivalent topology with a merge commit M between B and C is:\n\nand the result of git merge-base A M is 1. Commit 2 is also a common ancestor between A and M, but 1 is a better common ancestor, because 2 is an ancestor of 1. Hence, 2 is not a merge base.\n\nThe result of git merge-base --octopus A B C is 2, because 2 is the best common ancestor of all commits.\n\nWhen the history involves criss-cross merges, there can be more than one best common ancestor for two commits. For example, with this topology:\n\nboth 1 and 2 are merge bases of A and B. Neither one is better than the other (both are best merge bases). When the --all option is not given, it is unspecified which best one is output.\n\nA common idiom to check \"fast-forward-ness\" between two commits A and B is (or at least used to be) to compute the merge base between A and B, and check if it is the same as A, in which case, A is an ancestor of B. You will see this idiom used often in older scripts.\n\nIn modern git, you can say this in a more direct way:",
        "code_examples": [
          "```bash\no---o---o---B\n\t/\n---o---1---o---o---o---A\n```",
          "```bash\no---o---o---o---C\n      /\n     /   o---o---o---B\n    /   /\n---2---1---o---o---o---A\n```",
          "```bash\no---o---o---o---o\n      /                 \\\n     /   o---o---o---o---M\n    /   /\n---2---1---o---o---o---A\n```",
          "```bash\n---1---o---A\n    \\ /\n     X\n    / \\\n---2---o---o---B\n```"
        ],
        "usage_examples": [
          "```bash\nA=$(git rev-parse --verify A)\nif test \"$A\" = \"$(git merge-base A B)\"\nthen\n\t... A is an ancestor of B ...\nfi\n```",
          "```bash\nif git merge-base --is-ancestor A B\nthen\n\t... A is an ancestor of B ...\nfi\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 11,
          "content_length": 1476
        }
      },
      {
        "header": "Discussion on fork-point mode",
        "content": "After working on the topic branch created with git switch -c topic origin/master, the history of remote-tracking branch origin/master may have been rewound and rebuilt, leading to a history of this shape:\n\nwhere origin/master used to point at commits B0, B1, B2 and now it points at B, and your topic branch was started on top of it back when origin/master was at B0, and you built three commits, D0, D1, and D, on top of it. Imagine that you now want to rebase the work you did on the topic on top of the updated origin/master.\n\nIn such a case, git merge-base origin/master topic would return the parent of B0 in the above picture, but B0^..D is not the range of commits you would want to replay on top of B (it includes B0, which is not what you wrote; it is a commit the other side discarded when it moved its tip from B0 to B1).\n\ngit merge-base --fork-point origin/master topic is designed to help in such a case. It takes not only B but also B0, B1, and B2 (i.e. old tips of the remote-tracking branches your repository’s reflog knows about) into account to see on which commit your topic branch was built and finds B0, allowing you to replay only the commits on your topic, excluding the commits the other side later discarded.\n\nwill replay D0, D1, and D on top of B to create a new history of this shape:\n\nA caveat is that older reflog entries in your repository may be expired by git gc. If B0 no longer appears in the reflog of the remote-tracking branch origin/master, the --fork-point mode obviously cannot find it and fails, avoiding to give a random and useless result (such as the parent of B0, like the same command without the --fork-point option gives).\n\nAlso, the remote-tracking branch you use the --fork-point mode with must be the one your topic forked from its tip. If you forked from an older commit than the tip, this mode would not find the fork point (imagine in the above sample history B0 did not exist, origin/master started at B1, moved to B2 and then B, and you forked your topic at origin/master^ when origin/master was B1; the shape of the history would be the same as above, without B0, and the parent of B1 is what git merge-base origin/master topic correctly finds, but the --fork-point mode will not, because it is not one of the commits that used to be at the tip of origin/master).",
        "code_examples": [
          "```bash\no---B2\n\t\t/\n---o---o---B1--o---o---o---B (origin/master)\n\t\\\n\t B0\n\t  \\\n\t   D0---D1---D (topic)\n```",
          "```bash\no---B2\n\t\t/\n---o---o---B1--o---o---o---B (origin/master)\n\t\\                   \\\n\t B0                  D0'--D1'--D' (topic - updated)\n\t  \\\n\t   D0---D1---D (topic - old)\n```"
        ],
        "usage_examples": [
          "```bash\n$ fork_point=$(git merge-base --fork-point origin/master topic)\n```",
          "```bash\n$ git rebase --onto origin/master $fork_point topic\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 2320
        }
      },
      {
        "header": "See also",
        "content": "git-rev-list[1], git-show-branch[1], git-merge[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 49
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-merge-base",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "Git",
    "summary": "NAME git-read-tree - Reads tree information into the index\n\ngit-read-tree - Reads tree information into the index",
    "sections": [
      {
        "header": "NAME",
        "content": "git-read-tree - Reads tree information into the index",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 53
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Reads the tree information given by <tree-ish> into the index, but does not actually update any of the files it \"caches\". (see: git-checkout-index[1])\n\nOptionally, it can merge a tree into the index, perform a fast-forward (i.e. 2-way) merge, or a 3-way merge, with the -m flag. When used with -m, the -u flag causes it to also update the files in the work tree with the result of the merge.\n\nOnly trivial merges are done by git read-tree itself. Only conflicting paths will be in an unmerged state when git read-tree returns.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 526
        }
      },
      {
        "header": "OPTIONS",
        "content": "Perform a merge, not just a read. The command will refuse to run if your index file has unmerged entries, indicating that you have not finished a previous merge you started.\n\nSame as -m, except that unmerged entries are discarded instead of failing. When used with -u, updates leading to loss of working tree changes or untracked files or directories will not abort the operation.\n\nAfter a successful merge, update the files in the work tree with the result of the merge.\n\nUsually a merge requires the index file as well as the files in the working tree to be up to date with the current head commit, in order not to lose local changes. This flag disables the check with the working tree and is meant to be used when creating a merge of trees that are not directly related to the current working tree status into a temporary index file.\n\nCheck if the command would error out, without updating the index or the files in the working tree for real.\n\nShow the progress of checking files out.\n\nRestrict three-way merge by git read-tree to happen only if there is no file-level merging required, instead of resolving merge for trivial cases and leaving conflicting files unresolved in the index.\n\nUsually a three-way merge by git read-tree resolves the merge for really trivial cases and leaves other cases unresolved in the index, so that porcelains can implement different merge policies. This flag makes the command resolve a few more cases internally:\n\nwhen one side removes a path and the other side leaves the path unmodified. The resolution is to remove that path.\n\nwhen both sides remove a path. The resolution is to remove that path.\n\nwhen both sides add a path identically. The resolution is to add that path.\n\nKeep the current index contents, and read the contents of the named tree-ish under the directory at <prefix>. The command will refuse to overwrite entries that already existed in the original index file.\n\nInstead of writing the results out to $GIT_INDEX_FILE, write the resulting index in the named file. While the command is operating, the original index file is locked with the same mechanism as usual. The file must allow to be rename(2)ed into from a temporary file that is created next to the usual index file; typically this means it needs to be on the same filesystem as the index file itself, and you need write permission to the directories the index file and index output file are located in.\n\nUsing --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules' HEAD to be detached at that commit.\n\nDisable sparse checkout support even if core.sparseCheckout is true.\n\nInstead of reading tree object(s) into the index, just empty it.\n\nQuiet, suppress feedback messages.\n\nThe id of the tree object(s) to be read/merged.\n\n• when one side removes a path and the other side leaves the path unmodified. The resolution is to remove that path.\n• when both sides remove a path. The resolution is to remove that path.\n• when both sides add a path identically. The resolution is to add that path.\n\n**-m**: Perform a merge, not just a read. The command will refuse to run if your index file has unmerged entries, indicating that you have not finished a previous merge you started.\n**--reset**: Same as -m, except that unmerged entries are discarded instead of failing. When used with -u, updates leading to loss of working tree changes or untracked files or directories will not abort the operation.\n**-u**: After a successful merge, update the files in the work tree with the result of the merge.\n**-i**: Usually a merge requires the index file as well as the files in the working tree to be up to date with the current head commit, in order not to lose local changes. This flag disables the check with the working tree and is meant to be used when creating a merge of trees that are not directly related to the current working tree status into a temporary index file.\n**-n**: Check if the command would error out, without updating the index or the files in the working tree for real.\n**--dry-run**: Show the progress of checking files out.\n**-v**: Restrict three-way merge by git read-tree to happen only if there is no file-level merging required, instead of resolving merge for trivial cases and leaving conflicting files unresolved in the index.\n**--trivial**: Usually a three-way merge by git read-tree resolves the merge for really trivial cases and leaves other cases unresolved in the index, so that porcelains can implement different merge policies. This flag makes the command resolve a few more cases internally: when one side removes a path and the other side leaves the path unmodified. The resolution is to remove that path. when both sides remove a path. The resolution is to remove that path. when both sides add a path identically. The resolution is to add that path.\n**--aggressive**: Keep the current index contents, and read the contents of the named tree-ish under the directory at <prefix>. The command will refuse to overwrite entries that already existed in the original index file.\n**--prefix=<prefix>**: Instead of writing the results out to $GIT_INDEX_FILE, write the resulting index in the named file. While the command is operating, the original index file is locked with the same mechanism as usual. The file must allow to be rename(2)ed into from a temporary file that is created next to the usual index file; typically this means it needs to be on the same filesystem as the index file itself, and you need write permission to the directories the index file and index output file are located in.\n**--index-output=<file>**: Using --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules' HEAD to be detached at that commit.\n**--[no-]recurse-submodules**: Disable sparse checkout support even if core.sparseCheckout is true.\n**--no-sparse-checkout**: Instead of reading tree object(s) into the index, just empty it.\n**--empty**: Quiet, suppress feedback messages.\n**-q**: The id of the tree object(s) to be read/merged.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 18,
          "content_length": 6216
        }
      },
      {
        "header": "MERGING",
        "content": "If -m is specified, git read-tree can perform 3 kinds of merge, a single tree merge if only 1 tree is given, a fast-forward merge with 2 trees, or a 3-way merge if 3 or more trees are provided.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 193
        }
      },
      {
        "header": "Single Tree Merge",
        "content": "If only 1 tree is specified, git read-tree operates as if the user did not specify -m, except that if the original index has an entry for a given pathname, and the contents of the path match with the tree being read, the stat info from the index is used. (In other words, the index’s stat()s take precedence over the merged tree’s).\n\nThat means that if you do a git read-tree -m <newtree> followed by a git checkout-index -f -u -a, the git checkout-index only checks out the stuff that really changed.\n\nThis is used to avoid unnecessary false hits when git diff-files is run after git read-tree.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 595
        }
      },
      {
        "header": "Two Tree Merge",
        "content": "Typically, this is invoked as git read-tree -m $H $M, where $H is the head commit of the current repository, and $M is the head of a foreign tree, which is simply ahead of $H (i.e. we are in a fast-forward situation).\n\nWhen two trees are specified, the user is telling git read-tree the following:\n\nThe current index and work tree is derived from $H, but the user may have local changes in them since $H.\n\nThe user wants to fast-forward to $M.\n\nIn this case, the git read-tree -m $H $M command makes sure that no local change is lost as the result of this \"merge\". Here are the \"carry forward\" rules, where \"I\" denotes the index, \"clean\" means that index and work tree coincide, and \"exists\"/\"nothing\" refer to the presence of a path in the specified commit:\n\nIn all \"keep index\" cases, the index entry stays as in the original index file. If the entry is not up to date, git read-tree keeps the copy in the work tree intact when operating under the -u flag.\n\nWhen this form of git read-tree returns successfully, you can see which of the \"local changes\" that you made were carried forward by running git diff-index --cached $M. Note that this does not necessarily match what git diff-index --cached $H would have produced before such a two tree merge. This is because of cases 18 and 19 — if you already had the changes in $M (e.g. maybe you picked it up via e-mail in a patch form), git diff-index --cached $H would have told you about the change before this merge, but it would not show in git diff-index --cached $M output after the two-tree merge.\n\nCase 3 is slightly tricky and needs explanation. The result from this rule logically should be to remove the path if the user staged the removal of the path and then switching to a new branch. That however will prevent the initial checkout from happening, so the rule is modified to use M (new tree) only when the content of the index is empty. Otherwise the removal of the path is kept as long as $H and $M are the same.\n\n• The current index and work tree is derived from $H, but the user may have local changes in them since $H.\n• The user wants to fast-forward to $M.",
        "code_examples": [
          "```bash\nI                   H        M        Result\n       -------------------------------------------------------\n     0  nothing             nothing  nothing  (does not happen)\n     1  nothing             nothing  exists   use M\n     2  nothing             exists   nothing  remove path from index\n     3  nothing             exists   exists,  use M if \"initial checkout\",\n\t\t\t\t     H == M   keep index otherwise\n\t\t\t\t     exists,  fail\n\t\t\t\t     H != M\n\n        clean I==H  I==M\n       ------------------\n     4  yes   N/A   N/A     nothing  nothing  keep index\n     5  no    N/A   N/A     nothing  nothing  keep index\n\n     6  yes   N/A   yes     nothing  exists   keep index\n     7  no    N/A   yes     nothing  exists   keep index\n     8  yes   N/A   no      nothing  exists   fail\n     9  no    N/A   no      nothing  exists   fail\n\n     10 yes   yes   N/A     exists   nothing  remove path from index\n     11 no    yes   N/A     exists   nothing  fail\n     12 yes   no    N/A     exists   nothing  fail\n     13 no    no    N/A     exists   nothing  fail\n\n\tclean (H==M)\n       ------\n     14 yes                 exists   exists   keep index\n     15 no                  exists   exists   keep index\n\n        clean I==H  I==M (H!=M)\n       ------------------\n     16 yes   no    no      exists   exists   fail\n     17 no    no    no      exists   exists   fail\n     18 yes   no    yes     exists   exists   keep index\n     19 no    no    yes     exists   exists   keep index\n     20 yes   yes   no      exists   exists   use M\n     21 no    yes   no      exists   exists   fail\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 2124
        }
      },
      {
        "header": "3-Way Merge",
        "content": "Each \"index\" entry has two bits worth of \"stage\" state. stage 0 is the normal one, and is the only one you’d see in any kind of normal use.\n\nHowever, when you do git read-tree with three trees, the \"stage\" starts out at 1.\n\nThis means that you can do\n\nand you will end up with an index with all of the <tree1> entries in \"stage1\", all of the <tree2> entries in \"stage2\" and all of the <tree3> entries in \"stage3\". When performing a merge of another branch into the current branch, we use the common ancestor tree as <tree1>, the current branch head as <tree2>, and the other branch head as <tree3>.\n\nFurthermore, git read-tree has special-case logic that says: if you see a file that matches in all respects in the following states, it \"collapses\" back to \"stage0\":\n\nstage 2 and 3 are the same; take one or the other (it makes no difference - the same work has been done on our branch in stage 2 and their branch in stage 3)\n\nstage 1 and stage 2 are the same and stage 3 is different; take stage 3 (our branch in stage 2 did not do anything since the ancestor in stage 1 while their branch in stage 3 worked on it)\n\nstage 1 and stage 3 are the same and stage 2 is different take stage 2 (we did something while they did nothing)\n\nThe git write-tree command refuses to write a nonsensical tree, and it will complain about unmerged entries if it sees a single entry that is not stage 0.\n\nOK, this all sounds like a collection of totally nonsensical rules, but it’s actually exactly what you want in order to do a fast merge. The different stages represent the \"result tree\" (stage 0, aka \"merged\"), the original tree (stage 1, aka \"orig\"), and the two trees you are trying to merge (stage 2 and 3 respectively).\n\nThe order of stages 1, 2 and 3 (hence the order of three <tree-ish> command-line arguments) are significant when you start a 3-way merge with an index file that is already populated. Here is an outline of how the algorithm works:\n\nif a file exists in identical format in all three trees, it will automatically collapse to \"merged\" state by git read-tree.\n\na file that has any difference what-so-ever in the three trees will stay as separate entries in the index. It’s up to \"porcelain policy\" to determine how to remove the non-0 stages, and insert a merged version.\n\nthe index file saves and restores with all this information, so you can merge things incrementally, but as long as it has entries in stages 1/2/3 (i.e., \"unmerged entries\") you can’t write the result. So now the merge algorithm ends up being really simple:\n\nyou walk the index in order, and ignore all entries of stage 0, since they’ve already been done.\n\nif you find a \"stage1\", but no matching \"stage2\" or \"stage3\", you know it’s been removed from both trees (it only existed in the original tree), and you remove that entry.\n\nif you find a matching \"stage2\" and \"stage3\" tree, you remove one of them, and turn the other into a \"stage0\" entry. Remove any matching \"stage1\" entry if it exists too. .. all the normal trivial rules ..\n\nYou would normally use git merge-index with supplied git merge-one-file to do this last step. The script updates the files in the working tree as it merges each path and at the end of a successful merge.\n\nWhen you start a 3-way merge with an index file that is already populated, it is assumed that it represents the state of the files in your work tree, and you can even have files with changes unrecorded in the index file. It is further assumed that this state is \"derived\" from the stage 2 tree. The 3-way merge refuses to run if it finds an entry in the original index file that does not match stage 2.\n\nThis is done to prevent you from losing your work-in-progress changes, and mixing your random changes in an unrelated merge commit. To illustrate, suppose you start from what has been committed last to your repository:\n\nYou do random edits, without running git update-index. And then you notice that the tip of your \"upstream\" tree has advanced since you pulled from him:\n\nYour work tree is still based on your HEAD ($JC), but you have some edits since. Three-way merge makes sure that you have not added or modified index entries since $JC, and if you haven’t, then does the right thing. So with the following sequence:\n\nwhat you would commit is a pure merge between $JC and $LT without your work-in-progress changes, and your work tree would be updated to the result of the merge.\n\nHowever, if you have local changes in the working tree that would be overwritten by this merge, git read-tree will refuse to run to prevent your changes from being lost.\n\nIn other words, there is no need to worry about what exists only in the working tree. When you have local changes in a part of the project that is not involved in the merge, your changes do not interfere with the merge, and are kept intact. When they do interfere, the merge does not even start (git read-tree complains loudly and fails without modifying anything). In such a case, you can simply continue doing what you were in the middle of doing, and when your working tree is ready (i.e. you have finished your work-in-progress), attempt the merge again.\n\n• stage 2 and 3 are the same; take one or the other (it makes no difference - the same work has been done on our branch in stage 2 and their branch in stage 3)\n• stage 1 and stage 2 are the same and stage 3 is different; take stage 3 (our branch in stage 2 did not do anything since the ancestor in stage 1 while their branch in stage 3 worked on it)\n• stage 1 and stage 3 are the same and stage 2 is different take stage 2 (we did something while they did nothing)\n\n• if a file exists in identical format in all three trees, it will automatically collapse to \"merged\" state by git read-tree.\n• a file that has any difference what-so-ever in the three trees will stay as separate entries in the index. It’s up to \"porcelain policy\" to determine how to remove the non-0 stages, and insert a merged version.\n• the index file saves and restores with all this information, so you can merge things incrementally, but as long as it has entries in stages 1/2/3 (i.e., \"unmerged entries\") you can’t write the result. So now the merge algorithm ends up being really simple: you walk the index in order, and ignore all entries of stage 0, since they’ve already been done. if you find a \"stage1\", but no matching \"stage2\" or \"stage3\", you know it’s been removed from both trees (it only existed in the original tree), and you remove that entry. if you find a matching \"stage2\" and \"stage3\" tree, you remove one of them, and turn the other into a \"stage0\" entry. Remove any matching \"stage1\" entry if it exists too. .. all the normal trivial rules ..\n\n• you walk the index in order, and ignore all entries of stage 0, since they’ve already been done.\n• if you find a \"stage1\", but no matching \"stage2\" or \"stage3\", you know it’s been removed from both trees (it only existed in the original tree), and you remove that entry.\n• if you find a matching \"stage2\" and \"stage3\" tree, you remove one of them, and turn the other into a \"stage0\" entry. Remove any matching \"stage1\" entry if it exists too. .. all the normal trivial rules ..",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git read-tree -m <tree1> <tree2> <tree3>\n```",
          "```bash\n$ JC=`git rev-parse --verify \"HEAD^0\"`\n$ git checkout-index -f -u -a $JC\n```",
          "```bash\n$ git fetch git://.... linus\n$ LT=`git rev-parse FETCH_HEAD`\n```",
          "```bash\n$ git read-tree -m -u `git merge-base $JC $LT` $JC $LT\n$ git merge-index git-merge-one-file -a\n$ echo \"Merge with Linus\" | \\\n  git commit-tree `git write-tree` -p $JC -p $LT\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 25,
          "content_length": 7157
        }
      },
      {
        "header": "SPARSE CHECKOUT",
        "content": "Note: The skip-worktree capabilities in git-update-index[1] and read-tree predated the introduction of git-sparse-checkout[1]. Users are encouraged to use the sparse-checkout command in preference to these plumbing commands for sparse-checkout/skip-worktree related needs. However, the information below might be useful to users trying to understand the pattern style used in non-cone mode of the sparse-checkout command.\n\n\"Sparse checkout\" allows populating the working directory sparsely. It uses the skip-worktree bit (see git-update-index[1]) to tell Git whether a file in the working directory is worth looking at.\n\ngit read-tree and other merge-based commands (git merge, git checkout…) can help maintaining the skip-worktree bitmap and working directory update. $GIT_DIR/info/sparse-checkout is used to define the skip-worktree reference bitmap. When git read-tree needs to update the working directory, it resets the skip-worktree bit in the index based on this file, which uses the same syntax as .gitignore files. If an entry matches a pattern in this file, or the entry corresponds to a file present in the working tree, then skip-worktree will not be set on that entry. Otherwise, skip-worktree will be set.\n\nThen it compares the new skip-worktree value with the previous one. If skip-worktree turns from set to unset, it will add the corresponding file back. If it turns from unset to set, that file will be removed.\n\nWhile $GIT_DIR/info/sparse-checkout is usually used to specify what files are in, you can also specify what files are not in, using negate patterns. For example, to remove the file unwanted:\n\nAnother tricky thing is fully repopulating the working directory when you no longer want sparse checkout. You cannot just disable \"sparse checkout\" because skip-worktree bits are still in the index and your working directory is still sparsely populated. You should re-populate the working directory with the $GIT_DIR/info/sparse-checkout file content as follows:\n\nThen you can disable sparse checkout. Sparse checkout support in git read-tree and similar commands is disabled by default. You need to turn core.sparseCheckout on in order to have sparse checkout support.",
        "code_examples": [
          "```bash\n/*\n!unwanted\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 2192
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-write-tree[1], git-ls-files[1], gitignore[5], git-sparse-checkout[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 72
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-read-tree",
    "doc_type": "git",
    "total_sections": 10
  },
  {
    "title": "Git",
    "summary": "NAME git-rev-list - Lists commit objects in reverse chronological order\n\ngit-rev-list - Lists commit objects in reverse chronological order",
    "sections": [
      {
        "header": "NAME",
        "content": "git-rev-list - Lists commit objects in reverse chronological order",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 66
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "List commits that are reachable by following the parent links from the given commit(s), but exclude commits that are reachable from the one(s) given with a ^ in front of them. The output is given in reverse chronological order by default.\n\nYou can think of this as a set operation. Commits reachable from any of the commits given on the command line form a set, and then commits reachable from any of the ones given with ^ in front are subtracted from that set. The remaining commits are what comes out in the command’s output. Various other options and paths parameters can be used to further limit the result.\n\nThus, the following command:\n\nmeans \"list all the commits which are reachable from foo or bar, but not from baz\".\n\nA special notation \"<commit1>..<commit2>\" can be used as a short-hand for \"^<commit1> <commit2>\". For example, either of the following may be used interchangeably:\n\nAnother special notation is \"<commit1>...<commit2>\" which is useful for merges. The resulting set of commits is the symmetric difference between the two operands. The following two commands are equivalent:\n\nrev-list is an essential Git command, since it provides the ability to build and traverse commit ancestry graphs. For this reason, it has a lot of different options that enable it to be used by commands as different as git bisect and git repack.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git rev-list foo bar ^baz\n```",
          "```bash\n$ git rev-list origin..HEAD\n$ git rev-list HEAD ^origin\n```",
          "```bash\n$ git rev-list A B --not $(git merge-base --all A B)\n$ git rev-list A...B\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 1345
        }
      },
      {
        "header": "Commit Limiting",
        "content": "Besides specifying a range of commits that should be listed using the special notations explained in the description, additional commit limiting may be applied.\n\nUsing more options generally further limits the output (e.g. --since=<date1> limits to commits newer than <date1>, and using it with --grep=<pattern> further limits to commits whose log message has a line that matches <pattern>), unless otherwise noted.\n\nNote that these are applied before commit ordering and formatting options, such as --reverse.\n\nLimit the output to <number> commits.\n\nSkip <number> commits before starting to show the commit output.\n\nShow commits more recent than <date>.\n\nShow all commits more recent than <date>. This visits all commits in the range, rather than stopping at the first commit which is older than <date>.\n\nShow commits older than <date>.\n\nLimit the commits output to specified time range.\n\nLimit the commits output to ones with author/committer header lines that match the <pattern> regular expression. With more than one --author=<pattern>, commits whose author matches any of the <pattern> are chosen (similarly for multiple --committer=<pattern>).\n\nLimit the commits output to ones with reflog entries that match the <pattern> regular expression. With more than one --grep-reflog, commits whose reflog message matches any of the given patterns are chosen. It is an error to use this option unless --walk-reflogs is in use.\n\nLimit the commits output to ones with a log message that matches the <pattern> regular expression. With more than one --grep=<pattern>, commits whose message matches any of the <pattern> are chosen (but see --all-match).\n\nLimit the commits output to ones that match all given --grep, instead of ones that match at least one.\n\nLimit the commits output to ones with a log message that do not match the <pattern> specified with --grep=<pattern>.\n\nMatch the regular expression limiting patterns without regard to letter case.\n\nConsider the limiting patterns to be basic regular expressions; this is the default.\n\nConsider the limiting patterns to be extended regular expressions instead of the default basic regular expressions.\n\nConsider the limiting patterns to be fixed strings (don’t interpret pattern as a regular expression).\n\nConsider the limiting patterns to be Perl-compatible regular expressions.\n\nSupport for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die.\n\nStop when a given path disappears from the tree.\n\nPrint only merge commits. This is exactly the same as --min-parents=2.\n\nDo not print commits with more than one parent. This is exactly the same as --max-parents=1.\n\nShow only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges. --max-parents=0 gives all root commits and --min-parents=3 all octopus merges.\n\n--no-min-parents and --no-max-parents reset these limits (to no limit) again. Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit).\n\nWhen finding commits to include, follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge.\n\nWhen finding commits to exclude (with a ^), follow only the first parent commit upon seeing a merge commit. This can be used to find the set of changes in a topic branch from the point where it diverged from the remote branch, given that arbitrary merges can be valid topic branch changes.\n\nReverses the meaning of the ^ prefix (or lack thereof) for all following revision specifiers, up to the next --not. When used on the command line before --stdin, the revisions passed through stdin will not be affected by it. Conversely, when passed via standard input, the revisions passed on the command line will not be affected by it.\n\nPretend as if all the refs in refs/, along with HEAD, are listed on the command line as <commit>.\n\nPretend as if all the refs in refs/heads are listed on the command line as <commit>. If <pattern> is given, limit branches to ones matching given shell glob. If <pattern> lacks ?, *, or [, /* at the end is implied.\n\nPretend as if all the refs in refs/tags are listed on the command line as <commit>. If <pattern> is given, limit tags to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied.\n\nPretend as if all the refs in refs/remotes are listed on the command line as <commit>. If <pattern> is given, limit remote-tracking branches to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied.\n\nPretend as if all the refs matching shell glob <glob-pattern> are listed on the command line as <commit>. Leading refs/, is automatically prepended if missing. If pattern lacks ?, *, or [, /* at the end is implied.\n\nDo not include refs matching <glob-pattern> that the next --all, --branches, --tags, --remotes, or --glob would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next --all, --branches, --tags, --remotes, or --glob option (other options or arguments do not clear accumulated patterns).\n\nThe patterns given should not begin with refs/heads, refs/tags, or refs/remotes when applied to --branches, --tags, or --remotes, respectively, and they must begin with refs/ when applied to --glob or --all. If a trailing /* is intended, it must be given explicitly.\n\nDo not include refs that would be hidden by git-fetch, git-receive-pack or git-upload-pack by consulting the appropriate fetch.hideRefs, receive.hideRefs or uploadpack.hideRefs configuration along with transfer.hideRefs (see git-config[1]). This option affects the next pseudo-ref option --all or --glob and is cleared after processing them.\n\nPretend as if all objects mentioned by reflogs are listed on the command line as <commit>.\n\nPretend as if all objects mentioned as ref tips of alternate repositories were listed on the command line. An alternate repository is any repository whose object directory is specified in objects/info/alternates. The set of included objects may be modified by core.alternateRefsCommand, etc. See git-config[1].\n\nBy default, all working trees will be examined by the following options when there are more than one (see git-worktree[1]): --all, --reflog and --indexed-objects. This option forces them to examine the current working tree only.\n\nUpon seeing an invalid object name in the input, pretend as if the bad input was not given.\n\nIn addition to getting arguments from the command line, read them from standard input as well. This accepts commits and pseudo-options like --all and --glob=. When a -- separator is seen, the following input is treated as paths and used to limit the result. Flags like --not which are read via standard input are only respected for arguments passed in the same way and will not influence any subsequent command line arguments.\n\nDon’t print anything to standard output. This form is primarily meant to allow the caller to test the exit status to see if a range of objects is fully connected (or not). It is faster than redirecting stdout to /dev/null as the output does not have to be formatted.\n\nSuppress normal output; instead, print the sum of the bytes used for on-disk storage by the selected commits or objects. This is equivalent to piping the output into git cat-file --batch-check='%(objectsize:disk), except that it runs much faster (especially with --use-bitmap-index). See the CAVEATS section in git-cat-file[1] for the limitations of what \"on-disk storage\" means. With the optional value human, on-disk storage size is shown in human-readable string(e.g. 12.24 Kib, 3.50 Mib).\n\nLike --cherry-pick (see below) but mark equivalent commits with = rather than omitting them, and inequivalent ones with +.\n\nOmit any commit that introduces the same change as another commit on the “other side” when the set of commits are limited with symmetric difference.\n\nFor example, if you have two branches, A and B, a usual way to list all commits on only one side of them is with --left-right (see the example below in the description of the --left-right option). However, it shows the commits that were cherry-picked from the other branch (for example, “3rd on b” may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output.\n\nList only commits on the respective side of a symmetric difference, i.e. only those which would be marked < resp. > by --left-right.\n\nFor example, --cherry-pick --right-only A...B omits those commits from B which are in A or are patch-equivalent to a commit in A. In other words, this lists the + commits from git cherry A B. More precisely, --cherry-pick --right-only --no-merges gives the exact list.\n\nA synonym for --right-only --cherry-mark --no-merges; useful to limit the output to the commits on our side and mark those that have been applied to the other side of a forked history with git log --cherry upstream...mybranch, similar to git cherry upstream mybranch.\n\nInstead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, ^<commit>, <commit1>..<commit2>, and <commit1>...<commit2> notations cannot be used).\n\nWith --pretty format other than oneline and reference (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as ref@{<Nth>} (where <Nth> is the reverse-chronological index in the reflog) or as ref@{<timestamp>} (with the <timestamp> for that entry), depending on a few rules:\n\nIf the starting point is specified as ref@{<Nth>}, show the index format.\n\nIf the starting point was specified as ref@{now}, show the timestamp format.\n\nIf neither was used, but --date was given on the command line, show the timestamp in the format requested by --date.\n\nOtherwise, show the index format.\n\nUnder --pretty=oneline, the commit message is prefixed with this information on the same line. This option cannot be combined with --reverse. See also git-reflog[1].\n\nUnder --pretty=reference, this information will not be shown at all.\n\nShow commits touching conflicted paths in the range HEAD...<other>, where <other> is the first existing pseudoref in MERGE_HEAD, CHERRY_PICK_HEAD, REVERT_HEAD or REBASE_HEAD. Only works when the index has unmerged entries. This option can be used to show relevant commits when resolving conflicts from a 3-way merge.\n\nOutput excluded boundary commits. Boundary commits are prefixed with -.\n\nTry to speed up the traversal using the pack bitmap index (if one is available). Note that when traversing with --objects, trees and blobs will not have their associated path printed.\n\nShow progress reports on stderr as objects are considered. The <header> text will be printed with each progress update.\n\nInstead of being newline-delimited, each outputted object and its accompanying metadata is delimited using NUL bytes. Output is printed in the following form:\n\nAdditional object metadata, such as object paths or boundary objects, is printed using the <token>=<value> form. Token values are printed as-is without any encoding/truncation. An OID entry never contains a = character and thus is used to signal the start of a new object record. Examples:\n\nThis mode is only compatible with the --objects, --boundary, and --missing output options.\n\n• If the starting point is specified as ref@{<Nth>}, show the index format.\n• If the starting point was specified as ref@{now}, show the timestamp format.\n• If neither was used, but --date was given on the command line, show the timestamp in the format requested by --date.\n• Otherwise, show the index format.\n\n**-<number>**: Limit the output to <number> commits.\n**-n <number>**: Skip <number> commits before starting to show the commit output.\n**--max-count=<number>**: Show commits more recent than <date>.\n**--skip=<number>**: Show all commits more recent than <date>. This visits all commits in the range, rather than stopping at the first commit which is older than <date>.\n**--since=<date>**: Show commits older than <date>.\n**--after=<date>**: Limit the commits output to specified time range.\n**--since-as-filter=<date>**: Limit the commits output to ones with author/committer header lines that match the <pattern> regular expression. With more than one --author=<pattern>, commits whose author matches any of the <pattern> are chosen (similarly for multiple --committer=<pattern>).\n**--until=<date>**: Limit the commits output to ones with reflog entries that match the <pattern> regular expression. With more than one --grep-reflog, commits whose reflog message matches any of the given patterns are chosen. It is an error to use this option unless --walk-reflogs is in use.\n**--before=<date>**: Limit the commits output to ones with a log message that matches the <pattern> regular expression. With more than one --grep=<pattern>, commits whose message matches any of the <pattern> are chosen (but see --all-match).\n**--max-age=<timestamp>**: Limit the commits output to ones that match all given --grep, instead of ones that match at least one.\n**--min-age=<timestamp>**: Limit the commits output to ones with a log message that do not match the <pattern> specified with --grep=<pattern>.\n**--author=<pattern>**: Match the regular expression limiting patterns without regard to letter case.\n**--committer=<pattern>**: Consider the limiting patterns to be basic regular expressions; this is the default.\n**--grep-reflog=<pattern>**: Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions.\n**--grep=<pattern>**: Consider the limiting patterns to be fixed strings (don’t interpret pattern as a regular expression).\n**--all-match**: Consider the limiting patterns to be Perl-compatible regular expressions. Support for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die.\n**--invert-grep**: Stop when a given path disappears from the tree.\n**-i**: Print only merge commits. This is exactly the same as --min-parents=2.\n**--regexp-ignore-case**: Do not print commits with more than one parent. This is exactly the same as --max-parents=1.\n**--basic-regexp**: Show only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges. --max-parents=0 gives all root commits and --min-parents=3 all octopus merges. --no-min-parents and --no-max-parents reset these limits (to no limit) again. Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit).\n**-E**: When finding commits to include, follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge.\n**--extended-regexp**: When finding commits to exclude (with a ^), follow only the first parent commit upon seeing a merge commit. This can be used to find the set of changes in a topic branch from the point where it diverged from the remote branch, given that arbitrary merges can be valid topic branch changes.\n**-F**: Reverses the meaning of the ^ prefix (or lack thereof) for all following revision specifiers, up to the next --not. When used on the command line before --stdin, the revisions passed through stdin will not be affected by it. Conversely, when passed via standard input, the revisions passed on the command line will not be affected by it.\n**--fixed-strings**: Pretend as if all the refs in refs/, along with HEAD, are listed on the command line as <commit>.\n**-P**: Pretend as if all the refs in refs/heads are listed on the command line as <commit>. If <pattern> is given, limit branches to ones matching given shell glob. If <pattern> lacks ?, *, or [, /* at the end is implied.\n**--perl-regexp**: Pretend as if all the refs in refs/tags are listed on the command line as <commit>. If <pattern> is given, limit tags to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied.\n**--remove-empty**: Pretend as if all the refs in refs/remotes are listed on the command line as <commit>. If <pattern> is given, limit remote-tracking branches to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied.\n**--merges**: Pretend as if all the refs matching shell glob <glob-pattern> are listed on the command line as <commit>. Leading refs/, is automatically prepended if missing. If pattern lacks ?, *, or [, /* at the end is implied.\n**--no-merges**: Do not include refs matching <glob-pattern> that the next --all, --branches, --tags, --remotes, or --glob would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next --all, --branches, --tags, --remotes, or --glob option (other options or arguments do not clear accumulated patterns). The patterns given should not begin with refs/heads, refs/tags, or refs/remotes when applied to --branches, --tags, or --remotes, respectively, and they must begin with refs/ when applied to --glob or --all. If a trailing /* is intended, it must be given explicitly.\n**--min-parents=<number>**: Do not include refs that would be hidden by git-fetch, git-receive-pack or git-upload-pack by consulting the appropriate fetch.hideRefs, receive.hideRefs or uploadpack.hideRefs configuration along with transfer.hideRefs (see git-config[1]). This option affects the next pseudo-ref option --all or --glob and is cleared after processing them.\n**--max-parents=<number>**: Pretend as if all objects mentioned by reflogs are listed on the command line as <commit>.\n**--no-min-parents**: Pretend as if all objects mentioned as ref tips of alternate repositories were listed on the command line. An alternate repository is any repository whose object directory is specified in objects/info/alternates. The set of included objects may be modified by core.alternateRefsCommand, etc. See git-config[1].\n**--no-max-parents**: By default, all working trees will be examined by the following options when there are more than one (see git-worktree[1]): --all, --reflog and --indexed-objects. This option forces them to examine the current working tree only.\n**--first-parent**: Upon seeing an invalid object name in the input, pretend as if the bad input was not given.\n**--exclude-first-parent-only**: In addition to getting arguments from the command line, read them from standard input as well. This accepts commits and pseudo-options like --all and --glob=. When a -- separator is seen, the following input is treated as paths and used to limit the result. Flags like --not which are read via standard input are only respected for arguments passed in the same way and will not influence any subsequent command line arguments.\n**--not**: Don’t print anything to standard output. This form is primarily meant to allow the caller to test the exit status to see if a range of objects is fully connected (or not). It is faster than redirecting stdout to /dev/null as the output does not have to be formatted.\n**--all**: Suppress normal output; instead, print the sum of the bytes used for on-disk storage by the selected commits or objects. This is equivalent to piping the output into git cat-file --batch-check='%(objectsize:disk), except that it runs much faster (especially with --use-bitmap-index). See the CAVEATS section in git-cat-file[1] for the limitations of what \"on-disk storage\" means. With the optional value human, on-disk storage size is shown in human-readable string(e.g. 12.24 Kib, 3.50 Mib).\n**--branches[=<pattern>]**: Like --cherry-pick (see below) but mark equivalent commits with = rather than omitting them, and inequivalent ones with +.\n**--tags[=<pattern>]**: Omit any commit that introduces the same change as another commit on the “other side” when the set of commits are limited with symmetric difference. For example, if you have two branches, A and B, a usual way to list all commits on only one side of them is with --left-right (see the example below in the description of the --left-right option). However, it shows the commits that were cherry-picked from the other branch (for example, “3rd on b” may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output.\n**--remotes[=<pattern>]**: List only commits on the respective side of a symmetric difference, i.e. only those which would be marked < resp. > by --left-right. For example, --cherry-pick --right-only A...B omits those commits from B which are in A or are patch-equivalent to a commit in A. In other words, this lists the + commits from git cherry A B. More precisely, --cherry-pick --right-only --no-merges gives the exact list.\n**--glob=<glob-pattern>**: A synonym for --right-only --cherry-mark --no-merges; useful to limit the output to the commits on our side and mark those that have been applied to the other side of a forked history with git log --cherry upstream...mybranch, similar to git cherry upstream mybranch.\n**--exclude=<glob-pattern>**: Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, ^<commit>, <commit1>..<commit2>, and <commit1>...<commit2> notations cannot be used). With --pretty format other than oneline and reference (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as ref@{<Nth>} (where <Nth> is the reverse-chronological index in the reflog) or as ref@{<timestamp>} (with the <timestamp> for that entry), depending on a few rules: If the starting point is specified as ref@{<Nth>}, show the index format. If the starting point was specified as ref@{now}, show the timestamp format. If neither was used, but --date was given on the command line, show the timestamp in the format requested by --date. Otherwise, show the index format. Under --pretty=oneline, the commit message is prefixed with this information on the same line. This option cannot be combined with --reverse. See also git-reflog[1]. Under --pretty=reference, this information will not be shown at all.\n**--exclude-hidden=(fetch|receive|uploadpack)**: Show commits touching conflicted paths in the range HEAD...<other>, where <other> is the first existing pseudoref in MERGE_HEAD, CHERRY_PICK_HEAD, REVERT_HEAD or REBASE_HEAD. Only works when the index has unmerged entries. This option can be used to show relevant commits when resolving conflicts from a 3-way merge.\n**--reflog**: Output excluded boundary commits. Boundary commits are prefixed with -.\n**--alternate-refs**: Try to speed up the traversal using the pack bitmap index (if one is available). Note that when traversing with --objects, trees and blobs will not have their associated path printed.\n**--single-worktree**: Show progress reports on stderr as objects are considered. The <header> text will be printed with each progress update.\n**--ignore-missing**: Instead of being newline-delimited, each outputted object and its accompanying metadata is delimited using NUL bytes. Output is printed in the following form: <OID> NUL [<token>=<value> NUL]... Additional object metadata, such as object paths or boundary objects, is printed using the <token>=<value> form. Token values are printed as-is without any encoding/truncation. An OID entry never contains a = character and thus is used to signal the start of a new object record. Examples: <OID> NUL <OID> NUL path=<path> NUL <OID> NUL boundary=yes NUL <OID> NUL missing=yes NUL [<token>=<value> NUL]... This mode is only compatible with the --objects, --boundary, and --missing output options.",
        "code_examples": [
          "```bash\n<OID> NUL [<token>=<value> NUL]...\n```",
          "```bash\n<OID> NUL\n<OID> NUL path=<path> NUL\n<OID> NUL boundary=yes NUL\n<OID> NUL missing=yes NUL [<token>=<value> NUL]...\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 64,
          "content_length": 24569
        }
      },
      {
        "header": "History Simplification",
        "content": "Sometimes you are only interested in parts of the history, for example the commits modifying a particular <path>. But there are two parts of History Simplification, one part is selecting the commits and the other is how to do it, as there are various strategies to simplify the history.\n\nThe following options select the commits to be shown:\n\nCommits modifying the given <paths> are selected.\n\nCommits that are referred by some branch or tag are selected.\n\nNote that extra commits can be shown to give a meaningful history.\n\nThe following options affect the way the simplification is performed:\n\nSimplifies the history to the simplest history explaining the final state of the tree. Simplest because it prunes some side branches if the end result is the same (i.e. merging branches with the same content)\n\nInclude all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent. This mode is helpful for showing the merge commits that \"first introduced\" a change to a branch.\n\nSame as the default mode, but does not prune some history.\n\nOnly the selected commits are shown, plus some to have a meaningful history.\n\nAll commits in the simplified history are shown.\n\nAdditional option to --full-history to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge.\n\nWhen given a range of commits to display (e.g. <commit1>..<commit2> or <commit2> ^<commit1>), and a commit <commit> in that range, only display commits in that range that are ancestors of <commit>, descendants of <commit>, or <commit> itself. If no commit is specified, use <commit1> (the excluded part of the range) as <commit>. Can be passed multiple times; if so, a commit is included if it is any of the commits given or if it is an ancestor or descendant of one of them.\n\nA more detailed explanation follows.\n\nSuppose you specified foo as the <paths>. We shall call commits that modify foo !TREESAME, and the rest TREESAME. (In a diff filtered for foo, they look different and equal, respectively.)\n\nIn the following, we will always refer to the same example history to illustrate the differences between simplification settings. We assume that you are filtering for a file foo in this commit graph:\n\nThe horizontal line of history A---Q is taken to be the first parent of each merge. The commits are:\n\nI is the initial commit, in which foo exists with contents asdf, and a file quux exists with contents quux. Initial commits are compared to an empty tree, so I is !TREESAME.\n\nIn A, foo contains just foo.\n\nB contains the same change as A. Its merge M is trivial and hence TREESAME to all parents.\n\nC does not change foo, but its merge N changes it to foobar, so it is not TREESAME to any parent.\n\nD sets foo to baz. Its merge O combines the strings from N and D to foobarbaz; i.e., it is not TREESAME to any parent.\n\nE changes quux to xyzzy, and its merge P combines the strings to quux xyzzy. P is TREESAME to O, but not to E.\n\nX is an independent root commit that added a new file side, and Y modified it. Y is TREESAME to X. Its merge Q added side to P, and Q is TREESAME to P, but not to Y.\n\nrev-list walks backwards through history, including or excluding commits based on whether --full-history and/or parent rewriting (via --parents or --children) are used. The following settings are available.\n\nCommits are included if they are not TREESAME to any parent (though this can be changed, see --sparse below). If the commit was a merge, and it was TREESAME to one parent, follow only that parent. (Even if there are several TREESAME parents, follow only one of them.) Otherwise, follow all parents.\n\nNote how the rule to only follow the TREESAME parent, if one is available, removed B from consideration entirely. C was considered via N, but is TREESAME. Root commits are compared to an empty tree, so I is !TREESAME.\n\nParent/child relations are only visible with --parents, but that does not affect the commits selected in default mode, so we have shown the parent lines.\n\nThis mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is! In the example, we get\n\nM was excluded because it is TREESAME to both parents. E, C and B were all walked, but only B was !TREESAME, so the others do not appear.\n\nNote that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected.\n\nOrdinary commits are only included if they are !TREESAME (though this can be changed, see --sparse below).\n\nMerges are always included. However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves. This results in\n\nCompare to --full-history without rewriting above. Note that E was pruned away because it is TREESAME, but the parent list of P was rewritten to contain E's parent I. The same happened for C and N, and X, Y and Q.\n\nIn addition to the above settings, you can change whether TREESAME affects inclusion:\n\nCommits that are walked are included if they are not TREESAME to any parent.\n\nAll commits that are walked are included.\n\nNote that without --full-history, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked.\n\nFirst, build a history graph in the same way that --full-history with parent rewriting does (see above).\n\nThen simplify each commit C to its replacement C' in the final history according to the following rules:\n\nReplace each parent P of C' with its simplification P'. In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to.\n\nIf after this parent rewriting, C' is a root or merge commit (has zero or >1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent.\n\nThe effect of this is best shown by way of comparing to --full-history with parent rewriting. The example turns into:\n\nNote the major differences in N, P, and Q over --full-history:\n\nN's parent list had I removed, because it is an ancestor of the other parent M. Still, N remained because it is !TREESAME.\n\nP's parent list similarly had I removed. P was then removed completely, because it had one parent and is TREESAME.\n\nQ's parent list had Y simplified to X. X was then removed, because it was a TREESAME root. Q was then removed completely, because it had one parent and is TREESAME.\n\nThere is another simplification mode available:\n\nLimit the displayed commits to those which are an ancestor of <commit>, or which are a descendant of <commit>, or are <commit> itself.\n\nAs an example use case, consider the following commit history:\n\nA regular D..M computes the set of commits that are ancestors of M, but excludes the ones that are ancestors of D. This is useful to see what happened to the history leading to M since D, in the sense that \"what does M have that did not exist in D\". The result in this example would be all the commits, except A and B (and D itself, of course).\n\nWhen we want to find out what commits in M are contaminated with the bug introduced by D and need fixing, however, we might want to view only the subset of D..M that are actually descendants of D, i.e. excluding C and K. This is exactly what the --ancestry-path option does. Applied to the D..M range, it results in:\n\nWe can also use --ancestry-path=D instead of --ancestry-path which means the same thing when applied to the D..M range but is just more explicit.\n\nIf we instead are interested in a given topic within this range, and all commits affected by that topic, we may only want to view the subset of D..M which contain that topic in their ancestry path. So, using --ancestry-path=H D..M for example would result in:\n\nWhereas --ancestry-path=K D..M would result in\n\nBefore discussing another option, --show-pulls, we need to create a new example history.\n\nA common problem users face when looking at simplified history is that a commit they know changed a file somehow does not appear in the file’s simplified history. Let’s demonstrate a new example and show how options such as --full-history and --simplify-merges works in that case:\n\nFor this example, suppose I created file.txt which was modified by A, B, and X in different ways. The single-parent commits C, Z, and Y do not change file.txt. The merge commit M was created by resolving the merge conflict to include both changes from A and B and hence is not TREESAME to either. The merge commit R, however, was created by ignoring the contents of file.txt at M and taking only the contents of file.txt at X. Hence, R is TREESAME to X but not M. Finally, the natural merge resolution to create N is to take the contents of file.txt at R, so N is TREESAME to R but not C. The merge commits O and P are TREESAME to their first parents, but not to their second parents, Z and Y respectively.\n\nWhen using the default mode, N and R both have a TREESAME parent, so those edges are walked and the others are ignored. The resulting history graph is:\n\nWhen using --full-history, Git walks every edge. This will discover the commits A and B and the merge M, but also will reveal the merge commits O and P. With parent rewriting, the resulting graph is:\n\nHere, the merge commits O and P contribute extra noise, as they did not actually contribute a change to file.txt. They only merged a topic that was based on an older version of file.txt. This is a common issue in repositories using a workflow where many contributors work in parallel and merge their topic branches along a single trunk: many unrelated merges appear in the --full-history results.\n\nWhen using the --simplify-merges option, the commits O and P disappear from the results. This is because the rewritten second parents of O and P are reachable from their first parents. Those edges are removed and then the commits look like single-parent commits that are TREESAME to their parent. This also happens to the commit N, resulting in a history view as follows:\n\nIn this view, we see all of the important single-parent changes from A, B, and X. We also see the carefully-resolved merge M and the not-so-carefully-resolved merge R. This is usually enough information to determine why the commits A and B \"disappeared\" from history in the default view. However, there are a few issues with this approach.\n\nThe first issue is performance. Unlike any previous option, the --simplify-merges option requires walking the entire commit history before returning a single result. This can make the option difficult to use for very large repositories.\n\nThe second issue is one of auditing. When many contributors are working on the same repository, it is important which merge commits introduced a change into an important branch. The problematic merge R above is not likely to be the merge commit that was used to merge into an important branch. Instead, the merge N was used to merge R and X into the important branch. This commit may have information about why the change X came to override the changes from A and B in its commit message.\n\nIn addition to the commits shown in the default history, show each merge commit that is not TREESAME to its first parent but is TREESAME to a later parent.\n\nWhen a merge commit is included by --show-pulls, the merge is treated as if it \"pulled\" the change from another branch. When using --show-pulls on this example (and no other options) the resulting graph is:\n\nHere, the merge commits R and N are included because they pulled the commits X and R into the base branch, respectively. These merges are the reason the commits A and B do not appear in the default history.\n\nWhen --show-pulls is paired with --simplify-merges, the graph includes all of the necessary information:\n\nNotice that since M is reachable from R, the edge from N to M was simplified away. However, N still appears in the history as an important commit because it \"pulled\" the change R into the main branch.\n\nThe --simplify-by-decoration option allows you to view only the big picture of the topology of the history, by omitting commits that are not referenced by tags. Commits are marked as !TREESAME (in other words, kept after history simplification rules described above) if (1) they are referenced by tags, or (2) they change the contents of the paths given on the command line. All other commits are marked as TREESAME (subject to be simplified away).\n\n• I is the initial commit, in which foo exists with contents asdf, and a file quux exists with contents quux. Initial commits are compared to an empty tree, so I is !TREESAME.\n• In A, foo contains just foo.\n• B contains the same change as A. Its merge M is trivial and hence TREESAME to all parents.\n• C does not change foo, but its merge N changes it to foobar, so it is not TREESAME to any parent.\n• D sets foo to baz. Its merge O combines the strings from N and D to foobarbaz; i.e., it is not TREESAME to any parent.\n• E changes quux to xyzzy, and its merge P combines the strings to quux xyzzy. P is TREESAME to O, but not to E.\n• X is an independent root commit that added a new file side, and Y modified it. Y is TREESAME to X. Its merge Q added side to P, and Q is TREESAME to P, but not to Y.\n\n• Set C' to C.\n• Replace each parent P of C' with its simplification P'. In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to.\n• If after this parent rewriting, C' is a root or merge commit (has zero or >1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent.\n\n• N's parent list had I removed, because it is an ancestor of the other parent M. Still, N remained because it is !TREESAME.\n• P's parent list similarly had I removed. P was then removed completely, because it had one parent and is TREESAME.\n• Q's parent list had Y simplified to X. X was then removed, because it was a TREESAME root. Q was then removed completely, because it had one parent and is TREESAME.\n\n**<paths>**: Commits modifying the given <paths> are selected.\n**--simplify-by-decoration**: Commits that are referred by some branch or tag are selected.\n**Default mode**: Simplifies the history to the simplest history explaining the final state of the tree. Simplest because it prunes some side branches if the end result is the same (i.e. merging branches with the same content)\n**--show-pulls**: Include all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent. This mode is helpful for showing the merge commits that \"first introduced\" a change to a branch.\n**--full-history**: Same as the default mode, but does not prune some history.\n**--dense**: Only the selected commits are shown, plus some to have a meaningful history.\n**--sparse**: All commits in the simplified history are shown.\n**--simplify-merges**: Additional option to --full-history to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge.\n**--ancestry-path[=<commit>]**: When given a range of commits to display (e.g. <commit1>..<commit2> or <commit2> ^<commit1>), and a commit <commit> in that range, only display commits in that range that are ancestors of <commit>, descendants of <commit>, or <commit> itself. If no commit is specified, use <commit1> (the excluded part of the range) as <commit>. Can be passed multiple times; if so, a commit is included if it is any of the commits given or if it is an ancestor or descendant of one of them.\n**Default mode**: Commits are included if they are not TREESAME to any parent (though this can be changed, see --sparse below). If the commit was a merge, and it was TREESAME to one parent, follow only that parent. (Even if there are several TREESAME parents, follow only one of them.) Otherwise, follow all parents. This results in: .-A---N---O / / / I---------D Note how the rule to only follow the TREESAME parent, if one is available, removed B from consideration entirely. C was considered via N, but is TREESAME. Root commits are compared to an empty tree, so I is !TREESAME. Parent/child relations are only visible with --parents, but that does not affect the commits selected in default mode, so we have shown the parent lines.\n**--full-history without parent rewriting**: This mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is! In the example, we get I A B N D O P Q M was excluded because it is TREESAME to both parents. E, C and B were all walked, but only B was !TREESAME, so the others do not appear. Note that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected.\n**--full-history with parent rewriting**: Ordinary commits are only included if they are !TREESAME (though this can be changed, see --sparse below). Merges are always included. However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves. This results in .-A---M---N---O---P---Q / / / / / I B / D / \\ / / / / `-------------' Compare to --full-history without rewriting above. Note that E was pruned away because it is TREESAME, but the parent list of P was rewritten to contain E's parent I. The same happened for C and N, and X, Y and Q.\n**--dense**: Commits that are walked are included if they are not TREESAME to any parent.\n**--sparse**: All commits that are walked are included. Note that without --full-history, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked.\n**--simplify-merges**: First, build a history graph in the same way that --full-history with parent rewriting does (see above). Then simplify each commit C to its replacement C' in the final history according to the following rules: Set C' to C. Replace each parent P of C' with its simplification P'. In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to. If after this parent rewriting, C' is a root or merge commit (has zero or >1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent. The effect of this is best shown by way of comparing to --full-history with parent rewriting. The example turns into: .-A---M---N---O / / / I B D \\ / / `---------' Note the major differences in N, P, and Q over --full-history: N's parent list had I removed, because it is an ancestor of the other parent M. Still, N remained because it is !TREESAME. P's parent list similarly had I removed. P was then removed completely, because it had one parent and is TREESAME. Q's parent list had Y simplified to X. X was then removed, because it was a TREESAME root. Q was then removed completely, because it had one parent and is TREESAME.\n**--ancestry-path[=<commit>]**: Limit the displayed commits to those which are an ancestor of <commit>, or which are a descendant of <commit>, or are <commit> itself. As an example use case, consider the following commit history: D---E-------F / \\ \\ B---C---G---H---I---J / \\ A-------K---------------L--M A regular D..M computes the set of commits that are ancestors of M, but excludes the ones that are ancestors of D. This is useful to see what happened to the history leading to M since D, in the sense that \"what does M have that did not exist in D\". The result in this example would be all the commits, except A and B (and D itself, of course). When we want to find out what commits in M are contaminated with the bug introduced by D and need fixing, however, we might want to view only the subset of D..M that are actually descendants of D, i.e. excluding C and K. This is exactly what the --ancestry-path option does. Applied to the D..M range, it results in: E-------F \\ \\ G---H---I---J \\ L--M We can also use --ancestry-path=D instead of --ancestry-path which means the same thing when applied to the D..M range but is just more explicit. If we instead are interested in a given topic within this range, and all commits affected by that topic, we may only want to view the subset of D..M which contain that topic in their ancestry path. So, using --ancestry-path=H D..M for example would result in: E \\ C---G---H---I---J \\ L--M Whereas --ancestry-path=K D..M would result in K---------------L--M\n**--show-pulls**: In addition to the commits shown in the default history, show each merge commit that is not TREESAME to its first parent but is TREESAME to a later parent. When a merge commit is included by --show-pulls, the merge is treated as if it \"pulled\" the change from another branch. When using --show-pulls on this example (and no other options) the resulting graph is: I---X---R---N Here, the merge commits R and N are included because they pulled the commits X and R into the base branch, respectively. These merges are the reason the commits A and B do not appear in the default history. When --show-pulls is paired with --simplify-merges, the graph includes all of the necessary information: .-A---M--. N / / \\ / I B R \\ / / \\ / / `---X--' Notice that since M is reachable from R, the edge from N to M was simplified away. However, N still appears in the history as an important commit because it \"pulled\" the change R into the main branch.",
        "code_examples": [
          "```bash\n.-A---M---N---O---P---Q\n\t /     /   /   /   /   /\n\tI     B   C   D   E   Y\n\t \\   /   /   /   /   /\n\t  `-------------'   X\n```",
          "```bash\n.-A---N---O\n\t /     /   /\n\tI---------D\n```",
          "```bash\nI  A  B  N  D  O  P  Q\n```",
          "```bash\n.-A---M---N---O---P---Q\n\t /     /   /   /   /\n\tI     B   /   D   /\n\t \\   /   /   /   /\n\t  `-------------'\n```",
          "```bash\n.-A---M---N---O\n\t /     /       /\n\tI     B       D\n\t \\   /       /\n\t  `---------'\n```",
          "```bash\nD---E-------F\n\t   /     \\       \\\n\t  B---C---G---H---I---J\n\t /                     \\\n\tA-------K---------------L--M\n```",
          "```bash\nE-------F\n\t\t \\       \\\n\t\t  G---H---I---J\n\t\t\t       \\\n\t\t\t\tL--M\n```",
          "```bash\nE\n\t\t \\\n\t      C---G---H---I---J\n\t\t\t       \\\n\t\t\t\tL--M\n```",
          "```bash\nK---------------L--M\n```",
          "```bash\n.-A---M-----C--N---O---P\n\t /     / \\  \\  \\/   /   /\n\tI     B   \\  R-'`-Z'   /\n\t \\   /     \\/         /\n\t  \\ /      /\\        /\n\t   `---X--'  `---Y--'\n```",
          "```bash\n.-A---M--------N---O---P\n\t /     / \\  \\  \\/   /   /\n\tI     B   \\  R-'`--'   /\n\t \\   /     \\/         /\n\t  \\ /      /\\        /\n\t   `---X--'  `------'\n```",
          "```bash\n.-A---M--.\n\t /     /    \\\n\tI     B      R\n\t \\   /      /\n\t  \\ /      /\n\t   `---X--'\n```",
          "```bash\nI---X---R---N\n```",
          "```bash\n.-A---M--.   N\n\t /     /    \\ /\n\tI     B      R\n\t \\   /      /\n\t  \\ /      /\n\t   `---X--'\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 71,
          "content_length": 22013
        }
      },
      {
        "header": "Bisection Helpers",
        "content": "Limit output to the one commit object which is roughly halfway between included and excluded commits. Note that the bad bisection ref refs/bisect/bad is added to the included commits (if it exists) and the good bisection refs refs/bisect/good-* are added to the excluded commits (if they exist). Thus, supposing there are no refs in refs/bisect/, if\n\noutputs midpoint, the output of the two commands\n\nwould be of roughly the same length. Finding the change which introduces a regression is thus reduced to a binary search: repeatedly generate and test new 'midpoint’s until the commit chain is of length one.\n\nThis calculates the same as --bisect, except that refs in refs/bisect/ are not used, and except that this outputs text ready to be eval’ed by the shell. These lines will assign the name of the midpoint revision to the variable bisect_rev, and the expected number of commits to be tested after bisect_rev is tested to bisect_nr, the expected number of commits to be tested if bisect_rev turns out to be good to bisect_good, the expected number of commits to be tested if bisect_rev turns out to be bad to bisect_bad, and the number of commits we are bisecting right now to bisect_all.\n\nThis outputs all the commit objects between the included and excluded commits, ordered by their distance to the included and excluded commits. Refs in refs/bisect/ are not used. The farthest from them is displayed first. (This is the only one displayed by --bisect.)\n\nThis is useful because it makes it easy to choose a good commit to test when you want to avoid to test some of them for some reason (they may not compile for example).\n\nThis option can be used along with --bisect-vars, in this case, after all the sorted commit objects, there will be the same text as if --bisect-vars had been used alone.\n\n**--bisect**: Limit output to the one commit object which is roughly halfway between included and excluded commits. Note that the bad bisection ref refs/bisect/bad is added to the included commits (if it exists) and the good bisection refs refs/bisect/good-* are added to the excluded commits (if they exist). Thus, supposing there are no refs in refs/bisect/, if $ git rev-list --bisect foo ^bar ^baz outputs midpoint, the output of the two commands $ git rev-list foo ^midpoint $ git rev-list midpoint ^bar ^baz would be of roughly the same length. Finding the change which introduces a regression is thus reduced to a binary search: repeatedly generate and test new 'midpoint’s until the commit chain is of length one.\n**--bisect-vars**: This calculates the same as --bisect, except that refs in refs/bisect/ are not used, and except that this outputs text ready to be eval’ed by the shell. These lines will assign the name of the midpoint revision to the variable bisect_rev, and the expected number of commits to be tested after bisect_rev is tested to bisect_nr, the expected number of commits to be tested if bisect_rev turns out to be good to bisect_good, the expected number of commits to be tested if bisect_rev turns out to be bad to bisect_bad, and the number of commits we are bisecting right now to bisect_all.\n**--bisect-all**: This outputs all the commit objects between the included and excluded commits, ordered by their distance to the included and excluded commits. Refs in refs/bisect/ are not used. The farthest from them is displayed first. (This is the only one displayed by --bisect.) This is useful because it makes it easy to choose a good commit to test when you want to avoid to test some of them for some reason (they may not compile for example). This option can be used along with --bisect-vars, in this case, after all the sorted commit objects, there will be the same text as if --bisect-vars had been used alone.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git rev-list --bisect foo ^bar ^baz\n```",
          "```bash\n$ git rev-list foo ^midpoint\n\t$ git rev-list midpoint ^bar ^baz\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 7,
          "content_length": 3750
        }
      },
      {
        "header": "Commit Ordering",
        "content": "By default, the commits are shown in reverse chronological order.\n\nShow no parents before all of its children are shown, but otherwise show commits in the commit timestamp order.\n\nShow no parents before all of its children are shown, but otherwise show commits in the author timestamp order.\n\nShow no parents before all of its children are shown, and avoid showing commits on multiple lines of history intermixed.\n\nFor example, in a commit history like this:\n\nwhere the numbers denote the order of commit timestamps, git rev-list and friends with --date-order show the commits in the timestamp order: 8 7 6 5 4 3 2 1.\n\nWith --topo-order, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown before newer ones in order to avoid showing the commits from two parallel development track mixed together.\n\nOutput the commits chosen to be shown (see Commit Limiting section above) in reverse order. Cannot be combined with --walk-reflogs.\n\n**--date-order**: Show no parents before all of its children are shown, but otherwise show commits in the commit timestamp order.\n**--author-date-order**: Show no parents before all of its children are shown, but otherwise show commits in the author timestamp order.\n**--topo-order**: Show no parents before all of its children are shown, and avoid showing commits on multiple lines of history intermixed. For example, in a commit history like this: ---1----2----4----7 \\ \\ 3----5----6----8--- where the numbers denote the order of commit timestamps, git rev-list and friends with --date-order show the commits in the timestamp order: 8 7 6 5 4 3 2 1. With --topo-order, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown before newer ones in order to avoid showing the commits from two parallel development track mixed together.\n**--reverse**: Output the commits chosen to be shown (see Commit Limiting section above) in reverse order. Cannot be combined with --walk-reflogs.",
        "code_examples": [
          "```bash\n---1----2----4----7\n\t\\\t       \\\n\t 3----5----6----8---\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 1971
        }
      },
      {
        "header": "Object Traversal",
        "content": "These options are mostly targeted for packing of Git repositories.\n\nPrint the object IDs of any object referenced by the listed commits. --objects foo ^bar thus means \"send me all object IDs which I need to download if I have the commit object bar but not foo\". See also --object-names below.\n\nPrint tree and blob ids in order of the commits. The tree and blob ids are printed after they are first referenced by a commit.\n\nSimilar to --objects, but also print the IDs of excluded commits prefixed with a \"-\" character. This is used by git-pack-objects[1] to build a “thin” pack, which records objects in deltified form based on objects contained in these excluded commits to reduce network traffic.\n\nSimilar to --objects-edge, but it tries harder to find excluded commits at the cost of increased time. This is used instead of --objects-edge to build “thin” packs for shallow repositories.\n\nPretend as if all trees and blobs used by the index are listed on the command line. Note that you probably want to use --objects, too.\n\nOnly useful with --objects; print the object IDs that are not in packs.\n\nOnly useful with --objects; print the names of the object IDs that are found. This is the default behavior. Note that the \"name\" of each object is ambiguous, and mostly intended as a hint for packing objects. In particular: no distinction is made between the names of tags, trees, and blobs; path names may be modified to remove newlines; and if an object would appear multiple times with different names, only one name is shown.\n\nOnly useful with --objects; does not print the names of the object IDs that are found. This inverts --object-names. This flag allows the output to be more easily parsed by commands such as git-cat-file[1].\n\nOnly useful with one of the --objects*; omits objects (usually blobs) from the list of printed objects. The <filter-spec> may be one of the following:\n\nThe form --filter=blob:none omits all blobs.\n\nThe form --filter=blob:limit=<n>[kmg] omits blobs of size at least <n> bytes or units. <n> may be zero. The suffixes k, m, and g can be used to name units in KiB, MiB, or GiB. For example, blob:limit=1k is the same as blob:limit=1024.\n\nThe form --filter=object:type=(tag|commit|tree|blob) omits all objects which are not of the requested type.\n\nThe form --filter=sparse:oid=<blob-ish> uses a sparse-checkout specification contained in the blob (or blob-expression) <blob-ish> to omit blobs that would not be required for a sparse checkout on the requested refs.\n\nThe form --filter=tree:<depth> omits all blobs and trees whose depth from the root tree is >= <depth> (minimum depth if an object is located at multiple depths in the commits traversed). <depth>=0 will not include any trees or blobs unless included explicitly in the command-line (or standard input when --stdin is used). <depth>=1 will include only the tree and blobs which are referenced directly by a commit reachable from <commit> or an explicitly-given object. <depth>=2 is like <depth>=1 while also including trees and blobs one more level removed from an explicitly-given commit or tree.\n\nNote that the form --filter=sparse:path=<path> that wants to read from an arbitrary path on the filesystem has been dropped for security reasons.\n\nMultiple --filter= flags can be specified to combine filters. Only objects which are accepted by every filter are included.\n\nThe form --filter=combine:<filter1>+<filter2>+...<filterN> can also be used to combined several filters, but this is harder than just repeating the --filter flag and is usually not necessary. Filters are joined by + and individual filters are %-encoded (i.e. URL-encoded). Besides the + and % characters, the following characters are reserved and also must be encoded: ~!@#$^&*()[]{}\\;\",<>?'` as well as all characters with ASCII code <= 0x20, which includes space and newline.\n\nOther arbitrary characters can also be encoded. For instance, combine:tree:3+blob:none and combine:tree%3A3+blob%3Anone are equivalent.\n\nTurn off any previous --filter= argument.\n\nFilter the list of explicitly provided objects, which would otherwise always be printed even if they did not match any of the filters. Only useful with --filter=.\n\nOnly useful with --filter=; prints a list of the objects omitted by the filter. Object IDs are prefixed with a “~” character.\n\nA debug option to help with future \"partial clone\" development. This option specifies how missing objects are handled.\n\nThe form --missing=error requests that rev-list stop with an error if a missing object is encountered. This is the default action.\n\nThe form --missing=allow-any will allow object traversal to continue if a missing object is encountered. Missing objects will silently be omitted from the results.\n\nThe form --missing=allow-promisor is like allow-any, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing objects will raise an error.\n\nThe form --missing=print is like allow-any, but will also print a list of the missing objects. Object IDs are prefixed with a “?” character.\n\nThe form --missing=print-info is like print, but will also print additional information about the missing object inferred from its containing object. The information is all printed on the same line with the missing object ID in the form: ?<oid> [<token>=<value>].... The <token>=<value> pairs containing additional information are separated from each other by a SP. The value is encoded in a token specific fashion, but SP or LF contained in value are always expected to be represented in such a way that the resulting encoded value does not have either of these two problematic bytes. Each <token>=<value> may be one of the following:\n\nThe path=<path> shows the path of the missing object inferred from a containing object. A path containing SP or special characters is enclosed in double-quotes in the C style as needed.\n\nThe type=<type> shows the type of the missing object inferred from a containing object.\n\nIf some tips passed to the traversal are missing, they will be considered as missing too, and the traversal will ignore them. In case we cannot get their Object ID though, an error will be raised.\n\n(For internal use only.) Prefilter object traversal at promisor boundary. This is used with partial clone. This is stronger than --missing=allow-promisor because it limits the traversal, rather than just silencing errors about missing objects.\n\nOnly show the given commits, but do not traverse their ancestors. This has no effect if a range is specified. If the argument unsorted is given, the commits are shown in the order they were given on the command line. Otherwise (if sorted or no argument was given), the commits are shown in reverse chronological order by commit time. Cannot be combined with --graph.\n\nOverrides a previous --no-walk.\n\n• The path=<path> shows the path of the missing object inferred from a containing object. A path containing SP or special characters is enclosed in double-quotes in the C style as needed.\n• The type=<type> shows the type of the missing object inferred from a containing object.\n\n**--objects**: Print the object IDs of any object referenced by the listed commits. --objects foo ^bar thus means \"send me all object IDs which I need to download if I have the commit object bar but not foo\". See also --object-names below.\n**--in-commit-order**: Print tree and blob ids in order of the commits. The tree and blob ids are printed after they are first referenced by a commit.\n**--objects-edge**: Similar to --objects, but also print the IDs of excluded commits prefixed with a \"-\" character. This is used by git-pack-objects[1] to build a “thin” pack, which records objects in deltified form based on objects contained in these excluded commits to reduce network traffic.\n**--objects-edge-aggressive**: Similar to --objects-edge, but it tries harder to find excluded commits at the cost of increased time. This is used instead of --objects-edge to build “thin” packs for shallow repositories.\n**--indexed-objects**: Pretend as if all trees and blobs used by the index are listed on the command line. Note that you probably want to use --objects, too.\n**--unpacked**: Only useful with --objects; print the object IDs that are not in packs.\n**--object-names**: Only useful with --objects; print the names of the object IDs that are found. This is the default behavior. Note that the \"name\" of each object is ambiguous, and mostly intended as a hint for packing objects. In particular: no distinction is made between the names of tags, trees, and blobs; path names may be modified to remove newlines; and if an object would appear multiple times with different names, only one name is shown.\n**--no-object-names**: Only useful with --objects; does not print the names of the object IDs that are found. This inverts --object-names. This flag allows the output to be more easily parsed by commands such as git-cat-file[1].\n**--filter=<filter-spec>**: Only useful with one of the --objects*; omits objects (usually blobs) from the list of printed objects. The <filter-spec> may be one of the following: The form --filter=blob:none omits all blobs. The form --filter=blob:limit=<n>[kmg] omits blobs of size at least <n> bytes or units. <n> may be zero. The suffixes k, m, and g can be used to name units in KiB, MiB, or GiB. For example, blob:limit=1k is the same as blob:limit=1024. The form --filter=object:type=(tag|commit|tree|blob) omits all objects which are not of the requested type. The form --filter=sparse:oid=<blob-ish> uses a sparse-checkout specification contained in the blob (or blob-expression) <blob-ish> to omit blobs that would not be required for a sparse checkout on the requested refs. The form --filter=tree:<depth> omits all blobs and trees whose depth from the root tree is >= <depth> (minimum depth if an object is located at multiple depths in the commits traversed). <depth>=0 will not include any trees or blobs unless included explicitly in the command-line (or standard input when --stdin is used). <depth>=1 will include only the tree and blobs which are referenced directly by a commit reachable from <commit> or an explicitly-given object. <depth>=2 is like <depth>=1 while also including trees and blobs one more level removed from an explicitly-given commit or tree. Note that the form --filter=sparse:path=<path> that wants to read from an arbitrary path on the filesystem has been dropped for security reasons. Multiple --filter= flags can be specified to combine filters. Only objects which are accepted by every filter are included. The form --filter=combine:<filter1>+<filter2>+...<filterN> can also be used to combined several filters, but this is harder than just repeating the --filter flag and is usually not necessary. Filters are joined by + and individual filters are %-encoded (i.e. URL-encoded). Besides the + and % characters, the following characters are reserved and also must be encoded: ~!@#$^&*()[]{}\\;\",<>?'` as well as all characters with ASCII code <= 0x20, which includes space and newline. Other arbitrary characters can also be encoded. For instance, combine:tree:3+blob:none and combine:tree%3A3+blob%3Anone are equivalent.\n**--no-filter**: Turn off any previous --filter= argument.\n**--filter-provided-objects**: Filter the list of explicitly provided objects, which would otherwise always be printed even if they did not match any of the filters. Only useful with --filter=.\n**--filter-print-omitted**: Only useful with --filter=; prints a list of the objects omitted by the filter. Object IDs are prefixed with a “~” character.\n**--missing=<missing-action>**: A debug option to help with future \"partial clone\" development. This option specifies how missing objects are handled. The form --missing=error requests that rev-list stop with an error if a missing object is encountered. This is the default action. The form --missing=allow-any will allow object traversal to continue if a missing object is encountered. Missing objects will silently be omitted from the results. The form --missing=allow-promisor is like allow-any, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing objects will raise an error. The form --missing=print is like allow-any, but will also print a list of the missing objects. Object IDs are prefixed with a “?” character. The form --missing=print-info is like print, but will also print additional information about the missing object inferred from its containing object. The information is all printed on the same line with the missing object ID in the form: ?<oid> [<token>=<value>].... The <token>=<value> pairs containing additional information are separated from each other by a SP. The value is encoded in a token specific fashion, but SP or LF contained in value are always expected to be represented in such a way that the resulting encoded value does not have either of these two problematic bytes. Each <token>=<value> may be one of the following: The path=<path> shows the path of the missing object inferred from a containing object. A path containing SP or special characters is enclosed in double-quotes in the C style as needed. The type=<type> shows the type of the missing object inferred from a containing object. If some tips passed to the traversal are missing, they will be considered as missing too, and the traversal will ignore them. In case we cannot get their Object ID though, an error will be raised.\n**--exclude-promisor-objects**: (For internal use only.) Prefilter object traversal at promisor boundary. This is used with partial clone. This is stronger than --missing=allow-promisor because it limits the traversal, rather than just silencing errors about missing objects.\n**--no-walk[=(sorted|unsorted)]**: Only show the given commits, but do not traverse their ancestors. This has no effect if a range is specified. If the argument unsorted is given, the commits are shown in the order they were given on the command line. Otherwise (if sorted or no argument was given), the commits are shown in reverse chronological order by commit time. Cannot be combined with --graph.\n**--do-walk**: Overrides a previous --no-walk.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 34,
          "content_length": 14212
        }
      },
      {
        "header": "Commit Formatting",
        "content": "Using these options, git-rev-list[1] will act similar to the more specialized family of commit log tools: git-log[1], git-show[1], and git-whatchanged[1].\n\nPretty-print the contents of the commit logs in a given format, where <format> can be one of oneline, short, medium, full, fuller, reference, email, raw, format:<string> and tformat:<string>. When <format> is none of the above, and has %<placeholder> in it, it acts as if --pretty=tformat:<format> were given.\n\nSee the \"PRETTY FORMATS\" section for some additional details for each format. When =<format> part is omitted, it defaults to medium.\n\nInstead of showing the full 40-byte hexadecimal commit object name, show a prefix that names the object uniquely. --abbrev=<n> (which also modifies diff output, if it is displayed) option can be used to specify the minimum length of the prefix.\n\nThis should make --pretty=oneline a whole lot more readable for people using 80-column terminals.\n\nShow the full 40-byte hexadecimal commit object name. This negates --abbrev-commit, either explicit or implied by other options such as --oneline. It also overrides the log.abbrevCommit variable.\n\nThis is a shorthand for --pretty=oneline --abbrev-commit used together.\n\nCommit objects record the character encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user. For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in X and we are outputting in X, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output. Likewise, if iconv(3) fails to convert the commit, we will quietly output the original object verbatim.\n\nPerform a tab expansion (replace each tab with enough spaces to fill to the next display column that is a multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion.\n\nBy default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e. medium, which is the default, full, and fuller).\n\nCheck the validity of a signed commit object by passing the signature to gpg --verify and show the output.\n\nSynonym for --date=relative.\n\nOnly takes effect for dates shown in human-readable format, such as when using --pretty. log.date config variable sets a default value for the log command’s --date option. By default, dates are shown in the original time zone (either committer’s or author’s). If -local is appended to the format (e.g., iso-local), the user’s local time zone is used instead.\n\n--date=relative shows dates relative to the current time, e.g. “2 hours ago”. The -local option has no effect for --date=relative.\n\n--date=local is an alias for --date=default-local.\n\n--date=iso (or --date=iso8601) shows timestamps in a ISO 8601-like format. The differences to the strict ISO 8601 format are:\n\na space instead of the T date/time delimiter\n\na space between time and time zone\n\nno colon between hours and minutes of the time zone\n\n--date=iso-strict (or --date=iso8601-strict) shows timestamps in strict ISO 8601 format.\n\n--date=rfc (or --date=rfc2822) shows timestamps in RFC 2822 format, often found in email messages.\n\n--date=short shows only the date, but not the time, in YYYY-MM-DD format.\n\n--date=raw shows the date as seconds since the epoch (1970-01-01 00:00:00 UTC), followed by a space, and then the timezone as an offset from UTC (a + or - with four digits; the first two are hours, and the second two are minutes). I.e., as if the timestamp were formatted with strftime(\"%s %z\")). Note that the -local option does not affect the seconds-since-epoch value (which is always measured in UTC), but does switch the accompanying timezone value.\n\n--date=human shows the timezone if the timezone does not match the current time-zone, and doesn’t print the whole date if that matches (ie skip printing year for dates that are \"this year\", but also skip the whole date itself if it’s in the last few days and we can just say what weekday it was). For older dates the hour and minute is also omitted.\n\n--date=unix shows the date as a Unix epoch timestamp (seconds since 1970). As with --raw, this is always in UTC and therefore -local has no effect.\n\n--date=format:<format> feeds the <format> to your system strftime, except for %s, %z, and %Z, which are handled internally. Use --date=format:%c to show the date in your system locale’s preferred format. See the strftime(3) manual for a complete list of format placeholders. When using -local, the correct syntax is --date=format-local:<format>.\n\n--date=default is the default format, and is based on ctime(3) output. It shows a single line with three-letter day of the week, three-letter month, day-of-month, hour-minute-seconds in \"HH:MM:SS\" format, followed by 4-digit year, plus timezone information, unless the local time zone is used, e.g. Thu Jan 1 00:00:00 1970 +0000.\n\nPrint the contents of the commit in raw-format; each record is separated with a NUL character.\n\nSuppress the header line containing \"commit\" and the object ID printed before the specified format. This has no effect on the built-in formats; only custom formats are affected.\n\nOverrides a previous --no-commit-header.\n\nPrint also the parents of the commit (in the form \"commit parent…\"). Also enables parent rewriting, see History Simplification above.\n\nPrint also the children of the commit (in the form \"commit child…\"). Also enables parent rewriting, see History Simplification above.\n\nPrint the raw commit timestamp.\n\nMark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with < and those from the right with >. If combined with --boundary, those commits are prefixed with -.\n\nFor example, if you have this topology:\n\nyou would get an output like this:\n\nDraw a text-based graphical representation of the commit history on the left hand side of the output. This may cause extra lines to be printed in between commits, in order for the graph history to be drawn properly. Cannot be combined with --no-walk.\n\nThis enables parent rewriting, see History Simplification above.\n\nThis implies the --topo-order option by default, but the --date-order option may also be specified.\n\nWhen --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If <barrier> is specified, it is the string that will be shown instead of the default one.\n\nPrint a number stating how many commits would have been listed, and suppress all other output. When used together with --left-right, instead print the counts for left and right commits, separated by a tab. When used together with --cherry-mark, omit patch equivalent commits from these counts and print the count for equivalent commits separated by a tab.\n\n• a space instead of the T date/time delimiter\n• a space between time and time zone\n• no colon between hours and minutes of the time zone\n\n**--pretty[=<format>]**: Pretty-print the contents of the commit logs in a given format, where <format> can be one of oneline, short, medium, full, fuller, reference, email, raw, format:<string> and tformat:<string>. When <format> is none of the above, and has %<placeholder> in it, it acts as if --pretty=tformat:<format> were given. See the \"PRETTY FORMATS\" section for some additional details for each format. When =<format> part is omitted, it defaults to medium. Note you can specify the default pretty format in the repository configuration (see git-config[1]).\n**--format=<format>**: Instead of showing the full 40-byte hexadecimal commit object name, show a prefix that names the object uniquely. --abbrev=<n> (which also modifies diff output, if it is displayed) option can be used to specify the minimum length of the prefix. This should make --pretty=oneline a whole lot more readable for people using 80-column terminals.\n**--abbrev-commit**: Show the full 40-byte hexadecimal commit object name. This negates --abbrev-commit, either explicit or implied by other options such as --oneline. It also overrides the log.abbrevCommit variable.\n**--no-abbrev-commit**: This is a shorthand for --pretty=oneline --abbrev-commit used together.\n**--oneline**: Commit objects record the character encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user. For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in X and we are outputting in X, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output. Likewise, if iconv(3) fails to convert the commit, we will quietly output the original object verbatim.\n**--encoding=<encoding>**: Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is a multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion. By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e. medium, which is the default, full, and fuller).\n**--expand-tabs=<n>**: Check the validity of a signed commit object by passing the signature to gpg --verify and show the output.\n**--expand-tabs**: Synonym for --date=relative.\n**--no-expand-tabs**: Only takes effect for dates shown in human-readable format, such as when using --pretty. log.date config variable sets a default value for the log command’s --date option. By default, dates are shown in the original time zone (either committer’s or author’s). If -local is appended to the format (e.g., iso-local), the user’s local time zone is used instead. --date=relative shows dates relative to the current time, e.g. “2 hours ago”. The -local option has no effect for --date=relative. --date=local is an alias for --date=default-local. --date=iso (or --date=iso8601) shows timestamps in a ISO 8601-like format. The differences to the strict ISO 8601 format are: a space instead of the T date/time delimiter a space between time and time zone no colon between hours and minutes of the time zone --date=iso-strict (or --date=iso8601-strict) shows timestamps in strict ISO 8601 format. --date=rfc (or --date=rfc2822) shows timestamps in RFC 2822 format, often found in email messages. --date=short shows only the date, but not the time, in YYYY-MM-DD format. --date=raw shows the date as seconds since the epoch (1970-01-01 00:00:00 UTC), followed by a space, and then the timezone as an offset from UTC (a + or - with four digits; the first two are hours, and the second two are minutes). I.e., as if the timestamp were formatted with strftime(\"%s %z\")). Note that the -local option does not affect the seconds-since-epoch value (which is always measured in UTC), but does switch the accompanying timezone value. --date=human shows the timezone if the timezone does not match the current time-zone, and doesn’t print the whole date if that matches (ie skip printing year for dates that are \"this year\", but also skip the whole date itself if it’s in the last few days and we can just say what weekday it was). For older dates the hour and minute is also omitted. --date=unix shows the date as a Unix epoch timestamp (seconds since 1970). As with --raw, this is always in UTC and therefore -local has no effect. --date=format:<format> feeds the <format> to your system strftime, except for %s, %z, and %Z, which are handled internally. Use --date=format:%c to show the date in your system locale’s preferred format. See the strftime(3) manual for a complete list of format placeholders. When using -local, the correct syntax is --date=format-local:<format>. --date=default is the default format, and is based on ctime(3) output. It shows a single line with three-letter day of the week, three-letter month, day-of-month, hour-minute-seconds in \"HH:MM:SS\" format, followed by 4-digit year, plus timezone information, unless the local time zone is used, e.g. Thu Jan 1 00:00:00 1970 +0000.\n**--show-signature**: Print the contents of the commit in raw-format; each record is separated with a NUL character.\n**--relative-date**: Suppress the header line containing \"commit\" and the object ID printed before the specified format. This has no effect on the built-in formats; only custom formats are affected.\n**--date=<format>**: Overrides a previous --no-commit-header.\n**--header**: Print also the parents of the commit (in the form \"commit parent…\"). Also enables parent rewriting, see History Simplification above.\n**--no-commit-header**: Print also the children of the commit (in the form \"commit child…\"). Also enables parent rewriting, see History Simplification above.\n**--commit-header**: Print the raw commit timestamp.\n**--parents**: Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with < and those from the right with >. If combined with --boundary, those commits are prefixed with -. For example, if you have this topology: y---b---b branch B / \\ / / . / / \\ o---x---a---a branch A you would get an output like this: $ git rev-list --left-right --boundary --pretty=oneline A...B >bbbbbbb... 3rd on b >bbbbbbb... 2nd on b <aaaaaaa... 3rd on a <aaaaaaa... 2nd on a -yyyyyyy... 1st on b -xxxxxxx... 1st on a\n**--children**: Draw a text-based graphical representation of the commit history on the left hand side of the output. This may cause extra lines to be printed in between commits, in order for the graph history to be drawn properly. Cannot be combined with --no-walk. This enables parent rewriting, see History Simplification above. This implies the --topo-order option by default, but the --date-order option may also be specified.\n**--timestamp**: When --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If <barrier> is specified, it is the string that will be shown instead of the default one.\n**--left-right**: Print a number stating how many commits would have been listed, and suppress all other output. When used together with --left-right, instead print the counts for left and right commits, separated by a tab. When used together with --cherry-mark, omit patch equivalent commits from these counts and print the count for equivalent commits separated by a tab.\n\nNote | you can specify the default pretty format in the repository configuration (see git-config[1]).\n\n[Note] Note you can specify the default pretty format in the repository configuration (see git-config[1]).",
        "code_examples": [
          "```bash\ny---b---b  branch B\n\t    / \\ /\n\t   /   .\n\t  /   / \\\n\t o---x---a---a  branch A\n```"
        ],
        "usage_examples": [
          "```bash\n$ git rev-list --left-right --boundary --pretty=oneline A...B\n\n\t>bbbbbbb... 3rd on b\n\t>bbbbbbb... 2nd on b\n\t<aaaaaaa... 3rd on a\n\t<aaaaaaa... 2nd on a\n\t-yyyyyyy... 1st on b\n\t-xxxxxxx... 1st on a\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 41,
          "content_length": 15047
        }
      },
      {
        "header": "PRETTY FORMATS",
        "content": "If the commit is a merge, and if the pretty-format is not oneline, email or raw, an additional line is inserted before the Author: line. This line begins with \"Merge: \" and the hashes of ancestral commits are printed, separated by spaces. Note that the listed commits may not necessarily be the list of the direct parent commits if you have limited your view of history: for example, if you are only interested in changes related to a certain directory or file.\n\nThere are several built-in formats, and you can define additional formats by setting a pretty.<name> config option to either another format name, or a format: string, as described below (see git-config[1]). Here are the details of the built-in formats:\n\nThis is designed to be as compact as possible.\n\nThis format is used to refer to another commit in a commit message and is the same as --pretty='format:%C(auto)%h (%s, %ad). By default, the date is formatted with --date=short unless another --date option is explicitly specified. As with any format: with format placeholders, its output is not affected by other options like --decorate and --walk-reflogs.\n\nLike email, but lines in the commit message starting with \"From \" (preceded by zero or more \">\") are quoted with \">\" so they aren’t confused as starting a new commit.\n\nThe raw format shows the entire commit exactly as stored in the commit object. Notably, the hashes are displayed in full, regardless of whether --abbrev or --no-abbrev are used, and parents information show the true parent commits, without taking grafts or history simplification into account. Note that this format affects the way commits are displayed, but not the way the diff is shown e.g. with git log --raw. To get full object names in a raw diff format, use --no-abbrev.\n\nformat:<format-string>\n\nThe format:<format-string> format allows you to specify which information you want to show. It works a little bit like printf format, with the notable exception that you get a newline with %n instead of \\n.\n\nE.g, format:\"The author of %h was %an, %ar%nThe title was >>%s<<%n\" would show something like this:\n\nThe placeholders are:\n\nPlaceholders that expand to a single literal character:\n\n%x followed by two hexadecimal digits is replaced with a byte with the hexadecimal digits' value (we will call this \"literal formatting code\" in the rest of this document).\n\nPlaceholders that affect formatting of later placeholders:\n\nswitch color to green\n\nswitch color to blue\n\ncolor specification, as described under Values in the \"CONFIGURATION FILE\" section of git-config[1]. By default, colors are shown only when enabled for log output (by color.diff, color.ui, or --color, and respecting the auto settings of the former if we are going to a terminal). %C(auto,<spec>) is accepted as a historical synonym for the default (e.g., %C(auto,red)). Specifying %C(always,<spec>) will show the colors even when color is not otherwise enabled (though consider just using --color=always to enable color for the whole output, including this format and anything else git might color). auto alone (i.e. %C(auto)) will turn on auto coloring on the next placeholders until the color is switched again.\n\nleft (<), right (>) or boundary (-) mark\n\nswitch line wrapping, like the -w option of git-shortlog[1].\n\nmake the next placeholder take at least N column widths, padding spaces on the right if necessary. Optionally truncate (with ellipsis ..) at the left (ltrunc) ..ft, the middle (mtrunc) mi..le, or the end (trunc) rig.., if the output is longer than <n> columns. Note 1: that truncating only works correctly with <n> >= 2. Note 2: spaces around the <n> and <m> (see below) values are optional. Note 3: Emojis and other wide characters will take two display columns, which may over-run column boundaries. Note 4: decomposed character combining marks may be misplaced at padding boundaries.\n\nmake the next placeholder take at least until <m> th display column, padding spaces on the right if necessary. Use negative <m> values for column positions measured from the right hand edge of the terminal window.\n\nsimilar to %<(<n>), %<|(<m>) respectively, but padding spaces on the left\n\nsimilar to %>(<n>), %>|(<m>) respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces\n\nsimilar to %<(<n>), %<|(<m>) respectively, but padding both sides (i.e. the text is centered)\n\nPlaceholders that expand to information extracted from the commit:\n\nabbreviated commit hash\n\nabbreviated tree hash\n\nabbreviated parent hashes\n\nauthor name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\nauthor email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\nauthor email local-part (the part before the @ sign)\n\nauthor local-part (see %al) respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\nauthor date (format respects --date= option)\n\nauthor date, RFC2822 style\n\nauthor date, relative\n\nauthor date, UNIX timestamp\n\nauthor date, ISO 8601-like format\n\nauthor date, strict ISO 8601 format\n\nauthor date, short format (YYYY-MM-DD)\n\nauthor date, human style (like the --date=human option of git-rev-list[1])\n\ncommitter name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\ncommitter email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\ncommitter email local-part (the part before the @ sign)\n\ncommitter local-part (see %cl) respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\ncommitter date (format respects --date= option)\n\ncommitter date, RFC2822 style\n\ncommitter date, relative\n\ncommitter date, UNIX timestamp\n\ncommitter date, ISO 8601-like format\n\ncommitter date, strict ISO 8601 format\n\ncommitter date, short format (YYYY-MM-DD)\n\ncommitter date, human style (like the --date=human option of git-rev-list[1])\n\nref names, like the --decorate option of git-log[1]\n\nref names without the \" (\", \")\" wrapping.\n\nref names with custom decorations. The decorate string may be followed by a colon and zero or more comma-separated options. Option values may contain literal formatting codes. These must be used for commas (%x2C) and closing parentheses (%x29), due to their role in the option syntax.\n\nprefix=<value>: Shown before the list of ref names. Defaults to \" (\".\n\nsuffix=<value>: Shown after the list of ref names. Defaults to \")\".\n\nseparator=<value>: Shown between ref names. Defaults to \", \".\n\npointer=<value>: Shown between HEAD and the branch it points to, if any. Defaults to \" → \".\n\ntag=<value>: Shown before tag names. Defaults to \"tag: \".\n\nFor example, to produce decorations with no wrapping or tag annotations, and spaces as separators:\n\n%(decorate:prefix=,suffix=,tag=,separator= )\n\nhuman-readable name, like git-describe[1]; empty string for undescribable commits. The describe string may be followed by a colon and zero or more comma-separated options. Descriptions can be inconsistent when tags are added or removed at the same time.\n\ntags[=<bool-value>]: Instead of only considering annotated tags, consider lightweight tags as well.\n\nabbrev=<number>: Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <number> digits, or as many digits as needed to form a unique object name.\n\nmatch=<pattern>: Only consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix.\n\nexclude=<pattern>: Do not consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix.\n\nref name given on the command line by which the commit was reached (like git log --source), only works with git log\n\nsanitized subject line, suitable for a filename\n\nraw body (unwrapped subject and body)\n\nraw verification message from GPG for a signed commit\n\nshow \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key) and \"N\" for no signature\n\nshow the name of the signer for a signed commit\n\nshow the key used to sign a signed commit\n\nshow the fingerprint of the key used to sign a signed commit\n\nshow the fingerprint of the primary key whose subkey was used to sign a signed commit\n\nshow the trust level for the key used to sign a signed commit\n\nreflog selector, e.g., refs/stash@{1} or refs/stash@{2 minutes ago}; the format follows the rules described for the -g option. The portion before the @ is the refname as given on the command line (so git log -g refs/heads/master would yield refs/heads/master@{0}).\n\nshortened reflog selector; same as %gD, but the refname portion is shortened for human readability (so refs/heads/master becomes just master).\n\nreflog identity name\n\nreflog identity name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\nreflog identity email\n\nreflog identity email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n\ndisplay the trailers of the body as interpreted by git-interpret-trailers[1]. The trailers string may be followed by a colon and zero or more comma-separated options. If any option is provided multiple times, the last occurrence wins.\n\nkey=<key>: only show trailers with specified <key>. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the only option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with only=false. E.g., %(trailers:key=Reviewed-by) shows trailer lines with key Reviewed-by.\n\nonly[=<bool>]: select whether non-trailer lines from the trailer block should be included.\n\nseparator=<sep>: specify the separator inserted between trailer lines. Defaults to a line feed character. The string <sep> may contain the literal formatting codes described above. To use comma as separator one must use %x2C as it would otherwise be parsed as next option. E.g., %(trailers:key=Ticket,separator=%x2C ) shows all trailer lines whose key is \"Ticket\" separated by a comma and a space.\n\nunfold[=<bool>]: make it behave as if interpret-trailer’s --unfold option was given. E.g., %(trailers:only,unfold=true) unfolds and shows all trailer lines.\n\nkeyonly[=<bool>]: only show the key part of the trailer.\n\nvalueonly[=<bool>]: only show the value part of the trailer.\n\nkey_value_separator=<sep>: specify the separator inserted between the key and value of each trailer. Defaults to \": \". Otherwise it shares the same semantics as separator=<sep> above.\n\nThe boolean options accept an optional value [=<bool-value>]. The values taken by --type=bool git-config[1], like yes and off, are all accepted. Giving a boolean option without =<value> is equivalent to giving it with =true.\n\nIf you add a + (plus sign) after % of a placeholder, a line-feed is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.\n\nIf you add a - (minus sign) after % of a placeholder, all consecutive line-feeds immediately preceding the expansion are deleted if and only if the placeholder expands to an empty string.\n\nIf you add a (space) after % of a placeholder, a space is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.\n\nThe tformat: format works exactly like format:, except that it provides \"terminator\" semantics instead of \"separator\" semantics. In other words, each commit has the message terminator character (usually a newline) appended, rather than a separator placed between entries. This means that the final entry of a single-line format will be properly terminated with a new line, just as the \"oneline\" format does. For example:\n\nIn addition, any unrecognized string that has a % in it is interpreted as if it has tformat: in front of it. For example, these two are equivalent:\n\n• oneline <hash> <title-line> This is designed to be as compact as possible.\n• short commit <hash> Author: <author> <title-line>\n• medium commit <hash> Author: <author> Date: <author-date> <title-line> <full-commit-message>\n• full commit <hash> Author: <author> Commit: <committer> <title-line> <full-commit-message>\n• fuller commit <hash> Author: <author> AuthorDate: <author-date> Commit: <committer> CommitDate: <committer-date> <title-line> <full-commit-message>\n• reference <abbrev-hash> (<title-line>, <short-author-date>) This format is used to refer to another commit in a commit message and is the same as --pretty='format:%C(auto)%h (%s, %ad). By default, the date is formatted with --date=short unless another --date option is explicitly specified. As with any format: with format placeholders, its output is not affected by other options like --decorate and --walk-reflogs.\n• email From <hash> <date> From: <author> Date: <author-date> Subject: [PATCH] <title-line> <full-commit-message>\n• mboxrd Like email, but lines in the commit message starting with \"From \" (preceded by zero or more \">\") are quoted with \">\" so they aren’t confused as starting a new commit.\n• raw The raw format shows the entire commit exactly as stored in the commit object. Notably, the hashes are displayed in full, regardless of whether --abbrev or --no-abbrev are used, and parents information show the true parent commits, without taking grafts or history simplification into account. Note that this format affects the way commits are displayed, but not the way the diff is shown e.g. with git log --raw. To get full object names in a raw diff format, use --no-abbrev.\n• format:<format-string> The format:<format-string> format allows you to specify which information you want to show. It works a little bit like printf format, with the notable exception that you get a newline with %n instead of \\n. E.g, format:\"The author of %h was %an, %ar%nThe title was >>%s<<%n\" would show something like this: The author of fe6e0ee was Junio C Hamano, 23 hours ago The title was >>t4119: test autocomputing -p<n> for traditional diff input.<< The placeholders are: Placeholders that expand to a single literal character: %n newline %% a raw % %x00 %x followed by two hexadecimal digits is replaced with a byte with the hexadecimal digits' value (we will call this \"literal formatting code\" in the rest of this document). Placeholders that affect formatting of later placeholders: %Cred switch color to red %Cgreen switch color to green %Cblue switch color to blue %Creset reset color %C(<spec>) color specification, as described under Values in the \"CONFIGURATION FILE\" section of git-config[1]. By default, colors are shown only when enabled for log output (by color.diff, color.ui, or --color, and respecting the auto settings of the former if we are going to a terminal). %C(auto,<spec>) is accepted as a historical synonym for the default (e.g., %C(auto,red)). Specifying %C(always,<spec>) will show the colors even when color is not otherwise enabled (though consider just using --color=always to enable color for the whole output, including this format and anything else git might color). auto alone (i.e. %C(auto)) will turn on auto coloring on the next placeholders until the color is switched again. %m left (<), right (>) or boundary (-) mark %w([<w>[,<i1>[,<i2>]]]) switch line wrapping, like the -w option of git-shortlog[1]. %<(<n>[,(trunc|ltrunc|mtrunc)]) make the next placeholder take at least N column widths, padding spaces on the right if necessary. Optionally truncate (with ellipsis ..) at the left (ltrunc) ..ft, the middle (mtrunc) mi..le, or the end (trunc) rig.., if the output is longer than <n> columns. Note 1: that truncating only works correctly with <n> >= 2. Note 2: spaces around the <n> and <m> (see below) values are optional. Note 3: Emojis and other wide characters will take two display columns, which may over-run column boundaries. Note 4: decomposed character combining marks may be misplaced at padding boundaries. %<|(<m> ) make the next placeholder take at least until <m> th display column, padding spaces on the right if necessary. Use negative <m> values for column positions measured from the right hand edge of the terminal window. %>(<n>) %>|(<m>) similar to %<(<n>), %<|(<m>) respectively, but padding spaces on the left %>>(<n>) %>>|(<m>) similar to %>(<n>), %>|(<m>) respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces %><(<n>) %><|(<m>) similar to %<(<n>), %<|(<m>) respectively, but padding both sides (i.e. the text is centered) Placeholders that expand to information extracted from the commit: %H commit hash %h abbreviated commit hash %T tree hash %t abbreviated tree hash %P parent hashes %p abbreviated parent hashes %an author name %aN author name (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ae author email %aE author email (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %al author email local-part (the part before the @ sign) %aL author local-part (see %al) respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ad author date (format respects --date= option) %aD author date, RFC2822 style %ar author date, relative %at author date, UNIX timestamp %ai author date, ISO 8601-like format %aI author date, strict ISO 8601 format %as author date, short format (YYYY-MM-DD) %ah author date, human style (like the --date=human option of git-rev-list[1]) %cn committer name %cN committer name (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ce committer email %cE committer email (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %cl committer email local-part (the part before the @ sign) %cL committer local-part (see %cl) respecting .mailmap, see git-shortlog[1] or git-blame[1]) %cd committer date (format respects --date= option) %cD committer date, RFC2822 style %cr committer date, relative %ct committer date, UNIX timestamp %ci committer date, ISO 8601-like format %cI committer date, strict ISO 8601 format %cs committer date, short format (YYYY-MM-DD) %ch committer date, human style (like the --date=human option of git-rev-list[1]) %d ref names, like the --decorate option of git-log[1] %D ref names without the \" (\", \")\" wrapping. %(decorate[:<option>,...]) ref names with custom decorations. The decorate string may be followed by a colon and zero or more comma-separated options. Option values may contain literal formatting codes. These must be used for commas (%x2C) and closing parentheses (%x29), due to their role in the option syntax. prefix=<value>: Shown before the list of ref names. Defaults to \" (\". suffix=<value>: Shown after the list of ref names. Defaults to \")\". separator=<value>: Shown between ref names. Defaults to \", \". pointer=<value>: Shown between HEAD and the branch it points to, if any. Defaults to \" → \". tag=<value>: Shown before tag names. Defaults to \"tag: \". For example, to produce decorations with no wrapping or tag annotations, and spaces as separators: %(decorate:prefix=,suffix=,tag=,separator= ) %(describe[:<option>,...]) human-readable name, like git-describe[1]; empty string for undescribable commits. The describe string may be followed by a colon and zero or more comma-separated options. Descriptions can be inconsistent when tags are added or removed at the same time. tags[=<bool-value>]: Instead of only considering annotated tags, consider lightweight tags as well. abbrev=<number>: Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <number> digits, or as many digits as needed to form a unique object name. match=<pattern>: Only consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix. exclude=<pattern>: Do not consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix. %S ref name given on the command line by which the commit was reached (like git log --source), only works with git log %e encoding %s subject %f sanitized subject line, suitable for a filename %b body %B raw body (unwrapped subject and body) %GG raw verification message from GPG for a signed commit %G? show \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key) and \"N\" for no signature %GS show the name of the signer for a signed commit %GK show the key used to sign a signed commit %GF show the fingerprint of the key used to sign a signed commit %GP show the fingerprint of the primary key whose subkey was used to sign a signed commit %GT show the trust level for the key used to sign a signed commit %gD reflog selector, e.g., refs/stash@{1} or refs/stash@{2 minutes ago}; the format follows the rules described for the -g option. The portion before the @ is the refname as given on the command line (so git log -g refs/heads/master would yield refs/heads/master@{0}). %gd shortened reflog selector; same as %gD, but the refname portion is shortened for human readability (so refs/heads/master becomes just master). %gn reflog identity name %gN reflog identity name (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ge reflog identity email %gE reflog identity email (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %gs reflog subject %(trailers[:<option>,...]) display the trailers of the body as interpreted by git-interpret-trailers[1]. The trailers string may be followed by a colon and zero or more comma-separated options. If any option is provided multiple times, the last occurrence wins. key=<key>: only show trailers with specified <key>. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the only option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with only=false. E.g., %(trailers:key=Reviewed-by) shows trailer lines with key Reviewed-by. only[=<bool>]: select whether non-trailer lines from the trailer block should be included. separator=<sep>: specify the separator inserted between trailer lines. Defaults to a line feed character. The string <sep> may contain the literal formatting codes described above. To use comma as separator one must use %x2C as it would otherwise be parsed as next option. E.g., %(trailers:key=Ticket,separator=%x2C ) shows all trailer lines whose key is \"Ticket\" separated by a comma and a space. unfold[=<bool>]: make it behave as if interpret-trailer’s --unfold option was given. E.g., %(trailers:only,unfold=true) unfolds and shows all trailer lines. keyonly[=<bool>]: only show the key part of the trailer. valueonly[=<bool>]: only show the value part of the trailer. key_value_separator=<sep>: specify the separator inserted between the key and value of each trailer. Defaults to \": \". Otherwise it shares the same semantics as separator=<sep> above.\n\n• Placeholders that expand to a single literal character: %n newline %% a raw % %x00 %x followed by two hexadecimal digits is replaced with a byte with the hexadecimal digits' value (we will call this \"literal formatting code\" in the rest of this document).\n• Placeholders that affect formatting of later placeholders: %Cred switch color to red %Cgreen switch color to green %Cblue switch color to blue %Creset reset color %C(<spec>) color specification, as described under Values in the \"CONFIGURATION FILE\" section of git-config[1]. By default, colors are shown only when enabled for log output (by color.diff, color.ui, or --color, and respecting the auto settings of the former if we are going to a terminal). %C(auto,<spec>) is accepted as a historical synonym for the default (e.g., %C(auto,red)). Specifying %C(always,<spec>) will show the colors even when color is not otherwise enabled (though consider just using --color=always to enable color for the whole output, including this format and anything else git might color). auto alone (i.e. %C(auto)) will turn on auto coloring on the next placeholders until the color is switched again. %m left (<), right (>) or boundary (-) mark %w([<w>[,<i1>[,<i2>]]]) switch line wrapping, like the -w option of git-shortlog[1]. %<(<n>[,(trunc|ltrunc|mtrunc)]) make the next placeholder take at least N column widths, padding spaces on the right if necessary. Optionally truncate (with ellipsis ..) at the left (ltrunc) ..ft, the middle (mtrunc) mi..le, or the end (trunc) rig.., if the output is longer than <n> columns. Note 1: that truncating only works correctly with <n> >= 2. Note 2: spaces around the <n> and <m> (see below) values are optional. Note 3: Emojis and other wide characters will take two display columns, which may over-run column boundaries. Note 4: decomposed character combining marks may be misplaced at padding boundaries. %<|(<m> ) make the next placeholder take at least until <m> th display column, padding spaces on the right if necessary. Use negative <m> values for column positions measured from the right hand edge of the terminal window. %>(<n>) %>|(<m>) similar to %<(<n>), %<|(<m>) respectively, but padding spaces on the left %>>(<n>) %>>|(<m>) similar to %>(<n>), %>|(<m>) respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces %><(<n>) %><|(<m>) similar to %<(<n>), %<|(<m>) respectively, but padding both sides (i.e. the text is centered)\n• Placeholders that expand to information extracted from the commit: %H commit hash %h abbreviated commit hash %T tree hash %t abbreviated tree hash %P parent hashes %p abbreviated parent hashes %an author name %aN author name (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ae author email %aE author email (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %al author email local-part (the part before the @ sign) %aL author local-part (see %al) respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ad author date (format respects --date= option) %aD author date, RFC2822 style %ar author date, relative %at author date, UNIX timestamp %ai author date, ISO 8601-like format %aI author date, strict ISO 8601 format %as author date, short format (YYYY-MM-DD) %ah author date, human style (like the --date=human option of git-rev-list[1]) %cn committer name %cN committer name (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %ce committer email %cE committer email (respecting .mailmap, see git-shortlog[1] or git-blame[1]) %cl committer email local-part (the part before the @ sign) %cL committer local-part (see %cl) respecting .mailmap, see git-shortlog[1] or git-blame[1]) %cd committer date (format respects --date= option) %cD committer date, RFC2822 style %cr committer date, relative %ct committer date, UNIX timestamp %ci committer date, ISO 8601-like format %cI committer date, strict ISO 8601 format %cs committer date, short format (YYYY-MM-DD) %ch committer date, human style (like the --date=human option of git-rev-list[1]) %d ref names, like the --decorate option of git-log[1] %D ref names without the \" (\", \")\" wrapping. %(decorate[:<option>,...]) ref names with custom decorations. The decorate string may be followed by a colon and zero or more comma-separated options. Option values may contain literal formatting codes. These must be used for commas (%x2C) and closing parentheses (%x29), due to their role in the option syntax. prefix=<value>: Shown before the list of ref names. Defaults to \" (\". suffix=<value>: Shown after the list of ref names. Defaults to \")\". separator=<value>: Shown between ref names. Defaults to \", \". pointer=<value>: Shown between HEAD and the branch it points to, if any. Defaults to \" → \". tag=<value>: Shown before tag names. Defaults to \"tag: \".\n\n• prefix=<value>: Shown before the list of ref names. Defaults to \" (\".\n• suffix=<value>: Shown after the list of ref names. Defaults to \")\".\n• separator=<value>: Shown between ref names. Defaults to \", \".\n• pointer=<value>: Shown between HEAD and the branch it points to, if any. Defaults to \" → \".\n• tag=<value>: Shown before tag names. Defaults to \"tag: \".\n\n• tags[=<bool-value>]: Instead of only considering annotated tags, consider lightweight tags as well.\n• abbrev=<number>: Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <number> digits, or as many digits as needed to form a unique object name.\n• match=<pattern>: Only consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix.\n• exclude=<pattern>: Do not consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix.\n\n• key=<key>: only show trailers with specified <key>. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the only option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with only=false. E.g., %(trailers:key=Reviewed-by) shows trailer lines with key Reviewed-by.\n• only[=<bool>]: select whether non-trailer lines from the trailer block should be included.\n• separator=<sep>: specify the separator inserted between trailer lines. Defaults to a line feed character. The string <sep> may contain the literal formatting codes described above. To use comma as separator one must use %x2C as it would otherwise be parsed as next option. E.g., %(trailers:key=Ticket,separator=%x2C ) shows all trailer lines whose key is \"Ticket\" separated by a comma and a space.\n• unfold[=<bool>]: make it behave as if interpret-trailer’s --unfold option was given. E.g., %(trailers:only,unfold=true) unfolds and shows all trailer lines.\n• keyonly[=<bool>]: only show the key part of the trailer.\n• valueonly[=<bool>]: only show the value part of the trailer.\n• key_value_separator=<sep>: specify the separator inserted between the key and value of each trailer. Defaults to \": \". Otherwise it shares the same semantics as separator=<sep> above.\n\n• tformat: The tformat: format works exactly like format:, except that it provides \"terminator\" semantics instead of \"separator\" semantics. In other words, each commit has the message terminator character (usually a newline) appended, rather than a separator placed between entries. This means that the final entry of a single-line format will be properly terminated with a new line, just as the \"oneline\" format does. For example: $ git log -2 --pretty=format:%h 4da45bef \\ | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/' 4da45be 7134973 -- NO NEWLINE $ git log -2 --pretty=tformat:%h 4da45bef \\ | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/' 4da45be 7134973 In addition, any unrecognized string that has a % in it is interpreted as if it has tformat: in front of it. For example, these two are equivalent: $ git log -2 --pretty=tformat:%h 4da45bef $ git log -2 --pretty=%h 4da45bef\n\n**%n**: newline\n**%%**: a raw %\n**%x00**: %x followed by two hexadecimal digits is replaced with a byte with the hexadecimal digits' value (we will call this \"literal formatting code\" in the rest of this document).\n**%Cred**: switch color to red\n**%Cgreen**: switch color to green\n**%Cblue**: switch color to blue\n**%Creset**: reset color\n**%C(<spec>)**: color specification, as described under Values in the \"CONFIGURATION FILE\" section of git-config[1]. By default, colors are shown only when enabled for log output (by color.diff, color.ui, or --color, and respecting the auto settings of the former if we are going to a terminal). %C(auto,<spec>) is accepted as a historical synonym for the default (e.g., %C(auto,red)). Specifying %C(always,<spec>) will show the colors even when color is not otherwise enabled (though consider just using --color=always to enable color for the whole output, including this format and anything else git might color). auto alone (i.e. %C(auto)) will turn on auto coloring on the next placeholders until the color is switched again.\n**%m**: left (<), right (>) or boundary (-) mark\n**%w([<w>[,<i1>[,<i2>]]])**: switch line wrapping, like the -w option of git-shortlog[1].\n**%<(<n>[,(trunc|ltrunc|mtrunc)])**: make the next placeholder take at least N column widths, padding spaces on the right if necessary. Optionally truncate (with ellipsis ..) at the left (ltrunc) ..ft, the middle (mtrunc) mi..le, or the end (trunc) rig.., if the output is longer than <n> columns. Note 1: that truncating only works correctly with <n> >= 2. Note 2: spaces around the <n> and <m> (see below) values are optional. Note 3: Emojis and other wide characters will take two display columns, which may over-run column boundaries. Note 4: decomposed character combining marks may be misplaced at padding boundaries.\n**%<|(<m> )**: make the next placeholder take at least until <m> th display column, padding spaces on the right if necessary. Use negative <m> values for column positions measured from the right hand edge of the terminal window.\n**%>(<n>)**: similar to %<(<n>), %<|(<m>) respectively, but padding spaces on the left\n**%>|(<m>)**: similar to %>(<n>), %>|(<m>) respectively, except that if the next placeholder takes more spaces than given and there are spaces on its left, use those spaces\n**%>>(<n>)**: similar to %<(<n>), %<|(<m>) respectively, but padding both sides (i.e. the text is centered)\n**%H**: commit hash\n**%h**: abbreviated commit hash\n**%T**: tree hash\n**%t**: abbreviated tree hash\n**%P**: parent hashes\n**%p**: abbreviated parent hashes\n**%an**: author name\n**%aN**: author name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%ae**: author email\n**%aE**: author email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%al**: author email local-part (the part before the @ sign)\n**%aL**: author local-part (see %al) respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%ad**: author date (format respects --date= option)\n**%aD**: author date, RFC2822 style\n**%ar**: author date, relative\n**%at**: author date, UNIX timestamp\n**%ai**: author date, ISO 8601-like format\n**%aI**: author date, strict ISO 8601 format\n**%as**: author date, short format (YYYY-MM-DD)\n**%ah**: author date, human style (like the --date=human option of git-rev-list[1])\n**%cn**: committer name\n**%cN**: committer name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%ce**: committer email\n**%cE**: committer email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%cl**: committer email local-part (the part before the @ sign)\n**%cL**: committer local-part (see %cl) respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%cd**: committer date (format respects --date= option)\n**%cD**: committer date, RFC2822 style\n**%cr**: committer date, relative\n**%ct**: committer date, UNIX timestamp\n**%ci**: committer date, ISO 8601-like format\n**%cI**: committer date, strict ISO 8601 format\n**%cs**: committer date, short format (YYYY-MM-DD)\n**%ch**: committer date, human style (like the --date=human option of git-rev-list[1])\n**%d**: ref names, like the --decorate option of git-log[1]\n**%D**: ref names without the \" (\", \")\" wrapping.\n**%(decorate[:<option>,...])**: ref names with custom decorations. The decorate string may be followed by a colon and zero or more comma-separated options. Option values may contain literal formatting codes. These must be used for commas (%x2C) and closing parentheses (%x29), due to their role in the option syntax. prefix=<value>: Shown before the list of ref names. Defaults to \" (\". suffix=<value>: Shown after the list of ref names. Defaults to \")\". separator=<value>: Shown between ref names. Defaults to \", \". pointer=<value>: Shown between HEAD and the branch it points to, if any. Defaults to \" → \". tag=<value>: Shown before tag names. Defaults to \"tag: \".\n**%(describe[:<option>,...])**: human-readable name, like git-describe[1]; empty string for undescribable commits. The describe string may be followed by a colon and zero or more comma-separated options. Descriptions can be inconsistent when tags are added or removed at the same time. tags[=<bool-value>]: Instead of only considering annotated tags, consider lightweight tags as well. abbrev=<number>: Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <number> digits, or as many digits as needed to form a unique object name. match=<pattern>: Only consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix. exclude=<pattern>: Do not consider tags matching the given glob(7) <pattern>, excluding the refs/tags/ prefix.\n**%S**: ref name given on the command line by which the commit was reached (like git log --source), only works with git log\n**%e**: encoding\n**%s**: subject\n**%f**: sanitized subject line, suitable for a filename\n**%b**: body\n**%B**: raw body (unwrapped subject and body)\n**%GG**: raw verification message from GPG for a signed commit\n**%G?**: show \"G\" for a good (valid) signature, \"B\" for a bad signature, \"U\" for a good signature with unknown validity, \"X\" for a good signature that has expired, \"Y\" for a good signature made by an expired key, \"R\" for a good signature made by a revoked key, \"E\" if the signature cannot be checked (e.g. missing key) and \"N\" for no signature\n**%GS**: show the name of the signer for a signed commit\n**%GK**: show the key used to sign a signed commit\n**%GF**: show the fingerprint of the key used to sign a signed commit\n**%GP**: show the fingerprint of the primary key whose subkey was used to sign a signed commit\n**%GT**: show the trust level for the key used to sign a signed commit\n**%gD**: reflog selector, e.g., refs/stash@{1} or refs/stash@{2 minutes ago}; the format follows the rules described for the -g option. The portion before the @ is the refname as given on the command line (so git log -g refs/heads/master would yield refs/heads/master@{0}).\n**%gd**: shortened reflog selector; same as %gD, but the refname portion is shortened for human readability (so refs/heads/master becomes just master).\n**%gn**: reflog identity name\n**%gN**: reflog identity name (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%ge**: reflog identity email\n**%gE**: reflog identity email (respecting .mailmap, see git-shortlog[1] or git-blame[1])\n**%gs**: reflog subject\n**%(trailers[:<option>,...])**: display the trailers of the body as interpreted by git-interpret-trailers[1]. The trailers string may be followed by a colon and zero or more comma-separated options. If any option is provided multiple times, the last occurrence wins. key=<key>: only show trailers with specified <key>. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the only option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with only=false. E.g., %(trailers:key=Reviewed-by) shows trailer lines with key Reviewed-by. only[=<bool>]: select whether non-trailer lines from the trailer block should be included. separator=<sep>: specify the separator inserted between trailer lines. Defaults to a line feed character. The string <sep> may contain the literal formatting codes described above. To use comma as separator one must use %x2C as it would otherwise be parsed as next option. E.g., %(trailers:key=Ticket,separator=%x2C ) shows all trailer lines whose key is \"Ticket\" separated by a comma and a space. unfold[=<bool>]: make it behave as if interpret-trailer’s --unfold option was given. E.g., %(trailers:only,unfold=true) unfolds and shows all trailer lines. keyonly[=<bool>]: only show the key part of the trailer. valueonly[=<bool>]: only show the value part of the trailer. key_value_separator=<sep>: specify the separator inserted between the key and value of each trailer. Defaults to \": \". Otherwise it shares the same semantics as separator=<sep> above.\n\nNote | Some placeholders may depend on other options given to the revision traversal engine. For example, the %g* reflog options will insert an empty string unless we are traversing reflog entries (e.g., by git log -g). The %d and %D placeholders will use the \"short\" decoration format if --decorate was not already provided on the command line.\n\n[Note] Note Some placeholders may depend on other options given to the revision traversal engine. For example, the %g* reflog options will insert an empty string unless we are traversing reflog entries (e.g., by git log -g). The %d and %D placeholders will use the \"short\" decoration format if --decorate was not already provided on the command line.",
        "code_examples": [
          "```bash\n<hash><title-line>\n```",
          "```bash\ncommit<hash>Author: <author>\n```",
          "```bash\n<title-line>\n```",
          "```bash\ncommit<hash>Author: <author>\nDate:   <author-date>\n```",
          "```bash\n<title-line>\n```",
          "```bash\n<full-commit-message>\n```",
          "```bash\ncommit<hash>Author: <author>\nCommit: <committer>\n```",
          "```bash\n<title-line>\n```",
          "```bash\n<full-commit-message>\n```",
          "```bash\ncommit<hash>Author:     <author>\nAuthorDate: <author-date>\nCommit:     <committer>\nCommitDate: <committer-date>\n```",
          "```bash\n<title-line>\n```",
          "```bash\n<full-commit-message>\n```",
          "```bash\n<abbrev-hash> (<title-line>, <short-author-date>)\n```",
          "```bash\nFrom<hash><date>\nFrom: <author>\nDate: <author-date>\nSubject: [PATCH] <title-line>\n```",
          "```bash\n<full-commit-message>\n```",
          "```bash\nThe author of fe6e0ee was Junio C Hamano, 23 hours ago\nThe title was >>t4119: test autocomputing -p<n> for traditional diff input.<<\n```"
        ],
        "usage_examples": [
          "```bash\n$ git log -2 --pretty=format:%h 4da45bef \\\n  | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/'\n4da45be\n7134973 -- NO NEWLINE\n\n$ git log -2 --pretty=tformat:%h 4da45bef \\\n  | perl -pe '$_ .= \" -- NO NEWLINE\\n\" unless /\\n/'\n4da45be\n7134973\n```",
          "```bash\n$ git log -2 --pretty=tformat:%h 4da45bef\n$ git log -2 --pretty=%h 4da45bef\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 96,
          "content_length": 41224
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Print the list of commits reachable from the current branch.\n\nPrint the list of commits on this branch, but not present in the upstream branch.\n\nFormat commits with their author and commit message (see also the porcelain git-log[1]).\n\nFormat commits along with their diffs (see also the porcelain git-log[1], which can do this in a single process).\n\nPrint the list of commits on the current branch that touched any file in the Documentation directory.\n\nPrint the list of commits authored by you in the past year, on any branch, tag, or other ref.\n\nPrint the list of objects reachable from the current branch (i.e., all commits and the blobs and trees they contain).\n\nCompare the disk size of all reachable objects, versus those reachable from reflogs, versus the total packed size. This can tell you whether running git repack -ad might reduce the repository size (by dropping unreachable objects), and whether expiring reflogs might help.\n\nReport the disk size of each branch, not including objects used by the current branch. This can find outliers that are contributing to a bloated repository size (e.g., because somebody accidentally committed large build artifacts).\n\nCompare the on-disk size of branches in one group of refs, excluding another. If you co-mingle objects from multiple remotes in a single repository, this can show which remotes are contributing to the repository size (taking the size of origin as a baseline).\n\n• Print the list of commits reachable from the current branch. git rev-list HEAD\n• Print the list of commits on this branch, but not present in the upstream branch. git rev-list @{upstream}..HEAD\n• Format commits with their author and commit message (see also the porcelain git-log[1]). git rev-list --format=medium HEAD\n• Format commits along with their diffs (see also the porcelain git-log[1], which can do this in a single process). git rev-list HEAD | git diff-tree --stdin --format=medium -p\n• Print the list of commits on the current branch that touched any file in the Documentation directory. git rev-list HEAD -- Documentation/\n• Print the list of commits authored by you in the past year, on any branch, tag, or other ref. git rev-list --author=you@example.com --since=1.year.ago --all\n• Print the list of objects reachable from the current branch (i.e., all commits and the blobs and trees they contain). git rev-list --objects HEAD\n• Compare the disk size of all reachable objects, versus those reachable from reflogs, versus the total packed size. This can tell you whether running git repack -ad might reduce the repository size (by dropping unreachable objects), and whether expiring reflogs might help. # reachable objects git rev-list --disk-usage --objects --all # plus reflogs git rev-list --disk-usage --objects --all --reflog # total disk size used du -c .git/objects/pack/*.pack .git/objects/??/* # alternative to du: add up \"size\" and \"size-pack\" fields git count-objects -v\n• Report the disk size of each branch, not including objects used by the current branch. This can find outliers that are contributing to a bloated repository size (e.g., because somebody accidentally committed large build artifacts). git for-each-ref --format='%(refname)' | while read branch do size=$(git rev-list --disk-usage --objects HEAD..$branch) echo \"$size $branch\" done | sort -n\n• Compare the on-disk size of branches in one group of refs, excluding another. If you co-mingle objects from multiple remotes in a single repository, this can show which remotes are contributing to the repository size (taking the size of origin as a baseline). git rev-list --disk-usage --objects --remotes=$suspect --not --remotes=origin",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit rev-list HEAD\n```",
          "```bash\ngit rev-list @{upstream}..HEAD\n```",
          "```bash\ngit rev-list --format=medium HEAD\n```",
          "```bash\ngit rev-list HEAD |\ngit diff-tree --stdin --format=medium -p\n```",
          "```bash\ngit rev-list HEAD -- Documentation/\n```",
          "```bash\ngit rev-list --author=you@example.com --since=1.year.ago --all\n```",
          "```bash\ngit rev-list --objects HEAD\n```",
          "```bash\n# reachable objects\ngit rev-list --disk-usage --objects --all\n# plus reflogs\ngit rev-list --disk-usage --objects --all --reflog\n# total disk size used\ndu -c .git/objects/pack/*.pack .git/objects/??/*\n# alternative to du: add up \"size\" and \"size-pack\" fields\ngit count-objects -v\n```",
          "```bash\ngit for-each-ref --format='%(refname)' |\nwhile read branch\ndo\n\tsize=$(git rev-list --disk-usage --objects HEAD..$branch)\n\techo \"$size $branch\"\ndone |\nsort -n\n```",
          "```bash\ngit rev-list --disk-usage --objects --remotes=$suspect --not --remotes=origin\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 3663
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-rev-list",
    "doc_type": "git",
    "total_sections": 11
  },
  {
    "title": "Git",
    "summary": "NAME git-rev-parse - Pick out and massage parameters",
    "sections": [
      {
        "header": "NAME",
        "content": "git-rev-parse - Pick out and massage parameters",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 47
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Many Git porcelainish commands take a mixture of flags (i.e. parameters that begin with a dash -) and parameters meant for the underlying git rev-list command they use internally and flags and parameters for the other commands they use downstream of git rev-list. The primary purpose of this command is to allow calling programs to distinguish between them. There are a few other operation modes that have nothing to do with the above \"help parse command line options\".\n\nUnless otherwise specified, most of the options and operation modes require you to run this command inside a git repository or a working tree that is under the control of a git repository, and will give you a fatal error otherwise.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 702
        }
      },
      {
        "header": "Operation Modes",
        "content": "Each of these options must appear first on the command line.\n\nUse git rev-parse in option parsing mode (see PARSEOPT section below). The command in this mode can be used outside a repository or a working tree controlled by a repository.\n\nUse git rev-parse in shell quoting mode (see SQ-QUOTE section below). In contrast to the --sq option below, this mode only does quoting. Nothing else is done to command input. The command in this mode can be used outside a repository or a working tree controlled by a repository.\n\n**--parseopt**: Use git rev-parse in option parsing mode (see PARSEOPT section below). The command in this mode can be used outside a repository or a working tree controlled by a repository.\n**--sq-quote**: Use git rev-parse in shell quoting mode (see SQ-QUOTE section below). In contrast to the --sq option below, this mode only does quoting. Nothing else is done to command input. The command in this mode can be used outside a repository or a working tree controlled by a repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 1005
        }
      },
      {
        "header": "Options for --parseopt",
        "content": "Only meaningful in --parseopt mode. Tells the option parser to echo out the first -- met instead of skipping it.\n\nOnly meaningful in --parseopt mode. Lets the option parser stop at the first non-option argument. This can be used to parse sub-commands that take options themselves.\n\nOnly meaningful in --parseopt mode. Output the options in their long form if available, and with their arguments stuck.\n\n**--keep-dashdash**: Only meaningful in --parseopt mode. Tells the option parser to echo out the first -- met instead of skipping it.\n**--stop-at-non-option**: Only meaningful in --parseopt mode. Lets the option parser stop at the first non-option argument. This can be used to parse sub-commands that take options themselves.\n**--stuck-long**: Only meaningful in --parseopt mode. Output the options in their long form if available, and with their arguments stuck.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 867
        }
      },
      {
        "header": "Options for Filtering",
        "content": "Do not output flags and parameters not meant for git rev-list command.\n\nDo not output flags and parameters meant for git rev-list command.\n\nDo not output non-flag parameters.\n\nDo not output flag parameters.\n\n**--revs-only**: Do not output flags and parameters not meant for git rev-list command.\n**--no-revs**: Do not output flags and parameters meant for git rev-list command.\n**--flags**: Do not output non-flag parameters.\n**--no-flags**: Do not output flag parameters.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 472
        }
      },
      {
        "header": "Options for Output",
        "content": "If there is no parameter given by the user, use <arg> instead.\n\nBehave as if git rev-parse was invoked from the <arg> subdirectory of the working tree. Any relative filenames are resolved as if they are prefixed by <arg> and will be printed in that form.\n\nThis can be used to convert arguments to a command run in a subdirectory so that they can still be used after moving to the top-level of the repository. For example:\n\nVerify that exactly one parameter is provided, and that it can be turned into a raw 20-byte SHA-1 that can be used to access the object database. If so, emit it to the standard output; otherwise, error out.\n\nIf you want to make sure that the output actually names an object in your object database and/or can be used as a specific type of object you require, you can add the ^{type} peeling operator to the parameter. For example, git rev-parse \"$VAR^{commit}\" will make sure $VAR names an existing object that is a commit-ish (i.e. a commit, or an annotated tag that points at a commit). To make sure that $VAR names an existing object of any type, git rev-parse \"$VAR^{object}\" can be used.\n\nNote that if you are verifying a name from an untrusted source, it is wise to use --end-of-options so that the name argument is not mistaken for another option.\n\nOnly meaningful in --verify mode. Do not output an error message if the first argument is not a valid object name; instead exit with non-zero status silently. SHA-1s for valid object names are printed to stdout on success.\n\nUsually the output is made one line per flag and parameter. This option makes output a single line, properly quoted for consumption by shell. Useful when you expect your parameter to contain whitespaces and newlines (e.g. when using pickaxe -S with git diff-*). In contrast to the --sq-quote option, the command input is still interpreted as usual.\n\nSame as --verify but shortens the object name to a unique prefix with at least length characters. The minimum length is 4, the default is the effective value of the core.abbrev configuration variable (see git-config[1]).\n\nWhen showing object names, prefix them with ^ and strip ^ prefix from the object names that already have one.\n\nA non-ambiguous short name of the objects name. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode.\n\nUsually the object names are output in SHA-1 form (with possible ^ prefix); this option makes them output in a form as close to the original input as possible.\n\nThis is similar to --symbolic, but it omits input that are not refs (i.e. branch or tag names; or more explicitly disambiguating \"heads/master\" form, when you want to name the \"master\" branch when there is an unfortunately named tag \"master\"), and shows them as full refnames (e.g. \"refs/heads/master\").\n\nAllow oids to be input from any object format that the current repository supports.\n\nSpecifying \"sha1\" translates if necessary and returns a sha1 oid.\n\nSpecifying \"sha256\" translates if necessary and returns a sha256 oid.\n\nSpecifying \"storage\" translates if necessary and returns an oid in encoded in the storage hash algorithm.\n\n**--default <arg>**: If there is no parameter given by the user, use <arg> instead.\n**--prefix <arg>**: Behave as if git rev-parse was invoked from the <arg> subdirectory of the working tree. Any relative filenames are resolved as if they are prefixed by <arg> and will be printed in that form. This can be used to convert arguments to a command run in a subdirectory so that they can still be used after moving to the top-level of the repository. For example: prefix=$(git rev-parse --show-prefix) cd \"$(git rev-parse --show-toplevel)\" # rev-parse provides the -- needed for 'set' eval \"set $(git rev-parse --sq --prefix \"$prefix\" -- \"$@\")\"\n**--verify**: Verify that exactly one parameter is provided, and that it can be turned into a raw 20-byte SHA-1 that can be used to access the object database. If so, emit it to the standard output; otherwise, error out. If you want to make sure that the output actually names an object in your object database and/or can be used as a specific type of object you require, you can add the ^{type} peeling operator to the parameter. For example, git rev-parse \"$VAR^{commit}\" will make sure $VAR names an existing object that is a commit-ish (i.e. a commit, or an annotated tag that points at a commit). To make sure that $VAR names an existing object of any type, git rev-parse \"$VAR^{object}\" can be used. Note that if you are verifying a name from an untrusted source, it is wise to use --end-of-options so that the name argument is not mistaken for another option.\n**-q**: Only meaningful in --verify mode. Do not output an error message if the first argument is not a valid object name; instead exit with non-zero status silently. SHA-1s for valid object names are printed to stdout on success.\n**--quiet**: Usually the output is made one line per flag and parameter. This option makes output a single line, properly quoted for consumption by shell. Useful when you expect your parameter to contain whitespaces and newlines (e.g. when using pickaxe -S with git diff-*). In contrast to the --sq-quote option, the command input is still interpreted as usual.\n**--sq**: Same as --verify but shortens the object name to a unique prefix with at least length characters. The minimum length is 4, the default is the effective value of the core.abbrev configuration variable (see git-config[1]).\n**--short[=<length>]**: When showing object names, prefix them with ^ and strip ^ prefix from the object names that already have one.\n**--not**: A non-ambiguous short name of the objects name. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode.\n**--abbrev-ref[=(strict|loose)]**: Usually the object names are output in SHA-1 form (with possible ^ prefix); this option makes them output in a form as close to the original input as possible.\n**--symbolic**: This is similar to --symbolic, but it omits input that are not refs (i.e. branch or tag names; or more explicitly disambiguating \"heads/master\" form, when you want to name the \"master\" branch when there is an unfortunately named tag \"master\"), and shows them as full refnames (e.g. \"refs/heads/master\").\n**--symbolic-full-name**: Allow oids to be input from any object format that the current repository supports. Specifying \"sha1\" translates if necessary and returns a sha1 oid. Specifying \"sha256\" translates if necessary and returns a sha256 oid. Specifying \"storage\" translates if necessary and returns an oid in encoded in the storage hash algorithm.",
        "code_examples": [],
        "usage_examples": [
          "```bash\nprefix=$(git rev-parse --show-prefix)\ncd \"$(git rev-parse --show-toplevel)\"\n# rev-parse provides the -- needed for 'set'\neval \"set $(git rev-parse --sq --prefix \"$prefix\" -- \"$@\")\"\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 17,
          "content_length": 6587
        }
      },
      {
        "header": "Options for Objects",
        "content": "Show all refs found in refs/.\n\nShow all branches, tags, or remote-tracking branches, respectively (i.e., refs found in refs/heads, refs/tags, or refs/remotes, respectively).\n\nIf a pattern is given, only refs matching the given shell glob are shown. If the pattern does not contain a globbing character (?, *, or [), it is turned into a prefix match by appending /*.\n\nShow all refs matching the shell glob pattern pattern. If the pattern does not start with refs/, this is automatically prepended. If the pattern does not contain a globbing character (?, *, or [), it is turned into a prefix match by appending /*.\n\nDo not include refs matching <glob-pattern> that the next --all, --branches, --tags, --remotes, or --glob would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next --all, --branches, --tags, --remotes, or --glob option (other options or arguments do not clear accumulated patterns).\n\nThe patterns given should not begin with refs/heads, refs/tags, or refs/remotes when applied to --branches, --tags, or --remotes, respectively, and they must begin with refs/ when applied to --glob or --all. If a trailing /* is intended, it must be given explicitly.\n\nDo not include refs that would be hidden by git-fetch, git-receive-pack or git-upload-pack by consulting the appropriate fetch.hideRefs, receive.hideRefs or uploadpack.hideRefs configuration along with transfer.hideRefs (see git-config[1]). This option affects the next pseudo-ref option --all or --glob and is cleared after processing them.\n\nShow every object whose name begins with the given prefix. The <prefix> must be at least 4 hexadecimal digits long to avoid listing each and every object in the repository by mistake.\n\n**--all**: Show all refs found in refs/.\n**--branches[=<pattern>]**: Show all branches, tags, or remote-tracking branches, respectively (i.e., refs found in refs/heads, refs/tags, or refs/remotes, respectively). If a pattern is given, only refs matching the given shell glob are shown. If the pattern does not contain a globbing character (?, *, or [), it is turned into a prefix match by appending /*.\n**--tags[=<pattern>]**: Show all refs matching the shell glob pattern pattern. If the pattern does not start with refs/, this is automatically prepended. If the pattern does not contain a globbing character (?, *, or [), it is turned into a prefix match by appending /*.\n**--remotes[=<pattern>]**: Do not include refs matching <glob-pattern> that the next --all, --branches, --tags, --remotes, or --glob would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next --all, --branches, --tags, --remotes, or --glob option (other options or arguments do not clear accumulated patterns). The patterns given should not begin with refs/heads, refs/tags, or refs/remotes when applied to --branches, --tags, or --remotes, respectively, and they must begin with refs/ when applied to --glob or --all. If a trailing /* is intended, it must be given explicitly.\n**--glob=<pattern>**: Do not include refs that would be hidden by git-fetch, git-receive-pack or git-upload-pack by consulting the appropriate fetch.hideRefs, receive.hideRefs or uploadpack.hideRefs configuration along with transfer.hideRefs (see git-config[1]). This option affects the next pseudo-ref option --all or --glob and is cleared after processing them.\n**--exclude=<glob-pattern>**: Show every object whose name begins with the given prefix. The <prefix> must be at least 4 hexadecimal digits long to avoid listing each and every object in the repository by mistake.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 3603
        }
      },
      {
        "header": "Options for Files",
        "content": "List the GIT_* environment variables that are local to the repository (e.g. GIT_DIR or GIT_WORK_TREE, but not GIT_EDITOR). Only the names of the variables are listed, not their value, even if they are set.\n\nControls the behavior of certain other options. If specified as absolute, the paths printed by those options will be absolute and canonical. If specified as relative, the paths will be relative to the current working directory if that is possible. The default is option specific.\n\nThis option may be specified multiple times and affects only the arguments that follow it on the command line, either to the end of the command line or the next instance of this option.\n\nThe following options are modified by --path-format:\n\nShow $GIT_DIR if defined. Otherwise show the path to the .git directory. The path shown, when relative, is relative to the current working directory.\n\nIf $GIT_DIR is not defined and the current directory is not detected to lie in a Git repository or work tree print a message to stderr and exit with nonzero status.\n\nShow $GIT_COMMON_DIR if defined, else $GIT_DIR.\n\nCheck if <path> is a valid repository or a gitfile that points at a valid repository, and print the location of the repository. If <path> is a gitfile then the resolved path to the real repository is printed.\n\nResolve \"$GIT_DIR/<path>\" and takes other path relocation variables such as $GIT_OBJECT_DIRECTORY, $GIT_INDEX_FILE… into account. For example, if $GIT_OBJECT_DIRECTORY is set to /foo/bar then \"git rev-parse --git-path objects/abc\" returns /foo/bar/abc.\n\nShow the (by default, absolute) path of the top-level directory of the working tree. If there is no working tree, report an error.\n\nShow the absolute path of the root of the superproject’s working tree (if exists) that uses the current repository as its submodule. Outputs nothing if the current repository is not used as a submodule by any project.\n\nShow the path to the shared index file in split index mode, or empty if not in split-index mode.\n\nThe following options are unaffected by --path-format:\n\nLike --git-dir, but its output is always the canonicalized absolute path.\n\nWhen the current working directory is below the repository directory print \"true\", otherwise \"false\".\n\nWhen the current working directory is inside the work tree of the repository print \"true\", otherwise \"false\".\n\nWhen the repository is bare print \"true\", otherwise \"false\".\n\nWhen the repository is shallow print \"true\", otherwise \"false\".\n\nWhen the command is invoked from a subdirectory, show the path of the top-level directory relative to the current directory (typically a sequence of \"../\", or an empty string).\n\nWhen the command is invoked from a subdirectory, show the path of the current directory relative to the top-level directory.\n\nShow the object format (hash algorithm) used for the repository for storage inside the .git directory, input, or output. For input, multiple algorithms may be printed, space-separated. If not specified, the default is \"storage\".\n\nShow the reference storage format used for the repository.\n\n**--local-env-vars**: List the GIT_* environment variables that are local to the repository (e.g. GIT_DIR or GIT_WORK_TREE, but not GIT_EDITOR). Only the names of the variables are listed, not their value, even if they are set.\n**--path-format=(absolute|relative)**: Controls the behavior of certain other options. If specified as absolute, the paths printed by those options will be absolute and canonical. If specified as relative, the paths will be relative to the current working directory if that is possible. The default is option specific. This option may be specified multiple times and affects only the arguments that follow it on the command line, either to the end of the command line or the next instance of this option.\n**--git-dir**: Show $GIT_DIR if defined. Otherwise show the path to the .git directory. The path shown, when relative, is relative to the current working directory. If $GIT_DIR is not defined and the current directory is not detected to lie in a Git repository or work tree print a message to stderr and exit with nonzero status.\n**--git-common-dir**: Show $GIT_COMMON_DIR if defined, else $GIT_DIR.\n**--resolve-git-dir <path>**: Check if <path> is a valid repository or a gitfile that points at a valid repository, and print the location of the repository. If <path> is a gitfile then the resolved path to the real repository is printed.\n**--git-path <path>**: Resolve \"$GIT_DIR/<path>\" and takes other path relocation variables such as $GIT_OBJECT_DIRECTORY, $GIT_INDEX_FILE… into account. For example, if $GIT_OBJECT_DIRECTORY is set to /foo/bar then \"git rev-parse --git-path objects/abc\" returns /foo/bar/abc.\n**--show-toplevel**: Show the (by default, absolute) path of the top-level directory of the working tree. If there is no working tree, report an error.\n**--show-superproject-working-tree**: Show the absolute path of the root of the superproject’s working tree (if exists) that uses the current repository as its submodule. Outputs nothing if the current repository is not used as a submodule by any project.\n**--shared-index-path**: Show the path to the shared index file in split index mode, or empty if not in split-index mode.\n**--absolute-git-dir**: Like --git-dir, but its output is always the canonicalized absolute path.\n**--is-inside-git-dir**: When the current working directory is below the repository directory print \"true\", otherwise \"false\".\n**--is-inside-work-tree**: When the current working directory is inside the work tree of the repository print \"true\", otherwise \"false\".\n**--is-bare-repository**: When the repository is bare print \"true\", otherwise \"false\".\n**--is-shallow-repository**: When the repository is shallow print \"true\", otherwise \"false\".\n**--show-cdup**: When the command is invoked from a subdirectory, show the path of the top-level directory relative to the current directory (typically a sequence of \"../\", or an empty string).\n**--show-prefix**: When the command is invoked from a subdirectory, show the path of the current directory relative to the top-level directory.\n**--show-object-format[=(storage|input|output)]**: Show the object format (hash algorithm) used for the repository for storage inside the .git directory, input, or output. For input, multiple algorithms may be printed, space-separated. If not specified, the default is \"storage\".\n**--show-ref-format**: Show the reference storage format used for the repository.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 22,
          "content_length": 6493
        }
      },
      {
        "header": "Other Options",
        "content": "Parse the date string, and output the corresponding --max-age= parameter for git rev-list.\n\nParse the date string, and output the corresponding --min-age= parameter for git rev-list.\n\nFlags and parameters to be parsed.\n\n**--since=<datestring>**: Parse the date string, and output the corresponding --max-age= parameter for git rev-list.\n**--after=<datestring>**: Parse the date string, and output the corresponding --min-age= parameter for git rev-list.\n**--until=<datestring>**: Flags and parameters to be parsed.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 514
        }
      },
      {
        "header": "SPECIFYING REVISIONS",
        "content": "A revision parameter <rev> typically, but not necessarily, names a commit object. It uses what is called an extended SHA-1 syntax. Here are various ways to spell object names. The ones listed near the end of this list name trees and blobs contained in a commit.\n\nThe full SHA-1 object name (40-byte hexadecimal string), or a leading substring that is unique within the repository. E.g. dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the same commit object if there is no other object in your repository whose object name starts with dae86e.\n\nOutput from git describe; i.e. a closest tag, optionally followed by a dash and a number of commits, followed by a dash, a g, and an abbreviated object name.\n\nA symbolic ref name. E.g. master typically means the commit object referenced by refs/heads/master. If you happen to have both heads/master and tags/master, you can explicitly say heads/master to tell Git which one you mean. When ambiguous, a <refname> is disambiguated by taking the first match in the following rules:\n\nIf $GIT_DIR/<refname> exists, that is what you mean (this is usually useful only for HEAD, FETCH_HEAD, ORIG_HEAD, MERGE_HEAD, REBASE_HEAD, REVERT_HEAD, CHERRY_PICK_HEAD, BISECT_HEAD and AUTO_MERGE);\n\notherwise, refs/<refname> if it exists;\n\notherwise, refs/tags/<refname> if it exists;\n\notherwise, refs/heads/<refname> if it exists;\n\notherwise, refs/remotes/<refname> if it exists;\n\notherwise, refs/remotes/<refname>/HEAD if it exists.\n\nnames the commit on which you based the changes in the working tree.\n\nrecords the branch which you fetched from a remote repository with your last git fetch invocation.\n\nis created by commands that move your HEAD in a drastic way (git am, git merge, git rebase, git reset), to record the position of the HEAD before their operation, so that you can easily change the tip of the branch back to the state before you ran them.\n\nrecords the commit(s) which you are merging into your branch when you run git merge.\n\nduring a rebase, records the commit at which the operation is currently stopped, either because of conflicts or an edit command in an interactive rebase.\n\nrecords the commit which you are reverting when you run git revert.\n\nrecords the commit which you are cherry-picking when you run git cherry-pick.\n\nrecords the current commit to be tested when you run git bisect --no-checkout.\n\nrecords a tree object corresponding to the state the ort merge strategy wrote to the working tree when a merge operation resulted in conflicts.\n\nNote that any of the refs/* cases above may come either from the $GIT_DIR/refs directory or from the $GIT_DIR/packed-refs file. While the ref name encoding is unspecified, UTF-8 is preferred as some output processing may assume ref names in UTF-8.\n\n@ alone is a shortcut for HEAD.\n\nA ref followed by the suffix @ with a date specification enclosed in a brace pair (e.g. {yesterday}, {1 month 2 weeks 3 days 1 hour 1 second ago} or {1979-02-26 18:30:00}) specifies the value of the ref at a prior point in time. This suffix may only be used immediately following a ref name and the ref must have an existing log ($GIT_DIR/logs/<ref>). Note that this looks up the state of your local ref at a given time; e.g., what was in your local master branch last week. If you want to look at commits made during certain times, see --since and --until.\n\nA ref followed by the suffix @ with an ordinal specification enclosed in a brace pair (e.g. {1}, {15}) specifies the n-th prior value of that ref. For example master@{1} is the immediate prior value of master while master@{5} is the 5th prior value of master. This suffix may only be used immediately following a ref name and the ref must have an existing log ($GIT_DIR/logs/<refname>).\n\nYou can use the @ construct with an empty ref part to get at a reflog entry of the current branch. For example, if you are on branch blabla then @{1} means the same as blabla@{1}.\n\nThe construct @{-<n>} means the <n>th branch/commit checked out before the current one.\n\nA branch B may be set up to build on top of a branch X (configured with branch.<name>.merge) at a remote R (configured with branch.<name>.remote). B@{u} refers to the remote-tracking branch for the branch X taken from remote R, typically found at refs/remotes/R/X.\n\nThe suffix @{push} reports the branch \"where we would push to\" if git push were run while branchname was checked out (or the current HEAD if no branchname is specified). Like for @{upstream}, we report the remote-tracking branch that corresponds to that branch at the remote.\n\nHere’s an example to make it more clear:\n\nNote in the example that we set up a triangular workflow, where we pull from one location and push to another. In a non-triangular workflow, @{push} is the same as @{upstream}, and there is no need for it.\n\nThis suffix is also accepted when spelled in uppercase, and means the same thing no matter the case.\n\nA suffix ^ to a revision parameter means the first parent of that commit object. ^<n> means the <n>th parent (i.e. <rev>^ is equivalent to <rev>^1). As a special rule, <rev>^0 means the commit itself and is used when <rev> is the object name of a tag object that refers to a commit object.\n\nA suffix ~ to a revision parameter means the first parent of that commit object. A suffix ~<n> to a revision parameter means the commit object that is the <n>th generation ancestor of the named commit object, following only the first parents. I.e. <rev>~3 is equivalent to <rev>^^^ which is equivalent to <rev>^1^1^1. See below for an illustration of the usage of this form.\n\nA suffix ^ followed by an object type name enclosed in brace pair means dereference the object at <rev> recursively until an object of type <type> is found or the object cannot be dereferenced anymore (in which case, barf). For example, if <rev> is a commit-ish, <rev>^{commit} describes the corresponding commit object. Similarly, if <rev> is a tree-ish, <rev>^{tree} describes the corresponding tree object. <rev>^0 is a short-hand for <rev>^{commit}.\n\n<rev>^{object} can be used to make sure <rev> names an object that exists, without requiring <rev> to be a tag, and without dereferencing <rev>; because a tag is already an object, it does not have to be dereferenced even once to get to an object.\n\n<rev>^{tag} can be used to ensure that <rev> identifies an existing tag object.\n\nA suffix ^ followed by an empty brace pair means the object could be a tag, and dereference the tag recursively until a non-tag object is found.\n\nA suffix ^ to a revision parameter, followed by a brace pair that contains a text led by a slash, is the same as the :/fix nasty bug syntax below except that it returns the youngest matching commit which is reachable from the <rev> before ^.\n\nA colon, followed by a slash, followed by a text, names a commit whose commit message matches the specified regular expression. This name returns the youngest matching commit which is reachable from any ref, including HEAD. The regular expression can match any part of the commit message. To match messages starting with a string, one can use e.g. :/^foo. The special sequence :/! is reserved for modifiers to what is matched. :/!-foo performs a negative match, while :/!!foo matches a literal ! character, followed by foo. Any other sequence beginning with :/! is reserved for now. Depending on the given text, the shell’s word splitting rules might require additional quoting.\n\nA suffix : followed by a path names the blob or tree at the given path in the tree-ish object named by the part before the colon. A path starting with ./ or ../ is relative to the current working directory. The given path will be converted to be relative to the working tree’s root directory. This is most useful to address a blob or tree from a commit or tree that has the same tree structure as the working tree.\n\nA colon, optionally followed by a stage number (0 to 3) and a colon, followed by a path, names a blob object in the index at the given path. A missing stage number (and the colon that follows it) names a stage 0 entry. During a merge, stage 1 is the common ancestor, stage 2 is the target branch’s version (typically the current branch), and stage 3 is the version from the branch which is being merged.\n\nHere is an illustration, by Jon Loeliger. Both commit nodes B and C are parents of commit node A. Parent commits are ordered left-to-right.\n\n• If $GIT_DIR/<refname> exists, that is what you mean (this is usually useful only for HEAD, FETCH_HEAD, ORIG_HEAD, MERGE_HEAD, REBASE_HEAD, REVERT_HEAD, CHERRY_PICK_HEAD, BISECT_HEAD and AUTO_MERGE);\n• otherwise, refs/<refname> if it exists;\n• otherwise, refs/tags/<refname> if it exists;\n• otherwise, refs/heads/<refname> if it exists;\n• otherwise, refs/remotes/<refname> if it exists;\n• otherwise, refs/remotes/<refname>/HEAD if it exists. HEAD names the commit on which you based the changes in the working tree. FETCH_HEAD records the branch which you fetched from a remote repository with your last git fetch invocation. ORIG_HEAD is created by commands that move your HEAD in a drastic way (git am, git merge, git rebase, git reset), to record the position of the HEAD before their operation, so that you can easily change the tip of the branch back to the state before you ran them. MERGE_HEAD records the commit(s) which you are merging into your branch when you run git merge. REBASE_HEAD during a rebase, records the commit at which the operation is currently stopped, either because of conflicts or an edit command in an interactive rebase. REVERT_HEAD records the commit which you are reverting when you run git revert. CHERRY_PICK_HEAD records the commit which you are cherry-picking when you run git cherry-pick. BISECT_HEAD records the current commit to be tested when you run git bisect --no-checkout. AUTO_MERGE records a tree object corresponding to the state the ort merge strategy wrote to the working tree when a merge operation resulted in conflicts.\n\n**<sha1>, e.g. dae86e1950b1277e545cee180551750029cfe735, dae86e**: The full SHA-1 object name (40-byte hexadecimal string), or a leading substring that is unique within the repository. E.g. dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the same commit object if there is no other object in your repository whose object name starts with dae86e.\n**<describeOutput>, e.g. v1.7.4.2-679-g3bee7fb**: Output from git describe; i.e. a closest tag, optionally followed by a dash and a number of commits, followed by a dash, a g, and an abbreviated object name.\n**<refname>, e.g. master, heads/master, refs/heads/master**: A symbolic ref name. E.g. master typically means the commit object referenced by refs/heads/master. If you happen to have both heads/master and tags/master, you can explicitly say heads/master to tell Git which one you mean. When ambiguous, a <refname> is disambiguated by taking the first match in the following rules: If $GIT_DIR/<refname> exists, that is what you mean (this is usually useful only for HEAD, FETCH_HEAD, ORIG_HEAD, MERGE_HEAD, REBASE_HEAD, REVERT_HEAD, CHERRY_PICK_HEAD, BISECT_HEAD and AUTO_MERGE); otherwise, refs/<refname> if it exists; otherwise, refs/tags/<refname> if it exists; otherwise, refs/heads/<refname> if it exists; otherwise, refs/remotes/<refname> if it exists; otherwise, refs/remotes/<refname>/HEAD if it exists. HEAD names the commit on which you based the changes in the working tree. FETCH_HEAD records the branch which you fetched from a remote repository with your last git fetch invocation. ORIG_HEAD is created by commands that move your HEAD in a drastic way (git am, git merge, git rebase, git reset), to record the position of the HEAD before their operation, so that you can easily change the tip of the branch back to the state before you ran them. MERGE_HEAD records the commit(s) which you are merging into your branch when you run git merge. REBASE_HEAD during a rebase, records the commit at which the operation is currently stopped, either because of conflicts or an edit command in an interactive rebase. REVERT_HEAD records the commit which you are reverting when you run git revert. CHERRY_PICK_HEAD records the commit which you are cherry-picking when you run git cherry-pick. BISECT_HEAD records the current commit to be tested when you run git bisect --no-checkout. AUTO_MERGE records a tree object corresponding to the state the ort merge strategy wrote to the working tree when a merge operation resulted in conflicts. Note that any of the refs/* cases above may come either from the $GIT_DIR/refs directory or from the $GIT_DIR/packed-refs file. While the ref name encoding is unspecified, UTF-8 is preferred as some output processing may assume ref names in UTF-8.\n**HEAD**: names the commit on which you based the changes in the working tree.\n**FETCH_HEAD**: records the branch which you fetched from a remote repository with your last git fetch invocation.\n**ORIG_HEAD**: is created by commands that move your HEAD in a drastic way (git am, git merge, git rebase, git reset), to record the position of the HEAD before their operation, so that you can easily change the tip of the branch back to the state before you ran them.\n**MERGE_HEAD**: records the commit(s) which you are merging into your branch when you run git merge.\n**REBASE_HEAD**: during a rebase, records the commit at which the operation is currently stopped, either because of conflicts or an edit command in an interactive rebase.\n**REVERT_HEAD**: records the commit which you are reverting when you run git revert.\n**CHERRY_PICK_HEAD**: records the commit which you are cherry-picking when you run git cherry-pick.\n**BISECT_HEAD**: records the current commit to be tested when you run git bisect --no-checkout.\n**AUTO_MERGE**: records a tree object corresponding to the state the ort merge strategy wrote to the working tree when a merge operation resulted in conflicts.\n**@**: @ alone is a shortcut for HEAD.\n**[<refname>]@{<date>}, e.g. master@{yesterday}, HEAD@{5 minutes ago}**: A ref followed by the suffix @ with a date specification enclosed in a brace pair (e.g. {yesterday}, {1 month 2 weeks 3 days 1 hour 1 second ago} or {1979-02-26 18:30:00}) specifies the value of the ref at a prior point in time. This suffix may only be used immediately following a ref name and the ref must have an existing log ($GIT_DIR/logs/<ref>). Note that this looks up the state of your local ref at a given time; e.g., what was in your local master branch last week. If you want to look at commits made during certain times, see --since and --until.\n**<refname>@{<n>}, e.g. master@{1}**: A ref followed by the suffix @ with an ordinal specification enclosed in a brace pair (e.g. {1}, {15}) specifies the n-th prior value of that ref. For example master@{1} is the immediate prior value of master while master@{5} is the 5th prior value of master. This suffix may only be used immediately following a ref name and the ref must have an existing log ($GIT_DIR/logs/<refname>).\n**@{<n>}, e.g. @{1}**: You can use the @ construct with an empty ref part to get at a reflog entry of the current branch. For example, if you are on branch blabla then @{1} means the same as blabla@{1}.\n**@{-<n>}, e.g. @{-1}**: The construct @{-<n>} means the <n>th branch/commit checked out before the current one.\n**[<branchname>]@{upstream}, e.g. master@{upstream}, @{u}**: A branch B may be set up to build on top of a branch X (configured with branch.<name>.merge) at a remote R (configured with branch.<name>.remote). B@{u} refers to the remote-tracking branch for the branch X taken from remote R, typically found at refs/remotes/R/X.\n**[<branchname>]@{push}, e.g. master@{push}, @{push}**: The suffix @{push} reports the branch \"where we would push to\" if git push were run while branchname was checked out (or the current HEAD if no branchname is specified). Like for @{upstream}, we report the remote-tracking branch that corresponds to that branch at the remote. Here’s an example to make it more clear: $ git config push.default current $ git config remote.pushdefault myfork $ git switch -c mybranch origin/master $ git rev-parse --symbolic-full-name @{upstream} refs/remotes/origin/master $ git rev-parse --symbolic-full-name @{push} refs/remotes/myfork/mybranch Note in the example that we set up a triangular workflow, where we pull from one location and push to another. In a non-triangular workflow, @{push} is the same as @{upstream}, and there is no need for it. This suffix is also accepted when spelled in uppercase, and means the same thing no matter the case.\n**<rev>^[<n>], e.g. HEAD^, v1.5.1^0**: A suffix ^ to a revision parameter means the first parent of that commit object. ^<n> means the <n>th parent (i.e. <rev>^ is equivalent to <rev>^1). As a special rule, <rev>^0 means the commit itself and is used when <rev> is the object name of a tag object that refers to a commit object.\n**<rev>~[<n>], e.g. HEAD~, master~3**: A suffix ~ to a revision parameter means the first parent of that commit object. A suffix ~<n> to a revision parameter means the commit object that is the <n>th generation ancestor of the named commit object, following only the first parents. I.e. <rev>~3 is equivalent to <rev>^^^ which is equivalent to <rev>^1^1^1. See below for an illustration of the usage of this form.\n**<rev>^{<type>}, e.g. v0.99.8^{commit}**: A suffix ^ followed by an object type name enclosed in brace pair means dereference the object at <rev> recursively until an object of type <type> is found or the object cannot be dereferenced anymore (in which case, barf). For example, if <rev> is a commit-ish, <rev>^{commit} describes the corresponding commit object. Similarly, if <rev> is a tree-ish, <rev>^{tree} describes the corresponding tree object. <rev>^0 is a short-hand for <rev>^{commit}. <rev>^{object} can be used to make sure <rev> names an object that exists, without requiring <rev> to be a tag, and without dereferencing <rev>; because a tag is already an object, it does not have to be dereferenced even once to get to an object. <rev>^{tag} can be used to ensure that <rev> identifies an existing tag object.\n**<rev>^{}, e.g. v0.99.8^{}**: A suffix ^ followed by an empty brace pair means the object could be a tag, and dereference the tag recursively until a non-tag object is found.\n**<rev>^{/<text>}, e.g. HEAD^{/fix nasty bug}**: A suffix ^ to a revision parameter, followed by a brace pair that contains a text led by a slash, is the same as the :/fix nasty bug syntax below except that it returns the youngest matching commit which is reachable from the <rev> before ^.\n**:/<text>, e.g. :/fix nasty bug**: A colon, followed by a slash, followed by a text, names a commit whose commit message matches the specified regular expression. This name returns the youngest matching commit which is reachable from any ref, including HEAD. The regular expression can match any part of the commit message. To match messages starting with a string, one can use e.g. :/^foo. The special sequence :/! is reserved for modifiers to what is matched. :/!-foo performs a negative match, while :/!!foo matches a literal ! character, followed by foo. Any other sequence beginning with :/! is reserved for now. Depending on the given text, the shell’s word splitting rules might require additional quoting.\n**<rev>:<path>, e.g. HEAD:README, master:./README**: A suffix : followed by a path names the blob or tree at the given path in the tree-ish object named by the part before the colon. A path starting with ./ or ../ is relative to the current working directory. The given path will be converted to be relative to the working tree’s root directory. This is most useful to address a blob or tree from a commit or tree that has the same tree structure as the working tree.\n**:[<n>:]<path>, e.g. :0:README, :README**: A colon, optionally followed by a stage number (0 to 3) and a colon, followed by a path, names a blob object in the index at the given path. A missing stage number (and the colon that follows it) names a stage 0 entry. During a merge, stage 1 is the common ancestor, stage 2 is the target branch’s version (typically the current branch), and stage 3 is the version from the branch which is being merged.\n**HEAD**: names the commit on which you based the changes in the working tree.\n**FETCH_HEAD**: records the branch which you fetched from a remote repository with your last git fetch invocation.\n**ORIG_HEAD**: is created by commands that move your HEAD in a drastic way (git am, git merge, git rebase, git reset), to record the position of the HEAD before their operation, so that you can easily change the tip of the branch back to the state before you ran them.\n**MERGE_HEAD**: records the commit(s) which you are merging into your branch when you run git merge.\n**REBASE_HEAD**: during a rebase, records the commit at which the operation is currently stopped, either because of conflicts or an edit command in an interactive rebase.\n**REVERT_HEAD**: records the commit which you are reverting when you run git revert.\n**CHERRY_PICK_HEAD**: records the commit which you are cherry-picking when you run git cherry-pick.\n**BISECT_HEAD**: records the current commit to be tested when you run git bisect --no-checkout.\n**AUTO_MERGE**: records a tree object corresponding to the state the ort merge strategy wrote to the working tree when a merge operation resulted in conflicts.\n\nNote | This document shows the \"raw\" syntax as seen by git. The shell and other UIs might require additional quoting to protect special characters and to avoid word splitting.\n\n[Note] Note This document shows the \"raw\" syntax as seen by git. The shell and other UIs might require additional quoting to protect special characters and to avoid word splitting.",
        "code_examples": [
          "```bash\nG   H   I   J\n \\ /     \\ /\n  D   E   F\n   \\  |  / \\\n    \\ | /   |\n     \\|/    |\n      B     C\n       \\   /\n        \\ /\n         A\n```",
          "```bash\nA =      = A^0\nB = A^   = A^1     = A~1\nC =      = A^2\nD = A^^  = A^1^1   = A~2\nE = B^2  = A^^2\nF = B^3  = A^^3\nG = A^^^ = A^1^1^1 = A~3\nH = D^2  = B^^2    = A^^^2  = A~2^2\nI = F^   = B^3^    = A^^3^\nJ = F^2  = B^3^2   = A^^3^2\n```"
        ],
        "usage_examples": [
          "```bash\n$ git config push.default current\n$ git config remote.pushdefault myfork\n$ git switch -c mybranch origin/master\n\n$ git rev-parse --symbolic-full-name @{upstream}\nrefs/remotes/origin/master\n\n$ git rev-parse --symbolic-full-name @{push}\nrefs/remotes/myfork/mybranch\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": true,
          "paragraph_count": 41,
          "content_length": 21778
        }
      },
      {
        "header": "SPECIFYING RANGES",
        "content": "History traversing commands such as git log operate on a set of commits, not just a single commit.\n\nFor these commands, specifying a single revision, using the notation described in the previous section, means the set of commits reachable from the given commit.\n\nSpecifying several revisions means the set of commits reachable from any of the given commits.\n\nA commit’s reachable set is the commit itself and the commits in its ancestry chain.\n\nThere are several notations to specify a set of connected commits (called a \"revision range\"), illustrated below.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 558
        }
      },
      {
        "header": "Commit Exclusions",
        "content": "To exclude commits reachable from a commit, a prefix ^ notation is used. E.g. ^r1 r2 means commits reachable from r2 but exclude the ones reachable from r1 (i.e. r1 and its ancestors).\n\n**^<rev> (caret) Notation**: To exclude commits reachable from a commit, a prefix ^ notation is used. E.g. ^r1 r2 means commits reachable from r2 but exclude the ones reachable from r1 (i.e. r1 and its ancestors).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 399
        }
      },
      {
        "header": "Dotted Range Notations",
        "content": "The ^r1 r2 set operation appears so often that there is a shorthand for it. When you have two commits r1 and r2 (named according to the syntax explained in SPECIFYING REVISIONS above), you can ask for commits that are reachable from r2 excluding those that are reachable from r1 by ^r1 r2 and it can be written as r1..r2.\n\nA similar notation r1...r2 is called symmetric difference of r1 and r2 and is defined as r1 r2 --not $(git merge-base --all r1 r2). It is the set of commits that are reachable from either one of r1 (left side) or r2 (right side) but not from both.\n\nIn these two shorthand notations, you can omit one end and let it default to HEAD. For example, origin.. is a shorthand for origin..HEAD and asks \"What did I do since I forked from the origin branch?\" Similarly, ..origin is a shorthand for HEAD..origin and asks \"What did the origin do since I forked from them?\" Note that .. would mean HEAD..HEAD which is an empty range that is both reachable and unreachable from HEAD.\n\nCommands that are specifically designed to take two distinct ranges (e.g. \"git range-diff R1 R2\" to compare two ranges) do exist, but they are exceptions. Unless otherwise noted, all \"git\" commands that operate on a set of commits work on a single revision range. In other words, writing two \"two-dot range notation\" next to each other, e.g.\n\ndoes not specify two revision ranges for most commands. Instead it will name a single connected set of commits, i.e. those that are reachable from either B or D but are reachable from neither A or C. In a linear history like this:\n\nbecause A and B are reachable from C, the revision range specified by these two dotted ranges is a single commit D.\n\n**The .. (two-dot) Range Notation**: The ^r1 r2 set operation appears so often that there is a shorthand for it. When you have two commits r1 and r2 (named according to the syntax explained in SPECIFYING REVISIONS above), you can ask for commits that are reachable from r2 excluding those that are reachable from r1 by ^r1 r2 and it can be written as r1..r2.\n**The ... (three-dot) Symmetric Difference Notation**: A similar notation r1...r2 is called symmetric difference of r1 and r2 and is defined as r1 r2 --not $(git merge-base --all r1 r2). It is the set of commits that are reachable from either one of r1 (left side) or r2 (right side) but not from both.",
        "code_examples": [
          "```bash\n---A---B---o---o---C---D\n```"
        ],
        "usage_examples": [
          "```bash\n$ git log A..B C..D\n```"
        ],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 6,
          "content_length": 2348
        }
      },
      {
        "header": "Other <rev>^ Parent Shorthand Notations",
        "content": "Three other shorthands exist, particularly useful for merge commits, for naming a set that is formed by a commit and its parent commits.\n\nThe r1^@ notation means all parents of r1.\n\nThe r1^! notation includes commit r1 but excludes all of its parents. By itself, this notation denotes the single commit r1.\n\nThe <rev>^-[<n>] notation includes <rev> but excludes the <n>th parent (i.e. a shorthand for <rev>^<n>..<rev>), with <n> = 1 if not given. This is typically useful for merge commits where you can just pass <commit>^- to get all the commits in the branch that was merged in merge commit <commit> (including <commit> itself).\n\nWhile <rev>^<n> was about specifying a single commit parent, these three notations also consider its parents. For example you can say HEAD^2^@, however you cannot say HEAD^@^2.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 809
        }
      },
      {
        "header": "Revision Range Summary",
        "content": "Include commits that are reachable from <rev> (i.e. <rev> and its ancestors).\n\nExclude commits that are reachable from <rev> (i.e. <rev> and its ancestors).\n\nInclude commits that are reachable from <rev2> but exclude those that are reachable from <rev1>. When either <rev1> or <rev2> is omitted, it defaults to HEAD.\n\nInclude commits that are reachable from either <rev1> or <rev2> but exclude those that are reachable from both. When either <rev1> or <rev2> is omitted, it defaults to HEAD.\n\nA suffix ^ followed by an at sign is the same as listing all parents of <rev> (meaning, include anything reachable from its parents, but not the commit itself).\n\nA suffix ^ followed by an exclamation mark is the same as giving commit <rev> and all its parents prefixed with ^ to exclude them (and their ancestors).\n\nEquivalent to <rev>^<n>..<rev>, with <n> = 1 if not given.\n\nHere are a handful of examples using the Loeliger illustration above, with each step in the notation’s expansion and selection carefully spelt out:\n\n**<rev>**: Include commits that are reachable from <rev> (i.e. <rev> and its ancestors).\n**^<rev>**: Exclude commits that are reachable from <rev> (i.e. <rev> and its ancestors).\n**<rev1>..<rev2>**: Include commits that are reachable from <rev2> but exclude those that are reachable from <rev1>. When either <rev1> or <rev2> is omitted, it defaults to HEAD.\n**<rev1>...<rev2>**: Include commits that are reachable from either <rev1> or <rev2> but exclude those that are reachable from both. When either <rev1> or <rev2> is omitted, it defaults to HEAD.\n**<rev>^@, e.g. HEAD^@**: A suffix ^ followed by an at sign is the same as listing all parents of <rev> (meaning, include anything reachable from its parents, but not the commit itself).\n**<rev>^!, e.g. HEAD^!**: A suffix ^ followed by an exclamation mark is the same as giving commit <rev> and all its parents prefixed with ^ to exclude them (and their ancestors).\n**<rev>^-<n>, e.g. HEAD^-, HEAD^-2**: Equivalent to <rev>^<n>..<rev>, with <n> = 1 if not given.",
        "code_examples": [
          "```bash\nArgs   Expanded arguments    Selected commits\n   D                            G H D\n   D F                          G H I J D F\n   ^G D                         H D\n   ^D B                         E I J F B\n   ^D B C                       E I J F B C\n   C                            I J F C\n   B..C   = ^B C                C\n   B...C  = B ^F C              G H D E B C\n   B^-    = B^..B\n\t  = ^B^1 B              E I J F B\n   C^@    = C^1\n\t  = F                   I J F\n   B^@    = B^1 B^2 B^3\n\t  = D E F               D G H E F I J\n   C^!    = C ^C^@\n\t  = C ^C^1\n\t  = C ^F                C\n   B^!    = B ^B^@\n\t  = B ^B^1 ^B^2 ^B^3\n\t  = B ^D ^E ^F          B\n   F^! D  = F ^I ^J D           G H D F\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 8,
          "content_length": 2033
        }
      },
      {
        "header": "PARSEOPT",
        "content": "In --parseopt mode, git rev-parse helps massaging options to bring to shell scripts the same facilities C builtins have. It works as an option normalizer (e.g. splits single switches aggregate values), a bit like getopt(1) does.\n\nIt takes on the standard input the specification of the options to parse and understand, and echoes on the standard output a string suitable for sh(1) eval to replace the arguments with normalized ones. In case of error, it outputs usage on the standard error stream, and exits with code 129.\n\nNote: Make sure you quote the result when passing it to eval. See below for an example.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 611
        }
      },
      {
        "header": "Input Format",
        "content": "git rev-parse --parseopt input format is fully text based. It has two parts, separated by a line that contains only --. The lines before the separator (should be one or more) are used for the usage. The lines after the separator describe the options.\n\nEach line of options has this format:\n\nits format is the short option character, then the long option name separated by a comma. Both parts are not required, though at least one is necessary. May not contain any of the <flags> characters. h,help, dry-run and f are examples of correct <opt-spec>.\n\n<flags> are of *, =, ? or !.\n\nUse = if the option takes an argument.\n\nUse ? to mean that the option takes an optional argument. You probably want to use the --stuck-long mode to be able to unambiguously parse the optional argument.\n\nUse * to mean that this option should not be listed in the usage generated for the -h argument. It’s shown for --help-all as documented in gitcli[7].\n\nUse ! to not make the corresponding negated long option available.\n\n<arg-hint>, if specified, is used as a name of the argument in the help output, for options that take arguments. <arg-hint> is terminated by the first whitespace. It is customary to use a dash to separate words in a multi-word argument hint.\n\nThe remainder of the line, after stripping the spaces, is used as the help associated with the option.\n\nBlank lines are ignored, and lines that don’t match this specification are used as option group headers (start the line with a space to create such lines on purpose).\n\n• Use = if the option takes an argument.\n• Use ? to mean that the option takes an optional argument. You probably want to use the --stuck-long mode to be able to unambiguously parse the optional argument.\n• Use * to mean that this option should not be listed in the usage generated for the -h argument. It’s shown for --help-all as documented in gitcli[7].\n• Use ! to not make the corresponding negated long option available.\n\n**<opt-spec>**: its format is the short option character, then the long option name separated by a comma. Both parts are not required, though at least one is necessary. May not contain any of the <flags> characters. h,help, dry-run and f are examples of correct <opt-spec>.\n**<flags>**: <flags> are of *, =, ? or !. Use = if the option takes an argument. Use ? to mean that the option takes an optional argument. You probably want to use the --stuck-long mode to be able to unambiguously parse the optional argument. Use * to mean that this option should not be listed in the usage generated for the -h argument. It’s shown for --help-all as documented in gitcli[7]. Use ! to not make the corresponding negated long option available.\n**<arg-hint>**: <arg-hint>, if specified, is used as a name of the argument in the help output, for options that take arguments. <arg-hint> is terminated by the first whitespace. It is customary to use a dash to separate words in a multi-word argument hint.",
        "code_examples": [
          "```bash\n<opt-spec><flags>*<arg-hint>? SP+ help LF\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 11,
          "content_length": 2935
        }
      },
      {
        "header": "Usage text",
        "content": "When \"$@\" is -h or --help in the above example, the following usage text would be shown:",
        "code_examples": [
          "```bash\nusage: some-command [<options>] <args>...\n\n    some-command does foo and bar!\n\n    -h, --help            show the help\n    --[no-]foo            some nifty option --foo\n    --[no-]bar ...        some cool option --bar with an argument\n    --[no-]baz <arg>      another cool option --baz with a named argument\n    --[no-]qux[=<path>]   qux may take a path argument but has meaning by itself\n\nAn option group Header\n    -C[...]               option C with an optional argument\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h3",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 88
        }
      },
      {
        "header": "SQ-QUOTE",
        "content": "In --sq-quote mode, git rev-parse echoes on the standard output a single line suitable for sh(1) eval. This line is made by normalizing the arguments following --sq-quote. Nothing other than quoting the arguments is done.\n\nIf you want command input to still be interpreted as usual by git rev-parse before the output is shell quoted, see the --sq option.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 354
        }
      },
      {
        "header": "EXAMPLES",
        "content": "Print the object name of the current commit:\n\nPrint the commit object name from the revision in the $REV shell variable:\n\nThis will error out if $REV is empty or not a valid revision.\n\nbut if $REV is empty, the commit object name from master will be printed.\n\n• Print the object name of the current commit: $ git rev-parse --verify HEAD\n• Print the commit object name from the revision in the $REV shell variable: $ git rev-parse --verify --end-of-options $REV^{commit} This will error out if $REV is empty or not a valid revision.\n• Similar to above: $ git rev-parse --default master --verify --end-of-options $REV but if $REV is empty, the commit object name from master will be printed.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git rev-parse --verify HEAD\n```",
          "```bash\n$ git rev-parse --verify --end-of-options $REV^{commit}\n```",
          "```bash\n$ git rev-parse --default master --verify --end-of-options $REV\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 689
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-rev-parse",
    "doc_type": "git",
    "total_sections": 21
  },
  {
    "title": "Git",
    "summary": "NAME git-show-ref - List references in a local repository\n\ngit-show-ref - List references in a local repository",
    "sections": [
      {
        "header": "NAME",
        "content": "git-show-ref - List references in a local repository",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 52
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Displays references available in a local repository along with the associated commit IDs. Results can be filtered using a pattern and tags can be dereferenced into object IDs. Additionally, it can be used to test whether a particular ref exists.\n\nBy default, shows the tags, heads, and remote refs.\n\nThe --exclude-existing form is a filter that does the inverse. It reads refs from stdin, one ref per line, and shows those that don’t exist in the local repository.\n\nThe --exists form can be used to check for the existence of a single references. This form does not verify whether the reference resolves to an actual object.\n\nUse of this utility is encouraged in favor of directly accessing files under the .git directory.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 722
        }
      },
      {
        "header": "OPTIONS",
        "content": "Show the HEAD reference, even if it would normally be filtered out.\n\nLimit to local branches and local tags, respectively. These options are not mutually exclusive; when given both, references stored in \"refs/heads\" and \"refs/tags\" are displayed. Note that --heads is a deprecated synonym for --branches and may be removed in the future.\n\nDereference tags into object IDs as well. They will be shown with ^{} appended.\n\nOnly show the OID, not the reference name. When combined with --dereference, the dereferenced tag will still be shown after the OID.\n\nEnable stricter reference checking by requiring an exact ref path. Aside from returning an error code of 1, it will also print an error message if --quiet was not specified.\n\nCheck whether the given reference exists. Returns an exit code of 0 if it does, 2 if it is missing, and 1 in case looking up the reference failed with an error other than the reference being missing.\n\nAbbreviate the object name. When using --hash, you do not have to say --hash --abbrev; --hash=n would do.\n\nDo not print any results to stdout. Can be used with --verify to silently check if a reference exists.\n\nMake git show-ref act as a filter that reads refs from stdin of the form ^(?:<anything>\\s)?<refname>(?:\\^{})?$ and performs the following actions on each: (1) strip ^{} at the end of line if any; (2) ignore if pattern is provided and does not head-match refname; (3) warn if refname is not a well-formed refname and skip; (4) ignore if refname is a ref that exists in the local repository; (5) otherwise output the line.\n\nShow references matching one or more patterns. Patterns are matched from the end of the full name, and only complete parts are matched, e.g. master matches refs/heads/master, refs/remotes/origin/master, refs/tags/jedi/master but not refs/heads/mymaster or refs/remotes/master/jedi.\n\n**--head**: Show the HEAD reference, even if it would normally be filtered out.\n**--branches**: Limit to local branches and local tags, respectively. These options are not mutually exclusive; when given both, references stored in \"refs/heads\" and \"refs/tags\" are displayed. Note that --heads is a deprecated synonym for --branches and may be removed in the future.\n**--tags**: Dereference tags into object IDs as well. They will be shown with ^{} appended.\n**-d**: Only show the OID, not the reference name. When combined with --dereference, the dereferenced tag will still be shown after the OID.\n**--dereference**: Enable stricter reference checking by requiring an exact ref path. Aside from returning an error code of 1, it will also print an error message if --quiet was not specified.\n**-s**: Check whether the given reference exists. Returns an exit code of 0 if it does, 2 if it is missing, and 1 in case looking up the reference failed with an error other than the reference being missing.\n**--hash[=<n>]**: Abbreviate the object name. When using --hash, you do not have to say --hash --abbrev; --hash=n would do.\n**--verify**: Do not print any results to stdout. Can be used with --verify to silently check if a reference exists.\n**--exists**: Make git show-ref act as a filter that reads refs from stdin of the form ^(?:<anything>\\s)?<refname>(?:\\^{})?$ and performs the following actions on each: (1) strip ^{} at the end of line if any; (2) ignore if pattern is provided and does not head-match refname; (3) warn if refname is not a well-formed refname and skip; (4) ignore if refname is a ref that exists in the local repository; (5) otherwise output the line.\n**--abbrev[=<n>]**: Show references matching one or more patterns. Patterns are matched from the end of the full name, and only complete parts are matched, e.g. master matches refs/heads/master, refs/remotes/origin/master, refs/tags/jedi/master but not refs/heads/mymaster or refs/remotes/master/jedi.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 3822
        }
      },
      {
        "header": "OUTPUT",
        "content": "The output is in the format:\n\nWhen using --hash (and not --dereference), the output is in the format:",
        "code_examples": [
          "```bash\n<oid> SP<ref>LF\n```",
          "```bash\n<oid> LF\n```"
        ],
        "usage_examples": [
          "```bash\n$ git show-ref --head --dereference\n832e76a9899f560a90ffd62ae2ce83bbeff58f54 HEAD\n832e76a9899f560a90ffd62ae2ce83bbeff58f54 refs/heads/master\n832e76a9899f560a90ffd62ae2ce83bbeff58f54 refs/heads/origin\n3521017556c5de4159da4615a39fa4d5d2c279b5 refs/tags/v0.99.9c\n6ddc0964034342519a87fe013781abf31c6db6ad refs/tags/v0.99.9c^{}\n055e4ae3ae6eb344cbabf2a5256a49ea66040131 refs/tags/v1.0rc4\n423325a2d24638ddcc82ce47be5e40be550f4507 refs/tags/v1.0rc4^{}\n...\n```",
          "```bash\n$ git show-ref --branches --hash\n2e3ba0114a1f52b47df29743d6915d056be13278\n185008ae97960c8d551adcd9e23565194651b5d1\n03adf42c988195b50e1a1935ba5fcbc39b2b029b\n...\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 101
        }
      },
      {
        "header": "EXAMPLES",
        "content": "To show all references called \"master\", whether tags or heads or anything else, and regardless of how deep in the reference naming hierarchy they are, use:\n\nThis will show \"refs/heads/master\" but also \"refs/remote/other-repo/master\", if such references exist.\n\nWhen using the --verify flag, the command requires an exact path:\n\nwill only match the exact branch called \"master\".\n\nIf nothing matches, git show-ref will return an error code of 1, and in the case of verification, it will show an error message.\n\nFor scripting, you can ask it to be quiet with the --quiet flag, which allows you to do things like\n\nto check whether a particular branch exists or not (notice how we don’t actually want to show any results, and we want to use the full refname for it in order to not trigger the problem with ambiguous partial matches).\n\nTo show only tags, or only proper branch heads, use --tags and/or --branches respectively (using both means that it shows tags and branches, but not other random references under the refs/ subdirectory).\n\nTo do automatic tag object dereferencing, use the -d or --dereference flag, so you can do\n\nto get a listing of all tags together with what they dereference.",
        "code_examples": [],
        "usage_examples": [
          "```bash\ngit show-ref master\n```",
          "```bash\ngit show-ref --verify refs/heads/master\n```",
          "```bash\ngit show-ref --quiet --verify -- \"refs/heads/$headname\" ||\n\t\techo \"$headname is not a valid branch\"\n```",
          "```bash\ngit show-ref --tags --dereference\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 1191
        }
      },
      {
        "header": "FILES",
        "content": ".git/refs/*, .git/packed-refs",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 29
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-for-each-ref[1], git-ls-remote[1], git-update-ref[1], gitrepository-layout[5]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 81
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-show-ref",
    "doc_type": "git",
    "total_sections": 8
  },
  {
    "title": "Git",
    "summary": "NAME git-symbolic-ref - Read, modify and delete symbolic refs\n\ngit-symbolic-ref - Read, modify and delete symbolic refs",
    "sections": [
      {
        "header": "NAME",
        "content": "git-symbolic-ref - Read, modify and delete symbolic refs",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 56
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Given one argument, reads which branch head the given symbolic ref refers to and outputs its path, relative to the .git/ directory. Typically you would give HEAD as the <name> argument to see which branch your working tree is on.\n\nGiven two arguments, creates or updates a symbolic ref <name> to point at the given branch <ref>.\n\nGiven --delete and an additional argument, deletes the given symbolic ref.\n\nA symbolic ref is a regular file that stores a string that begins with ref: refs/. For example, your .git/HEAD is a regular file whose content is ref: refs/heads/master.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 575
        }
      },
      {
        "header": "OPTIONS",
        "content": "Delete the symbolic ref <name>.\n\nDo not issue an error message if the <name> is not a symbolic ref but a detached HEAD; instead exit with non-zero status silently.\n\nWhen showing the value of <name> as a symbolic ref, try to shorten the value, e.g. from refs/heads/master to master.\n\nWhen showing the value of <name> as a symbolic ref, if <name> refers to another symbolic ref, follow such a chain of symbolic refs until the result no longer points at a symbolic ref (--recurse, which is the default). --no-recurse stops after dereferencing only a single level of symbolic ref.\n\nUpdate the reflog for <name> with <reason>. This is valid only when creating or updating a symbolic ref.\n\n**-d**: Delete the symbolic ref <name>.\n**--delete**: Do not issue an error message if the <name> is not a symbolic ref but a detached HEAD; instead exit with non-zero status silently.\n**-q**: When showing the value of <name> as a symbolic ref, try to shorten the value, e.g. from refs/heads/master to master.\n**--quiet**: When showing the value of <name> as a symbolic ref, if <name> refers to another symbolic ref, follow such a chain of symbolic refs until the result no longer points at a symbolic ref (--recurse, which is the default). --no-recurse stops after dereferencing only a single level of symbolic ref.\n**--short**: Update the reflog for <name> with <reason>. This is valid only when creating or updating a symbolic ref.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1418
        }
      },
      {
        "header": "NOTES",
        "content": "In the past, .git/HEAD was a symbolic link pointing at refs/heads/master. When we wanted to switch to another branch, we did ln -sf refs/heads/newbranch .git/HEAD, and when we wanted to find out which branch we are on, we did readlink .git/HEAD. But symbolic links are not entirely portable, so they are now deprecated and symbolic refs (as described above) are used by default.\n\ngit symbolic-ref will exit with status 0 if the contents of the symbolic ref were printed correctly, with status 1 if the requested name is not a symbolic ref, or 128 if another error occurs.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 571
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-symbolic-ref",
    "doc_type": "git",
    "total_sections": 5
  },
  {
    "title": "Git",
    "summary": "NAME git-update-index - Register file contents in the working tree to the index\n\ngit-update-index - Register file contents in the working tree to the index",
    "sections": [
      {
        "header": "NAME",
        "content": "git-update-index - Register file contents in the working tree to the index",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 74
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Modifies the index. Each file mentioned is updated into the index and any unmerged or needs updating state is cleared.\n\nSee also git-add[1] for a more user-friendly way to do some of the most common operations on the index.\n\nThe way git update-index handles files it is told about can be modified using the various options:",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 323
        }
      },
      {
        "header": "OPTIONS",
        "content": "If a specified file isn’t in the index already then it’s added. Default behaviour is to ignore new files.\n\nIf a specified file is in the index but is missing then it’s removed. Default behavior is to ignore removed files.\n\nLooks at the current index and checks to see if merges or updates are needed by checking stat() information.\n\nQuiet. If --refresh finds that the index needs an update, the default behavior is to error out. This option makes git update-index continue anyway.\n\nDo not try to update submodules. This option is only respected when passed before --refresh.\n\nIf --refresh finds unmerged changes in the index, the default behavior is to error out. This option makes git update-index continue anyway.\n\nIgnores missing files during a --refresh\n\nDirectly insert the specified info into the index. For backward compatibility, you can also give these three arguments as three separate parameters, but new users are encouraged to use a single-parameter form.\n\nRead index information from stdin.\n\nSet the execute permissions on the updated files.\n\nWhen this flag is specified, the object names recorded for the paths are not updated. Instead, this option sets/unsets the \"assume unchanged\" bit for the paths. When the \"assume unchanged\" bit is on, the user promises not to change the file and allows Git to assume that the working tree file matches what is recorded in the index. If you want to change the working tree file, you need to unset the bit to tell Git. This is sometimes helpful when working with a big project on a filesystem that has a very slow lstat(2) system call (e.g. cifs).\n\nGit will fail (gracefully) in case it needs to modify this file in the index e.g. when merging in a commit; thus, in case the assumed-untracked file is changed upstream, you will need to handle the situation manually.\n\nLike --refresh, but checks stat information unconditionally, without regard to the \"assume unchanged\" setting.\n\nWhen one of these flags is specified, the object names recorded for the paths are not updated. Instead, these options set and unset the \"skip-worktree\" bit for the paths. See section \"Skip-worktree bit\" below for more information.\n\nDo not remove skip-worktree (AKA \"index-only\") entries even when the --remove option was specified.\n\nWhen one of these flags is specified, the object names recorded for the paths are not updated. Instead, these options set and unset the \"fsmonitor valid\" bit for the paths. See section \"File System Monitor\" below for more information.\n\nRuns git update-index itself on the paths whose index entries are different from those of the HEAD commit.\n\nRestores the unmerged or needs updating state of a file during a merge if it was cleared by accident.\n\nDo not create objects in the object database for all <file> arguments that follow this flag; just insert their object IDs into the index.\n\nRemove the file from the index even when the working directory still has such a file. (Implies --remove.)\n\nBy default, when a file path exists in the index, git update-index refuses an attempt to add path/file. Similarly if a file path/file exists, a file path cannot be added. With --replace flag, existing entries that conflict with the entry being added are automatically removed with warning messages.\n\nInstead of taking a list of paths from the command line, read a list of paths from the standard input. Paths are separated by LF (i.e. one path per line) by default.\n\nReport what is being added and removed from the index.\n\nWrite the resulting index out in the named on-disk format version. Supported versions are 2, 3, and 4. The current default version is 2 or 3, depending on whether extra features are used, such as git add -N. With --verbose, also report the version the index file uses before and after this command.\n\nVersion 4 performs a simple pathname compression that reduces index size by 30%-50% on large repositories, which results in faster load time. Git supports it since version 1.8.0, released in October 2012, and support for it was added to libgit2 in 2016 and to JGit in 2020. Older versions of this manual page called it \"relatively young\", but it should be considered mature technology these days.\n\nReport the index format version used by the on-disk index file. See --index-version above.\n\nOnly meaningful with --stdin or --index-info; paths are separated with NUL character instead of LF.\n\nEnable or disable split index mode. If split-index mode is already enabled and --split-index is given again, all changes in $GIT_DIR/index are pushed back to the shared index file.\n\nThese options take effect whatever the value of the core.splitIndex configuration variable (see git-config[1]). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.\n\nEnable or disable untracked cache feature. Please use --test-untracked-cache before enabling it.\n\nThese options take effect whatever the value of the core.untrackedCache configuration variable (see git-config[1]). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.\n\nOnly perform tests on the working directory to make sure untracked cache can be used. You have to manually enable untracked cache using --untracked-cache or --force-untracked-cache or the core.untrackedCache configuration variable afterwards if you really want to use it. If a test fails the exit code is 1 and a message explains what is not working as needed, otherwise the exit code is 0 and OK is printed.\n\nSame as --untracked-cache. Provided for backwards compatibility with older versions of Git where --untracked-cache used to imply --test-untracked-cache but this option would enable the extension unconditionally.\n\nEnable or disable files system monitor feature. These options take effect whatever the value of the core.fsmonitor configuration variable (see git-config[1]). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.\n\nDo not interpret any more arguments as options.\n\nFiles to act on. Note that files beginning with . are discarded. This includes ./file and dir/./file. If you don’t want this, then use cleaner names. The same applies to directories ending / and paths with //\n\n**--add**: If a specified file isn’t in the index already then it’s added. Default behaviour is to ignore new files.\n**--remove**: If a specified file is in the index but is missing then it’s removed. Default behavior is to ignore removed files.\n**--refresh**: Looks at the current index and checks to see if merges or updates are needed by checking stat() information.\n**-q**: Quiet. If --refresh finds that the index needs an update, the default behavior is to error out. This option makes git update-index continue anyway.\n**--ignore-submodules**: Do not try to update submodules. This option is only respected when passed before --refresh.\n**--unmerged**: If --refresh finds unmerged changes in the index, the default behavior is to error out. This option makes git update-index continue anyway.\n**--ignore-missing**: Ignores missing files during a --refresh\n**--cacheinfo <mode>,<object>,<path>**: Directly insert the specified info into the index. For backward compatibility, you can also give these three arguments as three separate parameters, but new users are encouraged to use a single-parameter form.\n**--cacheinfo <mode> <object> <path>**: Read index information from stdin.\n**--index-info**: Set the execute permissions on the updated files.\n**--chmod=(+|-)x**: When this flag is specified, the object names recorded for the paths are not updated. Instead, this option sets/unsets the \"assume unchanged\" bit for the paths. When the \"assume unchanged\" bit is on, the user promises not to change the file and allows Git to assume that the working tree file matches what is recorded in the index. If you want to change the working tree file, you need to unset the bit to tell Git. This is sometimes helpful when working with a big project on a filesystem that has a very slow lstat(2) system call (e.g. cifs). Git will fail (gracefully) in case it needs to modify this file in the index e.g. when merging in a commit; thus, in case the assumed-untracked file is changed upstream, you will need to handle the situation manually.\n**--[no-]assume-unchanged**: Like --refresh, but checks stat information unconditionally, without regard to the \"assume unchanged\" setting.\n**--really-refresh**: When one of these flags is specified, the object names recorded for the paths are not updated. Instead, these options set and unset the \"skip-worktree\" bit for the paths. See section \"Skip-worktree bit\" below for more information.\n**--[no-]skip-worktree**: Do not remove skip-worktree (AKA \"index-only\") entries even when the --remove option was specified.\n**--[no-]ignore-skip-worktree-entries**: When one of these flags is specified, the object names recorded for the paths are not updated. Instead, these options set and unset the \"fsmonitor valid\" bit for the paths. See section \"File System Monitor\" below for more information.\n**--[no-]fsmonitor-valid**: Runs git update-index itself on the paths whose index entries are different from those of the HEAD commit.\n**-g**: Restores the unmerged or needs updating state of a file during a merge if it was cleared by accident.\n**--again**: Do not create objects in the object database for all <file> arguments that follow this flag; just insert their object IDs into the index.\n**--unresolve**: Remove the file from the index even when the working directory still has such a file. (Implies --remove.)\n**--info-only**: By default, when a file path exists in the index, git update-index refuses an attempt to add path/file. Similarly if a file path/file exists, a file path cannot be added. With --replace flag, existing entries that conflict with the entry being added are automatically removed with warning messages.\n**--force-remove**: Instead of taking a list of paths from the command line, read a list of paths from the standard input. Paths are separated by LF (i.e. one path per line) by default.\n**--replace**: Report what is being added and removed from the index.\n**--stdin**: Write the resulting index out in the named on-disk format version. Supported versions are 2, 3, and 4. The current default version is 2 or 3, depending on whether extra features are used, such as git add -N. With --verbose, also report the version the index file uses before and after this command. Version 4 performs a simple pathname compression that reduces index size by 30%-50% on large repositories, which results in faster load time. Git supports it since version 1.8.0, released in October 2012, and support for it was added to libgit2 in 2016 and to JGit in 2020. Older versions of this manual page called it \"relatively young\", but it should be considered mature technology these days.\n**--verbose**: Report the index format version used by the on-disk index file. See --index-version above.\n**--index-version <n>**: Only meaningful with --stdin or --index-info; paths are separated with NUL character instead of LF.\n**--show-index-version**: Enable or disable split index mode. If split-index mode is already enabled and --split-index is given again, all changes in $GIT_DIR/index are pushed back to the shared index file. These options take effect whatever the value of the core.splitIndex configuration variable (see git-config[1]). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.\n**-z**: Enable or disable untracked cache feature. Please use --test-untracked-cache before enabling it. These options take effect whatever the value of the core.untrackedCache configuration variable (see git-config[1]). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.\n**--split-index**: Only perform tests on the working directory to make sure untracked cache can be used. You have to manually enable untracked cache using --untracked-cache or --force-untracked-cache or the core.untrackedCache configuration variable afterwards if you really want to use it. If a test fails the exit code is 1 and a message explains what is not working as needed, otherwise the exit code is 0 and OK is printed.\n**--no-split-index**: Same as --untracked-cache. Provided for backwards compatibility with older versions of Git where --untracked-cache used to imply --test-untracked-cache but this option would enable the extension unconditionally.\n**--untracked-cache**: Enable or disable files system monitor feature. These options take effect whatever the value of the core.fsmonitor configuration variable (see git-config[1]). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.\n**--no-untracked-cache**: Do not interpret any more arguments as options.\n**--test-untracked-cache**: Files to act on. Note that files beginning with . are discarded. This includes ./file and dir/./file. If you don’t want this, then use cleaner names. The same applies to directories ending / and paths with //",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 36,
          "content_length": 13691
        }
      },
      {
        "header": "USING --REFRESH",
        "content": "--refresh does not calculate a new sha1 file or bring the index up to date for mode/content changes. But what it does do is to \"re-match\" the stat information of a file with the index, so that you can refresh the index for a file that hasn’t been changed but where the stat entry is out of date.\n\nFor example, you’d want to do this after doing a git read-tree, to link up the stat index details with the proper files.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 417
        }
      },
      {
        "header": "USING --CACHEINFO OR --INFO-ONLY",
        "content": "--cacheinfo is used to register a file that is not in the current working directory. This is useful for minimum-checkout merging.\n\nTo pretend you have a file at path with mode and sha1, say:\n\n--info-only is used to register files without placing them in the object database. This is useful for status-only repositories.\n\nBoth --cacheinfo and --info-only behave similarly: the index is updated but the object database isn’t. --cacheinfo is useful when the object is in the database but the file isn’t available locally. --info-only is useful when the file is available, but you do not wish to update the object database.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git update-index --add --cacheinfo <mode>,<sha1>,<path>\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 619
        }
      },
      {
        "header": "USING --INDEX-INFO",
        "content": "--index-info is a more powerful mechanism that lets you feed multiple entry definitions from the standard input, and designed specifically for scripts. It can take inputs of three formats:\n\nmode SP type SP sha1 TAB path\n\nThis format is to stuff git ls-tree output into the index.\n\nmode SP sha1 SP stage TAB path\n\nThis format is to put higher order stages into the index file and matches git ls-files --stage output.\n\nmode SP sha1 TAB path\n\nThis format is no longer produced by any Git command, but is and will continue to be supported by update-index --index-info.\n\nTo place a higher stage entry to the index, the path should first be removed by feeding a mode=0 entry for the path, and then feeding necessary input lines in the third format.\n\nFor example, starting with this index:\n\nyou can feed the following input to --index-info:\n\nThe first line of the input feeds 0 as the mode to remove the path; the SHA-1 does not matter as long as it is well formatted. Then the second and third line feeds stage 1 and stage 2 entries for that path. After the above, we would end up with this:\n\n• mode SP type SP sha1 TAB path This format is to stuff git ls-tree output into the index.\n• mode SP sha1 SP stage TAB path This format is to put higher order stages into the index file and matches git ls-files --stage output.\n• mode SP sha1 TAB path This format is no longer produced by any Git command, but is and will continue to be supported by update-index --index-info.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git ls-files -s\n100644 8a1218a1024a212bb3db30becd860315f9f3ac52 0       frotz\n```",
          "```bash\n$ git update-index --index-info\n0 0000000000000000000000000000000000000000\tfrotz\n100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1\tfrotz\n100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2\tfrotz\n```",
          "```bash\n$ git ls-files -s\n100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1\tfrotz\n100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2\tfrotz\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 11,
          "content_length": 1462
        }
      },
      {
        "header": "USING “ASSUME UNCHANGED” BIT",
        "content": "Many operations in Git depend on your filesystem to have an efficient lstat(2) implementation, so that st_mtime information for working tree files can be cheaply checked to see if the file contents have changed from the version recorded in the index file. Unfortunately, some filesystems have inefficient lstat(2). If your filesystem is one of them, you can set \"assume unchanged\" bit to paths you have not changed to cause Git not to do this check. Note that setting this bit on a path does not mean Git will check the contents of the file to see if it has changed — it makes Git to omit any checking and assume it has not changed. When you make changes to working tree files, you have to explicitly tell Git about it by dropping \"assume unchanged\" bit, either before or after you modify them.\n\nIn order to set \"assume unchanged\" bit, use --assume-unchanged option. To unset, use --no-assume-unchanged. To see which files have the \"assume unchanged\" bit set, use git ls-files -v (see git-ls-files[1]).\n\nThe command looks at core.ignorestat configuration variable. When this is true, paths updated with git update-index paths... and paths updated with other Git commands that update both index and working tree (e.g. git apply --index, git checkout-index -u, and git read-tree -u) are automatically marked as \"assume unchanged\". Note that \"assume unchanged\" bit is not set if git update-index --refresh finds the working tree file matches the index (use git update-index --really-refresh if you want to mark them as \"assume unchanged\").\n\nSometimes users confuse the assume-unchanged bit with the skip-worktree bit. See the final paragraph in the \"Skip-worktree bit\" section below for an explanation of the differences.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 1718
        }
      },
      {
        "header": "EXAMPLES",
        "content": "To update and refresh only the files already checked out:\n\nforces lstat(2) to set \"assume unchanged\" bits for paths that match index.\n\nmark the path to be edited.\n\nthis does lstat(2) and finds index matches the path.\n\nthis does lstat(2) and finds index does not match the path.\n\nregistering the new version to index sets \"assume unchanged\" bit.\n\nand it is assumed unchanged.\n\neven after you edit it.\n\nyou can tell about the change after the fact.\n\nnow it checks with lstat(2) and finds it has been changed.\n\n• forces lstat(2) to set \"assume unchanged\" bits for paths that match index.\n• mark the path to be edited.\n• this does lstat(2) and finds index matches the path.\n• this does lstat(2) and finds index does not match the path.\n• registering the new version to index sets \"assume unchanged\" bit.\n• and it is assumed unchanged.\n• even after you edit it.\n• you can tell about the change after the fact.\n• now it checks with lstat(2) and finds it has been changed.\n\n**On an inefficient filesystem with core.ignorestat set**: $ git update-index --really-refresh (1) $ git update-index --no-assume-unchanged foo.c (2) $ git diff --name-only (3) $ edit foo.c $ git diff --name-only (4) M foo.c $ git update-index foo.c (5) $ git diff --name-only (6) $ edit foo.c $ git diff --name-only (7) $ git update-index --no-assume-unchanged foo.c (8) $ git diff --name-only (9) M foo.c forces lstat(2) to set \"assume unchanged\" bits for paths that match index. mark the path to be edited. this does lstat(2) and finds index matches the path. this does lstat(2) and finds index does not match the path. registering the new version to index sets \"assume unchanged\" bit. and it is assumed unchanged. even after you edit it. you can tell about the change after the fact. now it checks with lstat(2) and finds it has been changed.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git checkout-index -n -f -a && git update-index --ignore-missing --refresh\n```",
          "```bash\n$ git update-index --really-refresh(1)$ git update-index --no-assume-unchanged foo.c(2)$ git diff --name-only(3)$ edit foo.c\n$ git diff --name-only(4)M foo.c\n$ git update-index foo.c(5)$ git diff --name-only(6)$ edit foo.c\n$ git diff --name-only(7)$ git update-index --no-assume-unchanged foo.c(8)$ git diff --name-only(9)M foo.c\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 10,
          "content_length": 1813
        }
      },
      {
        "header": "SKIP-WORKTREE BIT",
        "content": "Skip-worktree bit can be defined in one (long) sentence: Tell git to avoid writing the file to the working directory when reasonably possible, and treat the file as unchanged when it is not present in the working directory.\n\nNote that not all git commands will pay attention to this bit, and some only partially support it.\n\nThe update-index flags and the read-tree capabilities relating to the skip-worktree bit predated the introduction of the git-sparse-checkout[1] command, which provides a much easier way to configure and handle the skip-worktree bits. If you want to reduce your working tree to only deal with a subset of the files in the repository, we strongly encourage the use of git-sparse-checkout[1] in preference to the low-level update-index and read-tree primitives.\n\nThe primary purpose of the skip-worktree bit is to enable sparse checkouts, i.e. to have working directories with only a subset of paths present. When the skip-worktree bit is set, Git commands (such as switch, pull, merge) will avoid writing these files. However, these commands will sometimes write these files anyway in important cases such as conflicts during a merge or rebase. Git commands will also avoid treating the lack of such files as an intentional deletion; for example git add -u will not stage a deletion for these files and git commit -a will not make a commit deleting them either.\n\nAlthough this bit looks similar to assume-unchanged bit, its goal is different. The assume-unchanged bit is for leaving the file in the working tree but having Git omit checking it for changes and presuming that the file has not been changed (though if it can determine without stat’ing the file that it has changed, it is free to record the changes). skip-worktree tells Git to ignore the absence of the file, avoid updating it when possible with commands that normally update much of the working directory (e.g. checkout, switch, pull, etc.), and not have its absence be recorded in commits. Note that in sparse checkouts (setup by git sparse-checkout or by configuring core.sparseCheckout to true), if a file is marked as skip-worktree in the index but is found in the working tree, Git will clear the skip-worktree bit for that file.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 2223
        }
      },
      {
        "header": "SPLIT INDEX",
        "content": "This mode is designed for repositories with very large indexes, and aims at reducing the time it takes to repeatedly write these indexes.\n\nIn this mode, the index is split into two files, $GIT_DIR/index and $GIT_DIR/sharedindex.<SHA-1>. Changes are accumulated in $GIT_DIR/index, the split index, while the shared index file contains all index entries and stays unchanged.\n\nAll changes in the split index are pushed back to the shared index file when the number of entries in the split index reaches a level specified by the splitIndex.maxPercentChange config variable (see git-config[1]).\n\nEach time a new shared index file is created, the old shared index files are deleted if their modification time is older than what is specified by the splitIndex.sharedIndexExpire config variable (see git-config[1]).\n\nTo avoid deleting a shared index file that is still used, its modification time is updated to the current time every time a new split index based on the shared index file is either created or read from.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1011
        }
      },
      {
        "header": "UNTRACKED CACHE",
        "content": "This cache is meant to speed up commands that involve determining untracked files such as git status.\n\nThis feature works by recording the mtime of the working tree directories and then omitting reading directories and stat calls against files in those directories whose mtime hasn’t changed. For this to work the underlying operating system and file system must change the st_mtime field of directories if files in the directory are added, modified or deleted.\n\nYou can test whether the filesystem supports that with the --test-untracked-cache option. The --untracked-cache option used to implicitly perform that test in older versions of Git, but that’s no longer the case.\n\nIf you want to enable (or disable) this feature, it is easier to use the core.untrackedCache configuration variable (see git-config[1]) than using the --untracked-cache option to git update-index in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable to true (or false) in your $HOME/.gitconfig just once and have it affect all repositories you touch.\n\nWhen the core.untrackedCache configuration variable is changed, the untracked cache is added to or removed from the index the next time a command reads the index; while when --[no-|force-]untracked-cache are used, the untracked cache is immediately added to or removed from the index.\n\nBefore 2.17, the untracked cache had a bug where replacing a directory with a symlink to another directory could cause it to incorrectly show files tracked by git as untracked. See the \"status: add a failing test showing a core.untrackedCache bug\" commit to git.git. A workaround for that is (and this might work for other undiscovered bugs in the future):\n\nThis bug has also been shown to affect non-symlink cases of replacing a directory with a file when it comes to the internal structures of the untracked cache, but no case has been reported where this resulted in wrong \"git status\" output.\n\nThere are also cases where existing indexes written by git versions before 2.17 will reference directories that don’t exist anymore, potentially causing many \"could not open directory\" warnings to be printed on \"git status\". These are new warnings for existing issues that were previously silently discarded.\n\nAs with the bug described above the solution is to one-off do a \"git status\" run with core.untrackedCache=false to flush out the leftover bad data.",
        "code_examples": [],
        "usage_examples": [
          "```bash\n$ git -c core.untrackedCache=false status\n```"
        ],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": true,
          "has_table": false,
          "paragraph_count": 9,
          "content_length": 2448
        }
      },
      {
        "header": "FILE SYSTEM MONITOR",
        "content": "This feature is intended to speed up git operations for repos that have large working directories.\n\nIt enables git to work together with a file system monitor (see git-fsmonitor--daemon[1] and the \"fsmonitor-watchman\" section of githooks[5]) that can inform it as to what files have been modified. This enables git to avoid having to lstat() every file to find modified files.\n\nWhen used in conjunction with the untracked cache, it can further improve performance by avoiding the cost of scanning the entire working directory looking for new files.\n\nIf you want to enable (or disable) this feature, it is easier to use the core.fsmonitor configuration variable (see git-config[1]) than using the --fsmonitor option to git update-index in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable in your $HOME/.gitconfig just once and have it affect all repositories you touch.\n\nWhen the core.fsmonitor configuration variable is changed, the file system monitor is added to or removed from the index the next time a command reads the index. When --[no-]fsmonitor are used, the file system monitor is immediately added to or removed from the index.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1218
        }
      },
      {
        "header": "CONFIGURATION",
        "content": "The command honors core.filemode configuration variable. If your repository is on a filesystem whose executable bits are unreliable, this should be set to false (see git-config[1]). This causes the command to ignore differences in file modes recorded in the index and the file mode on the filesystem if they differ only on executable bit. On such an unfortunate filesystem, you may need to use git update-index --chmod=.\n\nQuite similarly, if core.symlinks configuration variable is set to false (see git-config[1]), symbolic links are checked out as plain files, and this command does not modify a recorded file mode from symbolic link to regular file.\n\nThe command looks at core.ignorestat configuration variable. See Using \"assume unchanged\" bit section above.\n\nThe command also looks at core.trustctime configuration variable. It can be useful when the inode change time is regularly modified by something outside Git (file system crawlers and backup systems use ctime for marking files processed) (see git-config[1]).\n\nThe untracked cache extension can be enabled by the core.untrackedCache configuration variable (see git-config[1]).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 5,
          "content_length": 1138
        }
      },
      {
        "header": "NOTES",
        "content": "Users often try to use the assume-unchanged and skip-worktree bits to tell Git to ignore changes to files that are tracked. This does not work as expected, since Git may still check working tree files against the index when performing certain operations. In general, Git does not provide a way to ignore changes to tracked files, so alternate solutions are recommended.\n\nFor example, if the file you want to change is some sort of config file, the repository can include a sample config file that can then be copied into the ignored name and modified. The repository can even include a script to treat the sample file as a template, modifying and copying it automatically.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 672
        }
      },
      {
        "header": "SEE ALSO",
        "content": "git-config[1], git-add[1], git-ls-files[1]",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 42
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-update-index",
    "doc_type": "git",
    "total_sections": 16
  },
  {
    "title": "Git",
    "summary": "NAME git-update-ref - Update the object name stored in a ref safely\n\ngit-update-ref - Update the object name stored in a ref safely",
    "sections": [
      {
        "header": "NAME",
        "content": "git-update-ref - Update the object name stored in a ref safely",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 62
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Given two arguments, stores the <new-oid> in the <ref>, possibly dereferencing the symbolic refs. E.g. git update-ref HEAD <new-oid> updates the current branch head to the new object.\n\nGiven three arguments, stores the <new-oid> in the <ref>, possibly dereferencing the symbolic refs, after verifying that the current value of the <ref> matches <old-oid>. E.g. git update-ref refs/heads/master <new-oid> <old-oid> updates the master branch head to <new-oid> only if its current value is <old-oid>. You can specify 40 \"0\" or an empty string as <old-oid> to make sure that the ref you are creating does not exist.\n\nThe final arguments are object names; this command without any options does not support updating a symbolic ref to point to another ref (see git-symbolic-ref[1]). But git update-ref --stdin does have the symref-* commands so that regular refs and symbolic refs can be committed in the same transaction.\n\nIf --no-deref is given, <ref> itself is overwritten, rather than the result of following the symbolic pointers.\n\nWith -d, it deletes the named <ref> after verifying that it still contains <old-oid>.\n\nWith --stdin, update-ref reads instructions from standard input and performs all modifications together. Specify commands of the form:\n\nWith --create-reflog, update-ref will create a reflog for each ref even if one would not ordinarily be created.\n\nWith --batch-updates, update-ref executes the updates in a batch but allows individual updates to fail due to invalid or incorrect user input, applying only the successful updates. However, system-related errors—such as I/O failures or memory issues—will result in a full failure of all batched updates. Any failed updates will be reported in the following format:\n\nQuote fields containing whitespace as if they were strings in C source code; i.e., surrounded by double-quotes and with backslash escapes. Use 40 \"0\" characters or the empty string to specify a zero value. To specify a missing value, omit the value and its preceding SP entirely.\n\nAlternatively, use -z to specify in NUL-terminated format, without quoting:\n\nIn this format, use 40 \"0\" to specify a zero value, and use the empty string to specify a missing value.\n\nIn either format, values can be specified in any form that Git recognizes as an object name. Commands in any other format or a repeated <ref> produce an error. Command meanings are:\n\nSet <ref> to <new-oid> after verifying <old-oid>, if given. Specify a zero <new-oid> to ensure the ref does not exist after the update and/or a zero <old-oid> to make sure the ref does not exist before the update.\n\nCreate <ref> with <new-oid> after verifying that it does not exist. The given <new-oid> may not be zero.\n\nDelete <ref> after verifying that it exists with <old-oid>, if given. If given, <old-oid> may not be zero.\n\nSet <ref> to <new-target> after verifying <old-target> or <old-oid>, if given. Specify a zero <old-oid> to ensure that the ref does not exist before the update.\n\nVerify <ref> against <old-oid> but do not change it. If <old-oid> is zero or missing, the ref must not exist.\n\nsymref-create: Create symbolic ref <ref> with <new-target> after verifying that it does not exist.\n\nDelete <ref> after verifying that it exists with <old-target>, if given.\n\nVerify symbolic <ref> against <old-target> but do not change it. If <old-target> is missing, the ref must not exist. Can only be used in no-deref mode.\n\nModify the behavior of the next command naming a <ref>. The only valid option is no-deref to avoid dereferencing a symbolic ref.\n\nStart a transaction. In contrast to a non-transactional session, a transaction will automatically abort if the session ends without an explicit commit. This command may create a new empty transaction when the current one has been committed or aborted already.\n\nPrepare to commit the transaction. This will create lock files for all queued reference updates. If one reference could not be locked, the transaction will be aborted.\n\nCommit all reference updates queued for the transaction, ending the transaction.\n\nAbort the transaction, releasing all locks if the transaction is in prepared state.\n\nIf all <ref>s can be locked with matching <old-oid>s simultaneously, all modifications are performed. Otherwise, no modifications are performed. Note that while each individual <ref> is updated or deleted atomically, a concurrent reader may still see a subset of the modifications.\n\n**update**: Set <ref> to <new-oid> after verifying <old-oid>, if given. Specify a zero <new-oid> to ensure the ref does not exist after the update and/or a zero <old-oid> to make sure the ref does not exist before the update.\n**create**: Create <ref> with <new-oid> after verifying that it does not exist. The given <new-oid> may not be zero.\n**delete**: Delete <ref> after verifying that it exists with <old-oid>, if given. If given, <old-oid> may not be zero.\n**symref-update**: Set <ref> to <new-target> after verifying <old-target> or <old-oid>, if given. Specify a zero <old-oid> to ensure that the ref does not exist before the update.\n**verify**: Verify <ref> against <old-oid> but do not change it. If <old-oid> is zero or missing, the ref must not exist.\n**symref-delete**: Delete <ref> after verifying that it exists with <old-target>, if given.\n**symref-verify**: Verify symbolic <ref> against <old-target> but do not change it. If <old-target> is missing, the ref must not exist. Can only be used in no-deref mode.\n**option**: Modify the behavior of the next command naming a <ref>. The only valid option is no-deref to avoid dereferencing a symbolic ref.\n**start**: Start a transaction. In contrast to a non-transactional session, a transaction will automatically abort if the session ends without an explicit commit. This command may create a new empty transaction when the current one has been committed or aborted already.\n**prepare**: Prepare to commit the transaction. This will create lock files for all queued reference updates. If one reference could not be locked, the transaction will be aborted.\n**commit**: Commit all reference updates queued for the transaction, ending the transaction.\n**abort**: Abort the transaction, releasing all locks if the transaction is in prepared state.",
        "code_examples": [
          "```bash\nupdate SP<ref>SP <new-oid> [SP <old-oid>] LF\ncreate SP<ref>SP <new-oid> LF\ndelete SP<ref>[SP <old-oid>] LF\nverify SP<ref>[SP <old-oid>] LF\nsymref-update SP<ref>SP <new-target> [SP (ref SP <old-target> | oid SP <old-oid>)] LF\nsymref-create SP<ref>SP <new-target> LF\nsymref-delete SP<ref>[SP <old-target>] LF\nsymref-verify SP<ref>[SP <old-target>] LF\noption SP <opt> LF\nstart LF\nprepare LF\ncommit LF\nabort LF\n```",
          "```bash\nrejected SP (<old-oid> | <old-target>) SP (<new-oid> | <new-target>) SP <rejection-reason> LF\n```",
          "```bash\nupdate SP<ref>NUL <new-oid> NUL [<old-oid>] NUL\ncreate SP<ref>NUL <new-oid> NUL\ndelete SP<ref>NUL [<old-oid>] NUL\nverify SP<ref>NUL [<old-oid>] NUL\nsymref-update SP<ref>NUL <new-target> [NUL (ref NUL <old-target> | oid NUL <old-oid>)] NUL\nsymref-create SP<ref>NUL <new-target> NUL\nsymref-delete SP<ref>[NUL <old-target>] NUL\nsymref-verify SP<ref>[NUL <old-target>] NUL\noption SP <opt> NUL\nstart NUL\nprepare NUL\ncommit NUL\nabort NUL\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 26,
          "content_length": 6225
        }
      },
      {
        "header": "LOGGING UPDATES",
        "content": "If config parameter \"core.logAllRefUpdates\" is true and the ref is one under \"refs/heads/\", \"refs/remotes/\", \"refs/notes/\", or a pseudoref like HEAD or ORIG_HEAD; or the file \"$GIT_DIR/logs/<ref>\" exists then git update-ref will append a line to the log file \"$GIT_DIR/logs/<ref>\" (dereferencing all symbolic refs before creating the log name) describing the change in ref value. Log lines are formatted as:\n\nWhere \"oldsha1\" is the 40 character hexadecimal value previously stored in <ref>, \"newsha1\" is the 40 character hexadecimal value of <new-oid> and \"committer\" is the committer’s name, email address and date in the standard Git committer ident format.\n\nWhere all fields are as described above and \"message\" is the value supplied to the -m option.\n\nAn update will fail (without changing <ref>) if the current user is unable to create a new log file, append to the existing log file or does not have committer information available.",
        "code_examples": [
          "```bash\noldsha1 SP newsha1 SP committer LF\n```",
          "```bash\noldsha1 SP newsha1 SP committer TAB message LF\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 4,
          "content_length": 938
        }
      },
      {
        "header": "NOTES",
        "content": "Symbolic refs were initially implemented using symbolic links. This is now deprecated since not all filesystems support symbolic links.\n\nThis command follows real symlinks only if they start with \"refs/\": otherwise it will just try to read them and update them as a regular file (i.e. it will allow the filesystem to follow them, but will overwrite such a symlink to somewhere else with a regular filename).",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 407
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-update-ref",
    "doc_type": "git",
    "total_sections": 5
  },
  {
    "title": "Git",
    "summary": "NAME git-verify-pack - Validate packed Git archive files\n\ngit-verify-pack - Validate packed Git archive files",
    "sections": [
      {
        "header": "NAME",
        "content": "git-verify-pack - Validate packed Git archive files",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 51
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Read each idx file for packed Git archive given on the command line, and verify the idx file and the corresponding pack file.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 125
        }
      },
      {
        "header": "OPTIONS",
        "content": "After verifying the pack, show the list of objects contained in the pack and a histogram of delta chain length.\n\nDo not verify the pack contents; only show the histogram of delta chain length. With --verbose, the list of objects is also shown.\n\nDo not interpret any more arguments as options.\n\n**-v**: After verifying the pack, show the list of objects contained in the pack and a histogram of delta chain length.\n**--verbose**: Do not verify the pack contents; only show the histogram of delta chain length. With --verbose, the list of objects is also shown.\n**-s**: Do not interpret any more arguments as options.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 615
        }
      },
      {
        "header": "OUTPUT FORMAT",
        "content": "When specifying the -v option the format used is:\n\nfor objects that are not deltified in the pack, and\n\nfor objects that are deltified.",
        "code_examples": [
          "```bash\nobject-name type size size-in-packfile offset-in-packfile\n```",
          "```bash\nobject-name type size size-in-packfile offset-in-packfile depth base-object-name\n```"
        ],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": true,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 135
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-verify-pack",
    "doc_type": "git",
    "total_sections": 5
  },
  {
    "title": "Git",
    "summary": "NAME git-write-tree - Create a tree object from the current index\n\ngit-write-tree - Create a tree object from the current index",
    "sections": [
      {
        "header": "NAME",
        "content": "git-write-tree - Create a tree object from the current index",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 60
        }
      },
      {
        "header": "DESCRIPTION",
        "content": "Creates a tree object using the current index. The name of the new tree object is printed to standard output.\n\nThe index must be in a fully merged state.\n\nConceptually, git write-tree sync()s the current index contents into a set of tree files. In order to have that match what is actually in your directory right now, you need to have done a git update-index phase before you did the git write-tree.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 3,
          "content_length": 400
        }
      },
      {
        "header": "OPTIONS",
        "content": "Normally git write-tree ensures that the objects referenced by the directory exist in the object database. This option disables this check.\n\nWrites a tree object that represents a subdirectory <prefix>. This can be used to write the tree object for a subproject that is in the named subdirectory.\n\n**--missing-ok**: Normally git write-tree ensures that the objects referenced by the directory exist in the object database. This option disables this check.\n**--prefix=<prefix>/**: Writes a tree object that represents a subdirectory <prefix>. This can be used to write the tree object for a subproject that is in the named subdirectory.",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 2,
          "content_length": 635
        }
      },
      {
        "header": "GIT",
        "content": "Part of the git[1] suite",
        "code_examples": [],
        "usage_examples": [],
        "metadata": {
          "level": "h2",
          "has_code": false,
          "has_usage": false,
          "has_table": false,
          "paragraph_count": 1,
          "content_length": 24
        }
      }
    ],
    "url": "https://git-scm.com/docs/git-write-tree",
    "doc_type": "git",
    "total_sections": 4
  }
]