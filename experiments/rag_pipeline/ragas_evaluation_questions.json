{
  "metadata": {
    "total_questions": 80,
    "python_questions": 40,
    "git_questions": 40,
    "difficulty_distribution": {
      "easy": 32,
      "medium": 32,
      "hard": 16
    },
    "question_types": [
      "concept_explanation",
      "usage_how_to",
      "comparison",
      "troubleshooting",
      "best_practice"
    ]
  },
  "questions": [
    {
      "id": "python_001",
      "domain": "python",
      "difficulty": "easy",
      "type": "concept_explanation",
      "question": "Python에서 리스트(list)와 튜플(tuple)의 차이는 무엇인가요?",
      "ground_truth": "리스트는 mutable(변경 가능)하여 요소를 추가, 삭제, 수정할 수 있지만, 튜플은 immutable(변경 불가)하여 한번 생성되면 수정할 수 없습니다. 리스트는 []로, 튜플은 ()로 정의합니다.",
      "expected_topics": ["mutable", "immutable", "list", "tuple", "difference"]
    },
    {
      "id": "python_002",
      "domain": "python",
      "difficulty": "easy",
      "type": "concept_explanation",
      "question": "Python에서 *args와 **kwargs는 무엇인가요?",
      "ground_truth": "*args는 가변 개수의 위치 인자를 튜플로 받고, **kwargs는 가변 개수의 키워드 인자를 딕셔너리로 받습니다. 함수에 유연하게 인자를 전달할 때 사용합니다.",
      "expected_topics": ["args", "kwargs", "variable arguments", "function"]
    },
    {
      "id": "python_003",
      "domain": "python",
      "difficulty": "easy",
      "type": "concept_explanation",
      "question": "Python에서 얕은 복사(shallow copy)와 깊은 복사(deep copy)의 차이는?",
      "ground_truth": "얕은 복사는 최상위 객체만 복사하고 내부 객체는 참조를 공유하지만, 깊은 복사는 모든 중첩 객체까지 재귀적으로 복사하여 완전히 독립적인 복사본을 만듭니다.",
      "expected_topics": ["shallow copy", "deep copy", "copy", "reference"]
    },
    {
      "id": "python_004",
      "domain": "python",
      "difficulty": "easy",
      "type": "usage_how_to",
      "question": "Python에서 리스트 컴프리헨션(list comprehension)은 어떻게 사용하나요?",
      "ground_truth": "[expression for item in iterable if condition] 형태로 사용합니다. 예: [x*2 for x in range(10) if x % 2 == 0]는 0-9 중 짝수를 2배한 리스트를 생성합니다.",
      "expected_topics": ["list comprehension", "syntax", "example"]
    },
    {
      "id": "python_005",
      "domain": "python",
      "difficulty": "easy",
      "type": "usage_how_to",
      "question": "Python에서 딕셔너리의 값을 안전하게 가져오는 방법은?",
      "ground_truth": "dict.get(key, default) 메서드를 사용합니다. 키가 없으면 KeyError 대신 기본값을 반환합니다. 예: my_dict.get('name', 'Unknown')",
      "expected_topics": ["dictionary", "get", "default value", "KeyError"]
    },
    {
      "id": "python_006",
      "domain": "python",
      "difficulty": "easy",
      "type": "concept_explanation",
      "question": "Python에서 문자열 포맷팅 방법에는 어떤 것들이 있나요?",
      "ground_truth": "% 포맷팅, str.format(), f-string(Python 3.6+) 세 가지가 있습니다. 현재는 f-string이 가장 권장됩니다. 예: f'{name}님 안녕하세요'",
      "expected_topics": ["string formatting", "f-string", "format", "percent"]
    },
    {
      "id": "python_007",
      "domain": "python",
      "difficulty": "easy",
      "type": "usage_how_to",
      "question": "Python에서 파일을 읽고 쓰는 기본 방법은?",
      "ground_truth": "with open('file.txt', 'r') as f: content = f.read() 형태로 읽고, 'w' 모드로 쓰기를 합니다. with 문을 사용하면 자동으로 파일이 닫힙니다.",
      "expected_topics": ["file io", "open", "with statement", "read", "write"]
    },
    {
      "id": "python_008",
      "domain": "python",
      "difficulty": "easy",
      "type": "concept_explanation",
      "question": "Python에서 None은 무엇인가요?",
      "ground_truth": "None은 Python의 null 값으로, 값이 없음을 나타내는 특수한 상수입니다. NoneType의 유일한 인스턴스이며, 함수가 명시적으로 값을 반환하지 않으면 None을 반환합니다.",
      "expected_topics": ["None", "null", "NoneType", "default return"]
    },
    {
      "id": "python_009",
      "domain": "python",
      "difficulty": "easy",
      "type": "usage_how_to",
      "question": "Python에서 리스트의 마지막 요소를 제거하는 방법은?",
      "ground_truth": "list.pop() 또는 del list[-1]을 사용합니다. pop()은 제거된 요소를 반환하고, del은 반환하지 않습니다.",
      "expected_topics": ["list", "pop", "del", "remove element"]
    },
    {
      "id": "python_010",
      "domain": "python",
      "difficulty": "easy",
      "type": "concept_explanation",
      "question": "Python에서 == 와 is의 차이는?",
      "ground_truth": "==는 값의 동등성을 비교하고, is는 객체의 identity(메모리 주소)를 비교합니다. is는 주로 None과 비교할 때 사용합니다.",
      "expected_topics": ["equality", "identity", "is", "==", "comparison"]
    },
    {
      "id": "python_011",
      "domain": "python",
      "difficulty": "medium",
      "type": "concept_explanation",
      "question": "Python 데코레이터(decorator)는 무엇이고 어떻게 작동하나요?",
      "ground_truth": "데코레이터는 함수나 클래스를 수정하지 않고 기능을 추가하는 고차 함수입니다. @decorator 문법으로 사용하며, 함수를 인자로 받아 새로운 함수를 반환합니다.",
      "expected_topics": ["decorator", "higher order function", "wrapper", "@syntax"]
    },
    {
      "id": "python_012",
      "domain": "python",
      "difficulty": "medium",
      "type": "concept_explanation",
      "question": "Python 제너레이터(generator)와 일반 함수의 차이는?",
      "ground_truth": "제너레이터는 yield 키워드를 사용하여 값을 하나씩 생성하며, 메모리 효율적입니다. 일반 함수는 return으로 모든 값을 한 번에 반환하지만, 제너레이터는 lazy evaluation으로 필요할 때마다 값을 생성합니다.",
      "expected_topics": ["generator", "yield", "lazy evaluation", "memory efficient"]
    },
    {
      "id": "python_013",
      "domain": "python",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Python에서 예외를 처리하는 올바른 방법은?",
      "ground_truth": "try-except-else-finally 블록을 사용합니다. except에서 구체적인 예외 타입을 지정하고, finally는 항상 실행됩니다. 일반적인 Exception 대신 구체적인 예외를 잡는 것이 좋습니다.",
      "expected_topics": ["exception handling", "try", "except", "finally", "specific exception"]
    },
    {
      "id": "python_014",
      "domain": "python",
      "difficulty": "medium",
      "type": "concept_explanation",
      "question": "Python의 GIL(Global Interpreter Lock)은 무엇인가요?",
      "ground_truth": "GIL은 한 번에 하나의 스레드만 Python 바이트코드를 실행할 수 있게 하는 뮤텍스입니다. CPU-bound 작업에서는 멀티스레딩 성능 향상이 제한되지만, I/O-bound 작업에는 영향이 적습니다.",
      "expected_topics": ["GIL", "threading", "concurrency", "multiprocessing"]
    },
    {
      "id": "python_015",
      "domain": "python",
      "difficulty": "medium",
      "type": "comparison",
      "question": "Python의 리스트와 NumPy 배열의 주요 차이점은?",
      "ground_truth": "리스트는 다양한 타입을 저장할 수 있지만 느리고, NumPy 배열은 같은 타입만 저장하지만 벡터화 연산으로 매우 빠릅니다. NumPy는 과학 계산에 최적화되어 있습니다.",
      "expected_topics": ["list", "numpy array", "performance", "vectorization"]
    },
    {
      "id": "python_016",
      "domain": "python",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Python에서 컨텍스트 매니저(context manager)는 어떻게 만드나요?",
      "ground_truth": "__enter__와 __exit__ 메서드를 구현하거나, contextlib.contextmanager 데코레이터를 사용합니다. with 문과 함께 사용하여 리소스 관리를 자동화합니다.",
      "expected_topics": ["context manager", "__enter__", "__exit__", "with statement", "contextlib"]
    },
    {
      "id": "python_017",
      "domain": "python",
      "difficulty": "medium",
      "type": "concept_explanation",
      "question": "Python의 덕 타이핑(duck typing)이란?",
      "ground_truth": "객체의 타입보다 객체가 특정 메서드나 속성을 가지고 있는지가 중요한 개념입니다. '오리처럼 걷고 오리처럼 꽥꽥거리면 오리다'라는 원칙에서 유래했습니다.",
      "expected_topics": ["duck typing", "dynamic typing", "EAFP", "interface"]
    },
    {
      "id": "python_018",
      "domain": "python",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Python에서 클래스 메서드와 정적 메서드의 차이는?",
      "ground_truth": "@classmethod는 첫 인자로 클래스(cls)를 받고, @staticmethod는 self나 cls를 받지 않습니다. 클래스 메서드는 클래스 변수에 접근하고, 정적 메서드는 독립적인 유틸리티 함수입니다.",
      "expected_topics": ["classmethod", "staticmethod", "decorator", "cls", "self"]
    },
    {
      "id": "python_019",
      "domain": "python",
      "difficulty": "medium",
      "type": "best_practice",
      "question": "Python에서 가변 기본 인자(mutable default argument)를 사용하면 안 되는 이유는?",
      "ground_truth": "기본 인자는 함수 정의 시 한 번만 생성되므로, 가변 객체(리스트, 딕셔너리)를 기본값으로 사용하면 모든 호출에서 같은 객체를 공유합니다. 대신 None을 기본값으로 하고 함수 내부에서 생성해야 합니다.",
      "expected_topics": ["mutable default argument", "function definition", "pitfall", "None"]
    },
    {
      "id": "python_020",
      "domain": "python",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Python에서 람다(lambda) 함수는 언제 사용하나요?",
      "ground_truth": "간단한 일회용 함수가 필요할 때 사용합니다. sorted(), map(), filter() 등과 함께 자주 쓰이지만, 복잡한 로직은 일반 함수로 작성하는 것이 좋습니다.",
      "expected_topics": ["lambda", "anonymous function", "map", "filter", "sorted"]
    },
    {
      "id": "python_021",
      "domain": "python",
      "difficulty": "medium",
      "type": "concept_explanation",
      "question": "Python의 __init__와 __new__의 차이는?",
      "ground_truth": "__new__는 객체를 생성하고, __init__는 생성된 객체를 초기화합니다. __new__는 클래스 메서드이고 인스턴스를 반환하며, __init__는 인스턴스 메서드로 None을 반환합니다.",
      "expected_topics": ["__new__", "__init__", "constructor", "initialization"]
    },
    {
      "id": "python_022",
      "domain": "python",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Python에서 여러 예외를 한 번에 처리하는 방법은?",
      "ground_truth": "except (TypeError, ValueError) as e: 형태로 튜플을 사용하여 여러 예외를 한 번에 처리할 수 있습니다. 각 예외를 개별적으로 처리하려면 여러 except 블록을 사용합니다.",
      "expected_topics": ["multiple exceptions", "except", "tuple", "exception handling"]
    },
    {
      "id": "python_023",
      "domain": "python",
      "difficulty": "medium",
      "type": "best_practice",
      "question": "Python에서 EAFP와 LBYL의 차이는?",
      "ground_truth": "EAFP(Easier to Ask for Forgiveness than Permission)는 try-except로 먼저 실행하고, LBYL(Look Before You Leap)은 if 문으로 먼저 검사합니다. Python에서는 EAFP가 권장됩니다.",
      "expected_topics": ["EAFP", "LBYL", "pythonic", "try-except", "if statement"]
    },
    {
      "id": "python_024",
      "domain": "python",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Python에서 모듈을 임포트하는 다양한 방법은?",
      "ground_truth": "import module, from module import func, import module as alias, from module import * 등이 있습니다. from module import *는 네임스페이스 오염으로 권장되지 않습니다.",
      "expected_topics": ["import", "from", "alias", "namespace", "best practice"]
    },
    {
      "id": "python_025",
      "domain": "python",
      "difficulty": "hard",
      "type": "concept_explanation",
      "question": "Python의 메타클래스(metaclass)는 무엇이고 언제 사용하나요?",
      "ground_truth": "메타클래스는 클래스의 클래스로, 클래스 생성 과정을 커스터마이즈합니다. type은 기본 메타클래스이며, ORM, API 프레임워크 등에서 동적 클래스 생성 시 사용합니다.",
      "expected_topics": ["metaclass", "type", "class creation", "dynamic"]
    },
    {
      "id": "python_026",
      "domain": "python",
      "difficulty": "hard",
      "type": "concept_explanation",
      "question": "Python의 디스크립터(descriptor)는 무엇인가요?",
      "ground_truth": "디스크립터는 __get__, __set__, __delete__ 중 하나 이상을 구현한 객체로, 속성 접근을 커스터마이즈합니다. property, classmethod, staticmethod가 디스크립터로 구현되어 있습니다.",
      "expected_topics": ["descriptor", "__get__", "__set__", "property", "attribute access"]
    },
    {
      "id": "python_027",
      "domain": "python",
      "difficulty": "hard",
      "type": "troubleshooting",
      "question": "Python에서 순환 참조(circular reference) 문제를 해결하는 방법은?",
      "ground_truth": "weakref 모듈을 사용하거나, 명시적으로 참조를 제거합니다. 또는 구조를 재설계하여 순환 참조를 피합니다. gc 모듈로 수동 가비지 컬렉션도 가능합니다.",
      "expected_topics": ["circular reference", "weakref", "garbage collection", "memory leak"]
    },
    {
      "id": "python_028",
      "domain": "python",
      "difficulty": "hard",
      "type": "concept_explanation",
      "question": "Python의 asyncio와 threading의 차이는?",
      "ground_truth": "asyncio는 단일 스레드에서 이벤트 루프로 비동기 I/O를 처리하고, threading은 여러 스레드를 사용합니다. asyncio는 I/O-bound 작업에 효율적이고, threading은 I/O 대기 시 다른 작업을 수행합니다.",
      "expected_topics": ["asyncio", "threading", "concurrency", "event loop", "async/await"]
    },
    {
      "id": "python_029",
      "domain": "python",
      "difficulty": "hard",
      "type": "best_practice",
      "question": "Python에서 메모리 누수를 방지하는 방법은?",
      "ground_truth": "순환 참조 제거, weakref 사용, 명시적 리소스 해제(with 문), __del__ 남용 피하기, gc 모듈 활용 등이 있습니다. 프로파일러로 메모리 사용을 모니터링합니다.",
      "expected_topics": ["memory leak", "weakref", "resource management", "profiler", "gc"]
    },
    {
      "id": "python_030",
      "domain": "python",
      "difficulty": "hard",
      "type": "usage_how_to",
      "question": "Python에서 멀티프로세싱과 멀티스레딩 중 어떤 것을 선택해야 하나요?",
      "ground_truth": "CPU-bound 작업은 multiprocessing(GIL 우회), I/O-bound 작업은 threading 또는 asyncio를 사용합니다. 각 프로세스는 독립적인 메모리를 가지므로 오버헤드가 큽니다.",
      "expected_topics": ["multiprocessing", "threading", "GIL", "CPU-bound", "I/O-bound"]
    },
    {
      "id": "python_031",
      "domain": "python",
      "difficulty": "easy",
      "type": "usage_how_to",
      "question": "Python에서 문자열을 대문자와 소문자로 변환하는 방법은?",
      "ground_truth": "str.upper()는 대문자로, str.lower()는 소문자로 변환합니다. str.title()은 각 단어의 첫 글자를 대문자로, str.capitalize()는 첫 글자만 대문자로 만듭니다.",
      "expected_topics": ["string", "upper", "lower", "title", "capitalize"]
    },
    {
      "id": "python_032",
      "domain": "python",
      "difficulty": "easy",
      "type": "usage_how_to",
      "question": "Python에서 리스트를 정렬하는 방법은?",
      "ground_truth": "list.sort()는 원본을 수정하고 None을 반환하며, sorted(list)는 새로운 정렬된 리스트를 반환합니다. reverse=True로 역순 정렬, key 인자로 정렬 기준을 지정할 수 있습니다.",
      "expected_topics": ["sort", "sorted", "reverse", "key", "in-place"]
    },
    {
      "id": "python_033",
      "domain": "python",
      "difficulty": "medium",
      "type": "concept_explanation",
      "question": "Python의 클로저(closure)란 무엇인가요?",
      "ground_truth": "클로저는 함수가 정의된 환경의 변수를 기억하는 함수입니다. 중첩 함수에서 외부 함수의 변수를 참조할 때 클로저가 형성됩니다.",
      "expected_topics": ["closure", "nested function", "scope", "enclosing"]
    },
    {
      "id": "python_034",
      "domain": "python",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Python에서 JSON 데이터를 다루는 방법은?",
      "ground_truth": "json 모듈을 사용합니다. json.dumps()는 Python 객체를 JSON 문자열로, json.loads()는 JSON 문자열을 Python 객체로 변환합니다. 파일은 json.dump()와 json.load()를 사용합니다.",
      "expected_topics": ["json", "dumps", "loads", "serialization", "deserialization"]
    },
    {
      "id": "python_035",
      "domain": "python",
      "difficulty": "medium",
      "type": "best_practice",
      "question": "Python에서 상수를 정의하는 관례는?",
      "ground_truth": "모든 글자를 대문자로 작성하고 언더스코어로 단어를 구분합니다(예: MAX_SIZE = 100). Python에는 진짜 상수가 없으므로 이는 단지 관례입니다.",
      "expected_topics": ["constant", "naming convention", "uppercase", "PEP 8"]
    },
    {
      "id": "python_036",
      "domain": "python",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Python에서 enumerate()와 zip()의 사용법은?",
      "ground_truth": "enumerate(iterable)은 인덱스와 값을 튜플로 반환하고, zip(iter1, iter2)는 여러 iterable을 병렬로 순회합니다. for i, val in enumerate(list) 형태로 사용합니다.",
      "expected_topics": ["enumerate", "zip", "iteration", "index", "parallel"]
    },
    {
      "id": "python_037",
      "domain": "python",
      "difficulty": "hard",
      "type": "concept_explanation",
      "question": "Python의 추상 베이스 클래스(ABC)는 언제 사용하나요?",
      "ground_truth": "abc 모듈의 ABC를 상속하고 @abstractmethod로 구현을 강제할 메서드를 표시합니다. 인터페이스를 정의하고 다형성을 구현할 때 사용하며, 추상 메서드를 구현하지 않으면 인스턴스화할 수 없습니다.",
      "expected_topics": ["ABC", "abstract base class", "abstractmethod", "interface", "polymorphism"]
    },
    {
      "id": "python_038",
      "domain": "python",
      "difficulty": "hard",
      "type": "troubleshooting",
      "question": "Python에서 RecursionError를 해결하는 방법은?",
      "ground_truth": "재귀 깊이를 줄이거나, sys.setrecursionlimit()로 제한을 늘립니다. 더 나은 방법은 재귀를 반복문으로 변환하거나, 메모이제이션(functools.lru_cache)을 사용하는 것입니다.",
      "expected_topics": ["RecursionError", "recursion limit", "memoization", "lru_cache", "iteration"]
    },
    {
      "id": "python_039",
      "domain": "python",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Python에서 리스트의 중복을 제거하는 방법은?",
      "ground_truth": "set()으로 변환 후 다시 list()로 변환하지만 순서가 보장되지 않습니다. 순서를 유지하려면 dict.fromkeys(list)나 리스트 컴프리헨션을 사용합니다.",
      "expected_topics": ["duplicate removal", "set", "dict.fromkeys", "list", "order preservation"]
    },
    {
      "id": "python_040",
      "domain": "python",
      "difficulty": "medium",
      "type": "best_practice",
      "question": "Python에서 전역 변수를 사용할 때 주의할 점은?",
      "ground_truth": "함수 내에서 전역 변수를 수정하려면 global 키워드를 사용해야 합니다. 하지만 전역 변수는 코드 이해를 어렵게 하므로, 함수 인자와 반환값을 사용하거나 클래스를 사용하는 것이 좋습니다.",
      "expected_topics": ["global variable", "global keyword", "scope", "best practice", "code smell"]
    },
    {
      "id": "git_001",
      "domain": "git",
      "difficulty": "easy",
      "type": "usage_how_to",
      "question": "Git에서 새로운 브랜치를 만들고 전환하는 명령어는?",
      "ground_truth": "git checkout -b <branch-name> 또는 git switch -c <branch-name>을 사용합니다. -b나 -c 옵션은 브랜치를 생성하고 바로 전환합니다.",
      "expected_topics": ["git branch", "git checkout", "git switch", "create branch"]
    },
    {
      "id": "git_002",
      "domain": "git",
      "difficulty": "easy",
      "type": "usage_how_to",
      "question": "Git에서 변경사항을 스테이징하고 커밋하는 방법은?",
      "ground_truth": "git add <file>로 스테이징하고 git commit -m 'message'로 커밋합니다. git add .는 모든 변경사항을 스테이징하고, git commit -am은 수정된 파일을 동시에 스테이징하고 커밋합니다.",
      "expected_topics": ["git add", "git commit", "staging", "commit message"]
    },
    {
      "id": "git_003",
      "domain": "git",
      "difficulty": "easy",
      "type": "usage_how_to",
      "question": "Git에서 커밋 히스토리를 보는 명령어는?",
      "ground_truth": "git log를 사용합니다. git log --oneline은 한 줄로 요약하고, git log --graph는 브랜치 그래프를 보여주며, git log -p는 각 커밋의 변경 내용을 표시합니다.",
      "expected_topics": ["git log", "commit history", "oneline", "graph", "diff"]
    },
    {
      "id": "git_004",
      "domain": "git",
      "difficulty": "easy",
      "type": "concept_explanation",
      "question": "Git의 staging area(스테이징 영역)란 무엇인가요?",
      "ground_truth": "작업 디렉토리와 Git 저장소 사이의 중간 영역으로, 다음 커밋에 포함될 변경사항을 준비하는 곳입니다. git add로 파일을 스테이징 영역에 추가합니다.",
      "expected_topics": ["staging area", "index", "git add", "working directory"]
    },
    {
      "id": "git_005",
      "domain": "git",
      "difficulty": "easy",
      "type": "usage_how_to",
      "question": "Git에서 원격 저장소에 변경사항을 업로드하는 명령어는?",
      "ground_truth": "git push <remote> <branch>를 사용합니다. 보통 git push origin main처럼 사용하며, -u 옵션으로 upstream을 설정하면 이후에는 git push만 입력해도 됩니다.",
      "expected_topics": ["git push", "remote", "origin", "upstream", "-u"]
    },
    {
      "id": "git_006",
      "domain": "git",
      "difficulty": "easy",
      "type": "usage_how_to",
      "question": "Git에서 원격 저장소의 변경사항을 가져오는 방법은?",
      "ground_truth": "git pull은 fetch + merge를 한 번에 수행하고, git fetch는 변경사항만 가져옵니다. git fetch 후 git merge를 수동으로 실행하면 더 안전합니다.",
      "expected_topics": ["git pull", "git fetch", "git merge", "remote", "update"]
    },
    {
      "id": "git_007",
      "domain": "git",
      "difficulty": "easy",
      "type": "concept_explanation",
      "question": "Git에서 HEAD는 무엇을 의미하나요?",
      "ground_truth": "HEAD는 현재 체크아웃된 커밋이나 브랜치를 가리키는 포인터입니다. 보통 현재 브랜치의 최신 커밋을 가리키며, detached HEAD 상태에서는 특정 커밋을 직접 가리킵니다.",
      "expected_topics": ["HEAD", "pointer", "current commit", "detached HEAD"]
    },
    {
      "id": "git_008",
      "domain": "git",
      "difficulty": "easy",
      "type": "usage_how_to",
      "question": "Git에서 파일을 삭제하고 이를 기록하는 방법은?",
      "ground_truth": "git rm <file>을 사용하면 파일을 삭제하고 자동으로 스테이징합니다. 파일은 삭제하지 않고 Git 추적만 중지하려면 git rm --cached <file>을 사용합니다.",
      "expected_topics": ["git rm", "delete file", "untrack", "--cached"]
    },
    {
      "id": "git_009",
      "domain": "git",
      "difficulty": "easy",
      "type": "usage_how_to",
      "question": "Git에서 특정 파일의 변경 이력을 보는 방법은?",
      "ground_truth": "git log <file>로 커밋 히스토리를 보고, git log -p <file>로 각 커밋의 변경 내용을 확인합니다. git blame <file>은 각 줄이 누구에 의해 언제 수정되었는지 보여줍니다.",
      "expected_topics": ["git log", "git blame", "file history", "commit", "author"]
    },
    {
      "id": "git_010",
      "domain": "git",
      "difficulty": "easy",
      "type": "concept_explanation",
      "question": "Git의 .gitignore 파일은 무엇인가요?",
      "ground_truth": ".gitignore에 명시된 파일이나 디렉토리는 Git이 추적하지 않습니다. 빌드 산출물, 임시 파일, 환경 설정 등을 무시할 때 사용합니다. 패턴 매칭을 지원합니다.",
      "expected_topics": [".gitignore", "untracked files", "pattern", "ignore"]
    },
    {
      "id": "git_011",
      "domain": "git",
      "difficulty": "medium",
      "type": "concept_explanation",
      "question": "Git에서 merge와 rebase의 차이는?",
      "ground_truth": "merge는 두 브랜치를 합치는 새 커밋을 생성하고 히스토리를 보존합니다. rebase는 한 브랜치의 커밋을 다른 브랜치 위로 재배치하여 선형 히스토리를 만듭니다. rebase는 공유된 브랜치에서는 피해야 합니다.",
      "expected_topics": ["git merge", "git rebase", "history", "linear", "conflict"]
    },
    {
      "id": "git_012",
      "domain": "git",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Git에서 마지막 커밋을 수정하는 방법은?",
      "ground_truth": "git commit --amend를 사용합니다. 커밋 메시지만 수정하거나, 추가 변경사항을 포함할 수 있습니다. 이미 push한 커밋은 amend하지 않는 것이 좋습니다.",
      "expected_topics": ["git commit", "--amend", "modify commit", "rewrite history"]
    },
    {
      "id": "git_013",
      "domain": "git",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Git에서 특정 커밋의 변경사항만 가져오는 방법은?",
      "ground_truth": "git cherry-pick <commit-hash>를 사용합니다. 특정 커밋의 변경사항을 현재 브랜치에 적용하며, 여러 커밋을 한 번에 cherry-pick할 수도 있습니다.",
      "expected_topics": ["git cherry-pick", "commit", "apply changes", "selective merge"]
    },
    {
      "id": "git_014",
      "domain": "git",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Git에서 작업 중인 변경사항을 임시 저장하는 방법은?",
      "ground_truth": "git stash를 사용하여 변경사항을 임시 저장하고, git stash pop으로 복원합니다. git stash list로 목록을 보고, git stash apply로 특정 stash를 적용할 수 있습니다.",
      "expected_topics": ["git stash", "temporary save", "stash pop", "stash list"]
    },
    {
      "id": "git_015",
      "domain": "git",
      "difficulty": "medium",
      "type": "concept_explanation",
      "question": "Git에서 fast-forward merge란?",
      "ground_truth": "대상 브랜치가 현재 브랜치의 직접적인 조상일 때, 포인터만 이동하여 병합하는 방식입니다. 별도의 merge 커밋이 생성되지 않으며, --no-ff 옵션으로 강제로 merge 커밋을 만들 수 있습니다.",
      "expected_topics": ["fast-forward", "merge", "no-ff", "linear history"]
    },
    {
      "id": "git_016",
      "domain": "git",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Git에서 커밋을 취소하는 방법들은?",
      "ground_truth": "git reset은 커밋 히스토리를 재작성하고(--soft, --mixed, --hard), git revert는 변경사항을 되돌리는 새 커밋을 생성합니다. 공유 브랜치에서는 revert를 사용해야 합니다.",
      "expected_topics": ["git reset", "git revert", "undo commit", "soft", "hard"]
    },
    {
      "id": "git_017",
      "domain": "git",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Git에서 리모트 브랜치를 삭제하는 방법은?",
      "ground_truth": "git push origin --delete <branch-name> 또는 git push origin :<branch-name>을 사용합니다. 로컬 브랜치는 git branch -d <branch-name>으로 삭제합니다.",
      "expected_topics": ["git push", "delete branch", "remote branch", "git branch -d"]
    },
    {
      "id": "git_018",
      "domain": "git",
      "difficulty": "medium",
      "type": "troubleshooting",
      "question": "Git에서 merge conflict가 발생했을 때 해결 방법은?",
      "ground_truth": "충돌이 발생한 파일을 열어 <<<<<<<, =======, >>>>>>> 마커를 찾아 수동으로 수정합니다. 수정 후 git add로 스테이징하고 git commit으로 병합을 완료합니다. git merge --abort로 병합을 취소할 수도 있습니다.",
      "expected_topics": ["merge conflict", "conflict markers", "resolve", "git add", "abort"]
    },
    {
      "id": "git_019",
      "domain": "git",
      "difficulty": "medium",
      "type": "best_practice",
      "question": "Git에서 좋은 커밋 메시지를 작성하는 방법은?",
      "ground_truth": "첫 줄은 50자 이내로 요약하고, 두 번째 줄은 비우며, 본문은 72자로 줄바꿈합니다. 명령형 현재 시제('Add feature', not 'Added')를 사용하고, 무엇을 왜 변경했는지 설명합니다.",
      "expected_topics": ["commit message", "convention", "imperative mood", "summary", "body"]
    },
    {
      "id": "git_020",
      "domain": "git",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Git에서 태그(tag)는 어떻게 사용하나요?",
      "ground_truth": "git tag <tag-name>으로 lightweight 태그를, git tag -a <tag-name> -m 'message'로 annotated 태그를 생성합니다. git push origin <tag-name>으로 원격에 푸시하며, 주로 릴리스 버전 표시에 사용합니다.",
      "expected_topics": ["git tag", "lightweight", "annotated", "version", "release"]
    },
    {
      "id": "git_021",
      "domain": "git",
      "difficulty": "medium",
      "type": "concept_explanation",
      "question": "Git의 detached HEAD 상태란?",
      "ground_truth": "HEAD가 브랜치가 아닌 특정 커밋을 직접 가리키는 상태입니다. 이 상태에서 커밋하면 브랜치에 속하지 않아 나중에 찾기 어려울 수 있으므로, 새 브랜치를 만들어야 합니다.",
      "expected_topics": ["detached HEAD", "commit", "branch", "checkout", "warning"]
    },
    {
      "id": "git_022",
      "domain": "git",
      "difficulty": "hard",
      "type": "usage_how_to",
      "question": "Git에서 interactive rebase는 어떻게 사용하나요?",
      "ground_truth": "git rebase -i <base>를 사용하여 커밋을 재정렬, 합치기(squash), 수정(edit), 삭제(drop)할 수 있습니다. 공유되지 않은 브랜치에서만 사용해야 하며, 커밋 히스토리를 깔끔하게 정리할 때 유용합니다.",
      "expected_topics": ["interactive rebase", "squash", "reorder", "edit", "history rewrite"]
    },
    {
      "id": "git_023",
      "domain": "git",
      "difficulty": "hard",
      "type": "usage_how_to",
      "question": "Git에서 submodule은 어떻게 사용하나요?",
      "ground_truth": "git submodule add <repository> <path>로 추가하고, git submodule update --init으로 초기화합니다. 서브모듈은 별도 저장소를 프로젝트 내에 포함할 때 사용하며, 각각 독립적으로 버전 관리됩니다.",
      "expected_topics": ["git submodule", "add", "update", "init", "nested repository"]
    },
    {
      "id": "git_024",
      "domain": "git",
      "difficulty": "hard",
      "type": "troubleshooting",
      "question": "Git에서 잘못된 push를 되돌리는 방법은?",
      "ground_truth": "git revert로 되돌리는 새 커밋을 만들거나(안전), git reset + force push(위험)를 사용합니다. 공유 브랜치에서는 revert를 사용해야 하며, force push는 팀원과 조율 후 사용합니다.",
      "expected_topics": ["git revert", "git reset", "force push", "undo push", "collaboration"]
    },
    {
      "id": "git_025",
      "domain": "git",
      "difficulty": "hard",
      "type": "concept_explanation",
      "question": "Git의 reflog는 무엇이고 언제 사용하나요?",
      "ground_truth": "reflog는 HEAD와 브랜치 참조의 변경 기록을 저장합니다. git reflog로 확인하며, 잘못된 reset이나 rebase 후 커밋을 복구할 때 사용합니다. 로컬에만 존재하며 일정 기간 후 삭제됩니다.",
      "expected_topics": ["git reflog", "HEAD history", "recovery", "undo", "local"]
    },
    {
      "id": "git_026",
      "domain": "git",
      "difficulty": "hard",
      "type": "best_practice",
      "question": "Git에서 force push를 해야 할 때와 주의사항은?",
      "ground_truth": "rebase나 amend 후 필요하지만, 공유 브랜치에서는 피해야 합니다. --force-with-lease를 사용하면 원격에 새 커밋이 있을 때 push를 차단하여 더 안전합니다. 팀원과 소통이 필수입니다.",
      "expected_topics": ["force push", "--force-with-lease", "danger", "collaboration", "safety"]
    },
    {
      "id": "git_027",
      "domain": "git",
      "difficulty": "hard",
      "type": "usage_how_to",
      "question": "Git에서 bisect는 어떻게 사용하나요?",
      "ground_truth": "git bisect start로 시작하고, git bisect bad <commit>과 git bisect good <commit>으로 범위를 지정합니다. 이진 탐색으로 버그가 발생한 커밋을 찾으며, 각 단계에서 good/bad를 표시합니다.",
      "expected_topics": ["git bisect", "binary search", "bug finding", "good", "bad"]
    },
    {
      "id": "git_028",
      "domain": "git",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Git에서 브랜치 이름을 변경하는 방법은?",
      "ground_truth": "현재 브랜치는 git branch -m <new-name>, 다른 브랜치는 git branch -m <old-name> <new-name>으로 변경합니다. 원격 브랜치는 삭제 후 새 이름으로 다시 push해야 합니다.",
      "expected_topics": ["git branch", "rename", "-m", "local", "remote"]
    },
    {
      "id": "git_029",
      "domain": "git",
      "difficulty": "medium",
      "type": "best_practice",
      "question": "Git에서 작은 커밋을 자주 하는 것이 좋은 이유는?",
      "ground_truth": "작은 커밋은 이해하기 쉽고, 문제 발생 시 원인을 찾기 쉬우며, revert나 cherry-pick이 간단합니다. 논리적으로 관련된 변경사항을 하나의 커밋으로 그룹화하는 것이 좋습니다.",
      "expected_topics": ["commit size", "atomic commit", "best practice", "revert", "review"]
    },
    {
      "id": "git_030",
      "domain": "git",
      "difficulty": "hard",
      "type": "troubleshooting",
      "question": "Git에서 대용량 파일 문제를 해결하는 방법은?",
      "ground_truth": "Git LFS(Large File Storage)를 사용하여 대용량 파일을 별도로 관리합니다. 이미 커밋된 대용량 파일은 git filter-branch나 BFG Repo-Cleaner로 히스토리에서 제거할 수 있습니다.",
      "expected_topics": ["Git LFS", "large files", "filter-branch", "BFG", "history rewrite"]
    },
    {
      "id": "git_031",
      "domain": "git",
      "difficulty": "easy",
      "type": "usage_how_to",
      "question": "Git에서 현재 상태를 확인하는 명령어는?",
      "ground_truth": "git status로 수정된 파일, 스테이징된 파일, 브랜치 상태를 확인합니다. -s 옵션으로 간략하게 볼 수 있습니다.",
      "expected_topics": ["git status", "working directory", "staging", "modified"]
    },
    {
      "id": "git_032",
      "domain": "git",
      "difficulty": "easy",
      "type": "usage_how_to",
      "question": "Git에서 파일의 변경사항을 확인하는 방법은?",
      "ground_truth": "git diff는 작업 디렉토리와 스테이징 영역의 차이를, git diff --staged는 스테이징 영역과 마지막 커밋의 차이를 보여줍니다.",
      "expected_topics": ["git diff", "changes", "staged", "working directory"]
    },
    {
      "id": "git_033",
      "domain": "git",
      "difficulty": "medium",
      "type": "concept_explanation",
      "question": "Git의 origin이란 무엇인가요?",
      "ground_truth": "origin은 원격 저장소의 기본 이름(별칭)입니다. git clone 시 자동으로 설정되며, git remote -v로 확인할 수 있습니다. 다른 이름으로 변경하거나 여러 원격 저장소를 추가할 수도 있습니다.",
      "expected_topics": ["origin", "remote", "alias", "git clone", "git remote"]
    },
    {
      "id": "git_034",
      "domain": "git",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Git에서 원격 브랜치를 추적하는 방법은?",
      "ground_truth": "git checkout --track origin/<branch>나 git checkout <branch>(원격에만 있는 경우)로 자동 추적합니다. git branch -u origin/<branch>로 기존 브랜치에 upstream을 설정할 수 있습니다.",
      "expected_topics": ["tracking branch", "upstream", "--track", "git checkout", "remote"]
    },
    {
      "id": "git_035",
      "domain": "git",
      "difficulty": "medium",
      "type": "best_practice",
      "question": "Git에서 main 브랜치에 직접 커밋하지 않는 이유는?",
      "ground_truth": "main은 안정적인 프로덕션 코드를 유지해야 하므로, feature 브랜치에서 작업하고 리뷰 후 merge하는 것이 좋습니다. 이는 협업과 코드 품질을 위한 best practice입니다.",
      "expected_topics": ["main branch", "feature branch", "code review", "workflow", "best practice"]
    },
    {
      "id": "git_036",
      "domain": "git",
      "difficulty": "hard",
      "type": "usage_how_to",
      "question": "Git에서 특정 파일의 변경사항만 커밋하는 방법은?",
      "ground_truth": "git add <file>로 특정 파일만 스테이징하거나, git add -p로 파일 내 일부 변경사항만 선택적으로 스테이징할 수 있습니다. -p는 hunk 단위로 선택할 수 있습니다.",
      "expected_topics": ["git add", "selective staging", "-p", "patch", "hunk"]
    },
    {
      "id": "git_037",
      "domain": "git",
      "difficulty": "medium",
      "type": "troubleshooting",
      "question": "Git에서 실수로 스테이징한 파일을 unstage하는 방법은?",
      "ground_truth": "git reset <file> 또는 git restore --staged <file>을 사용합니다. 모든 파일을 unstage하려면 git reset을 인자 없이 실행합니다.",
      "expected_topics": ["unstage", "git reset", "git restore", "staging area"]
    },
    {
      "id": "git_038",
      "domain": "git",
      "difficulty": "medium",
      "type": "usage_how_to",
      "question": "Git에서 다른 브랜치의 특정 파일만 가져오는 방법은?",
      "ground_truth": "git checkout <branch> -- <file>을 사용하여 다른 브랜치의 특정 파일을 현재 브랜치로 가져옵니다. 여러 파일을 한 번에 가져올 수도 있습니다.",
      "expected_topics": ["git checkout", "file from branch", "selective merge", "copy file"]
    },
    {
      "id": "git_039",
      "domain": "git",
      "difficulty": "hard",
      "type": "best_practice",
      "question": "Git에서 feature 브랜치를 main에 merge하기 전 권장사항은?",
      "ground_truth": "main을 feature 브랜치로 rebase하거나 merge하여 최신 상태로 만들고, 충돌을 미리 해결합니다. 테스트를 실행하고, 코드 리뷰를 받은 후 merge합니다.",
      "expected_topics": ["feature branch", "rebase", "conflict resolution", "testing", "code review"]
    },
    {
      "id": "git_040",
      "domain": "git",
      "difficulty": "hard",
      "type": "concept_explanation",
      "question": "Git의 세 가지 영역(working directory, staging, repository)의 관계는?",
      "ground_truth": "working directory는 실제 작업 공간, staging은 다음 커밋 준비 영역, repository는 커밋된 히스토리입니다. git add로 working → staging, git commit으로 staging → repository로 이동합니다.",
      "expected_topics": ["three trees", "working directory", "staging", "repository", "git add", "git commit"]
    }
  ]
}
