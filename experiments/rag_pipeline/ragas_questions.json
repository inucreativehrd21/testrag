{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "domain": "git",
      "question": "Git에서 브랜치를 생성하는 명령어는 무엇인가요?",
      "ground_truth": "git branch <브랜치명> 명령어로 새로운 브랜치를 생성할 수 있습니다. 또는 git checkout -b <브랜치명>으로 브랜치를 생성하고 동시에 전환할 수 있습니다.",
      "reference_context": ["git branch 명령어는 브랜치를 관리하는 기본 명령어입니다.", "git checkout -b는 브랜치 생성과 전환을 동시에 수행합니다."]
    },
    {
      "id": 2,
      "difficulty": "easy",
      "domain": "python",
      "question": "Python에서 리스트와 튜플의 가장 큰 차이점은 무엇인가요?",
      "ground_truth": "리스트는 가변(mutable)이어서 요소를 추가, 삭제, 수정할 수 있지만, 튜플은 불변(immutable)이어서 한번 생성되면 요소를 변경할 수 없습니다.",
      "reference_context": ["리스트는 대괄호[]로 표현하고 수정 가능합니다.", "튜플은 소괄호()로 표현하고 불변입니다."]
    },
    {
      "id": 3,
      "difficulty": "easy",
      "domain": "docker",
      "question": "Docker 컨테이너를 실행하는 기본 명령어는 무엇인가요?",
      "ground_truth": "docker run 명령어를 사용하여 컨테이너를 실행합니다. 예: docker run -d -p 8080:80 nginx",
      "reference_context": ["docker run은 이미지로부터 컨테이너를 생성하고 실행합니다.", "-d 옵션은 백그라운드 실행, -p는 포트 매핑입니다."]
    },
    {
      "id": 4,
      "difficulty": "easy",
      "domain": "aws",
      "question": "AWS S3는 어떤 용도로 사용되나요?",
      "ground_truth": "AWS S3(Simple Storage Service)는 객체 스토리지 서비스로, 파일, 이미지, 비디오 등의 데이터를 저장하고 검색하는데 사용됩니다.",
      "reference_context": ["S3는 확장 가능한 객체 스토리지입니다.", "정적 웹사이트 호스팅, 백업, 데이터 아카이빙 등에 활용됩니다."]
    },
    {
      "id": 5,
      "difficulty": "medium",
      "domain": "git",
      "question": "Git에서 merge와 rebase의 차이점을 설명해주세요.",
      "ground_truth": "merge는 두 브랜치의 변경사항을 합치는 새로운 merge commit을 생성하여 히스토리를 보존합니다. rebase는 현재 브랜치의 커밋들을 다른 브랜치 위로 재배치하여 선형적인 히스토리를 만듭니다. merge는 히스토리가 복잡해질 수 있지만 안전하고, rebase는 깔끔한 히스토리를 만들지만 공개된 브랜치에서는 위험할 수 있습니다.",
      "reference_context": ["merge는 non-destructive하고 히스토리를 보존합니다.", "rebase는 히스토리를 재작성하여 선형화합니다.", "공개 브랜치에서는 rebase를 피해야 합니다."]
    },
    {
      "id": 6,
      "difficulty": "medium",
      "domain": "python",
      "question": "Python의 데코레이터(decorator)는 무엇이며 어떻게 사용하나요?",
      "ground_truth": "데코레이터는 함수나 클래스를 수정하지 않고 기능을 추가하는 디자인 패턴입니다. @decorator_name 구문으로 함수 위에 작성하며, 로깅, 인증, 캐싱 등의 공통 기능을 적용할 때 사용합니다.",
      "reference_context": ["데코레이터는 함수를 인자로 받아 새로운 함수를 반환합니다.", "@구문은 syntactic sugar입니다.", "functools.wraps를 사용하면 메타데이터를 보존할 수 있습니다."]
    },
    {
      "id": 7,
      "difficulty": "medium",
      "domain": "docker",
      "question": "Docker Compose는 무엇이고 언제 사용하나요?",
      "ground_truth": "Docker Compose는 여러 컨테이너를 정의하고 실행하는 도구입니다. YAML 파일로 서비스를 구성하고, docker-compose up 명령으로 한번에 실행할 수 있습니다. 마이크로서비스 아키텍처나 개발 환경 구성에 유용합니다.",
      "reference_context": ["docker-compose.yml 파일에 서비스를 정의합니다.", "여러 컨테이너 간 네트워킹을 자동으로 설정합니다.", "개발 환경에서 특히 유용합니다."]
    },
    {
      "id": 8,
      "difficulty": "medium",
      "domain": "aws",
      "question": "AWS EC2와 Lambda의 주요 차이점은 무엇인가요?",
      "ground_truth": "EC2는 가상 서버로 지속적으로 실행되며 사용자가 OS와 환경을 완전히 제어합니다. Lambda는 서버리스 컴퓨팅으로 이벤트 발생 시에만 실행되며, 인프라 관리가 필요 없습니다. EC2는 장기 실행 애플리케이션에, Lambda는 짧은 이벤트 기반 작업에 적합합니다.",
      "reference_context": ["EC2는 IaaS, Lambda는 FaaS입니다.", "Lambda는 실행 시간만큼만 과금됩니다.", "Lambda는 15분 실행 시간 제한이 있습니다."]
    },
    {
      "id": 9,
      "difficulty": "hard",
      "domain": "git",
      "question": "Git의 3-way merge는 어떻게 작동하며, conflict가 발생하는 경우를 설명해주세요.",
      "ground_truth": "3-way merge는 공통 조상(base), 현재 브랜치(ours), 대상 브랜치(theirs) 세 가지 버전을 비교합니다. 같은 부분이 양쪽에서 다르게 수정되었을 때 conflict가 발생합니다. Git은 자동으로 해결할 수 없는 경우 conflict marker(<<<<, ====, >>>>)를 삽입하고 사용자가 수동으로 해결하도록 합니다.",
      "reference_context": ["3-way merge는 공통 조상을 기준으로 변경사항을 비교합니다.", "conflict는 같은 라인이 다르게 수정되었을 때 발생합니다.", "git mergetool로 conflict를 해결할 수 있습니다."]
    },
    {
      "id": 10,
      "difficulty": "hard",
      "domain": "python",
      "question": "Python의 GIL(Global Interpreter Lock)이 무엇이며, 멀티스레딩 성능에 어떤 영향을 미치나요?",
      "ground_truth": "GIL은 한 번에 하나의 스레드만 Python 바이트코드를 실행할 수 있도록 하는 뮤텍스입니다. CPU-bound 작업에서는 멀티스레딩의 이점을 제한하지만, I/O-bound 작업에서는 큰 영향이 없습니다. CPU-bound 병렬 처리가 필요한 경우 multiprocessing을 사용하거나 C 확장을 활용할 수 있습니다.",
      "reference_context": ["GIL은 메모리 관리를 단순화하기 위해 존재합니다.", "I/O 작업 중에는 GIL이 해제됩니다.", "multiprocessing은 별도 프로세스로 GIL을 우회합니다."]
    },
    {
      "id": 11,
      "difficulty": "hard",
      "domain": "docker",
      "question": "Docker의 multi-stage build는 무엇이며, 어떤 이점이 있나요?",
      "ground_truth": "Multi-stage build는 하나의 Dockerfile에서 여러 FROM 구문을 사용하여 빌드 단계를 분리하는 기법입니다. 빌드 도구와 의존성은 중간 단계에서만 사용하고 최종 이미지에는 실행 파일만 포함시켜 이미지 크기를 크게 줄일 수 있습니다. 보안도 향상됩니다.",
      "reference_context": ["각 FROM은 새로운 빌드 단계를 시작합니다.", "COPY --from=<stage>로 이전 단계의 파일을 복사합니다.", "빌드 이미지와 런타임 이미지를 분리할 수 있습니다."]
    },
    {
      "id": 12,
      "difficulty": "hard",
      "domain": "aws",
      "question": "AWS VPC의 서브넷, 라우팅 테이블, 인터넷 게이트웨이가 어떻게 함께 작동하나요?",
      "ground_truth": "VPC는 격리된 가상 네트워크입니다. 서브넷은 VPC 내 IP 주소 범위를 나누며, 라우팅 테이블은 트래픽 경로를 결정합니다. 인터넷 게이트웨이는 VPC와 인터넷 간 통신을 가능하게 합니다. 퍼블릭 서브넷은 인터넷 게이트웨이로 향하는 라우트를 가지고, 프라이빗 서브넷은 NAT 게이트웨이를 통해 아웃바운드 인터넷 접근만 허용합니다.",
      "reference_context": ["서브넷은 가용영역(AZ)에 속합니다.", "라우팅 테이블은 0.0.0.0/0 대상에 IGW를 지정하면 퍼블릭 서브넷이 됩니다.", "보안 그룹과 NACL로 네트워크 보안을 제어합니다."]
    },
    {
      "id": 13,
      "difficulty": "hard",
      "domain": "integration",
      "question": "Python 애플리케이션을 Docker 컨테이너로 만들고 AWS ECS에 배포하는 전체 과정을 설명해주세요.",
      "ground_truth": "1) requirements.txt와 Dockerfile 작성 2) multi-stage build로 이미지 최적화 3) ECR에 이미지 푸시 4) ECS 태스크 정의 생성 (CPU, 메모리, 컨테이너 설정) 5) ECS 클러스터 및 서비스 생성 6) ALB나 CloudWatch와 통합 7) Auto Scaling 설정. 이 과정에서 IAM 역할, VPC 설정, 보안 그룹 구성도 필요합니다.",
      "reference_context": ["ECR은 AWS의 Docker 레지스트리입니다.", "ECS 태스크 정의는 컨테이너 실행 명세입니다.", "Fargate를 사용하면 서버 관리가 불필요합니다."]
    },
    {
      "id": 14,
      "difficulty": "hard",
      "domain": "integration",
      "question": "Git Flow 브랜치 전략을 Docker CI/CD 파이프라인과 어떻게 통합할 수 있나요?",
      "ground_truth": "develop 브랜치는 개발 환경 이미지를 빌드하고 테스트합니다. feature 브랜치는 PR시 자동 테스트를 실행합니다. release 브랜치는 스테이징 환경에 배포하고 통합 테스트를 수행합니다. main 브랜치는 프로덕션 이미지를 빌드하고 태그를 달아 프로덕션에 배포합니다. 각 단계에서 이미지 스캔, 보안 검사, 성능 테스트를 수행합니다.",
      "reference_context": ["GitHub Actions나 GitLab CI로 자동화할 수 있습니다.", "각 환경별로 다른 docker-compose 파일을 사용합니다.", "semantic versioning으로 이미지 태그를 관리합니다."]
    },
    {
      "id": 15,
      "difficulty": "medium",
      "domain": "integration",
      "question": "Python 웹 애플리케이션을 AWS Lambda로 마이그레이션할 때 고려해야 할 제약사항은 무엇인가요?",
      "ground_truth": "1) 15분 실행 시간 제한 2) 메모리 제한 (최대 10GB) 3) 패키지 크기 제한 (압축 50MB, 압축 해제 250MB) 4) 콜드 스타트로 인한 지연 5) 상태 비저장 아키텍처 필요 6) 파일 시스템 /tmp만 사용 가능 (512MB). Flask/FastAPI는 Mangum 어댑터로 Lambda와 호환 가능하며, 긴 작업은 Step Functions로 분리해야 합니다.",
      "reference_context": ["Lambda Layer로 공통 의존성을 관리합니다.", "RDS Proxy로 DB 연결 풀링을 처리합니다.", "API Gateway와 통합하여 REST API를 제공합니다."]
    }
  ]
}
